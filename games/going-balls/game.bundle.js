(() => {
  var Cs = Math.pow;
  var Ea = (Tn, Si) => () => (
    Si || Tn((Si = { exports: {} }).exports, Si), Si.exports
  );
  var pn = (Tn, Si, kt) =>
    new Promise((Fn, Se) => {
      var W = (T) => {
          try {
            x(kt.next(T));
          } catch (g) {
            Se(g);
          }
        },
        a = (T) => {
          try {
            x(kt.throw(T));
          } catch (g) {
            Se(g);
          }
        },
        x = (T) => (T.done ? Fn(T.value) : Promise.resolve(T.value).then(W, a));
      x((kt = kt.apply(Tn, Si)).next());
    });
  var Sa = Ea(($n) => {
    (() => {
      var Tn = {
          9742: (Se, W) => {
            "use strict";
            (W.byteLength = f), (W.toByteArray = l), (W.fromByteArray = i);
            for (
              var a = [],
                x = [],
                T = typeof Uint8Array != "undefined" ? Uint8Array : Array,
                g =
                  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
                c = 0,
                d = g.length;
              c < d;
              ++c
            )
              (a[c] = g[c]), (x[g.charCodeAt(c)] = c);
            (x["-".charCodeAt(0)] = 62), (x["_".charCodeAt(0)] = 63);
            function h(e) {
              var t = e.length;
              if (t % 4 > 0)
                throw new Error(
                  "Invalid string. Length must be a multiple of 4"
                );
              var r = e.indexOf("=");
              r === -1 && (r = t);
              var u = r === t ? 0 : 4 - (r % 4);
              return [r, u];
            }
            function f(e) {
              var t = h(e),
                r = t[0],
                u = t[1];
              return ((r + u) * 3) / 4 - u;
            }
            function s(e, t, r) {
              return ((t + r) * 3) / 4 - r;
            }
            function l(e) {
              var t,
                r = h(e),
                u = r[0],
                y = r[1],
                p = new T(s(e, u, y)),
                _ = 0,
                m = y > 0 ? u - 4 : u,
                E;
              for (E = 0; E < m; E += 4)
                (t =
                  (x[e.charCodeAt(E)] << 18) |
                  (x[e.charCodeAt(E + 1)] << 12) |
                  (x[e.charCodeAt(E + 2)] << 6) |
                  x[e.charCodeAt(E + 3)]),
                  (p[_++] = (t >> 16) & 255),
                  (p[_++] = (t >> 8) & 255),
                  (p[_++] = t & 255);
              return (
                y === 2 &&
                  ((t =
                    (x[e.charCodeAt(E)] << 2) | (x[e.charCodeAt(E + 1)] >> 4)),
                  (p[_++] = t & 255)),
                y === 1 &&
                  ((t =
                    (x[e.charCodeAt(E)] << 10) |
                    (x[e.charCodeAt(E + 1)] << 4) |
                    (x[e.charCodeAt(E + 2)] >> 2)),
                  (p[_++] = (t >> 8) & 255),
                  (p[_++] = t & 255)),
                p
              );
            }
            function n(e) {
              return (
                a[(e >> 18) & 63] +
                a[(e >> 12) & 63] +
                a[(e >> 6) & 63] +
                a[e & 63]
              );
            }
            function o(e, t, r) {
              for (var u, y = [], p = t; p < r; p += 3)
                (u =
                  ((e[p] << 16) & 16711680) +
                  ((e[p + 1] << 8) & 65280) +
                  (e[p + 2] & 255)),
                  y.push(n(u));
              return y.join("");
            }
            function i(e) {
              for (
                var t,
                  r = e.length,
                  u = r % 3,
                  y = [],
                  p = 16383,
                  _ = 0,
                  m = r - u;
                _ < m;
                _ += p
              )
                y.push(o(e, _, _ + p > m ? m : _ + p));
              return (
                u === 1
                  ? ((t = e[r - 1]),
                    y.push(a[t >> 2] + a[(t << 4) & 63] + "=="))
                  : u === 2 &&
                    ((t = (e[r - 2] << 8) + e[r - 1]),
                    y.push(
                      a[t >> 10] + a[(t >> 4) & 63] + a[(t << 2) & 63] + "="
                    )),
                y.join("")
              );
            }
          },
          4181: (Se) => {
            var W = 4096,
              a = 2 * W + 32,
              x = 2 * W - 1,
              T = new Uint32Array([
                0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191,
                16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151,
                4194303, 8388607, 16777215,
              ]);
            function g(c) {
              (this.buf_ = new Uint8Array(a)), (this.input_ = c), this.reset();
            }
            (g.READ_SIZE = W),
              (g.IBUF_MASK = x),
              (g.prototype.reset = function () {
                (this.buf_ptr_ = 0),
                  (this.val_ = 0),
                  (this.pos_ = 0),
                  (this.bit_pos_ = 0),
                  (this.bit_end_pos_ = 0),
                  (this.eos_ = 0),
                  this.readMoreInput();
                for (var c = 0; c < 4; c++)
                  (this.val_ |= this.buf_[this.pos_] << (8 * c)), ++this.pos_;
                return this.bit_end_pos_ > 0;
              }),
              (g.prototype.readMoreInput = function () {
                if (!(this.bit_end_pos_ > 256))
                  if (this.eos_) {
                    if (this.bit_pos_ > this.bit_end_pos_)
                      throw new Error(
                        "Unexpected end of input " +
                          this.bit_pos_ +
                          " " +
                          this.bit_end_pos_
                      );
                  } else {
                    var c = this.buf_ptr_,
                      d = this.input_.read(this.buf_, c, W);
                    if (d < 0) throw new Error("Unexpected end of input");
                    if (d < W) {
                      this.eos_ = 1;
                      for (var h = 0; h < 32; h++) this.buf_[c + d + h] = 0;
                    }
                    if (c === 0) {
                      for (var h = 0; h < 32; h++)
                        this.buf_[(W << 1) + h] = this.buf_[h];
                      this.buf_ptr_ = W;
                    } else this.buf_ptr_ = 0;
                    this.bit_end_pos_ += d << 3;
                  }
              }),
              (g.prototype.fillBitWindow = function () {
                for (; this.bit_pos_ >= 8; )
                  (this.val_ >>>= 8),
                    (this.val_ |= this.buf_[this.pos_ & x] << 24),
                    ++this.pos_,
                    (this.bit_pos_ = (this.bit_pos_ - 8) >>> 0),
                    (this.bit_end_pos_ = (this.bit_end_pos_ - 8) >>> 0);
              }),
              (g.prototype.readBits = function (c) {
                32 - this.bit_pos_ < c && this.fillBitWindow();
                var d = (this.val_ >>> this.bit_pos_) & T[c];
                return (this.bit_pos_ += c), d;
              }),
              (Se.exports = g);
          },
          7080: (Se, W) => {
            var a = 0,
              x = 1,
              T = 2,
              g = 3;
            (W.lookup = new Uint8Array([
              0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 12, 16, 12, 12, 20, 12, 16, 24,
              28, 12, 12, 32, 12, 36, 12, 44, 44, 44, 44, 44, 44, 44, 44, 44,
              44, 32, 32, 24, 40, 28, 12, 12, 48, 52, 52, 52, 48, 52, 52, 52,
              48, 52, 52, 52, 52, 52, 48, 52, 52, 52, 52, 52, 48, 52, 52, 52,
              52, 52, 24, 12, 28, 12, 12, 12, 56, 60, 60, 60, 56, 60, 60, 60,
              56, 60, 60, 60, 60, 60, 56, 60, 60, 60, 60, 60, 56, 60, 60, 60,
              60, 60, 24, 12, 28, 12, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
              1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
              1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
              1, 0, 1, 0, 1, 0, 1, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2,
              3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2,
              3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2,
              3, 2, 3, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,
              1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1,
              1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
              2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3,
              3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
              2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 1,
              1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2,
              2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
              2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3,
              3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
              3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
              3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4,
              4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
              4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
              4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5,
              5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
              5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6,
              6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
              8, 8, 8, 8, 8, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
              16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
              16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
              16, 16, 16, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
              24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
              24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
              24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
              24, 24, 24, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
              32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
              32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
              32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
              32, 32, 32, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
              40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
              40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
              40, 40, 40, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
              48, 48, 56, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
              16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
              32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
              48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 0,
              1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
              20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
              36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
              52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 0, 1, 2, 3, 4, 5,
              6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
              23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,
              39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54,
              55, 56, 57, 58, 59, 60, 61, 62, 63, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
              10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
              26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
              42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,
              58, 59, 60, 61, 62, 63, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3,
              3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8,
              9, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 13,
              13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17,
              17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21,
              21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 25,
              25, 25, 25, 26, 26, 26, 26, 27, 27, 27, 27, 28, 28, 28, 28, 29,
              29, 29, 29, 30, 30, 30, 30, 31, 31, 31, 31, 32, 32, 32, 32, 33,
              33, 33, 33, 34, 34, 34, 34, 35, 35, 35, 35, 36, 36, 36, 36, 37,
              37, 37, 37, 38, 38, 38, 38, 39, 39, 39, 39, 40, 40, 40, 40, 41,
              41, 41, 41, 42, 42, 42, 42, 43, 43, 43, 43, 44, 44, 44, 44, 45,
              45, 45, 45, 46, 46, 46, 46, 47, 47, 47, 47, 48, 48, 48, 48, 49,
              49, 49, 49, 50, 50, 50, 50, 51, 51, 51, 51, 52, 52, 52, 52, 53,
              53, 53, 53, 54, 54, 54, 54, 55, 55, 55, 55, 56, 56, 56, 56, 57,
              57, 57, 57, 58, 58, 58, 58, 59, 59, 59, 59, 60, 60, 60, 60, 61,
              61, 61, 61, 62, 62, 62, 62, 63, 63, 63, 63, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0,
            ])),
              (W.lookupOffsets = new Uint16Array([
                1024, 1536, 1280, 1536, 0, 256, 768, 512,
              ]));
          },
          6450: (Se, W, a) => {
            var x,
              T = a(6154).g,
              g = a(6154).j,
              c = a(4181),
              d = a(5139),
              h = a(966).h,
              f = a(966).g,
              s = a(7080),
              l = a(8435),
              n = a(2973),
              o = 8,
              i = 16,
              e = 256,
              t = 704,
              r = 26,
              u = 6,
              y = 2,
              p = 8,
              _ = 255,
              m = 1080,
              E = 18,
              v = new Uint8Array([
                1, 2, 3, 4, 0, 5, 17, 6, 16, 7, 8, 9, 10, 11, 12, 13, 14, 15,
              ]),
              P = 16,
              I = new Uint8Array([
                3, 2, 1, 0, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2,
              ]),
              A = new Int8Array([
                0, 0, 0, 0, -1, 1, -2, 2, -3, 3, -1, 1, -2, 2, -3, 3,
              ]),
              B = new Uint16Array([
                256, 402, 436, 468, 500, 534, 566, 598, 630, 662, 694, 726, 758,
                790, 822, 854, 886, 920, 952, 984, 1016, 1048, 1080,
              ]);
            function C(R) {
              var j;
              return R.readBits(1) === 0
                ? 16
                : ((j = R.readBits(3)),
                  j > 0 ? 17 + j : ((j = R.readBits(3)), j > 0 ? 8 + j : 17));
            }
            function w(R) {
              if (R.readBits(1)) {
                var j = R.readBits(3);
                return j === 0 ? 1 : R.readBits(j) + (1 << j);
              }
              return 0;
            }
            function k() {
              (this.meta_block_length = 0),
                (this.input_end = 0),
                (this.is_uncompressed = 0),
                (this.is_metadata = !1);
            }
            function K(R) {
              var j = new k(),
                se,
                ce,
                ie;
              if (((j.input_end = R.readBits(1)), j.input_end && R.readBits(1)))
                return j;
              if (((se = R.readBits(2) + 4), se === 7)) {
                if (((j.is_metadata = !0), R.readBits(1) !== 0))
                  throw new Error("Invalid reserved bit");
                if (((ce = R.readBits(2)), ce === 0)) return j;
                for (ie = 0; ie < ce; ie++) {
                  var b = R.readBits(8);
                  if (ie + 1 === ce && ce > 1 && b === 0)
                    throw new Error("Invalid size byte");
                  j.meta_block_length |= b << (ie * 8);
                }
              } else
                for (ie = 0; ie < se; ++ie) {
                  var M = R.readBits(4);
                  if (ie + 1 === se && se > 4 && M === 0)
                    throw new Error("Invalid size nibble");
                  j.meta_block_length |= M << (ie * 4);
                }
              return (
                ++j.meta_block_length,
                !j.input_end &&
                  !j.is_metadata &&
                  (j.is_uncompressed = R.readBits(1)),
                j
              );
            }
            function te(R, j, se) {
              var ce = j,
                ie;
              return (
                se.fillBitWindow(),
                (j += (se.val_ >>> se.bit_pos_) & _),
                (ie = R[j].bits - p),
                ie > 0 &&
                  ((se.bit_pos_ += p),
                  (j += R[j].value),
                  (j += (se.val_ >>> se.bit_pos_) & ((1 << ie) - 1))),
                (se.bit_pos_ += R[j].bits),
                R[j].value
              );
            }
            function X(R, j, se, ce) {
              for (
                var ie = 0, b = o, M = 0, F = 0, z = 32768, oe = [], de = 0;
                de < 32;
                de++
              )
                oe.push(new h(0, 0));
              for (f(oe, 0, 5, R, E); ie < j && z > 0; ) {
                var ge = 0,
                  Re;
                if (
                  (ce.readMoreInput(),
                  ce.fillBitWindow(),
                  (ge += (ce.val_ >>> ce.bit_pos_) & 31),
                  (ce.bit_pos_ += oe[ge].bits),
                  (Re = oe[ge].value & 255),
                  Re < i)
                )
                  (M = 0),
                    (se[ie++] = Re),
                    Re !== 0 && ((b = Re), (z -= 32768 >> Re));
                else {
                  var Te = Re - 14,
                    Ne,
                    Le,
                    ke = 0;
                  if (
                    (Re === i && (ke = b),
                    F !== ke && ((M = 0), (F = ke)),
                    (Ne = M),
                    M > 0 && ((M -= 2), (M <<= Te)),
                    (M += ce.readBits(Te) + 3),
                    (Le = M - Ne),
                    ie + Le > j)
                  )
                    throw new Error(
                      "[ReadHuffmanCodeLengths] symbol + repeat_delta > num_symbols"
                    );
                  for (var ht = 0; ht < Le; ht++) se[ie + ht] = F;
                  (ie += Le), F !== 0 && (z -= Le << (15 - F));
                }
              }
              if (z !== 0)
                throw new Error("[ReadHuffmanCodeLengths] space = " + z);
              for (; ie < j; ie++) se[ie] = 0;
            }
            function $(R, j, se, ce) {
              var ie = 0,
                b,
                M = new Uint8Array(R);
              if ((ce.readMoreInput(), (b = ce.readBits(2)), b === 1)) {
                for (
                  var F,
                    z = R - 1,
                    oe = 0,
                    de = new Int32Array(4),
                    ge = ce.readBits(2) + 1;
                  z;

                )
                  (z >>= 1), ++oe;
                for (F = 0; F < ge; ++F)
                  (de[F] = ce.readBits(oe) % R), (M[de[F]] = 2);
                switch (((M[de[0]] = 1), ge)) {
                  case 1:
                    break;
                  case 3:
                    if (de[0] === de[1] || de[0] === de[2] || de[1] === de[2])
                      throw new Error("[ReadHuffmanCode] invalid symbols");
                    break;
                  case 2:
                    if (de[0] === de[1])
                      throw new Error("[ReadHuffmanCode] invalid symbols");
                    M[de[1]] = 1;
                    break;
                  case 4:
                    if (
                      de[0] === de[1] ||
                      de[0] === de[2] ||
                      de[0] === de[3] ||
                      de[1] === de[2] ||
                      de[1] === de[3] ||
                      de[2] === de[3]
                    )
                      throw new Error("[ReadHuffmanCode] invalid symbols");
                    ce.readBits(1)
                      ? ((M[de[2]] = 3), (M[de[3]] = 3))
                      : (M[de[0]] = 2);
                    break;
                }
              } else {
                var F,
                  Re = new Uint8Array(E),
                  Te = 32,
                  Ne = 0,
                  Le = [
                    new h(2, 0),
                    new h(2, 4),
                    new h(2, 3),
                    new h(3, 2),
                    new h(2, 0),
                    new h(2, 4),
                    new h(2, 3),
                    new h(4, 1),
                    new h(2, 0),
                    new h(2, 4),
                    new h(2, 3),
                    new h(3, 2),
                    new h(2, 0),
                    new h(2, 4),
                    new h(2, 3),
                    new h(4, 5),
                  ];
                for (F = b; F < E && Te > 0; ++F) {
                  var ke = v[F],
                    ht = 0,
                    _e;
                  ce.fillBitWindow(),
                    (ht += (ce.val_ >>> ce.bit_pos_) & 15),
                    (ce.bit_pos_ += Le[ht].bits),
                    (_e = Le[ht].value),
                    (Re[ke] = _e),
                    _e !== 0 && ((Te -= 32 >> _e), ++Ne);
                }
                if (!(Ne === 1 || Te === 0))
                  throw new Error(
                    "[ReadHuffmanCode] invalid num_codes or space"
                  );
                X(Re, R, M, ce);
              }
              if (((ie = f(j, se, p, M, R)), ie === 0))
                throw new Error("[ReadHuffmanCode] BuildHuffmanTable failed: ");
              return ie;
            }
            function ne(R, j, se) {
              var ce, ie;
              return (
                (ce = te(R, j, se)),
                (ie = l.kBlockLengthPrefixCode[ce].nbits),
                l.kBlockLengthPrefixCode[ce].offset + se.readBits(ie)
              );
            }
            function Y(R, j, se) {
              var ce;
              return (
                R < P
                  ? ((se += I[R]), (se &= 3), (ce = j[se] + A[R]))
                  : (ce = R - P + 1),
                ce
              );
            }
            function Z(R, j) {
              for (var se = R[j], ce = j; ce; --ce) R[ce] = R[ce - 1];
              R[0] = se;
            }
            function ye(R, j) {
              var se = new Uint8Array(256),
                ce;
              for (ce = 0; ce < 256; ++ce) se[ce] = ce;
              for (ce = 0; ce < j; ++ce) {
                var ie = R[ce];
                (R[ce] = se[ie]), ie && Z(se, ie);
              }
            }
            function pe(R, j) {
              (this.alphabet_size = R),
                (this.num_htrees = j),
                (this.codes = new Array(j + j * B[(R + 31) >>> 5])),
                (this.htrees = new Uint32Array(j));
            }
            pe.prototype.decode = function (R) {
              var j,
                se,
                ce = 0;
              for (j = 0; j < this.num_htrees; ++j)
                (this.htrees[j] = ce),
                  (se = $(this.alphabet_size, this.codes, ce, R)),
                  (ce += se);
            };
            function O(R, j) {
              var se = { num_htrees: null, context_map: null },
                ce,
                ie = 0,
                b,
                M;
              j.readMoreInput();
              var F = (se.num_htrees = w(j) + 1),
                z = (se.context_map = new Uint8Array(R));
              if (F <= 1) return se;
              for (
                ce = j.readBits(1),
                  ce && (ie = j.readBits(4) + 1),
                  b = [],
                  M = 0;
                M < m;
                M++
              )
                b[M] = new h(0, 0);
              for ($(F + ie, b, 0, j), M = 0; M < R; ) {
                var oe;
                if ((j.readMoreInput(), (oe = te(b, 0, j)), oe === 0))
                  (z[M] = 0), ++M;
                else if (oe <= ie)
                  for (var de = 1 + (1 << oe) + j.readBits(oe); --de; ) {
                    if (M >= R)
                      throw new Error(
                        "[DecodeContextMap] i >= context_map_size"
                      );
                    (z[M] = 0), ++M;
                  }
                else (z[M] = oe - ie), ++M;
              }
              return j.readBits(1) && ye(z, R), se;
            }
            function me(R, j, se, ce, ie, b, M) {
              var F = se * 2,
                z = se,
                oe = te(j, se * m, M),
                de;
              oe === 0
                ? (de = ie[F + (b[z] & 1)])
                : oe === 1
                ? (de = ie[F + ((b[z] - 1) & 1)] + 1)
                : (de = oe - 2),
                de >= R && (de -= R),
                (ce[se] = de),
                (ie[F + (b[z] & 1)] = de),
                ++b[z];
            }
            function N(R, j, se, ce, ie, b) {
              var M = ie + 1,
                F = se & ie,
                z = b.pos_ & c.IBUF_MASK,
                oe;
              if (j < 8 || b.bit_pos_ + (j << 3) < b.bit_end_pos_) {
                for (; j-- > 0; )
                  b.readMoreInput(),
                    (ce[F++] = b.readBits(8)),
                    F === M && (R.write(ce, M), (F = 0));
                return;
              }
              if (b.bit_end_pos_ < 32)
                throw new Error(
                  "[CopyUncompressedBlockToOutput] br.bit_end_pos_ < 32"
                );
              for (; b.bit_pos_ < 32; )
                (ce[F] = b.val_ >>> b.bit_pos_), (b.bit_pos_ += 8), ++F, --j;
              if (
                ((oe = (b.bit_end_pos_ - b.bit_pos_) >> 3),
                z + oe > c.IBUF_MASK)
              ) {
                for (var de = c.IBUF_MASK + 1 - z, ge = 0; ge < de; ge++)
                  ce[F + ge] = b.buf_[z + ge];
                (oe -= de), (F += de), (j -= de), (z = 0);
              }
              for (var ge = 0; ge < oe; ge++) ce[F + ge] = b.buf_[z + ge];
              if (((F += oe), (j -= oe), F >= M)) {
                R.write(ce, M), (F -= M);
                for (var ge = 0; ge < F; ge++) ce[ge] = ce[M + ge];
              }
              for (; F + j >= M; ) {
                if (((oe = M - F), b.input_.read(ce, F, oe) < oe))
                  throw new Error(
                    "[CopyUncompressedBlockToOutput] not enough bytes"
                  );
                R.write(ce, M), (j -= oe), (F = 0);
              }
              if (b.input_.read(ce, F, j) < j)
                throw new Error(
                  "[CopyUncompressedBlockToOutput] not enough bytes"
                );
              b.reset();
            }
            function V(R) {
              var j = (R.bit_pos_ + 7) & -8,
                se = R.readBits(j - R.bit_pos_);
              return se == 0;
            }
            function L(R) {
              var j = new T(R),
                se = new c(j);
              C(se);
              var ce = K(se);
              return ce.meta_block_length;
            }
            x = L;
            function J(R, j) {
              var se = new T(R);
              j == null && (j = L(R));
              var ce = new Uint8Array(j),
                ie = new g(ce);
              return (
                ae(se, ie),
                ie.pos < ie.buffer.length &&
                  (ie.buffer = ie.buffer.subarray(0, ie.pos)),
                ie.buffer
              );
            }
            W.TO = J;
            function ae(R, j) {
              var se,
                ce = 0,
                ie = 0,
                b = 0,
                M,
                F = 0,
                z,
                oe,
                de,
                ge,
                Re = [16, 15, 11, 4],
                Te = 0,
                Ne = 0,
                Le = 0,
                ke = [new pe(0, 0), new pe(0, 0), new pe(0, 0)],
                ht,
                _e,
                U,
                H = 128 + c.READ_SIZE;
              (U = new c(R)),
                (b = C(U)),
                (M = (1 << b) - 16),
                (z = 1 << b),
                (oe = z - 1),
                (de = new Uint8Array(z + H + d.maxDictionaryWordLength)),
                (ge = z),
                (ht = []),
                (_e = []);
              for (var Ee = 0; Ee < 3 * m; Ee++)
                (ht[Ee] = new h(0, 0)), (_e[Ee] = new h(0, 0));
              for (; !ie; ) {
                var G = 0,
                  Q,
                  q = [1 << 28, 1 << 28, 1 << 28],
                  xe = [0],
                  be = [1, 1, 1],
                  Pe = [0, 1, 0, 1, 0, 1],
                  we = [0],
                  Oe,
                  $e,
                  gt,
                  qe,
                  Tt = null,
                  Mt = null,
                  Dt,
                  ut = null,
                  At,
                  xt = 0,
                  jt = null,
                  Gt = 0,
                  yt = 0,
                  Ae = null,
                  Xe = 0,
                  Ye = 0,
                  it = 0,
                  st,
                  He;
                for (se = 0; se < 3; ++se)
                  (ke[se].codes = null), (ke[se].htrees = null);
                U.readMoreInput();
                var at = K(U);
                if (((G = at.meta_block_length), ce + G > j.buffer.length)) {
                  var Pt = new Uint8Array(ce + G);
                  Pt.set(j.buffer), (j.buffer = Pt);
                }
                if (
                  ((ie = at.input_end),
                  (Q = at.is_uncompressed),
                  at.is_metadata)
                ) {
                  for (V(U); G > 0; --G) U.readMoreInput(), U.readBits(8);
                  continue;
                }
                if (G !== 0) {
                  if (Q) {
                    (U.bit_pos_ = (U.bit_pos_ + 7) & -8),
                      N(j, G, ce, de, oe, U),
                      (ce += G);
                    continue;
                  }
                  for (se = 0; se < 3; ++se)
                    (be[se] = w(U) + 1),
                      be[se] >= 2 &&
                        ($(be[se] + 2, ht, se * m, U),
                        $(r, _e, se * m, U),
                        (q[se] = ne(_e, se * m, U)),
                        (we[se] = 1));
                  for (
                    U.readMoreInput(),
                      Oe = U.readBits(2),
                      $e = P + (U.readBits(4) << Oe),
                      gt = (1 << Oe) - 1,
                      qe = $e + (48 << Oe),
                      Mt = new Uint8Array(be[0]),
                      se = 0;
                    se < be[0];
                    ++se
                  )
                    U.readMoreInput(), (Mt[se] = U.readBits(2) << 1);
                  var he = O(be[0] << u, U);
                  (Dt = he.num_htrees), (Tt = he.context_map);
                  var fe = O(be[2] << y, U);
                  for (
                    At = fe.num_htrees,
                      ut = fe.context_map,
                      ke[0] = new pe(e, Dt),
                      ke[1] = new pe(t, be[1]),
                      ke[2] = new pe(qe, At),
                      se = 0;
                    se < 3;
                    ++se
                  )
                    ke[se].decode(U);
                  for (
                    jt = 0,
                      Ae = 0,
                      st = Mt[xe[0]],
                      Ye = s.lookupOffsets[st],
                      it = s.lookupOffsets[st + 1],
                      He = ke[1].htrees[0];
                    G > 0;

                  ) {
                    var Ie, ue, De, et, Ze, Ve, tt, Be, ot, Qe, mt;
                    for (
                      U.readMoreInput(),
                        q[1] === 0 &&
                          (me(be[1], ht, 1, xe, Pe, we, U),
                          (q[1] = ne(_e, m, U)),
                          (He = ke[1].htrees[xe[1]])),
                        --q[1],
                        Ie = te(ke[1].codes, He, U),
                        ue = Ie >> 6,
                        ue >= 2 ? ((ue -= 2), (tt = -1)) : (tt = 0),
                        De = l.kInsertRangeLut[ue] + ((Ie >> 3) & 7),
                        et = l.kCopyRangeLut[ue] + (Ie & 7),
                        Ze =
                          l.kInsertLengthPrefixCode[De].offset +
                          U.readBits(l.kInsertLengthPrefixCode[De].nbits),
                        Ve =
                          l.kCopyLengthPrefixCode[et].offset +
                          U.readBits(l.kCopyLengthPrefixCode[et].nbits),
                        Ne = de[(ce - 1) & oe],
                        Le = de[(ce - 2) & oe],
                        Qe = 0;
                      Qe < Ze;
                      ++Qe
                    )
                      U.readMoreInput(),
                        q[0] === 0 &&
                          (me(be[0], ht, 0, xe, Pe, we, U),
                          (q[0] = ne(_e, 0, U)),
                          (xt = xe[0] << u),
                          (jt = xt),
                          (st = Mt[xe[0]]),
                          (Ye = s.lookupOffsets[st]),
                          (it = s.lookupOffsets[st + 1])),
                        (ot = s.lookup[Ye + Ne] | s.lookup[it + Le]),
                        (Gt = Tt[jt + ot]),
                        --q[0],
                        (Le = Ne),
                        (Ne = te(ke[0].codes, ke[0].htrees[Gt], U)),
                        (de[ce & oe] = Ne),
                        (ce & oe) === oe && j.write(de, z),
                        ++ce;
                    if (((G -= Ze), G <= 0)) break;
                    if (tt < 0) {
                      var ot;
                      if (
                        (U.readMoreInput(),
                        q[2] === 0 &&
                          (me(be[2], ht, 2, xe, Pe, we, U),
                          (q[2] = ne(_e, 2 * m, U)),
                          (yt = xe[2] << y),
                          (Ae = yt)),
                        --q[2],
                        (ot = (Ve > 4 ? 3 : Ve - 2) & 255),
                        (Xe = ut[Ae + ot]),
                        (tt = te(ke[2].codes, ke[2].htrees[Xe], U)),
                        tt >= $e)
                      ) {
                        var je, lt, Et;
                        (tt -= $e),
                          (lt = tt & gt),
                          (tt >>= Oe),
                          (je = (tt >> 1) + 1),
                          (Et = ((2 + (tt & 1)) << je) - 4),
                          (tt = $e + ((Et + U.readBits(je)) << Oe) + lt);
                      }
                    }
                    if (((Be = Y(tt, Re, Te)), Be < 0))
                      throw new Error("[BrotliDecompress] invalid distance");
                    if (
                      (ce < M && F !== M ? (F = ce) : (F = M),
                      (mt = ce & oe),
                      Be > F)
                    )
                      if (
                        Ve >= d.minDictionaryWordLength &&
                        Ve <= d.maxDictionaryWordLength
                      ) {
                        var Et = d.offsetsByLength[Ve],
                          ct = Be - F - 1,
                          pt = d.sizeBitsByLength[Ve],
                          vt = (1 << pt) - 1,
                          Fe = ct & vt,
                          Yt = ct >> pt;
                        if (((Et += Fe * Ve), Yt < n.kNumTransforms)) {
                          var Ot = n.transformDictionaryWord(
                            de,
                            mt,
                            Et,
                            Ve,
                            Yt
                          );
                          if (((mt += Ot), (ce += Ot), (G -= Ot), mt >= ge)) {
                            j.write(de, z);
                            for (var Rt = 0; Rt < mt - ge; Rt++)
                              de[Rt] = de[ge + Rt];
                          }
                        } else
                          throw new Error(
                            "Invalid backward reference. pos: " +
                              ce +
                              " distance: " +
                              Be +
                              " len: " +
                              Ve +
                              " bytes left: " +
                              G
                          );
                      } else
                        throw new Error(
                          "Invalid backward reference. pos: " +
                            ce +
                            " distance: " +
                            Be +
                            " len: " +
                            Ve +
                            " bytes left: " +
                            G
                        );
                    else {
                      if ((tt > 0 && ((Re[Te & 3] = Be), ++Te), Ve > G))
                        throw new Error(
                          "Invalid backward reference. pos: " +
                            ce +
                            " distance: " +
                            Be +
                            " len: " +
                            Ve +
                            " bytes left: " +
                            G
                        );
                      for (Qe = 0; Qe < Ve; ++Qe)
                        (de[ce & oe] = de[(ce - Be) & oe]),
                          (ce & oe) === oe && j.write(de, z),
                          ++ce,
                          --G;
                    }
                    (Ne = de[(ce - 1) & oe]), (Le = de[(ce - 2) & oe]);
                  }
                  ce &= 1073741823;
                }
              }
              j.write(de, ce & oe);
            }
            (x = ae), d.init();
          },
          5340: (Se, W, a) => {
            var x = a(9742);
            W.init = function () {
              var T = a(6450).TO,
                g = x.toByteArray(a(2722));
              return T(g);
            };
          },
          2722: (Se) => {
            Se.exports =
              "W5/fcQLn5gKf2XUbAiQ1XULX+TZz6ADToDsgqk6qVfeC0e4m6OO2wcQ1J76ZBVRV1fRkEsdu//62zQsFEZWSTCnMhcsQKlS2qOhuVYYMGCkV0fXWEoMFbESXrKEZ9wdUEsyw9g4bJlEt1Y6oVMxMRTEVbCIwZzJzboK5j8m4YH02qgXYhv1V+PM435sLVxyHJihaJREEhZGqL03txGFQLm76caGO/ovxKvzCby/3vMTtX/459f0igi7WutnKiMQ6wODSoRh/8Lx1V3Q99MvKtwB6bHdERYRY0hStJoMjNeTsNX7bn+Y7e4EQ3bf8xBc7L0BsyfFPK43dGSXpL6clYC/I328h54/VYrQ5i0648FgbGtl837svJ35L3Mot/+nPlNpWgKx1gGXQYqX6n+bbZ7wuyCHKcUok12Xjqub7NXZGzqBx0SD+uziNf87t7ve42jxSKQoW3nyxVrWIGlFShhCKxjpZZ5MeGna0+lBkk+kaN8F9qFBAFgEogyMBdcX/T1W/WnMOi/7ycWUQloEBKGeC48MkiwqJkJO+12eQiOFHMmck6q/IjWW3RZlany23TBm+cNr/84/oi5GGmGBZWrZ6j+zykVozz5fT/QH/Da6WTbZYYPynVNO7kxzuNN2kxKKWche5WveitPKAecB8YcAHz/+zXLjcLzkdDSktNIDwZE9J9X+tto43oJy65wApM3mDzYtCwX9lM+N5VR3kXYo0Z3t0TtXfgBFg7gU8oN0Dgl7fZlUbhNll+0uuohRVKjrEd8egrSndy5/Tgd2gqjA4CAVuC7ESUmL3DZoGnfhQV8uwnpi8EGvAVVsowNRxPudck7+oqAUDkwZopWqFnW1riss0t1z6iCISVKreYGNvQcXv+1L9+jbP8cd/dPUiqBso2q+7ZyFBvENCkkVr44iyPbtOoOoCecWsiuqMSML5lv+vN5MzUr+Dnh73G7Q1YnRYJVYXHRJaNAOByiaK6CusgFdBPE40r0rvqXV7tksKO2DrHYXBTv8P5ysqxEx8VDXUDDqkPH6NNOV/a2WH8zlkXRELSa8P+heNyJBBP7PgsG1EtWtNef6/i+lcayzQwQCsduidpbKfhWUDgAEmyhGu/zVTacI6RS0zTABrOYueemnVa19u9fT23N/Ta6RvTpof5DWygqreCqrDAgM4LID1+1T/taU6yTFVLqXOv+/MuQOFnaF8vLMKD7tKWDoBdALgxF33zQccCcdHx8fKIVdW69O7qHtXpeGr9jbbpFA+qRMWr5hp0s67FPc7HAiLV0g0/peZlW7hJPYEhZyhpSwahnf93/tZgfqZWXFdmdXBzqxGHLrQKxoAY6fRoBhgCRPmmGueYZ5JexTVDKUIXzkG/fqp/0U3hAgQdJ9zumutK6nqWbaqvm1pgu03IYR+G+8s0jDBBz8cApZFSBeuWasyqo2OMDKAZCozS+GWSvL/HsE9rHxooe17U3s/lTE+VZAk4j3dp6uIGaC0JMiqR5CUsabPyM0dOYDR7Ea7ip4USZlya38YfPtvrX/tBlhHilj55nZ1nfN24AOAi9BVtz/Mbn8AEDJCqJgsVUa6nQnSxv2Fs7l/NlCzpfYEjmPrNyib/+t0ei2eEMjvNhLkHCZlci4WhBe7ePZTmzYqlY9+1pxtS4GB+5lM1BHT9tS270EWUDYFq1I0yY/fNiAk4bk9yBgmef/f2k6AlYQZHsNFnW8wBQxCd68iWv7/35bXfz3JZmfGligWAKRjIs3IpzxQ27vAglHSiOzCYzJ9L9A1CdiyFvyR66ucA4jKifu5ehwER26yV7HjKqn5Mfozo7Coxxt8LWWPT47BeMxX8p0Pjb7hZn+6bw7z3Lw+7653j5sI8CLu5kThpMlj1m4c2ch3jGcP1FsT13vuK3qjecKTZk2kHcOZY40UX+qdaxstZqsqQqgXz+QGF99ZJLqr3VYu4aecl1Ab5GmqS8k/GV5b95zxQ5d4EfXUJ6kTS/CXF/aiqKDOT1T7Jz5z0PwDUcwr9clLN1OJGCiKfqvah+h3XzrBOiLOW8wvn8gW6qE8vPxi+Efv+UH55T7PQFVMh6cZ1pZQlzJpKZ7P7uWvwPGJ6DTlR6wbyj3Iv2HyefnRo/dv7dNx+qaa0N38iBsR++Uil7Wd4afwDNsrzDAK4fXZwvEY/jdKuIKXlfrQd2C39dW7ntnRbIp9OtGy9pPBn/V2ASoi/2UJZfS+xuGLH8bnLuPlzdTNS6zdyk8Dt/h6sfOW5myxh1f+zf3zZ3MX/mO9cQPp5pOx967ZA6/pqHvclNfnUFF+rq+Vd7alKr6KWPcIDhpn6v2K6NlUu6LrKo8b/pYpU/Gazfvtwhn7tEOUuXht5rUJdSf6sLjYf0VTYDgwJ81yaqKTUYej/tbHckSRb/HZicwGJqh1mAHB/IuNs9dc9yuvF3D5Xocm3elWFdq5oEy70dYFit79yaLiNjPj5UUcVmZUVhQEhW5V2Z6Cm4HVH/R8qlamRYwBileuh07CbEce3TXa2JmXWBf+ozt319psboobeZhVnwhMZzOeQJzhpTDbP71Tv8HuZxxUI/+ma3XW6DFDDs4+qmpERwHGBd2edxwUKlODRdUWZ/g0GOezrbzOZauFMai4QU6GVHV6aPNBiBndHSsV4IzpvUiiYyg6OyyrL4Dj5q/Lw3N5kAwftEVl9rNd7Jk5PDij2hTH6wIXnsyXkKePxbmHYgC8A6an5Fob/KH5GtC0l4eFso+VpxedtJHdHpNm+Bvy4C79yVOkrZsLrQ3OHCeB0Ra+kBIRldUGlDCEmq2RwXnfyh6Dz+alk6eftI2n6sastRrGwbwszBeDRS/Fa/KwRJkCzTsLr/JCs5hOPE/MPLYdZ1F1fv7D+VmysX6NpOC8aU9F4Qs6HvDyUy9PvFGDKZ/P5101TYHFl8pjj6wm/qyS75etZhhfg0UEL4OYmHk6m6dO192AzoIyPSV9QedDA4Ml23rRbqxMPMxf7FJnDc5FTElVS/PyqgePzmwVZ26NWhRDQ+oaT7ly7ell4s3DypS1s0g+tOr7XHrrkZj9+x/mJBttrLx98lFIaRZzHz4aC7r52/JQ4VjHahY2/YVXZn/QC2ztQb/sY3uRlyc5vQS8nLPGT/n27495i8HPA152z7Fh5aFpyn1GPJKHuPL8Iw94DuW3KjkURAWZXn4EQy89xiKEHN1mk/tkM4gYDBxwNoYvRfE6LFqsxWJtPrDGbsnLMap3Ka3MUoytW0cvieozOmdERmhcqzG+3HmZv2yZeiIeQTKGdRT4HHNxekm1tY+/n06rGmFleqLscSERzctTKM6G9P0Pc1RmVvrascIxaO1CQCiYPE15bD7c3xSeW7gXxYjgxcrUlcbIvO0r+Yplhx0kTt3qafDOmFyMjgGxXu73rddMHpV1wMubyAGcf/v5dLr5P72Ta9lBF+fzMJrMycwv+9vnU3ANIl1cH9tfW7af8u0/HG0vV47jNFXzFTtaha1xvze/s8KMtCYucXc1nzfd/MQydUXn/b72RBt5wO/3jRcMH9BdhC/yctKBIveRYPrNpDWqBsO8VMmP+WvRaOcA4zRMR1PvSoO92rS7pYEv+fZfEfTMzEdM+6X5tLlyxExhqLRkms5EuLovLfx66de5fL2/yX02H52FPVwahrPqmN/E0oVXnsCKhbi/yRxX83nRbUKWhzYceXOntfuXn51NszJ6MO73pQf5Pl4in3ec4JU8hF7ppV34+mm9r1LY0ee/i1O1wpd8+zfLztE0cqBxggiBi5Bu95v9l3r9r/U5hweLn+TbfxowrWDqdJauKd8+q/dH8sbPkc9ttuyO94f7/XK/nHX46MPFLEb5qQlNPvhJ50/59t9ft3LXu7uVaWaO2bDrDCnRSzZyWvFKxO1+vT8MwwunR3bX0CkfPjqb4K9O19tn5X50PvmYpEwHtiW9WtzuV/s76B1zvLLNkViNd8ySxIl/3orfqP90TyTGaf7/rx8jQzeHJXdmh/N6YDvbvmTBwCdxfEQ1NcL6wNMdSIXNq7b1EUzRy1/Axsyk5p22GMG1b+GxFgbHErZh92wuvco0AuOLXct9hvw2nw/LqIcDRRmJmmZzcgUa7JpM/WV/S9IUfbF56TL2orzqwebdRD8nIYNJ41D/hz37Fo11p2Y21wzPcn713qVGhqtevStYfGH4n69OEJtPvbbLYWvscDqc3Hgnu166+tAyLnxrX0Y5zoYjV++1sI7t5kMr02KT/+uwtkc+rZLOf/qn/s3nYCf13Dg8/sB2diJgjGqjQ+TLhxbzyue2Ob7X6/9lUwW7a+lbznHzOYy8LKW1C/uRPbQY3KW/0gO9LXunHLvPL97afba9bFtc9hmz7GAttjVYlCvQAiOwAk/gC5+hkLEs6tr3AZKxLJtOEwk2dLxTYWsIB/j/ToWtIWzo906FrSG8iaqqqqqqiIiIiAgzMzMzNz+AyK+01/zi8n8S+Y1MjoRaQ80WU/G8MBlO+53VPXANrWm4wzGUVZUjjBJZVdhpcfkjsmcWaO+UEldXi1e+zq+HOsCpknYshuh8pOLISJun7TN0EIGW2xTnlOImeecnoGW4raxe2G1T3HEvfYUYMhG+gAFOAwh5nK8mZhwJMmN7r224QVsNFvZ87Z0qatvknklyPDK3Hy45PgVKXji52Wen4d4PlFVVYGnNap+fSpFbK90rYnhUc6n91Q3AY9E0tJOFrcfZtm/491XbcG/jsViUPPX76qmeuiz+qY1Hk7/1VPM405zWVuoheLUimpWYdVzCmUdKHebMdzgrYrb8mL2eeLSnRWHdonfZa8RsOU9F37w+591l5FLYHiOqWeHtE/lWrBHcRKp3uhtr8yXm8LU/5ms+NM6ZKsqu90cFZ4o58+k4rdrtB97NADFbwmEG7lXqvirhOTOqU14xuUF2myIjURcPHrPOQ4lmM3PeMg7bUuk0nnZi67bXsU6H8lhqIo8TaOrEafCO1ARK9PjC0QOoq2BxmMdgYB9G/lIb9++fqNJ2s7BHGFyBNmZAR8J3KCo012ikaSP8BCrf6VI0X5xdnbhHIO+B5rbOyB54zXkzfObyJ4ecwxfqBJMLFc7m59rNcw7hoHnFZ0b00zee+gTqvjm61Pb4xn0kcDX4jvHM0rBXZypG3DCKnD/Waa/ZtHmtFPgO5eETx+k7RrVg3aSwm2YoNXnCs3XPQDhNn+Fia6IlOOuIG6VJH7TP6ava26ehKHQa2T4N0tcZ9dPCGo3ZdnNltsHQbeYt5vPnJezV/cAeNypdml1vCHI8M81nSRP5Qi2+mI8v/sxiZru9187nRtp3f/42NemcONa+4eVC3PCZzc88aZh851CqSsshe70uPxeN/dmYwlwb3trwMrN1Gq8jbnApcVDx/yDPeYs5/7r62tsQ6lLg+DiFXTEhzR9dHqv0iT4tgj825W+H3XiRUNUZT2kR9Ri0+lp+UM3iQtS8uOE23Ly4KYtvqH13jghUntJRAewuzNLDXp8RxdcaA3cMY6TO2IeSFRXezeWIjCqyhsUdMYuCgYTZSKpBype1zRfq8FshvfBPc6BAQWl7/QxIDp3VGo1J3vn42OEs3qznws+YLRXbymyB19a9XBx6n/owcyxlEYyFWCi+kG9F+EyD/4yn80+agaZ9P7ay2Dny99aK2o91FkfEOY8hBwyfi5uwx2y5SaHmG+oq/zl1FX/8irOf8Y3vAcX/6uLP6A6nvMO24edSGPjQc827Rw2atX+z2bKq0CmW9mOtYnr5/AfDa1ZfPaXnKtlWborup7QYx+Or2uWb+N3N//2+yDcXMqIJdf55xl7/vsj4WoPPlxLxtVrkJ4w/tTe3mLdATOOYwxcq52w5Wxz5MbPdVs5O8/lhfE7dPj0bIiPQ3QV0iqm4m3YX8hRfc6jQ3fWepevMqUDJd86Z4vwM40CWHnn+WphsGHfieF02D3tmZvpWD+kBpNCFcLnZhcmmrhpGzzbdA+sQ1ar18OJD87IOKOFoRNznaHPNHUfUNhvY1iU+uhvEvpKHaUn3qK3exVVyX4joipp3um7FmYJWmA+WbIDshRpbVRx5/nqstCgy87FGbfVB8yDGCqS+2qCsnRwnSAN6zgzxfdB2nBT/vZ4/6uxb6oH8b4VBRxiIB93wLa47hG3w2SL/2Z27yOXJFwZpSJaBYyvajA7vRRYNKqljXKpt/CFD/tSMr18DKKbwB0xggBePatl1nki0yvqW5zchlyZmJ0OTxJ3D+fsYJs/mxYN5+Le5oagtcl+YsVvy8kSjI2YGvGjvmpkRS9W2dtXqWnVuxUhURm1lKtou/hdEq19VBp9OjGvHEQSmrpuf2R24mXGheil8KeiANY8fW1VERUfBImb64j12caBZmRViZHbeVMjCrPDg9A90IXrtnsYCuZtRQ0PyrKDjBNOsPfKsg1pA02gHlVr0OXiFhtp6nJqXVzcbfM0KnzC3ggOENPE9VBdmHKN6LYaijb4wXxJn5A0FSDF5j+h1ooZx885Jt3ZKzO5n7Z5WfNEOtyyPqQEnn7WLv5Fis3PdgMshjF1FRydbNyeBbyKI1oN1TRVrVK7kgsb/zjX4NDPIRMctVeaxVB38Vh1x5KbeJbU138AM5KzmZu3uny0ErygxiJF7GVXUrPzFxrlx1uFdAaZFDN9cvIb74qD9tzBMo7L7WIEYK+sla1DVMHpF0F7b3+Y6S+zjvLeDMCpapmJo1weBWuxKF3rOocih1gun4BoJh1kWnV/Jmiq6uOhK3VfKxEHEkafjLgK3oujaPzY6SXg8phhL4TNR1xvJd1Wa0aYFfPUMLrNBDCh4AuGRTbtKMc6Z1Udj8evY/ZpCuMAUefdo69DZUngoqE1P9A3PJfOf7WixCEj+Y6t7fYeHbbxUAoFV3M89cCKfma3fc1+jKRe7MFWEbQqEfyzO2x/wrO2VYH7iYdQ9BkPyI8/3kXBpLaCpU7eC0Yv/am/tEDu7HZpqg0EvHo0nf/R/gRzUWy33/HXMJQeu1GylKmOkXzlCfGFruAcPPhaGqZOtu19zsJ1SO2Jz4Ztth5cBX6mRQwWmDwryG9FUMlZzNckMdK+IoMJv1rOWnBamS2w2KHiaPMPLC15hCZm4KTpoZyj4E2TqC/P6r7/EhnDMhKicZZ1ZwxuC7DPzDGs53q8gXaI9kFTK+2LTq7bhwsTbrMV8Rsfua5lMS0FwbTitUVnVa1yTb5IX51mmYnUcP9wPr8Ji1tiYJeJV9GZTrQhF7vvdU2OTU42ogJ9FDwhmycI2LIg++03C6scYhUyUuMV5tkw6kGUoL+mjNC38+wMdWNljn6tGPpRES7veqrSn5TRuv+dh6JVL/iDHU1db4c9WK3++OrH3PqziF916UMUKn8G67nN60GfWiHrXYhUG3yVWmyYak59NHj8t1smG4UDiWz2rPHNrKnN4Zo1LBbr2/eF9YZ0n0blx2nG4X+EKFxvS3W28JESD+FWk61VCD3z/URGHiJl++7TdBwkCj6tGOH3qDb0QqcOF9Kzpj0HUb/KyFW3Yhj2VMKJqGZleFBH7vqvf7WqLC3XMuHV8q8a4sTFuxUtkD/6JIBvKaVjv96ndgruKZ1k/BHzqf2K9fLk7HGXANyLDd1vxkK/i055pnzl+zw6zLnwXlVYVtfmacJgEpRP1hbGgrYPVN6v2lG+idQNGmwcKXu/8xEj/P6qe/sB2WmwNp6pp8jaISMkwdleFXYK55NHWLTTbutSUqjBfDGWo/Yg918qQ+8BRZSAHZbfuNZz2O0sov1Ue4CWlVg3rFhM3Kljj9ksGd/NUhk4nH+a5UN2+1i8+NM3vRNp7uQ6sqexSCukEVlVZriHNqFi5rLm9TMWa4qm3idJqppQACol2l4VSuvWLfta4JcXy3bROPNbXOgdOhG47LC0CwW/dMlSx4Jf17aEU3yA1x9p+Yc0jupXgcMuYNku64iYOkGToVDuJvlbEKlJqsmiHbvNrIVZEH+yFdF8DbleZ6iNiWwMqvtMp/mSpwx5KxRrT9p3MAPTHGtMbfvdFhyj9vhaKcn3At8Lc16Ai+vBcSp1ztXi7rCJZx/ql7TXcclq6Q76UeKWDy9boS0WHIjUuWhPG8LBmW5y2rhuTpM5vsLt+HOLh1Yf0DqXa9tsfC+kaKt2htA0ai/L2i7RKoNjEwztkmRU0GfgW1TxUvPFhg0V7DdfWJk5gfrccpYv+MA9M0dkGTLECeYwUixRzjRFdmjG7zdZIl3XKB9YliNKI31lfa7i2JG5C8Ss+rHe0D7Z696/V3DEAOWHnQ9yNahMUl5kENWS6pHKKp2D1BaSrrHdE1w2qNxIztpXgUIrF0bm15YML4b6V1k+GpNysTahKMVrrS85lTVo9OGJ96I47eAy5rYWpRf/mIzeoYU1DKaQCTUVwrhHeyNoDqHel+lLxr9WKzhSYw7vrR6+V5q0pfi2k3L1zqkubY6rrd9ZLvSuWNf0uqnkY+FpTvFzSW9Fp0b9l8JA7THV9eCi/PY/SCZIUYx3BU2alj7Cm3VV6eYpios4b6WuNOJdYXUK3zTqj5CVG2FqYM4Z7CuIU0qO05XR0d71FHM0YhZmJmTRfLlXEumN82BGtzdX0S19t1e+bUieK8zRmqpa4Qc5TSjifmaQsY2ETLjhI36gMR1+7qpjdXXHiceUekfBaucHShAOiFXmv3sNmGQyU5iVgnoocuonQXEPTFwslHtS8R+A47StI9wj0iSrtbi5rMysczFiImsQ+bdFClnFjjpXXwMy6O7qfjOr8Fb0a7ODItisjnn3EQO16+ypd1cwyaAW5Yzxz5QknfMO7643fXW/I9y3U2xH27Oapqr56Z/tEzglj6IbT6HEHjopiXqeRbe5mQQvxtcbDOVverN0ZgMdzqRYRjaXtMRd56Q4cZSmdPvZJdSrhJ1D9zNXPqAEqPIavPdfubt5oke2kmv0dztIszSv2VYuoyf1UuopbsYb+uX9h6WpwjpgtZ6fNNawNJ4q8O3CFoSbioAaOSZMx2GYaPYB+rEb6qjQiNRFQ76TvwNFVKD+BhH9VhcKGsXzmMI7BptU/CNWolM7YzROvpFAntsiWJp6eR2d3GarcYShVYSUqhmYOWj5E96NK2WvmYNTeY7Zs4RUEdv9h9QT4EseKt6LzLrqEOs3hxAY1MaNWpSa6zZx8F3YOVeCYMS88W+CYHDuWe4yoc6YK+djDuEOrBR5lvh0r+Q9uM88lrjx9x9AtgpQVNE8r+3O6Gvw59D+kBF/UMXyhliYUtPjmvXGY6Dk3x+kEOW+GtdMVC4EZTqoS/jmR0P0LS75DOc/w2vnri97M4SdbZ8qeU7gg8DVbERkU5geaMQO3mYrSYyAngeUQqrN0C0/vsFmcgWNXNeidsTAj7/4MncJR0caaBUpbLK1yBCBNRjEv6KvuVSdpPnEMJdsRRtqJ+U8tN1gXA4ePHc6ZT0eviI73UOJF0fEZ8YaneAQqQdGphNvwM4nIqPnXxV0xA0fnCT+oAhJuyw/q8jO0y8CjSteZExwBpIN6SvNp6A5G/abi6egeND/1GTguhuNjaUbbnSbGd4L8937Ezm34Eyi6n1maeOBxh3PI0jzJDf5mh/BsLD7F2GOKvlA/5gtvxI3/eV4sLfKW5Wy+oio+es/u6T8UU+nsofy57Icb/JlZHPFtCgd/x+bwt3ZT+xXTtTtTrGAb4QehC6X9G+8YT+ozcLxDsdCjsuOqwPFnrdLYaFc92Ui0m4fr39lYmlCaqTit7G6O/3kWDkgtXjNH4BiEm/+jegQnihOtfffn33WxsFjhfMd48HT+f6o6X65j7XR8WLSHMFkxbvOYsrRsF1bowDuSQ18Mkxk4qz2zoGPL5fu9h2Hqmt1asl3Q3Yu3szOc+spiCmX4AETBM3pLoTYSp3sVxahyhL8eC4mPN9k2x3o0xkiixIzM3CZFzf5oR4mecQ5+ax2wCah3/crmnHoqR0+KMaOPxRif1oEFRFOO/kTPPmtww+NfMXxEK6gn6iU32U6fFruIz8Q4WgljtnaCVTBgWx7diUdshC9ZEa5yKpRBBeW12r/iNc/+EgNqmhswNB8SBoihHXeDF7rrWDLcmt3V8GYYN7pXRy4DZjj4DJuUBL5iC3DQAaoo4vkftqVTYRGLS3mHZ7gdmdTTqbgNN/PTdTCOTgXolc88MhXAEUMdX0iy1JMuk5wLsgeu0QUYlz2S4skTWwJz6pOm/8ihrmgGfFgri+ZWUK2gAPHgbWa8jaocdSuM4FJYoKicYX/ZSENkg9Q1ZzJfwScfVnR2DegOGwCvmogaWJCLQepv9WNlU6QgsmOwICquU28Mlk3d9W5E81lU/5Ez0LcX6lwKMWDNluNKfBDUy/phJgBcMnfkh9iRxrdOzgs08JdPB85Lwo+GUSb4t3nC+0byqMZtO2fQJ4U2zGIr49t/28qmmGv2RanDD7a3FEcdtutkW8twwwlUSpb8QalodddbBfNHKDQ828BdE7OBgFdiKYohLawFYqpybQoxATZrheLhdI7+0Zlu9Q1myRcd15r9UIm8K2LGJxqTegntqNVMKnf1a8zQiyUR1rxoqjiFxeHxqFcYUTHfDu7rhbWng6qOxOsI+5A1p9mRyEPdVkTlE24vY54W7bWc6jMgZvNXdfC9/9q7408KDsbdL7Utz7QFSDetz2picArzrdpL8OaCHC9V26RroemtDZ5yNM/KGkWMyTmfnInEvwtSD23UcFcjhaE3VKzkoaEMKGBft4XbIO6forTY1lmGQwVmKicBCiArDzE+1oIxE08fWeviIOD5TznqH+OoHadvoOP20drMPe5Irg3XBQziW2XDuHYzjqQQ4wySssjXUs5H+t3FWYMHppUnBHMx/nYIT5d7OmjDbgD9F6na3m4l7KdkeSO3kTEPXafiWinogag7b52taiZhL1TSvBFmEZafFq2H8khQaZXuitCewT5FBgVtPK0j4xUHPfUz3Q28eac1Z139DAP23dgki94EC8vbDPTQC97HPPSWjUNG5tWKMsaxAEMKC0665Xvo1Ntd07wCLNf8Q56mrEPVpCxlIMVlQlWRxM3oAfpgIc+8KC3rEXUog5g06vt7zgXY8grH7hhwVSaeuvC06YYRAwpbyk/Unzj9hLEZNs2oxPQB9yc+GnL6zTgq7rI++KDJwX2SP8Sd6YzTuw5lV/kU6eQxRD12omfQAW6caTR4LikYkBB1CMOrvgRr/VY75+NSB40Cni6bADAtaK+vyxVWpf9NeKJxN2KYQ8Q2xPB3K1s7fuhvWbr2XpgW044VD6DRs0qXoqKf1NFsaGvKJc47leUV3pppP/5VTKFhaGuol4Esfjf5zyCyUHmHthChcYh4hYLQF+AFWsuq4t0wJyWgdwQVOZiV0efRHPoK5+E1vjz9wTJmVkITC9oEstAsyZSgE/dbicwKr89YUxKZI+owD205Tm5lnnmDRuP/JnzxX3gMtlrcX0UesZdxyQqYQuEW4R51vmQ5xOZteUd8SJruMlTUzhtVw/Nq7eUBcqN2/HVotgfngif60yKEtoUx3WYOZlVJuJOh8u59fzSDPFYtQgqDUAGyGhQOAvKroXMcOYY0qjnStJR/G3aP+Jt1sLVlGV8POwr/6OGsqetnyF3TmTqZjENfnXh51oxe9qVUw2M78EzAJ+IM8lZ1MBPQ9ZWSVc4J3mWSrLKrMHReA5qdGoz0ODRsaA+vwxXA2cAM4qlfzBJA6581m4hzxItQw5dxrrBL3Y6kCbUcFxo1S8jyV44q//+7ASNNudZ6xeaNOSIUffqMn4A9lIjFctYn2gpEPAb3f7p3iIBN8H14FUGQ9ct2hPsL+cEsTgUrR47uJVN4n4wt/wgfwwHuOnLd4yobkofy8JvxSQTA7rMpDIc608SlZFJfZYcmbT0tAHpPE8MrtQ42siTUNWxqvWZOmvu9f0JPoQmg+6l7sZWwyfi6PXkxJnwBraUG0MYG4zYHQz3igy/XsFkx5tNQxw43qvI9dU3f0DdhOUlHKjmi1VAr2Kiy0HZwD8VeEbhh0OiDdMYspolQsYdSwjCcjeowIXNZVUPmL2wwIkYhmXKhGozdCJ4lRKbsf4NBh/XnQoS92NJEWOVOFs2YhN8c5QZFeK0pRdAG40hqvLbmoSA8xQmzOOEc7wLcme9JOsjPCEgpCwUs9E2DohMHRhUeyGIN6TFvrbny8nDuilsDpzrH5mS76APoIEJmItS67sQJ+nfwddzmjPxcBEBBCw0kWDwd0EZCkNeOD7NNQhtBm7KHL9mRxj6U1yWU2puzlIDtpYxdH4ZPeXBJkTGAJfUr/oTCz/iypY6uXaR2V1doPxJYlrw2ghH0D5gbrhFcIxzYwi4a/4hqVdf2DdxBp6vGYDjavxMAAoy+1+3aiO6S3W/QAKNVXagDtvsNtx7Ks+HKgo6U21B+QSZgIogV5Bt+BnXisdVfy9VyXV+2P5fMuvdpAjM1o/K9Z+XnE4EOCrue+kcdYHqAQ0/Y/OmNlQ6OI33jH/uD1RalPaHpJAm2av0/xtpqdXVKNDrc9F2izo23Wu7firgbURFDNX9eGGeYBhiypyXZft2j3hTvzE6PMWKsod//rEILDkzBXfi7xh0eFkfb3/1zzPK/PI5Nk3FbZyTl4mq5BfBoVoqiPHO4Q4QKZAlrQ3MdNfi3oxIjvsM3kAFv3fdufurqYR3PSwX/mpGy/GFI/B2MNPiNdOppWVbs/gjF3YH+QA9jMhlAbhvasAHstB0IJew09iAkmXHl1/TEj+jvHOpOGrPRQXbPADM+Ig2/OEcUcpgPTItMtW4DdqgfYVI/+4hAFWYjUGpOP/UwNuB7+BbKOcALbjobdgzeBQfjgNSp2GOpxzGLj70Vvq5cw2AoYENwKLUtJUX8sGRox4dVa/TN4xKwaKcl9XawQR/uNus700Hf17pyNnezrUgaY9e4MADhEDBpsJT6y1gDJs1q6wlwGhuUzGR7C8kgpjPyHWwsvrf3yn1zJEIRa5eSxoLAZOCR9xbuztxFRJW9ZmMYfCFJ0evm9F2fVnuje92Rc4Pl6A8bluN8MZyyJGZ0+sNSb//DvAFxC2BqlEsFwccWeAl6CyBcQV1bx4mQMBP1Jxqk1EUADNLeieS2dUFbQ/c/kvwItbZ7tx0st16viqd53WsRmPTKv2AD8CUnhtPWg5aUegNpsYgasaw2+EVooeNKmrW3MFtj76bYHJm5K9gpAXZXsE5U8DM8XmVOSJ1F1WnLy6nQup+jx52bAb+rCq6y9WXl2B2oZDhfDkW7H3oYfT/4xx5VncBuxMXP2lNfhUVQjSSzSRbuZFE4vFawlzveXxaYKVs8LpvAb8IRYF3ZHiRnm0ADeNPWocwxSzNseG7NrSEVZoHdKWqaGEBz1N8Pt7kFbqh3LYmAbm9i1IChIpLpM5AS6mr6OAPHMwwznVy61YpBYX8xZDN/a+lt7n+x5j4bNOVteZ8lj3hpAHSx1VR8vZHec4AHO9XFCdjZ9eRkSV65ljMmZVzaej2qFn/qt1lvWzNZEfHxK3qOJrHL6crr0CRzMox5f2e8ALBB4UGFZKA3tN6F6IXd32GTJXGQ7DTi9j/dNcLF9jCbDcWGKxoKTYblIwbLDReL00LRcDPMcQuXLMh5YzgtfjkFK1DP1iDzzYYVZz5M/kWYRlRpig1htVRjVCknm+h1M5LiEDXOyHREhvzCGpFZjHS0RsK27o2avgdilrJkalWqPW3D9gmwV37HKmfM3F8YZj2ar+vHFvf3B8CRoH4kDHIK9mrAg+owiEwNjjd9V+FsQKYR8czJrUkf7Qoi2YaW6EVDZp5zYlqiYtuXOTHk4fAcZ7qBbdLDiJq0WNV1l2+Hntk1mMWvxrYmc8kIx8G3rW36J6Ra4lLrTOCgiOihmow+YnzUT19jbV2B3RWqSHyxkhmgsBqMYWvOcUom1jDQ436+fcbu3xf2bbeqU/ca+C4DOKE+e3qvmeMqW3AxejfzBRFVcwVYPq4L0APSWWoJu+5UYX4qg5U6YTioqQGPG9XrnuZ/BkxuYpe6Li87+18EskyQW/uA+uk2rpHpr6hut2TlVbKgWkFpx+AZffweiw2+VittkEyf/ifinS/0ItRL2Jq3tQOcxPaWO2xrG68GdFoUpZgFXaP2wYVtRc6xYCfI1CaBqyWpg4bx8OHBQwsV4XWMibZZ0LYjWEy2IxQ1mZrf1/UNbYCJplWu3nZ4WpodIGVA05d+RWSS+ET9tH3RfGGmNI1cIY7evZZq7o+a0bjjygpmR3mVfalkT/SZGT27Q8QGalwGlDOS9VHCyFAIL0a1Q7JiW3saz9gqY8lqKynFrPCzxkU4SIfLc9VfCI5edgRhDXs0edO992nhTKHriREP1NJC6SROMgQ0xO5kNNZOhMOIT99AUElbxqeZF8A3xrfDJsWtDnUenAHdYWSwAbYjFqQZ+D5gi3hNK8CSxU9i6f6ClL9IGlj1OPMQAsr84YG6ijsJpCaGWj75c3yOZKBB9mNpQNPUKkK0D6wgLH8MGoyRxTX6Y05Q4AnYNXMZwXM4eij/9WpsM/9CoRnFQXGR6MEaY+FXvXEO3RO0JaStk6OXuHVATHJE+1W+TU3bSZ2ksMtqjO0zfSJCdBv7y2d8DMx6TfVme3q0ZpTKMMu4YL/t7ciTNtdDkwPogh3Cnjx7qk08SHwf+dksZ7M2vCOlfsF0hQ6J4ehPCaHTNrM/zBSOqD83dBEBCW/F/LEmeh0nOHd7oVl3/Qo/9GUDkkbj7yz+9cvvu+dDAtx8NzCDTP4iKdZvk9MWiizvtILLepysflSvTLFBZ37RLwiriqyRxYv/zrgFd/9XVHh/OmzBvDX4mitMR/lUavs2Vx6cR94lzAkplm3IRNy4TFfu47tuYs9EQPIPVta4P64tV+sZ7n3ued3cgEx2YK+QL5+xms6osk8qQbTyuKVGdaX9FQqk6qfDnT5ykxk0VK7KZ62b6DNDUfQlqGHxSMKv1P0XN5BqMeKG1P4Wp5QfZDUCEldppoX0U6ss2jIko2XpURKCIhfaOqLPfShdtS37ZrT+jFRSH2xYVV1rmT/MBtRQhxiO4MQ3iAGlaZi+9PWBEIXOVnu9jN1f921lWLZky9bqbM3J2MAAI9jmuAx3gyoEUa6P2ivs0EeNv/OR+AX6q5SW6l5HaoFuS6jr6yg9limu+P0KYKzfMXWcQSfTXzpOzKEKpwI3YGXZpSSy2LTlMgfmFA3CF6R5c9xWEtRuCg2ZPUQ2Nb6dRFTNd4TfGHrnEWSKHPuRyiJSDAZ+KX0VxmSHjGPbQTLVpqixia2uyhQ394gBMt7C3ZAmxn/DJS+l1fBsAo2Eir/C0jG9csd4+/tp12pPc/BVJGaK9mfvr7M/CeztrmCO5qY06Edi4xAGtiEhnWAbzLy2VEyazE1J5nPmgU4RpW4Sa0TnOT6w5lgt3/tMpROigHHmexBGAMY0mdcDbDxWIz41NgdD6oxgHsJRgr5RnT6wZAkTOcStU4NMOQNemSO7gxGahdEsC+NRVGxMUhQmmM0llWRbbmFGHzEqLM4Iw0H7577Kyo+Zf+2cUFIOw93gEY171vQaM0HLwpjpdRR6Jz7V0ckE7XzYJ0TmY9znLdzkva0vNrAGGT5SUZ5uaHDkcGvI0ySpwkasEgZPMseYcu85w8HPdSNi+4T6A83iAwDbxgeFcB1ZM2iGXzFcEOUlYVrEckaOyodfvaYSQ7GuB4ISE0nYJc15X/1ciDTPbPCgYJK55VkEor4LvzL9S2WDy4xj+6FOqVyTAC2ZNowheeeSI5hA/02l8UYkv4nk9iaVn+kCVEUstgk5Hyq+gJm6R9vG3rhuM904he/hFmNQaUIATB1y3vw+OmxP4X5Yi6A5I5jJufHCjF9+AGNwnEllZjUco6XhsO5T5+R3yxz5yLVOnAn0zuS+6zdj0nTJbEZCbXJdtpfYZfCeCOqJHoE2vPPFS6eRLjIJlG69X93nfR0mxSFXzp1Zc0lt/VafDaImhUMtbnqWVb9M4nGNQLN68BHP7AR8Il9dkcxzmBv8PCZlw9guY0lurbBsmNYlwJZsA/B15/HfkbjbwPddaVecls/elmDHNW2r4crAx43feNkfRwsaNq/yyJ0d/p5hZ6AZajz7DBfUok0ZU62gCzz7x8eVfJTKA8IWn45vINLSM1q+HF9CV9qF3zP6Ml21kPPL3CXzkuYUlnSqT+Ij4tI/od5KwIs+tDajDs64owN7tOAd6eucGz+KfO26iNcBFpbWA5732bBNWO4kHNpr9D955L61bvHCF/mwSrz6eQaDjfDEANqGMkFc+NGxpKZzCD2sj/JrHd+zlPQ8Iz7Q+2JVIiVCuCKoK/hlAEHzvk/Piq3mRL1rT/fEh9hoT5GJmeYswg1otiKydizJ/fS2SeKHVu6Z3JEHjiW8NaTQgP5xdBli8nC57XiN9hrquBu99hn9zqwo92+PM2JXtpeVZS0PdqR5mDyDreMMtEws+CpwaRyyzoYtfcvt9PJIW0fJVNNi/FFyRsea7peLvJrL+5b4GOXJ8tAr+ATk9f8KmiIsRhqRy0vFzwRV3Z5dZ3QqIU8JQ/uQpkJbjMUMFj2F9sCFeaBjI4+fL/oN3+LQgjI4zuAfQ+3IPIPFQBccf0clJpsfpnBxD84atwtupkGqKvrH7cGNl/QcWcSi6wcVDML6ljOgYbo+2BOAWNNjlUBPiyitUAwbnhFvLbnqw42kR3Yp2kv2dMeDdcGOX5kT4S6M44KHEB/SpCfl7xgsUvs+JNY9G3O2X/6FEt9FyAn57lrbiu+tl83sCymSvq9eZbe9mchL7MTf/Ta78e80zSf0hYY5eUU7+ff14jv7Xy8qjzfzzzvaJnrIdvFb5BLWKcWGy5/w7+vV2cvIfwHqdTB+RuJK5oj9mbt0Hy94AmjMjjwYNZlNS6uiyxNnwNyt3gdreLb64p/3+08nXkb92LTkkRgFOwk1oGEVllcOj5lv1hfAZywDows0944U8vUFw+A/nuVq/UCygsrmWIBnHyU01d0XJPwriEOvx/ISK6Pk4y2w0gmojZs7lU8TtakBAdne4v/aNxmMpK4VcGMp7si0yqsiolXRuOi1Z1P7SqD3Zmp0CWcyK4Ubmp2SXiXuI5nGLCieFHKHNRIlcY3Pys2dwMTYCaqlyWSITwr2oGXvyU3h1Pf8eQ3w1bnD7ilocVjYDkcXR3Oo1BXgMLTUjNw2xMVwjtp99NhSVc5aIWrDQT5DHPKtCtheBP4zHcw4dz2eRdTMamhlHhtfgqJJHI7NGDUw1XL8vsSeSHyKqDtqoAmrQqsYwvwi7HW3ojWyhIa5oz5xJTaq14NAzFLjVLR12rRNUQ6xohDnrWFb5bG9yf8aCD8d5phoackcNJp+Dw3Due3RM+5Rid7EuIgsnwgpX0rUWh/nqPtByMhMZZ69NpgvRTKZ62ViZ+Q7Dp5r4K0d7EfJuiy06KuIYauRh5Ecrhdt2QpTS1k1AscEHvapNbU3HL1F2TFyR33Wxb5MvH5iZsrn3SDcsxlnnshO8PLwmdGN+paWnQuORtZGX37uhFT64SeuPsx8UOokY6ON85WdQ1dki5zErsJGazcBOddWJEKqNPiJpsMD1GrVLrVY+AOdPWQneTyyP1hRX/lMM4ZogGGOhYuAdr7F/DOiAoc++cn5vlf0zkMUJ40Z1rlgv9BelPqVOpxKeOpzKdF8maK+1Vv23MO9k/8+qpLoxrIGH2EDQlnGmH8CD31G8QqlyQIcpmR5bwmSVw9/Ns6IHgulCRehvZ/+VrM60Cu/r3AontFfrljew74skYe2uyn7JKQtFQBQRJ9ryGic/zQOsbS4scUBctA8cPToQ3x6ZBQu6DPu5m1bnCtP8TllLYA0UTQNVqza5nfew3Mopy1GPUwG5jsl0OVXniPmAcmLqO5HG8Hv3nSLecE9oOjPDXcsTxoCBxYyzBdj4wmnyEV4kvFDunipS8SSkvdaMnTBN9brHUR8xdmmEAp/Pdqk9uextp1t+JrtXwpN/MG2w/qhRMpSNxQ1uhg/kKO30eQ/FyHUDkWHT8V6gGRU4DhDMxZu7xXij9Ui6jlpWmQCqJg3FkOTq3WKneCRYZxBXMNAVLQgHXSCGSqNdjebY94oyIpVjMYehAiFx/tqzBXFHZaL5PeeD74rW5OysFoUXY8sebUZleFTUa/+zBKVTFDopTReXNuZq47QjkWnxjirCommO4L/GrFtVV21EpMyw8wyThL5Y59d88xtlx1g1ttSICDwnof6lt/6zliPzgVUL8jWBjC0o2D6Kg+jNuThkAlaDJsq/AG2aKA//A76avw2KNqtv223P+Wq3StRDDNKFFgtsFukYt1GFDWooFVXitaNhb3RCyJi4cMeNjROiPEDb4k+G3+hD8tsg+5hhmSc/8t2JTSwYoCzAI75doq8QTHe+E/Tw0RQSUDlU+6uBeNN3h6jJGX/mH8oj0i3caCNsjvTnoh73BtyZpsflHLq6AfwJNCDX4S98h4+pCOhGKDhV3rtkKHMa3EG4J9y8zFWI4UsfNzC/Rl5midNn7gwoN9j23HGCQQ+OAZpTTPMdiVow740gIyuEtd0qVxMyNXhHcnuXRKdw5wDUSL358ktjMXmAkvIB73BLa1vfF9BAUZInPYJiwxqFWQQBVk7gQH4ojfUQ/KEjn+A/WR6EEe4CtbpoLe1mzHkajgTIoE0SLDHVauKhrq12zrAXBGbPPWKCt4DGedq3JyGRbmPFW32bE7T20+73BatV/qQhhBWfWBFHfhYWXjALts38FemnoT+9bn1jDBMcUMmYgSc0e7GQjv2MUBwLU8ionCpgV+Qrhg7iUIfUY6JFxR0Y+ZTCPM+rVuq0GNLyJXX6nrUTt8HzFBRY1E/FIm2EeVA9NcXrj7S6YYIChVQCWr/m2fYUjC4j0XLkzZ8GCSLfmkW3PB/xq+nlXsKVBOj7vTvqKCOMq7Ztqr3cQ+N8gBnPaAps+oGwWOkbuxnRYj/x/WjiDclVrs22xMK4qArE1Ztk1456kiJriw6abkNeRHogaPRBgbgF9Z8i/tbzWELN4CvbqtrqV9TtGSnmPS2F9kqOIBaazHYaJ9bi3AoDBvlZasMluxt0BDXfhp02Jn411aVt6S4TUB8ZgFDkI6TP6gwPY85w+oUQSsjIeXVminrwIdK2ZAawb8Se6XOJbOaliQxHSrnAeONDLuCnFejIbp4YDtBcQCwMsYiRZfHefuEJqJcwKTTJ8sx5hjHmJI1sPFHOr6W9AhZ2NAod38mnLQk1gOz2LCAohoQbgMbUK9RMEA3LkiF7Sr9tLZp6lkciIGhE2V546w3Mam53VtVkGbB9w0Yk2XiRnCmbpxmHr2k4eSC0RuNbjNsUfDIfc8DZvRvgUDe1IlKdZTzcT4ZGEb53dp8VtsoZlyXzLHOdAbsp1LPTVaHvLA0GYDFMbAW/WUBfUAdHwqLFAV+3uHvYWrCfhUOR2i89qvCBoOb48usAGdcF2M4aKn79k/43WzBZ+xR1L0uZfia70XP9soQReeuhZiUnXFDG1T8/OXNmssTSnYO+3kVLAgeiY719uDwL9FQycgLPessNihMZbAKG7qwPZyG11G1+ZA3jAX2yddpYfmaKBlmfcK/V0mwIRUDC0nJSOPUl2KB8h13F4dlVZiRhdGY5farwN+f9hEb1cRi41ZcGDn6Xe9MMSTOY81ULJyXIHSWFIQHstVYLiJEiUjktlHiGjntN5/btB8Fu+vp28zl2fZXN+dJDyN6EXhS+0yzqpl/LSJNEUVxmu7BsNdjAY0jVsAhkNuuY0E1G48ej25mSt+00yPbQ4SRCVkIwb6ISvYtmJRPz9Zt5dk76blf+lJwAPH5KDF+vHAmACLoCdG2Adii6dOHnNJnTmZtoOGO8Q1jy1veMw6gbLFToQmfJa7nT7Al89mRbRkZZQxJTKgK5Kc9INzmTJFp0tpAPzNmyL/F08bX3nhCumM/cR/2RPn9emZ3VljokttZD1zVWXlUIqEU7SLk5I0lFRU0AcENXBYazNaVzsVHA/sD3o9hm42wbHIRb/BBQTKzAi8s3+bMtpOOZgLdQzCYPfX3UUxKd1WYVkGH7lh/RBBgMZZwXzU9+GYxdBqlGs0LP+DZ5g2BWNh6FAcR944B+K/JTWI3t9YyVyRhlP4CCoUk/mmF7+r2pilVBjxXBHFaBfBtr9hbVn2zDuI0kEOG3kBx8CGdPOjX1ph1POOZJUO1JEGG0jzUy2tK4X0CgVNYhmkqqQysRNtKuPdCJqK3WW57kaV17vXgiyPrl4KEEWgiGF1euI4QkSFHFf0TDroQiLNKJiLbdhH0YBhriRNCHPxSqJmNNoketaioohqMglh6wLtEGWSM1EZbQg72h0UJAIPVFCAJOThpQGGdKfFovcwEeiBuZHN2Ob4uVM7+gwZLz1D9E7ta4RmMZ24OBBAg7Eh6dLXGofZ4U2TFOCQMKjwhVckjrydRS+YaqCw1kYt6UexuzbNEDyYLTZnrY1PzsHZJT4U+awO2xlqTSYu6n/U29O2wPXgGOEKDMSq+zTUtyc8+6iLp0ivav4FKx+xxVy4FxhIF/pucVDqpsVe2jFOfdZhTzLz2QjtzvsTCvDPU7bzDH2eXVKUV9TZ+qFtaSSxnYgYdXKwVreIgvWhT9eGDB2OvnWyPLfIIIfNnfIxU8nW7MbcH05nhlsYtaW9EZRsxWcKdEqInq1DiZPKCz7iGmAU9/ccnnQud2pNgIGFYOTAWjhIrd63aPDgfj8/sdlD4l+UTlcxTI9jbaMqqN0gQxSHs60IAcW3cH4p3V1aSciTKB29L1tz2eUQhRiTgTvmqc+sGtBNh4ky0mQJGsdycBREP+fAaSs1EREDVo5gvgi5+aCN7NECw30owbCc1mSpjiahyNVwJd1jiGgzSwfTpzf2c5XJvG/g1n0fH88KHNnf+u7ZiRMlXueSIsloJBUtW9ezvsx9grfsX/FNxnbxU1Lvg0hLxixypHKGFAaPu0xCD8oDTeFSyfRT6s8109GMUZL8m2xXp8X2dpPCWWdX84iga4BrTlOfqox4shqEgh/Ht4qRst52cA1xOIUuOxgfUivp6v5f8IVyaryEdpVk72ERAwdT4aoY1usBgmP+0m06Q216H/nubtNYxHaOIYjcach3A8Ez/zc0KcShhel0HCYjFsA0FjYqyJ5ZUH1aZw3+zWC0hLpM6GDfcAdn9fq2orPmZbW6XXrf+Krc9RtvII5jeD3dFoT1KwZJwxfUMvc5KLfn8rROW23Jw89sJ2a5dpB3qWDUBWF2iX8OCuKprHosJ2mflBR+Wqs86VvgI/XMnsqb97+VlKdPVysczPj8Jhzf+WCvGBHijAqYlavbF60soMWlHbvKT+ScvhprgeTln51xX0sF+Eadc/l2s2a5BgkVbHYyz0E85p0LstqH+gEGiR84nBRRFIn8hLSZrGwqjZ3E29cuGi+5Z5bp7EM8MWFa9ssS/vy4VrDfECSv7DSU84DaP0sXI3Ap4lWznQ65nQoTKRWU30gd7Nn8ZowUvGIx4aqyXGwmA/PB4qN8msJUODezUHEl0VP9uo+cZ8vPFodSIB4C7lQYjEFj8yu49C2KIV3qxMFYTevG8KqAr0TPlkbzHHnTpDpvpzziAiNFh8xiT7C/TiyH0EguUw4vxAgpnE27WIypV+uFN2zW7xniF/n75trs9IJ5amB1zXXZ1LFkJ6GbS/dFokzl4cc2mamVwhL4XU0Av5gDWAl+aEWhAP7t2VIwU+EpvfOPDcLASX7H7lZpXA2XQfbSlD4qU18NffNPoAKMNSccBfO9YVVgmlW4RydBqfHAV7+hrZ84WJGho6bNT0YMhxxLdOx/dwGj0oyak9aAkNJ8lRJzUuA8sR+fPyiyTgUHio5+Pp+YaKlHrhR41jY5NESPS3x+zTMe0S2HnLOKCOQPpdxKyviBvdHrCDRqO+l96HhhNBLXWv4yEMuEUYo8kXnYJM8oIgVM4XJ+xXOev4YbWeqsvgq0lmw4/PiYr9sYLt+W5EAuYSFnJEan8CwJwbtASBfLBBpJZiRPor/aCJBZsM+MhvS7ZepyHvU8m5WSmaZnxuLts8ojl6KkS8oSAHkq5GWlCB/NgJ5W3rO2Cj1MK7ahxsCrbTT3a0V/QQH+sErxV4XUWDHx0kkFy25bPmBMBQ6BU3HoHhhYcJB9JhP6NXUWKxnE0raXHB6U9KHpWdQCQI72qevp5fMzcm+AvC85rsynVQhruDA9fp9COe7N56cg1UKGSas89vrN+WlGLYTwi5W+0xYdKEGtGCeNJwXKDU0XqU5uQYnWsMwTENLGtbQMvoGjIFIEMzCRal4rnBAg7D/CSn8MsCvS+FDJJAzoiioJEhZJgAp9n2+1Yznr7H+6eT4YkJ9Mpj60ImcW4i4iHDLn9RydB8dx3QYm3rsX6n4VRrZDsYK6DCGwkwd5n3/INFEpk16fYpP6JtMQpqEMzcOfQGAHXBTEGzuLJ03GYQL9bmV2/7ExDlRf+Uvf1sM2frRtCWmal12pMgtonvSCtR4n1CLUZRdTHDHP1Otwqd+rcdlavnKjUB/OYXQHUJzpNyFoKpQK+2OgrEKpGyIgIBgn2y9QHnTJihZOpEvOKIoHAMGAXHmj21Lym39Mbiow4IF+77xNuewziNVBxr6KD5e+9HzZSBIlUa/AmsDFJFXeyrQakR3FwowTGcADJHcEfhGkXYNGSYo4dh4bxwLM+28xjiqkdn0/3R4UEkvcBrBfn/SzBc1XhKM2VPlJgKSorjDac96V2UnQYXl1/yZPT4DVelgO+soMjexXwYO58VLl5xInQUZI8jc3H2CPnCNb9X05nOxIy4MlecasTqGK6s2az4RjpF2cQP2G28R+7wDPsZDZC/kWtjdoHC7SpdPmqQrUAhMwKVuxCmYTiD9q/O7GHtZvPSN0CAUQN/rymXZNniYLlJDE70bsk6Xxsh4kDOdxe7A2wo7P9F5YvqqRDI6brf79yPCSp4I0jVoO4YnLYtX5nzspR5WB4AKOYtR1ujXbOQpPyYDvfRE3FN5zw0i7reehdi7yV0YDRKRllGCGRk5Yz+Uv1fYl2ZwrnGsqsjgAVo0xEUba8ohjaNMJNwTwZA/wBDWFSCpg1eUH8MYL2zdioxRTqgGQrDZxQyNzyBJPXZF0+oxITJAbj7oNC5JwgDMUJaM5GqlGCWc//KCIrI+aclEe4IA0uzv7cuj6GCdaJONpi13O544vbtIHBF+A+JeDFUQNy61Gki3rtyQ4aUywn6ru314/dkGiP8Iwjo0J/2Txs49ZkwEl4mx+iYUUO55I6pJzU4P+7RRs+DXZkyKUYZqVWrPF4I94m4Wx1tXeE74o9GuX977yvJ/jkdak8+AmoHVjI15V+WwBdARFV2IPirJgVMdsg1Pez2VNHqa7EHWdTkl3XTcyjG9BiueWFvQfXI8aWSkuuRmqi/HUuzqyvLJfNfs0txMqldYYflWB1BS31WkuPJGGwXUCpjiQSktkuBMWwHjSkQxeehqw1Kgz0Trzm7QbtgxiEPDVmWCNCAeCfROTphd1ZNOhzLy6XfJyG6Xgd5MCAZw4xie0Sj5AnY1/akDgNS9YFl3Y06vd6FAsg2gVQJtzG7LVq1OH2frbXNHWH/NY89NNZ4QUSJqL2yEcGADbT38X0bGdukqYlSoliKOcsSTuqhcaemUeYLLoI8+MZor2RxXTRThF1LrHfqf/5LcLAjdl4EERgUysYS2geE+yFdasU91UgUDsc2cSQ1ZoT9+uLOwdgAmifwQqF028INc2IQEDfTmUw3eZxvz7Ud1z3xc1PQfeCvfKsB9jOhRj7rFyb9XcDWLcYj0bByosychMezMLVkFiYcdBBQtvI6K0KRuOZQH2kBsYHJaXTkup8F0eIhO1/GcIwWKpr2mouB7g5TUDJNvORXPXa/mU8bh27TAZYBe2sKx4NSv5OjnHIWD2RuysCzBlUfeNXhDd2jxnHoUlheJ3jBApzURy0fwm2FwwsSU0caQGl0Kv8hopRQE211NnvtLRsmCNrhhpEDoNiZEzD2QdJWKbRRWnaFedXHAELSN0t0bfsCsMf0ktfBoXBoNA+nZN9+pSlmuzspFevmsqqcMllzzvkyXrzoA+Ryo1ePXpdGOoJvhyru+EBRsmOp7MXZ0vNUMUqHLUoKglg1p73sWeZmPc+KAw0pE2zIsFFE5H4192KwDvDxdxEYoDBDNZjbg2bmADTeUKK57IPD4fTYF4c6EnXx/teYMORBDtIhPJneiZny7Nv/zG+YmekIKCoxr6kauE2bZtBLufetNG0BtBY7f+/ImUypMBvdWu/Q7vTMRzw5aQGZWuc1V0HEsItFYMIBnoKGZ0xcarba/TYZq50kCaflFysYjA4EDKHqGdpYWdKYmm+a7TADmW35yfnOYpZYrkpVEtiqF0EujI00aeplNs2k+qyFZNeE3CDPL9P6b4PQ/kataHkVpLSEVGK7EX6rAa7IVNrvZtFvOA6okKvBgMtFDAGZOx88MeBcJ8AR3AgUUeIznAN6tjCUipGDZONm1FjWJp4A3QIzSaIOmZ7DvF/ysYYbM/fFDOV0jntAjRdapxJxL0eThpEhKOjCDDq2ks+3GrwxqIFKLe1WdOzII8XIOPGnwy6LKXVfpSDOTEfaRsGujhpS4hBIsMOqHbl16PJxc4EkaVu9wpEYlF/84NSv5Zum4drMfp9yXbzzAOJqqS4YkI4cBrFrC7bMPiCfgI3nNZAqkk3QOZqR+yyqx+nDQKBBBZ7QKrfGMCL+XpqFaBJU0wpkBdAhbR4hJsmT5aynlvkouoxm/NjD5oe6BzVIO9uktM+/5dEC5P7vZvarmuO/lKXz4sBabVPIATuKTrwbJP8XUkdM6uEctHKXICUJGjaZIWRbZp8czquQYfY6ynBUCfIU+gG6wqSIBmYIm9pZpXdaL121V7q0VjDjmQnXvMe7ysoEZnZL15B0SpxS1jjd83uNIOKZwu5MPzg2NhOx3xMOPYwEn2CUzbSrwAs5OAtrz3GAaUkJOU74XwjaYUmGJdZBS1NJVkGYrToINLKDjxcuIlyfVsKQSG/G4DyiO2SlQvJ0d0Ot1uOG5IFSAkq+PRVMgVMDvOIJMdqjeCFKUGRWBW9wigYvcbU7CQL/7meF2KZAaWl+4y9uhowAX7elogAvItAAxo2+SFxGRsHGEW9BnhlTuWigYxRcnVUBRQHV41LV+Fr5CJYV7sHfeywswx4XMtUx6EkBhR+q8AXXUA8uPJ73Pb49i9KG9fOljvXeyFj9ixgbo6CcbAJ7WHWqKHy/h+YjBwp6VcN7M89FGzQ04qbrQtgrOFybg3gQRTYG5xn73ArkfQWjCJROwy3J38Dx/D7jOa6BBNsitEw1wGq780EEioOeD+ZGp2J66ADiVGMayiHYucMk8nTK2zzT9CnEraAk95kQjy4k0GRElLL5YAKLQErJ5rp1eay9O4Fb6yJGm9U4FaMwPGxtKD6odIIHKoWnhKo1U8KIpFC+MVn59ZXmc7ZTBZfsg6FQ8W10YfTr4u0nYrpHZbZ1jXiLmooF0cOm0+mPnJBXQtepc7n0BqOipNCqI6yyloTeRShNKH04FIo0gcMk0H/xThyN4pPAWjDDkEp3lNNPRNVfpMI44CWRlRgViP64eK0JSRp0WUvCWYumlW/c58Vcz/yMwVcW5oYb9+26TEhwvbxiNg48hl1VI1UXTU//Eta+BMKnGUivctfL5wINDD0giQL1ipt6U7C9cd4+lgqY2lMUZ02Uv6Prs+ZEZer7ZfWBXVghlfOOrClwsoOFKzWEfz6RZu1eCs+K8fLvkts5+BX0gyrFYve0C3qHrn5U/Oh6D/CihmWIrY7HUZRhJaxde+tldu6adYJ+LeXupQw0XExC36RETdNFxcq9glMu4cNQSX9cqR/GQYp+IxUkIcNGWVU7ZtGa6P3XAyodRt0XeS3Tp01AnCh0ZbUh4VrSZeV9RWfSoWyxnY3hzcZ30G/InDq4wxRrEejreBxnhIQbkxenxkaxl+k7eLUQkUR6vKJ2iDFNGX3WmVA1yaOH+mvhBd+sE6vacQzFobwY5BqEAFmejwW5ne7HtVNolOUgJc8CsUxmc/LBi8N5mu9VsIA5HyErnS6zeCz7VLI9+n/hbT6hTokMXTVyXJRKSG2hd2labXTbtmK4fNH3IZBPreSA4FMeVouVN3zG5x9CiGpLw/3pceo4qGqp+rVp+z+7yQ98oEf+nyH4F3+J9IheDBa94Wi63zJbLBCIZm7P0asHGpIJt3PzE3m0S4YIWyXBCVXGikj8MudDPB/6Nm2v4IxJ5gU0ii0guy5SUHqGUYzTP0jIJU5E82RHUXtX4lDdrihBLdP1YaG1AGUC12rQKuIaGvCpMjZC9bWSCYnjDlvpWbkdXMTNeBHLKiuoozMGIvkczmP0aRJSJ8PYnLCVNhKHXBNckH79e8Z8Kc2wUej4sQZoH8qDRGkg86maW/ZQWGNnLcXmq3FlXM6ssR/3P6E/bHMvm6HLrv1yRixit25JsH3/IOr2UV4BWJhxXW5BJ6Xdr07n9kF3ZNAk6/Xpc5MSFmYJ2R7bdL8Kk7q1OU9Elg/tCxJ8giT27wSTySF0GOxg4PbYJdi/Nyia9Nn89CGDulfJemm1aiEr/eleGSN+5MRrVJ4K6lgyTTIW3i9cQ0dAi6FHt0YMbH3wDSAtGLSAccezzxHitt1QdhW36CQgPcA8vIIBh3/JNjf/Obmc2yzpk8edSlS4lVdwgW5vzbYEyFoF4GCBBby1keVNueHAH+evi+H7oOVfS3XuPQSNTXOONAbzJeSb5stwdQHl1ZjrGoE49I8+A9j3t+ahhQj74FCSWpZrj7wRSFJJnnwi1T9HL5qrCFW/JZq6P62XkMWTb+u4lGpKfmmwiJWx178GOG7KbrZGqyWwmuyKWPkNswkZ1q8uptUlviIi+AXh2bOOTOLsrtNkfqbQJeh24reebkINLkjut5r4d9GR/r8CBa9SU0UQhsnZp5cP+RqWCixRm7i4YRFbtZ4EAkhtNa6jHb6gPYQv7MKqkPLRmX3dFsK8XsRLVZ6IEVrCbmNDc8o5mqsogjAQfoC9Bc7R6gfw03m+lQpv6kTfhxscDIX6s0w+fBxtkhjXAXr10UouWCx3C/p/FYwJRS/AXRKkjOb5CLmK4XRe0+xeDDwVkJPZau52bzLEDHCqV0f44pPgKOkYKgTZJ33fmk3Tu8SdxJ02SHM8Fem5SMsWqRyi2F1ynfRJszcFKykdWlNqgDA/L9lKYBmc7Zu/q9ii1FPF47VJkqhirUob53zoiJtVVRVwMR34gV9iqcBaHbRu9kkvqk3yMpfRFG49pKKjIiq7h/VpRwPGTHoY4cg05X5028iHsLvUW/uz+kjPyIEhhcKUwCkJAwbR9pIEGOn8z6svAO8i89sJ3dL5qDWFYbS+HGPRMxYwJItFQN86YESeJQhn2urGiLRffQeLptDl8dAgb+Tp47UQPxWOw17OeChLN1WnzlkPL1T5O+O3Menpn4C3IY5LEepHpnPeZHbvuWfeVtPlkH4LZjPbBrkJT3NoRJzBt86CO0Xq59oQ+8dsm0ymRcmQyn8w71mhmcuEI5byuF+C88VPYly2sEzjlzAQ3vdn/1+Hzguw6qFNNbqenhZGbdiG6RwZaTG7jTA2X9RdXjDN9yj1uQpyO4Lx8KRAcZcbZMafp4wPOd5MdXoFY52V1A8M9hi3sso93+uprE0qYNMjkE22CvK4HuUxqN7oIz5pWuETq1lQAjqlSlqdD2Rnr/ggp/TVkQYjn9lMfYelk2sH5HPdopYo7MHwlV1or9Bxf+QCyLzm92vzG2wjiIjC/ZHEJzeroJl6bdFPTpZho5MV2U86fLQqxNlGIMqCGy+9WYhJ8ob1r0+Whxde9L2PdysETv97O+xVw+VNN1TZSQN5I6l9m5Ip6pLIqLm4a1B1ffH6gHyqT9p82NOjntRWGIofO3bJz5GhkvSWbsXueTAMaJDou99kGLqDlhwBZNEQ4mKPuDvVwSK4WmLluHyhA97pZiVe8g+JxmnJF8IkV/tCs4Jq/HgOoAEGR9tCDsDbDmi3OviUQpG5D8XmKcSAUaFLRXb2lmJTNYdhtYyfjBYZQmN5qT5CNuaD3BVnlkCk7bsMW3AtXkNMMTuW4HjUERSJnVQ0vsBGa1wo3Qh7115XGeTF3NTz8w0440AgU7c3bSXO/KMINaIWXd0oLpoq/0/QJxCQSJ9XnYy1W7TYLBJpHsVWD1ahsA7FjNvRd6mxCiHsm8g6Z0pnzqIpF1dHUtP2ITU5Z1hZHbu+L3BEEStBbL9XYvGfEakv1bmf+bOZGnoiuHEdlBnaChxYKNzB23b8sw8YyT7Ajxfk49eJIAvdbVkdFCe2J0gMefhQ0bIZxhx3fzMIysQNiN8PgOUKxOMur10LduigREDRMZyP4oGWrP1GFY4t6groASsZ421os48wAdnrbovNhLt7ScNULkwZ5AIZJTrbaKYTLjA1oJ3sIuN/aYocm/9uoQHEIlacF1s/TM1fLcPTL38O9fOsjMEIwoPKfvt7opuI9G2Hf/PR4aCLDQ7wNmIdEuXJ/QNL72k5q4NejAldPfe3UVVqzkys8YZ/jYOGOp6c+YzRCrCuq0M11y7TiN6qk7YXRMn/gukxrEimbMQjr3jwRM6dKVZ4RUfWQr8noPXLJq6yh5R3EH1IVOHESst/LItbG2D2vRsZRkAObzvQAAD3mb3/G4NzopI0FAiHfbpq0X72adg6SRj+8OHMShtFxxLZlf/nLgRLbClwl5WmaYSs+yEjkq48tY7Z2bE0N91mJwt+ua0NlRJIDh0HikF4UvSVorFj2YVu9YeS5tfvlVjPSoNu/Zu6dEUfBOT555hahBdN3Sa5Xuj2Rvau1lQNIaC944y0RWj9UiNDskAK1WoL+EfXcC6IbBXFRyVfX/WKXxPAwUyIAGW8ggZ08hcijKTt1YKnUO6QPvcrmDVAb0FCLIXn5id4fD/Jx4tw/gbXs7WF9b2RgXtPhLBG9vF5FEkdHAKrQHZAJC/HWvk7nvzzDzIXZlfFTJoC3JpGgLPBY7SQTjGlUvG577yNutZ1hTfs9/1nkSXK9zzKLRZ3VODeKUovJe0WCq1zVMYxCJMenmNzPIU2S8TA4E7wWmbNkxq9rI2dd6v0VpcAPVMxnDsvWTWFayyqvKZO7Z08a62i/oH2/jxf8rpmfO64in3FLiL1GX8IGtVE9M23yGsIqJbxDTy+LtaMWDaPqkymb5VrQdzOvqldeU0SUi6IirG8UZ3jcpRbwHa1C0Dww9G/SFX3gPvTJQE+kyz+g1BeMILKKO+olcHzctOWgzxYHnOD7dpCRtuZEXACjgqesZMasoPgnuDC4nUviAAxDc5pngjoAITIkvhKwg5d608pdrZcA+qn5TMT6Uo/QzBaOxBCLTJX3Mgk85rMfsnWx86oLxf7p2PX5ONqieTa/qM3tPw4ZXvlAp83NSD8F7+ZgctK1TpoYwtiU2h02HCGioH5tkVCqNVTMH5p00sRy2JU1qyDBP2CII/Dg4WDsIl+zgeX7589srx6YORRQMBfKbodbB743Tl4WLKOEnwWUVBsm94SOlCracU72MSyj068wdpYjyz1FwC2bjQnxnB6Mp/pZ+yyZXtguEaYB+kqhjQ6UUmwSFazOb+rhYjLaoiM+aN9/8KKn0zaCTFpN9eKwWy7/u4EHzO46TdFSNjMfn2iPSJwDPCFHc0I1+vjdAZw5ZjqR/uzi9Zn20oAa5JnLEk/EA3VRWE7J/XrupfFJPtCUuqHPpnlL7ISJtRpSVcB8qsZCm2QEkWoROtCKKxUh3yEcMbWYJwk6DlEBG0bZP6eg06FL3v6RPb7odGuwm7FN8fG4woqtB8e7M5klPpo97GoObNwt+ludTAmxyC5hmcFx+dIvEZKI6igFKHqLH01iY1o7903VzG9QGetyVx5RNmBYUU+zIuSva/yIcECUi4pRmE3VkF2avqulQEUY4yZ/wmNboBzPmAPey3+dSYtBZUjeWWT0pPwCz4Vozxp9xeClIU60qvEFMQCaPvPaA70WlOP9f/ey39macvpGCVa+zfa8gO44wbxpJUlC8GN/pRMTQtzY8Z8/hiNrU+Zq64ZfFGIkdj7m7abcK1EBtws1X4J/hnqvasPvvDSDYWN+QcQVGMqXalkDtTad5rYY0TIR1Eqox3czwPMjKPvF5sFv17Thujr1IZ1Ytl4VX1J0vjXKmLY4lmXipRAro0qVGEcXxEVMMEl54jQMd4J7RjgomU0j1ptjyxY+cLiSyXPfiEcIS2lWDK3ISAy6UZ3Hb5vnPncA94411jcy75ay6B6DSTzK6UTCZR9uDANtPBrvIDgjsfarMiwoax2OlLxaSoYn4iRgkpEGqEkwox5tyI8aKkLlfZ12lO11TxsqRMY89j5JaO55XfPJPDL1LGSnC88Re9Ai+Nu5bZjtwRrvFITUFHPR4ZmxGslQMecgbZO7nHk32qHxYkdvWpup07ojcMCaVrpFAyFZJJbNvBpZfdf39Hdo2kPtT7v0/f8R/B5Nz4f1t9/3zNM/7n6SUHfcWk5dfQFJvcJMgPolGCpOFb/WC0FGWU2asuQyT+rm88ZKZ78Cei/CAh939CH0JYbpZIPtxc2ufXqjS3pHH9lnWK4iJ7OjR/EESpCo2R3MYKyE7rHfhTvWho4cL1QdN4jFTyR6syMwFm124TVDDRXMNveI1Dp/ntwdz8k8kxw7iFSx6+Yx6O+1LzMVrN0BBzziZi9kneZSzgollBnVwBh6oSOPHXrglrOj+QmR/AESrhDpKrWT+8/AiMDxS/5wwRNuGQPLlJ9ovomhJWn8sMLVItQ8N/7IXvtD8kdOoHaw+vBSbFImQsv/OCAIui99E+YSIOMlMvBXkAt+NAZK8wB9Jf8CPtB+TOUOR+z71d/AFXpPBT6+A5FLjxMjLIEoJzrQfquvxEIi+WoUzGR1IzQFNvbYOnxb2PyQ0kGdyXKzW2axQL8lNAXPk6NEjqrRD1oZtKLlFoofrXw0dCNWASHzy+7PSzOUJ3XtaPZsxLDjr+o41fKuKWNmjiZtfkOzItvlV2MDGSheGF0ma04qE3TUEfqJMrXFm7DpK+27DSvCUVf7rbNoljPhha5W7KBqVq0ShUSTbRmuqPtQreVWH4JET5yMhuqMoSd4r/N8sDmeQiQQvi1tcZv7Moc7dT5X5AtCD6kNEGZOzVcNYlpX4AbTsLgSYYliiPyVoniuYYySxsBy5cgb3pD+EK0Gpb0wJg031dPgaL8JZt6sIvzNPEHfVPOjXmaXj4bd4voXzpZ5GApMhILgMbCEWZ2zwgdeQgjNHLbPIt+KqxRwWPLTN6HwZ0Ouijj4UF+Sg0Au8XuIKW0WxlexdrFrDcZJ8Shauat3X0XmHygqgL1nAu2hrJFb4wZXkcS+i36KMyU1yFvYv23bQUJi/3yQpqr/naUOoiEWOxckyq/gq43dFou1DVDaYMZK9tho7+IXXokBCs5GRfOcBK7g3A+jXQ39K4YA8PBRW4m5+yR0ZAxWJncjRVbITvIAPHYRt1EJ3YLiUbqIvoKHtzHKtUy1ddRUQ0AUO41vonZDUOW+mrszw+SW/6Q/IUgNpcXFjkM7F4CSSQ2ExZg85otsMs7kqsQD4OxYeBNDcSpifjMoLb7GEbGWTwasVObmB/bfPcUlq0wYhXCYEDWRW02TP5bBrYsKTGWjnWDDJ1F7zWai0zW/2XsCuvBQjPFcTYaQX3tSXRSm8hsAoDdjArK/OFp6vcWYOE7lizP0Yc+8p16i7/NiXIiiQTp7c7Xus925VEtlKAjUdFhyaiLT7VxDagprMFwix4wZ05u0qj7cDWFd0W9OYHIu3JbJKMXRJ1aYNovugg+QqRN7fNHSi26VSgBpn+JfMuPo3aeqPWik/wI5Rz3BWarPQX4i5+dM0npwVOsX+KsOhC7vDg+OJsz4Q5zlnIeflUWL6QYMbf9WDfLmosLF4Qev3mJiOuHjoor/dMeBpA9iKDkMjYBNbRo414HCxjsHrB4EXNbHzNMDHCLuNBG6Sf+J4MZ/ElVsDSLxjIiGsTPhw8BPjxbfQtskj+dyNMKOOcUYIRBEIqbazz3lmjlRQhplxq673VklMMY6597vu+d89ec/zq7Mi4gQvh87ehYbpOuZEXj5g/Q7S7BFDAAB9DzG35SC853xtWVcnZQoH54jeOqYLR9NDuwxsVthTV7V99n/B7HSbAytbEyVTz/5NhJ8gGIjG0E5j3griULUd5Rg7tQR+90hJgNQKQH2btbSfPcaTOfIexc1db1BxUOhM1vWCpLaYuKr3FdNTt/T3PWCpEUWDKEtzYrjpzlL/wri3MITKsFvtF8QVV/NhVo97aKIBgdliNc10dWdXVDpVtsNn+2UIolrgqdWA4EY8so0YvB4a+aLzMXiMAuOHQrXY0tr+CL10JbvZzgjJJuB1cRkdT7DUqTvnswVUp5kkUSFVtIIFYK05+tQxT6992HHNWVhWxUsD1PkceIrlXuUVRogwmfdhyrf6zzaL8+c0L7GXMZOteAhAVQVwdJh+7nrX7x4LaIIfz2F2v7Dg/uDfz2Fa+4gFm2zHAor8UqimJG3VTJtZEoFXhnDYXvxMJFc6ku2bhbCxzij2z5UNuK0jmp1mnvkVNUfR+SEmj1Lr94Lym75PO7Fs0MIr3GdsWXRXSfgLTVY0FLqba97u1In8NAcY7IC6TjWLigwKEIm43NxTdaVTv9mcKkzuzBkKd8x/xt1p/9BbP7Wyb4bpo1K1gnOpbLvKz58pWl3B55RJ/Z5mRDLPtNQg14jdOEs9+h/V5UVpwrAI8kGbX8KPVPDIMfIqKDjJD9UyDOPhjZ3vFAyecwyq4akUE9mDOtJEK1hpDyi6Ae87sWAClXGTiwPwN7PXWwjxaR79ArHRIPeYKTunVW24sPr/3HPz2IwH8oKH4OlWEmt4BLM6W5g4kMcYbLwj2usodD1088stZA7VOsUSpEVl4w7NMb1EUHMRxAxLF0CIV+0L3iZb+ekB1vSDSFjAZ3hfLJf7gFaXrOKn+mhR+rWw/eTXIcAgl4HvFuBg1LOmOAwJH3eoVEjjwheKA4icbrQCmvAtpQ0mXG0agYp5mj4Rb6mdQ+RV4QBPbxMqh9C7o8nP0Wko2ocnCHeRGhN1XVyT2b9ACsL+6ylUy+yC3QEnaKRIJK91YtaoSrcWZMMwxuM0E9J68Z+YyjA0g8p1PfHAAIROy6Sa04VXOuT6A351FOWhKfTGsFJ3RTJGWYPoLk5FVK4OaYR9hkJvezwF9vQN1126r6isMGXWTqFW+3HL3I/jurlIdDWIVvYY+s6yq7lrFSPAGRdnU7PVwY/SvWbZGpXzy3BQ2LmAJlrONUsZs4oGkly0V267xbD5KMY8woNNsmWG1VVgLCra8aQBBcI4DP2BlNwxhiCtHlaz6OWFoCW0vMR3ErrG7JyMjTSCnvRcsEHgmPnwA6iNpJ2DrFb4gLlhKJyZGaWkA97H6FFdwEcLT6DRQQL++fOkVC4cYGW1TG/3iK5dShRSuiBulmihqgjR45Vi03o2RbQbP3sxt90VxQ6vzdlGfkXmmKmjOi080JSHkLntjvsBJnv7gKscOaTOkEaRQqAnCA4HWtB4XnMtOhpRmH2FH8tTXrIjAGNWEmudQLCkcVlGTQ965Kh0H6ixXbgImQP6b42B49sO5C8pc7iRlgyvSYvcnH9FgQ3azLbQG2cUW96SDojTQStxkOJyOuDGTHAnnWkz29aEwN9FT8EJ4yhXOg+jLTrCPKeEoJ9a7lDXOjEr8AgX4BmnMQ668oW0zYPyQiVMPxKRHtpfnEEyaKhdzNVThlxxDQNdrHeZiUFb6NoY2KwvSb7BnRcpJy+/g/zAYx3fYSN5QEaVD2Y1VsNWxB0BSO12MRsRY8JLfAezRMz5lURuLUnG1ToKk6Q30FughqWN6gBNcFxP/nY/iv+iaUQOa+2Nuym46wtI/DvSfzSp1jEi4SdYBE7YhTiVV5cX9gwboVDMVgZp5YBQlHOQvaDNfcCoCJuYhf5kz5kwiIKPjzgpcRJHPbOhJajeoeRL53cuMahhV8Z7IRr6M4hW0JzT7mzaMUzQpm866zwM7Cs07fJYXuWvjAMkbe5O6V4bu71sOG6JQ4oL8zIeXHheFVavzxmlIyBkgc9IZlEDplMPr8xlcyss4pVUdwK1e7CK2kTsSdq7g5SHRAl3pYUB9Ko4fsh4qleOyJv1z3KFSTSvwEcRO/Ew8ozEDYZSqpfoVW9uhJfYrNAXR0Z3VmeoAD+rVWtwP/13sE/3ICX3HhDG3CMc476dEEC0K3umSAD4j+ZQLVdFOsWL2C1TH5+4KiSWH+lMibo+B55hR3Gq40G1n25sGcN0mEcoU2wN9FCVyQLBhYOu9aHVLWjEKx2JIUZi5ySoHUAI9b8hGzaLMxCZDMLhv8MkcpTqEwz9KFDpCpqQhVmsGQN8m24wyB82FAKNmjgfKRsXRmsSESovAwXjBIoMKSG51p6Um8b3i7GISs7kjTq/PZoioCfJzfKdJTN0Q45kQEQuh9H88M3yEs3DbtRTKALraM0YC8laiMiOOe6ADmTcCiREeAWZelBaEXRaSuj2lx0xHaRYqF65O0Lo5OCFU18A8cMDE4MLYm9w2QSr9NgQAIcRxZsNpA7UJR0e71JL+VU+ISWFk5I97lra8uGg7GlQYhGd4Gc6rxsLFRiIeGO4abP4S4ekQ1fiqDCy87GZHd52fn5aaDGuvOmIofrzpVwMvtbreZ/855OaXTRcNiNE0wzGZSxbjg26v8ko8L537v/XCCWP2MFaArJpvnkep0pA+O86MWjRAZPQRfznZiSIaTppy6m3p6HrNSsY7fDtz7Cl4V/DJAjQDoyiL2uwf1UHVd2AIrzBUSlJaTj4k6NL97a/GqhWKU9RUmjnYKpm2r+JYUcrkCuZKvcYvrg8pDoUKQywY9GDWg03DUFSirlUXBS5SWn/KAntnf0IdHGL/7mwXqDG+LZYjbEdQmqUqq4y54TNmWUP7IgcAw5816YBzwiNIJiE9M4lPCzeI/FGBeYy3p6IAmH4AjXXmvQ4Iy0Y82NTobcAggT2Cdqz6Mx4TdGoq9fn2etrWKUNFyatAHydQTVUQ2S5OWVUlugcNvoUrlA8cJJz9MqOa/W3iVno4zDHfE7zhoY5f5lRTVZDhrQbR8LS4eRLz8iPMyBL6o4PiLlp89FjdokQLaSBmKHUwWp0na5fE3v9zny2YcDXG/jfI9sctulHRbdkI5a4GOPJx4oAJQzVZ/yYAado8KNZUdEFs9ZPiBsausotXMNebEgr0dyopuqfScFJ3ODNPHgclACPdccwv0YJGQdsN2lhoV4HVGBxcEUeUX/alr4nqpcc1CCR3vR7g40zteQg/JvWmFlUE4mAiTpHlYGrB7w+U2KdSwQz2QJKBe/5eiixWipmfP15AFWrK8Sh1GBBYLgzki1wTMhGQmagXqJ2+FuqJ8f0XzXCVJFHQdMAw8xco11HhM347alrAu+wmX3pDFABOvkC+WPX0Uhg1Z5MVHKNROxaR84YV3s12UcM+70cJ460SzEaKLyh472vOMD3XnaK7zxZcXlWqenEvcjmgGNR2OKbI1s8U+iwiW+HotHalp3e1MGDy6BMVIvajnAzkFHbeVsgjmJUkrP9OAwnEHYXVBqYx3q7LvXjoVR0mY8h+ZaOnh053pdsGkmbqhyryN01eVHySr+CkDYkSMeZ1xjPNVM+gVLTDKu2VGsMUJqWO4TwPDP0VOg2/8ITbAUaMGb4LjL7L+Pi11lEVMXTYIlAZ/QHmTENjyx3kDkBdfcvvQt6tKk6jYFM4EG5UXDTaF5+1ZjRz6W7MdJPC+wTkbDUim4p5QQH3b9kGk2Bkilyeur8Bc20wm5uJSBO95GfYDI1EZipoRaH7uVveneqz43tlTZGRQ4a7CNmMHgXyOQQOL6WQkgMUTQDT8vh21aSdz7ERiZT1jK9F+v6wgFvuEmGngSvIUR2CJkc5tx1QygfZnAruONobB1idCLB1FCfO7N1ZdRocT8/Wye+EnDiO9pzqIpnLDl4bkaRKW+ekBVwHn46Shw1X0tclt/0ROijuUB4kIInrVJU4buWf4YITJtjOJ6iKdr1u+flgQeFH70GxKjhdgt/MrwfB4K/sXczQ+9zYcrD4dhY6qZhZ010rrxggWA8JaZyg2pYij8ieYEg1aZJkZK9O1Re7sB0iouf60rK0Gd+AYlp7soqCBCDGwfKeUQhCBn0E0o0GS6PdmjLi0TtCYZeqazqwN+yNINIA8Lk3iPDnWUiIPLGNcHmZDxfeK0iAdxm/T7LnN+gemRL61hHIc0NCAZaiYJR+OHnLWSe8sLrK905B5eEJHNlWq4RmEXIaFTmo49f8w61+NwfEUyuJAwVqZCLFcyHBKAcIVj3sNzfEOXzVKIndxHw+AR93owhbCxUZf6Gs8cz6/1VdrFEPrv330+9s6BtMVPJ3zl/Uf9rUi0Z/opexfdL3ykF76e999GPfVv8fJv/Y/+/5hEMon1tqNFyVRevV9y9/uIvsG3dbB8GRRrgaEXfhx+2xeOFt+cEn3RZanNxdEe2+B6MHpNbrRE53PlDifPvFcp4kO78ILR0T4xyW/WGPyBsqGdoA7zJJCu1TKbGfhnqgnRbxbB2B3UZoeQ2bz2sTVnUwokTcTU21RxN1PYPS3Sar7T0eRIsyCNowr9amwoMU/od9s2APtiKNL6ENOlyKADstAEWKA+sdKDhrJ6BOhRJmZ+QJbAaZ3/5Fq0/lumCgEzGEbu3yi0Y4I4EgVAjqxh4HbuQn0GrRhOWyAfsglQJAVL1y/6yezS2k8RE2MstJLh92NOB3GCYgFXznF4d25qiP4ZCyI4RYGesut6FXK6GwPpKK8WHEkhYui0AyEmr5Ml3uBFtPFdnioI8RiCooa7Z1G1WuyIi3nSNglutc+xY8BkeW3JJXPK6jd2VIMpaSxpVtFq+R+ySK9J6WG5Qvt+C+QH1hyYUOVK7857nFmyDBYgZ/o+AnibzNVqyYCJQvyDXDTK+iXdkA71bY7TL3bvuLxLBQ8kbTvTEY9aqkQ3+MiLWbEgjLzOH+lXgco1ERgzd80rDCymlpaRQbOYnKG/ODoFl46lzT0cjM5FYVvv0qLUbD5lyJtMUaC1pFlTkNONx6lliaX9o0i/1vws5bNKn5OuENQEKmLlcP4o2ZmJjD4zzd3Fk32uQ4uRWkPSUqb4LBe3EXHdORNB2BWsws5daRnMfNVX7isPSb1hMQdAJi1/qmDMfRUlCU74pmnzjbXfL8PVG8NsW6IQM2Ne23iCPIpryJjYbVnm5hCvKpMa7HLViNiNc+xTfDIaKm3jctViD8A1M9YPJNk003VVr4Zo2MuGW8vil8SLaGpPXqG7I4DLdtl8a4Rbx1Lt4w5Huqaa1XzZBtj208EJVGcmKYEuaeN27zT9EE6a09JerXdEbpaNgNqYJdhP1NdqiPKsbDRUi86XvvNC7rME5mrSQtrzAZVndtSjCMqd8BmaeGR4l4YFULGRBeXIV9Y4yxLFdyoUNpiy2IhePSWzBofYPP0eIa2q5JP4j9G8at/AqoSsLAUuRXtvgsqX/zYwsE+of6oSDbUOo4RMJw+DOUTJq+hnqwKim9Yy/napyZNTc2rCq6V9jHtJbxGPDwlzWj/Sk3zF/BHOlT/fSjSq7FqlPI1q6J+ru8Aku008SFINXZfOfnZNOvGPMtEmn2gLPt+H4QLA+/SYe4j398auzhKIp2Pok3mPC5q1IN1HgR+mnEfc4NeeHYwd2/kpszR3cBn7ni9NbIqhtSWFW8xbUJuUPVOeeXu3j0IGZmFNiwaNZ6rH4/zQ2ODz6tFxRLsUYZu1bfd1uIvfQDt4YD/efKYv8VF8bHGDgK22w2Wqwpi43vNCOXFJZCGMqWiPbL8mil6tsmOTXAWCyMCw73e2rADZj2IK6rqksM3EXF2cbLb4vjB14wa/yXK5vwU+05MzERJ5nXsXsW21o7M+gO0js2OyKciP5uF2iXyb2DiptwQeHeqygkrNsqVCSlldxBMpwHi1vfc8RKpP/4L3Lmpq6DZcvhDDfxTCE3splacTcOtXdK2g303dIWBVe2wD/Gvja1cClFQ67gw0t1ZUttsUgQ1Veky8oOpS6ksYEc4bqseCbZy766SvL3FodmnahlWJRgVCNjPxhL/fk2wyvlKhITH/VQCipOI0dNcRa5B1M5HmOBjTLeZQJy237e2mobwmDyJNHePhdDmiknvLKaDbShL+Is1XTCJuLQd2wmdJL7+mKvs294whXQD+vtd88KKk0DXP8B1Xu9J+xo69VOuFgexgTrcvI6SyltuLix9OPuE6/iRJYoBMEXxU4shQMf4Fjqwf1PtnJ/wWSZd29rhZjRmTGgiGTAUQqRz+nCdjeMfYhsBD5Lv60KILWEvNEHfmsDs2L0A252351eUoYxAysVaCJVLdH9QFWAmqJDCODUcdoo12+gd6bW2boY0pBVHWL6LQDK5bYWh1V8vFvi0cRpfwv7cJiMX3AZNJuTddHehTIdU0YQ/sQ1dLoF2xQPcCuHKiuCWOY30DHe1OwcClLAhqAKyqlnIbH/8u9ScJpcS4kgp6HKDUdiOgRaRGSiUCRBjzI5gSksMZKqy7Sd51aeg0tgJ+x0TH9YH2Mgsap9N7ENZdEB0bey2DMTrBA1hn56SErNHf3tKtqyL9b6yXEP97/rc+jgD2N1LNUH6RM9AzP3kSipr06RkKOolR7HO768jjWiH1X92jA7dkg7gcNcjqsZCgfqWw0tPXdLg20cF6vnQypg7gLtkazrHAodyYfENPQZsdfnjMZiNu4nJO97D1/sQE+3vNFzrSDOKw+keLECYf7RJwVHeP/j79833oZ0egonYB2FlFE5qj02B/LVOMJQlsB8uNg3Leg4qtZwntsOSNidR0abbZmAK4sCzvt8Yiuz2yrNCJoH5O8XvX/vLeR/BBYTWj0sOPYM/jyxRd5+/JziKAABaPcw/34UA3aj/gLZxZgRCWN6m4m3demanNgsx0P237/Q+Ew5VYnJPkyCY0cIVHoFn2Ay/e7U4P19APbPFXEHX94N6KhEMPG7iwB3+I+O1jd5n6VSgHegxgaSawO6iQCYFgDsPSMsNOcUj4q3sF6KzGaH/0u5PQoAj/8zq6Uc9MoNrGqhYeb2jQo0WlGlXjxtanZLS24/OIN5Gx/2g684BPDQpwlqnkFcxpmP/osnOXrFuu4PqifouQH0eF5qCkvITQbJw/Zvy5mAHWC9oU+cTiYhJmSfKsCyt1cGVxisKu+NymEQIAyaCgud/V09qT3nk/9s/SWsYtha7yNpzBIMM40rCSGaJ9u6lEkl00vXBiEt7p9P5IBCiavynEOv7FgLqPdeqxRiCwuFVMolSIUBcoyfUC2e2FJSAUgYdVGFf0b0Kn2EZlK97yyxrT2MVgvtRikfdaAW8RwEEfN+B7/eK8bBdp7URpbqn1xcrC6d2UjdsKbzCjBFqkKkoZt7Mrhg6YagE7spkqj0jOrWM+UGQ0MUlG2evP1uE1p2xSv4dMK0dna6ENcNUF+xkaJ7B764NdxLCpuvhblltVRAf7vK5qPttJ/9RYFUUSGcLdibnz6mf7WkPO3MkUUhR2mAOuGv8IWw5XG1ZvoVMnjSAZe6T7WYA99GENxoHkMiKxHlCuK5Gd0INrISImHQrQmv6F4mqU/TTQ8nHMDzCRivKySQ8dqkpQgnUMnwIkaAuc6/FGq1hw3b2Sba398BhUwUZSAIO8XZvnuLdY2n6hOXws+gq9BHUKcKFA6kz6FDnpxLPICa3qGhnc97bo1FT/XJk48LrkHJ2CAtBv0RtN97N21plfpXHvZ8gMJb7Zc4cfI6MbPwsW7AilCSXMFIEUEmir8XLEklA0ztYbGpTTGqttp5hpFTTIqUyaAIqvMT9A/x+Ji5ejA4Bhxb/cl1pUdOD6epd3yilIdO6j297xInoiBPuEDW2/UfslDyhGkQs7Wy253bVnlT+SWg89zYIK/9KXFl5fe+jow2rd5FXv8zDPrmfMXiUPt9QBO/iK4QGbX5j/7Rx1c1vzsY8ONbP3lVIaPrhL4+1QrECTN3nyKavGG0gBBtHvTKhGoBHgMXHStFowN+HKrPriYu+OZ05Frn8okQrPaaxoKP1ULCS/cmKFN3gcH7HQlVjraCeQmtjg1pSQxeuqXiSKgLpxc/1OiZsU4+n4lz4hpahGyWBURLi4642n1gn9qz9bIsaCeEPJ0uJmenMWp2tJmIwLQ6VSgDYErOeBCfSj9P4G/vI7oIF+l/n5fp956QgxGvur77ynawAu3G9MdFbJbu49NZnWnnFcQHjxRuhUYvg1U/e84N4JTecciDAKb/KYIFXzloyuE1eYXf54MmhjTq7B/yBToDzzpx3tJCTo3HCmVPYfmtBRe3mPYEE/6RlTIxbf4fSOcaKFGk4gbaUWe44hVk9SZzhW80yfW5QWBHxmtUzvMhfVQli4gZTktIOZd9mjJ5hsbmzttaHQB29Am3dZkmx3g/qvYocyhZ2PXAWsNQiIaf+Q8W/MWPIK7/TjvCx5q2XRp4lVWydMc2wIQkhadDB0xsnw/kSEyGjLKjI4coVIwtubTF3E7MJ6LS6UOsJKj82XVAVPJJcepfewbzE91ivXZvOvYfsmMevwtPpfMzGmC7WJlyW2j0jh7AF1JLmwEJSKYwIvu6DHc3YnyLH9ZdIBnQ+nOVDRiP+REpqv++typYHIvoJyICGA40d8bR7HR2k7do6UQTHF4oriYeIQbxKe4Th6+/l1BjUtS9hqORh3MbgvYrStXTfSwaBOmAVQZzpYNqsAmQyjY56MUqty3c/xH6GuhNvNaG9vGbG6cPtBM8UA3e8r51D0AR9kozKuGGSMgLz3nAHxDNnc7GTwpLj7/6HeWp1iksDeTjwCLpxejuMtpMnGJgsiku1sOACwQ9ukzESiDRN77YNESxR5LphOlcASXA5uIts1LnBIcn1J7BLWs49DMALSnuz95gdOrTZr0u1SeYHinno/pE58xYoXbVO/S+FEMMs5qyWkMnp8Q3ClyTlZP52Y9nq7b8fITPuVXUk9ohG5EFHw4gAEcjFxfKb3xuAsEjx2z1wxNbSZMcgS9GKyW3R6KwJONgtA64LTyxWm8Bvudp0M1FdJPEGopM4Fvg7G/hsptkhCfHFegv4ENwxPeXmYhxwZy7js+BeM27t9ODBMynVCLJ7RWcBMteZJtvjOYHb5lOnCLYWNEMKC59BA7covu1cANa2PXL05iGdufOzkgFqqHBOrgQVUmLEc+Mkz4Rq8O6WkNr7atNkH4M8d+SD1t/tSzt3oFql+neVs+AwEI5JaBJaxARtY2Z4mKoUqxds4UpZ0sv3zIbNoo0J4fihldQTX3XNcuNcZmcrB5LTWMdzeRuAtBk3cZHYQF6gTi3PNuDJ0nmR+4LPLoHvxQIxRgJ9iNNXqf2SYJhcvCtJiVWo85TsyFOuq7EyBPJrAdhEgE0cTq16FQXhYPJFqSfiVn0IQnPOy0LbU4BeG94QjdYNB0CiQ3QaxQqD2ebSMiNjaVaw8WaM4Z5WnzcVDsr4eGweSLa2DE3BWViaxhZFIcSTjgxNCAfelg+hznVOYoe5VqTYs1g7WtfTm3e4/WduC6p+qqAM8H4ZyrJCGpewThTDPe6H7CzX/zQ8Tm+r65HeZn+MsmxUciEWPlAVaK/VBaQBWfoG/aRL/jSZIQfep/89GjasWmbaWzeEZ2R1FOjvyJT37O9B8046SRSKVEnXWlBqbkb5XCS3qFeuE9xb9+frEknxWB5h1D/hruz2iVDEAS7+qkEz5Ot5agHJc7WCdY94Ws61sURcX5nG8UELGBAHZ3i+3VulAyT0nKNNz4K2LBHBWJcTBX1wzf+//u/j/9+//v87+9/l9Lbh/L/uyNYiTsWV2LwsjaA6MxTuzFMqmxW8Jw/+IppdX8t/Clgi1rI1SN0UC/r6tX/4lUc2VV1OQReSeCsjUpKZchw4XUcjHfw6ryCV3R8s6VXm67vp4n+lcPV9gJwmbKQEsmrJi9c2vkwrm8HFbVYNTaRGq8D91t9n5+U+aD/hNtN3HjC/nC/vUoGFSCkXP+NlRcmLUqLbiUBl4LYf1U/CCvwtd3ryCH8gUmGITAxiH1O5rnGTz7y1LuFjmnFGQ1UWuM7HwfXtWl2fPFKklYwNUpF2IL/TmaRETjQiM5SJacI+3Gv5MBU8lP5Io6gWkawpyzNEVGqOdx4YlO1dCvjbWFZWbCmeiFKPSlMKtKcMFLs/KQxtgAHi7NZNCQ32bBAW2mbHflVZ8wXKi1JKVHkW20bnYnl3dKWJeWJOiX3oKPBD6Zbi0ZvSIuWktUHB8qDR8DMMh1ZfkBL9FS9x5r0hBGLJ8pUCJv3NYH+Ae8p40mZWd5m5fhobFjQeQvqTT4VKWIYfRL0tfaXKiVl75hHReuTJEcqVlug+eOIIc4bdIydtn2K0iNZPsYWQvQio2qbO3OqAlPHDDOB7DfjGEfVF51FqqNacd6QmgFKJpMfLp5DHTv4wXlONKVXF9zTJpDV4m1sYZqJPhotcsliZM8yksKkCkzpiXt+EcRQvSQqmBS9WdWkxMTJXPSw94jqI3varCjQxTazjlMH8jTS8ilaW8014/vwA/LNa+YiFoyyx3s/KswP3O8QW1jtq45yTM/DX9a8M4voTVaO2ebvw1EooDw/yg6Y1faY+WwrdVs5Yt0hQ5EwRfYXSFxray1YvSM+kYmlpLG2/9mm1MfmbKHXr44Ih8nVKb1M537ZANUkCtdsPZ80JVKVKabVHCadaLXg+IV8i5GSwpZti0h6diTaKs9sdpUKEpd7jDUpYmHtiX33SKiO3tuydkaxA7pEc9XIQEOfWJlszj5YpL5bKeQyT7aZSBOamvSHl8xsWvgo26IP/bqk+0EJUz+gkkcvlUlyPp2kdKFtt7y5aCdks9ZJJcFp5ZWeaWKgtnXMN3ORwGLBE0PtkEIek5FY2aVssUZHtsWIvnljMVJtuVIjpZup/5VL1yPOHWWHkOMc6YySWMckczD5jUj2mlLVquFaMU8leGVaqeXis+aRRL8zm4WuBk6cyWfGMxgtr8useQEx7k/PvRoZyd9nde1GUCV84gMX8Ogu/BWezYPSR27llzQnA97oo0pYyxobYUJfsj+ysTm9zJ+S4pk0TGo9VTG0KjqYhTmALfoDZVKla2b5yhv241PxFaLJs3i05K0AAIdcGxCJZmT3ZdT7CliR7q+kur7WdQjygYtOWRL9B8E4s4LI8KpAj7bE0dg7DLOaX+MGeAi0hMMSSWZEz+RudXbZCsGYS0QqiXjH9XQbd8sCB+nIVTq7/T/FDS+zWY9q7Z2fdq1tdLb6v3hKKVDAw5gjj6o9r1wHFROdHc18MJp4SJ2Ucvu+iQ9EgkekW8VCM+psM6y+/2SBy8tNN4a3L1MzP+OLsyvESo5gS7IQOnIqMmviJBVc6zbVG1n8eXiA3j46kmvvtJlewwNDrxk4SbJOtP/TV/lIVK9ueShNbbMHfwnLTLLhbZuO79ec5XvfgRwLFK+w1r5ZWW15rVFZrE+wKqNRv5KqsLNfpGgnoUU6Y71NxEmN7MyqwqAQqoIULOw/LbuUB2+uE75gJt+kq1qY4LoxV+qR/zalupea3D5+WMeaRIn0sAI6DDWDh158fqUb4YhAxhREbUN0qyyJYkBU4V2KARXDT65gW3gRsiv7xSPYEKLwzgriWcWgPr0sbZnv7m1XHNFW6xPdGNZUdxFiUYlmXNjDVWuu7LCkX/nVkrXaJhiYktBISC2xgBXQnNEP+cptWl1eG62a7CPXrnrkTQ5BQASbEqUZWMDiZUisKyHDeLFOaJILUo5f6iDt4ZO8MlqaKLto0AmTHVVbkGuyPa1R/ywZsWRoRDoRdNMMHwYTsklMVnlAd2S0282bgMI8fiJpDh69OSL6K3qbo20KfpNMurnYGQSr/stFqZ7hYsxKlLnKAKhsmB8AIpEQ4bd/NrTLTXefsE6ChRmKWjXKVgpGoPs8GAicgKVw4K0qgDgy1A6hFq1WRat3fHF+FkU+b6H4NWpOU3KXTxrIb2qSHAb+qhm8hiSROi/9ofapjxhyKxxntPpge6KL5Z4+WBMYkAcE6+0Hd3Yh2zBsK2MV3iW0Y6cvOCroXlRb2MMJtdWx+3dkFzGh2Pe3DZ9QpSqpaR/rE1ImOrHqYYyccpiLC22amJIjRWVAherTfpQLmo6/K2pna85GrDuQPlH1Tsar8isAJbXLafSwOof4gg9RkAGm/oYpBQQiPUoyDk2BCQ1k+KILq48ErFo4WSRhHLq/y7mgw3+L85PpP6xWr6cgp9sOjYjKagOrxF148uhuaWtjet953fh1IQiEzgC+d2IgBCcUZqgTAICm2bR8oCjDLBsmg+ThyhfD+zBalsKBY1Ce54Y/t9cwfbLu9SFwEgphfopNA3yNxgyDafUM3mYTovZNgPGdd4ZFFOj1vtfFW3u7N+iHEN1HkeesDMXKPyoCDCGVMo4GCCD6PBhQ3dRZIHy0Y/3MaE5zU9mTCrwwnZojtE+qNpMSkJSpmGe0EzLyFelMJqhfFQ7a50uXxZ8pCc2wxtAKWgHoeamR2O7R+bq7IbPYItO0esdRgoTaY38hZLJ5y02oIVwoPokGIzxAMDuanQ1vn2WDQ00Rh6o5QOaCRu99fwDbQcN0XAuqkFpxT/cfz3slGRVokrNU0iqiMAJFEbKScZdmSkTUznC0U+MfwFOGdLgsewRyPKwBZYSmy6U325iUhBQNxbAC3FLKDV9VSOuQpOOukJ/GAmu/tyEbX9DgEp6dv1zoU0IqzpG6gssSjIYRVPGgU1QAQYRgIT8gEV0EXr1sqeh2I6rXjtmoCYyEDCe/PkFEi/Q48FuT29p557iN+LCwk5CK/CZ2WdAdfQZh2Z9QGrzPLSNRj5igUWzl9Vi0rCqH8G1Kp4QMLkuwMCAypdviDXyOIk0AHTM8HBYKh3b0/F+DxoNj4ZdoZfCpQVdnZarqoMaHWnMLNVcyevytGsrXQEoIbubqWYNo7NRHzdc0zvT21fWVirj7g36iy6pxogfvgHp1xH1Turbz8QyyHnXeBJicpYUctbzApwzZ1HT+FPEXMAgUZetgeGMwt4G+DHiDT2Lu+PT21fjJCAfV16a/Wu1PqOkUHSTKYhWW6PhhHUlNtWzFnA7MbY+r64vkwdpfNB2JfWgWXAvkzd42K4lN9x7Wrg4kIKgXCb4mcW595MCPJ/cTfPAMQMFWwnqwde4w8HZYJFpQwcSMhjVz4B8p6ncSCN1X4klxoIH4BN2J6taBMj6lHkAOs8JJAmXq5xsQtrPIPIIp/HG6i21xMGcFgqDXSRF0xQg14d2uy6HgKE13LSvQe52oShF5Jx1R6avyL4thhXQZHfC94oZzuPUBKFYf1VvDaxIrtV6dNGSx7DO0i1p6CzBkuAmEqyWceQY7F9+U0ObYDzoa1iKao/cOD/v6Q9gHrrr1uCeOk8fST9MG23Ul0KmM3r+Wn6Hi6WAcL7gEeaykicvgjzkjSwFsAXIR81Zx4QJ6oosVyJkCcT+4xAldCcihqvTf94HHUPXYp3REIaR4dhpQF6+FK1H0i9i7Pvh8owu3lO4PT1iuqu+DkL2Bj9+kdfGAg2TXw03iNHyobxofLE2ibjsYDPgeEQlRMR7afXbSGQcnPjI2D+sdtmuQ771dbASUsDndU7t58jrrNGRzISvwioAlHs5FA+cBE5Ccznkd8NMV6BR6ksnKLPZnMUawRDU1MZ/ib3xCdkTblHKu4blNiylH5n213yM0zubEie0o4JhzcfAy3H5qh2l17uLooBNLaO+gzonTH2uF8PQu9EyH+pjGsACTMy4cHzsPdymUSXYJOMP3yTkXqvO/lpvt0cX5ekDEu9PUfBeZODkFuAjXCaGdi6ew4qxJ8PmFfwmPpkgQjQlWqomFY6UkjmcnAtJG75EVR+NpzGpP1Ef5qUUbfowrC3zcSLX3BxgWEgEx/v9cP8H8u1Mvt9/rMDYf6sjwU1xSOPBgzFEeJLMRVFtKo5QHsUYT8ZRLCah27599EuqoC9PYjYO6aoAMHB8X1OHwEAYouHfHB3nyb2B+SnZxM/vw/bCtORjLMSy5aZoEpvgdGvlJfNPFUu/p7Z4VVK1hiI0/UTuB3ZPq4ohEbm7Mntgc1evEtknaosgZSwnDC2BdMmibpeg48X8Ixl+/8+xXdbshQXUPPvx8jT3fkELivHSmqbhblfNFShWAyQnJ3WBU6SMYSIpTDmHjdLVAdlADdz9gCplZw6mTiHqDwIsxbm9ErGusiVpg2w8Q3khKV/R9Oj8PFeF43hmW/nSd99nZzhyjCX3QOZkkB6BsH4H866WGyv9E0hVAzPYah2tkRfQZMmP2rinfOeQalge0ovhduBjJs9a1GBwReerceify49ctOh5/65ATYuMsAkVltmvTLBk4oHpdl6i+p8DoNj4Fb2vhdFYer2JSEilEwPd5n5zNoGBXEjreg/wh2NFnNRaIUHSOXa4eJRwygZoX6vnWnqVdCRT1ARxeFrNBJ+tsdooMwqnYhE7zIxnD8pZH+P0Nu1wWxCPTADfNWmqx626IBJJq6NeapcGeOmbtXvl0TeWG0Y7OGGV4+EHTtNBIT5Wd0Bujl7inXgZgfXTM5efD3qDTJ54O9v3Bkv+tdIRlq1kXcVD0BEMirmFxglNPt5pedb1AnxuCYMChUykwsTIWqT23XDpvTiKEru1cTcEMeniB+HQDehxPXNmkotFdwUPnilB/u4Nx5Xc6l8J9jH1EgKZUUt8t8cyoZleDBEt8oibDmJRAoMKJ5Oe9CSWS5ZMEJvacsGVdXDWjp/Ype5x0p9PXB2PAwt2LRD3d+ftNgpuyvxlP8pB84oB1i73vAVpwyrmXW72hfW6Dzn9Jkj4++0VQ4d0KSx1AsDA4OtXXDo63/w+GD+zC7w5SJaxsmnlYRQ4dgdjA7tTl2KNLnpJ+mvkoDxtt1a4oPaX3EVqj96o9sRKBQqU7ZOiupeAIyLMD+Y3YwHx30XWHB5CQiw7q3mj1EDlP2eBsZbz79ayUMbyHQ7s8gu4Lgip1LiGJj7NQj905/+rgUYKAA5qdrlHKIknWmqfuR+PB8RdBkDg/NgnlT89G72h2NvySnj7UyBwD+mi/IWs1xWbxuVwUIVXun5cMqBtFbrccI+DILjsVQg6eeq0itiRfedn89CvyFtpkxaauEvSANuZmB1p8FGPbU94J9medwsZ9HkUYjmI7OH5HuxendLbxTaYrPuIfE2ffXFKhoNBUp33HsFAXmCV/Vxpq5AYgFoRr5Ay93ZLRlgaIPjhZjXZZChT+aE5iWAXMX0oSFQEtwjiuhQQItTQX5IYrKfKB+queTNplR1Hoflo5/I6aPPmACwQCE2jTOYo5Dz1cs7Sod0KTG/3kEDGk3kUaUCON19xSJCab3kNpWZhSWkO8l+SpW70Wn3g0ciOIJO5JXma6dbos6jyisuxXwUUhj2+1uGhcvuliKtWwsUTw4gi1c/diEEpZHoKoxTBeMDmhPhKTx7TXWRakV8imJR355DcIHkR9IREHxohP4TbyR5LtFU24umRPRmEYHbpe1LghyxPx7YgUHjNbbQFRQhh4KeU1EabXx8FS3JAxp2rwRDoeWkJgWRUSKw6gGP5U2PuO9V4ZuiKXGGzFQuRuf+tkSSsbBtRJKhCi3ENuLlXhPbjTKD4djXVnfXFds6Zb+1XiUrRfyayGxJq1+SYBEfbKlgjiSmk0orgTqzSS+DZ5rTqsJbttiNtp+KMqGE2AHGFw6jQqM5vD6vMptmXV9OAjq49Uf/Lx9Opam+Hn5O9p8qoBBAQixzQZ4eNVkO9sPzJAMyR1y4/RCQQ1s0pV5KAU5sKLw3tkcFbI/JqrjCsK4Mw+W8aod4lioYuawUiCyVWBE/qPaFi5bnkgpfu/ae47174rI1fqQoTbW0HrU6FAejq7ByM0V4zkZTg02/YJK2N7hUQRCeZ4BIgSEqgD8XsjzG6LIsSbuHoIdz/LhFzbNn1clci1NHWJ0/6/O8HJMdIpEZbqi1RrrFfoo/rI/7ufm2MPG5lUI0IYJ4MAiHRTSOFJ2oTverFHYXThkYFIoyFx6rMYFgaOKM4xNWdlOnIcKb/suptptgTOTdVIf4YgdaAjJnIAm4qNNHNQqqAzvi53GkyRCEoseUBrHohZsjUbkR8gfKtc/+Oa72lwxJ8Mq6HDfDATbfbJhzeIuFQJSiw1uZprHlzUf90WgqG76zO0eCB1WdPv1IT6sNxxh91GEL2YpgC97ikFHyoaH92ndwduqZ6IYjkg20DX33MWdoZk7QkcKUCgisIYslOaaLyvIIqRKWQj16jE1DlQWJJaPopWTJjXfixEjRJJo8g4++wuQjbq+WVYjsqCuNIQW3YjnxKe2M5ZKEqq+cX7ZVgnkbsU3RWIyXA1rxv4kGersYJjD//auldXGmcEbcfTeF16Y1708FB1HIfmWv6dSFi6oD4E+RIjCsEZ+kY7dKnwReJJw3xCjKvi3kGN42rvyhUlIz0Bp+fNSV5xwFiuBzG296e5s/oHoFtUyUplmPulIPl+e1CQIQVtjlzLzzzbV+D/OVQtYzo5ixtMi5BmHuG4N/uKfJk5UIREp7+12oZlKtPBomXSzAY0KgtbPzzZoHQxujnREUgBU+O/jKKhgxVhRPtbqyHiUaRwRpHv7pgRPyUrnE7fYkVblGmfTY28tFCvlILC04Tz3ivkNWVazA+OsYrxvRM/hiNn8Fc4bQBeUZABGx5S/xFf9Lbbmk298X7iFg2yeimvsQqqJ+hYbt6uq+Zf9jC+Jcwiccd61NKQtFvGWrgJiHB5lwi6fR8KzYS7EaEHf/ka9EC7H8D+WEa3TEACHBkNSj/cXxFeq4RllC+fUFm2xtstYLL2nos1DfzsC9vqDDdRVcPA3Ho95aEQHvExVThXPqym65llkKlfRXbPTRiDepdylHjmV9YTWAEjlD9DdQnCem7Aj/ml58On366392214B5zrmQz/9ySG2mFqEwjq5sFl5tYJPw5hNz8lyZPUTsr5E0F2C9VMPnZckWP7+mbwp/BiN7f4kf7vtGnZF2JGvjK/sDX1RtcFY5oPQnE4lIAYV49U3C9SP0LCY/9i/WIFK9ORjzM9kG/KGrAuwFmgdEpdLaiqQNpCTGZVuAO65afkY1h33hrqyLjZy92JK3/twdj9pafFcwfXONmPQWldPlMe7jlP24Js0v9m8bIJ9TgS2IuRvE9ZVRaCwSJYOtAfL5H/YS4FfzKWKbek+GFulheyKtDNlBtrdmr+KU+ibHTdalzFUmMfxw3f36x+3cQbJLItSilW9cuvZEMjKw987jykZRlsH/UI+HlKfo2tLwemBEeBFtmxF2xmItA/dAIfQ+rXnm88dqvXa+GapOYVt/2waFimXFx3TC2MUiOi5/Ml+3rj/YU6Ihx2hXgiDXFsUeQkRAD6wF3SCPi2flk7XwKAA4zboqynuELD312EJ88lmDEVOMa1W/K/a8tGylZRMrMoILyoMQzzbDJHNZrhH77L9qSC42HVmKiZ5S0016UTp83gOhCwz9XItK9fgXfK3F5d7nZCBUekoLxrutQaPHa16Rjsa0gTrzyjqTnmcIcrxg6X6dkKiucudc0DD5W4pJPf0vuDW8r5/uw24YfMuxFRpD2ovT2mFX79xH6Jf+MVdv2TYqR6/955QgVPe3JCD/WjAYcLA9tpXgFiEjge2J5ljeI/iUzg91KQuHkII4mmHZxC3XQORLAC6G7uFn5LOmlnXkjFdoO976moNTxElS8HdxWoPAkjjocDR136m2l+f5t6xaaNgdodOvTu0rievnhNAB79WNrVs6EsPgkgfahF9gSFzzAd+rJSraw5Mllit7vUP5YxA843lUpu6/5jAR0RvH4rRXkSg3nE+O5GFyfe+L0s5r3k05FyghSFnKo4TTgs07qj4nTLqOYj6qaW9knJTDkF5OFMYbmCP+8H16Ty482OjvERV6OFyw043L9w3hoJi408sR+SGo1WviXUu8d7qS+ehKjpKwxeCthsm2LBFSFeetx0x4AaKPxtp3CxdWqCsLrB1s/j5TAhc1jNZsXWl6tjo/WDoewxzg8T8NnhZ1niUwL/nhfygLanCnRwaFGDyLw+sfZhyZ1UtYTp8TYB6dE7R3VsKKH95CUxJ8u8N+9u2/9HUNKHW3x3w5GQrfOPafk2w5qZq8MaHT0ebeY3wIsp3rN9lrpIsW9c1ws3VNV+JwNz0Lo9+V7zZr6GD56We6gWVIvtmam5GPPkVAbr74r6SwhuL+TRXtW/0pgyX16VNl4/EAD50TnUPuwrW6OcUO2VlWXS0inq872kk7GUlW6o/ozFKq+Sip6LcTtSDfDrPTcCHhx75H8BeRon+KG2wRwzfDgWhALmiWOMO6h3pm1UCZEPEjScyk7tdLx6WrdA2N1QTPENvNnhCQjW6kl057/qv7IwRryHrZBCwVSbLLnFRiHdTwk8mlYixFt1slEcPD7FVht13HyqVeyD55HOXrh2ElAxJyinGeoFzwKA91zfrdLvDxJSjzmImfvTisreI25EDcVfGsmxLVbfU8PGe/7NmWWKjXcdTJ11jAlVIY/Bv/mcxg/Q10vCHwKG1GW/XbJq5nxDhyLqiorn7Wd7VEVL8UgVzpHMjQ+Z8DUgSukiVwWAKkeTlVVeZ7t1DGnCgJVIdBPZAEK5f8CDyDNo7tK4/5DBjdD5MPV86TaEhGsLVFPQSI68KlBYy84FievdU9gWh6XZrugvtCZmi9vfd6db6V7FmoEcRHnG36VZH8N4aZaldq9zZawt1uBFgxYYx+Gs/qW1jwANeFy+LCoymyM6zgG7j8bGzUyLhvrbJkTYAEdICEb4kMKusKT9V3eIwMLsjdUdgijMc+7iKrr+TxrVWG0U+W95SGrxnxGrE4eaJFfgvAjUM4SAy8UaRwE9j6ZQH5qYAWGtXByvDiLSDfOD0yFA3UCMKSyQ30fyy1mIRg4ZcgZHLNHWl+c9SeijOvbOJxoQy7lTN2r3Y8p6ovxvUY74aOYbuVezryqXA6U+fcp6wSV9X5/OZKP18tB56Ua0gMyxJI7XyNT7IrqN8GsB9rL/kP5KMrjXxgqKLDa+V5OCH6a5hmOWemMUsea9vQl9t5Oce76PrTyTv50ExOqngE3PHPfSL//AItPdB7kGnyTRhVUUFNdJJ2z7RtktZwgmQzhBG/G7QsjZmJfCE7k75EmdIKH7xlnmDrNM/XbTT6FzldcH/rcRGxlPrv4qDScqE7JSmQABJWqRT/TUcJSwoQM+1jvDigvrjjH8oeK2in1S+/yO1j8xAws/T5u0VnIvAPqaE1atNuN0cuRliLcH2j0nTL4JpcR7w9Qya0JoaHgsOiALLCCzRkl1UUESz+ze/gIXHGtDwgYrK6pCFKJ1webSDog4zTlPkgXZqxlQDiYMjhDpwTtBW2WxthWbov9dt2X9XFLFmcF+eEc1UaQ74gqZiZsdj63pH1qcv3Vy8JYciogIVKsJ8Yy3J9w/GhjWVSQAmrS0BPOWK+RKV+0lWqXgYMnIFwpcZVD7zPSp547i9HlflB8gVnSTGmmq1ClO081OW/UH11pEQMfkEdDFzjLC1Cdo/BdL3s7cXb8J++Hzz1rhOUVZFIPehRiZ8VYu6+7Er7j5PSZu9g/GBdmNzJmyCD9wiswj9BZw+T3iBrg81re36ihMLjoVLoWc+62a1U/7qVX5CpvTVF7rocSAKwv4cBVqZm7lLDS/qoXs4fMs/VQi6BtVbNA3uSzKpQfjH1o3x4LrvkOn40zhm6hjduDglzJUwA0POabgdXIndp9fzhOo23Pe+Rk9GSLX0d71Poqry8NQDTzNlsa+JTNG9+UrEf+ngxCjGEsDCc0bz+udVRyHQI1jmEO3S+IOQycEq7XwB6z3wfMfa73m8PVRp+iOgtZfeSBl01xn03vMaQJkyj7vnhGCklsCWVRUl4y+5oNUzQ63B2dbjDF3vikd/3RUMifPYnX5Glfuk2FsV/7RqjI9yKTbE8wJY+74p7qXO8+dIYgjtLD/N8TJtRh04N9tXJA4H59IkMmLElgvr0Q5OCeVfdAt+5hkh4pQgfRMHpL74XatLQpPiOyHRs/OdmHtBf8nOZcxVKzdGclIN16lE7kJ+pVMjspOI+5+TqLRO6m0ZpNXJoZRv9MPDRcAfJUtNZHyig/s2wwReakFgPPJwCQmu1I30/tcBbji+Na53i1W1N+BqoY7Zxo+U/M9XyJ4Ok2SSkBtoOrwuhAY3a03Eu6l8wFdIG1cN+e8hopTkiKF093KuH/BcB39rMiGDLn6XVhGKEaaT/vqb/lufuAdpGExevF1+J9itkFhCfymWr9vGb3BTK4j598zRH7+e+MU9maruZqb0pkGxRDRE1CD4Z8LV4vhgPidk5w2Bq816g3nHw1//j3JStz7NR9HIWELO8TMn3QrP/zZp//+Dv9p429/ogv+GATR+n/UdF+ns9xNkXZQJXY4t9jMkJNUFygAtzndXwjss+yWH9HAnLQQfhAskdZS2l01HLWv7L7us5uTH409pqitvfSOQg/c+Zt7k879P3K9+WV68n7+3cZfuRd/dDPP/03rn+d+/nBvWfgDlt8+LzjqJ/vx3CnNOwiXhho778C96iD+1TBvRZYeP+EH81LE0vVwOOrmCLB3iKzI1x+vJEsrPH4uF0UB4TJ4X3uDfOCo3PYpYe0MF4bouh0DQ/l43fxUF7Y+dpWuvTSffB0yO2UQUETI/LwCZE3BvnevJ7c9zUlY3H58xzke6DNFDQG8n0WtDN4LAYN4nogKav1ezOfK/z+t6tsCTp+dhx4ymjWuCJk1dEUifDP+HyS4iP/Vg9B2jTo9L4NbiBuDS4nuuHW6H+JDQn2JtqRKGkEQPEYE7uzazXIkcxIAqUq1esasZBETlEZY7y7Jo+RoV/IsjY9eIMkUvr42Hc0xqtsavZvhz1OLwSxMOTuqzlhb0WbdOwBH9EYiyBjatz40bUxTHbiWxqJ0uma19qhPruvcWJlbiSSH48OLDDpaHPszvyct41ZfTu10+vjox6kOqK6v0K/gEPphEvMl/vwSv+A4Hhm36JSP9IXTyCZDm4kKsqD5ay8b1Sad/vaiyO5N/sDfEV6Z4q95E+yfjxpqBoBETW2C7xl4pIO2bDODDFurUPwE7EWC2Uplq+AHmBHvir2PSgkR12/Ry65O0aZtQPeXi9mTlF/Wj5GQ+vFkYyhXsLTjrBSP9hwk4GPqDP5rBn5/l8b0mLRAvRSzXHc293bs3s8EsdE3m2exxidWVB4joHR+S+dz5/W+v00K3TqN14CDBth8eWcsTbiwXPsygHdGid0PEdy6HHm2v/IUuV5RVapYmzGsX90mpnIdNGcOOq64Dbc5GUbYpD9M7S+6cLY//QmjxFLP5cuTFRm3vA5rkFZroFnO3bjHF35uU3s8mvL7Tp9nyTc4mymTJ5sLIp7umSnGkO23faehtz3mmTS7fbVx5rP7x3HXIjRNeq/A3xCs9JNB08c9S9BF2O3bOur0ItslFxXgRPdaapBIi4dRpKGxVz7ir69t/bc9qTxjvtOyGOfiLGDhR4fYywHv1WdOplxIV87TpLBy3Wc0QP0P9s4G7FBNOdITS/tep3o3h1TEa5XDDii7fWtqRzUEReP2fbxz7bHWWJdbIOxOUJZtItNZpTFRfj6vm9sYjRxQVO+WTdiOhdPeTJ+8YirPvoeL88l5iLYOHd3b/Imkq+1ZN1El3UikhftuteEYxf1Wujof8Pr4ICTu5ezZyZ4tHQMxlzUHLYO2VMOoNMGL/20S5i2o2obfk+8qqdR7xzbRDbgU0lnuIgz4LelQ5XS7xbLuSQtNS95v3ZUOdaUx/Qd8qxCt6xf2E62yb/HukLO6RyorV8KgYl5YNc75y+KvefrxY+lc/64y9kvWP0a0bDz/rojq+RWjO06WeruWqNFU7r3HPIcLWRql8ICZsz2Ls/qOm/CLn6++X+Qf7mGspYCrZod/lpl6Rw4xN/yuq8gqV4B6aHk1hVE1SfILxWu5gvXqbfARYQpspcxKp1F/c8XOPzkZvmoSw+vEqBLdrq1fr3wAPv5NnM9i8F+jdAuxkP5Z71c6uhK3enlnGymr7UsWZKC12qgUiG8XXGQ9mxnqz4GSIlybF9eXmbqj2sHX+a1jf0gRoONHRdRSrIq03Ty89eQ1GbV/Bk+du4+V15zls+vvERvZ4E7ZbnxWTVjDjb4o/k8jlw44pTIrUGxxuJvBeO+heuhOjpFsO6lVJ/aXnJDa/bM0Ql1cLbXE/Pbv3EZ3vj3iVrB5irjupZTzlnv677NrI9UNYNqbPgp/HZXS+lJmk87wec+7YOxTDo2aw2l3NfDr34VNlvqWJBknuK7oSlZ6/T10zuOoPZOeoIk81N+sL843WJ2Q4Z0fZ3scsqC/JV2fuhWi1jGURSKZV637lf53Xnnx16/vKEXY89aVJ0fv91jGdfG+G4+sniwHes4hS+udOr4RfhFhG/F5gUG35QaU+McuLmclb5ZWmR+sG5V6nf+PxYzlrnFGxpZaK8eqqVo0NfmAWoGfXDiT/FnUbWvzGDOTr8aktOZWg4BYvz5YH12ZbfCcGtNk+dDAZNGWvHov+PIOnY9Prjg8h/wLRrT69suaMVZ5bNuK00lSVpnqSX1NON/81FoP92rYndionwgOiA8WMf4vc8l15KqEEG4yAm2+WAN5Brfu1sq9suWYqgoajgOYt/JCk1gC8wPkK+XKCtRX6TAtgvrnuBgNRmn6I8lVDipOVB9kX6Oxkp4ZKyd1M6Gj8/v2U7k+YQBL95Kb9PQENucJb0JlW3b5tObN7m/Z1j1ev388d7o15zgXsI9CikAGAViR6lkJv7nb4Ak40M2G8TJ447kN+pvfHiOFjSUSP6PM+QfbAywKJCBaxSVxpizHseZUyUBhq59vFwrkyGoRiHbo0apweEZeSLuNiQ+HAekOnarFg00dZNXaPeoHPTRR0FmEyqYExOVaaaO8c0uFUh7U4e/UxdBmthlBDgg257Q33j1hA7HTxSeTTSuVnPZbgW1nodwmG16aKBDKxEetv7D9OjO0JhrbJTnoe+kcGoDJazFSO8/fUN9Jy/g4XK5PUkw2dgPDGpJqBfhe7GA+cjzfE/EGsMM+FV9nj9IAhrSfT/J3QE5TEIYyk5UjsI6ZZcCPr6A8FZUF4g9nnpVmjX90MLSQysIPD0nFzqwCcSJmIb5mYv2Cmk+C1MDFkZQyCBq4c/Yai9LJ6xYkGS/x2s5/frIW2vmG2Wrv0APpCdgCA9snFvfpe8uc0OwdRs4G9973PGEBnQB5qKrCQ6m6X/H7NInZ7y/1674/ZXOVp7OeuCRk8JFS516VHrnH1HkIUIlTIljjHaQtEtkJtosYul77cVwjk3gW1Ajaa6zWeyHGLlpk3VHE2VFzT2yI/EvlGUSz2H9zYE1s4nsKMtMqNyKNtL/59CpFJki5Fou6VXGm8vWATEPwrUVOLvoA8jLuwOzVBCgHB2Cr5V6OwEWtJEKokJkfc87h+sNHTvMb0KVTp5284QTPupoWvQVUwUeogZR3kBMESYo0mfukewRVPKh5+rzLQb7HKjFFIgWhj1w3yN/qCNoPI8XFiUgBNT1hCHBsAz8L7Oyt8wQWUFj92ONn/APyJFg8hzueqoJdNj57ROrFbffuS/XxrSXLTRgj5uxZjpgQYceeMc2wJrahReSKpm3QjHfqExTLAB2ipVumE8pqcZv8LYXQiPHHsgb5BMW8zM5pvQit+mQx8XGaVDcfVbLyMTlY8xcfmm/RSAT/H09UQol5gIz7rESDmnrQ4bURIB4iRXMDQwxgex1GgtDxKp2HayIkR+E/aDmCttNm2C6lytWdfOVzD6X2SpDWjQDlMRvAp1symWv4my1bPCD+E1EmGnMGWhNwmycJnDV2WrQNxO45ukEb08AAffizYKVULp15I4vbNK5DzWwCSUADfmKhfGSUqii1L2UsE8rB7mLuHuUJZOx4+WiizHBJ/hwboaBzhpNOVvgFTf5cJsHef7L1HCI9dOUUbb+YxUJWn6dYOLz+THi91kzY5dtO5c+grX7v0jEbsuoOGnoIreDIg/sFMyG+TyCLIcAWd1IZ1UNFxE8Uie13ucm40U2fcxC0u3WLvLOxwu+F7MWUsHsdtFQZ7W+nlfCASiAKyh8rnP3EyDByvtJb6Kax6/HkLzT9SyEyTMVM1zPtM0MJY14DmsWh4MgD15Ea9Hd00AdkTZ0EiG5NAGuIBzQJJ0JR0na+OB7lQA6UKxMfihIQ7GCCnVz694QvykWXTxpS2soDu+smru1UdIxSvAszBFD1c8c6ZOobA8bJiJIvuycgIXBQIXWwhyTgZDQxJTRXgEwRNAawGSXO0a1DKjdihLVNp/taE/xYhsgwe+VpKEEB4LlraQyE84gEihxCnbfoyOuJIEXy2FIYw+JjRusybKlU2g/vhTSGTydvCvXhYBdtAXtS2v7LkHtmXh/8fly1do8FI/D0f8UbzVb5h+KRhMGSAmR2mhi0YG/uj7wgxcfzCrMvdjitUIpXDX8ae2JcF/36qUWIMwN6JsjaRGNj+jEteGDcFyTUb8X/NHSucKMJp7pduxtD6KuxVlyxxwaeiC1FbGBESO84lbyrAugYxdl+2N8/6AgWpo/IeoAOcsG35IA/b3AuSyoa55L7llBLlaWlEWvuCFd8f8NfcTUgzJv6CbB+6ohWwodlk9nGWFpBAOaz5uEW5xBvmjnHFeDsb0mXwayj3mdYq5gxxNf3H3/tnCgHwjSrpSgVxLmiTtuszdRUFIsn6LiMPjL808vL1uQhDbM7aA43mISXReqjSskynIRcHCJ9qeFopJfx9tqyUoGbSwJex/0aDE3plBPGtNBYgWbdLom3+Q/bjdizR2/AS/c/dH/d3G7pyl1qDXgtOFtEqidwLqxPYtrNEveasWq3vPUUtqTeu8gpov4bdOQRI2kneFvRNMrShyVeEupK1PoLDPMSfWMIJcs267mGB8X9CehQCF0gIyhpP10mbyM7lwW1e6TGvHBV1sg/UyTghHPGRqMyaebC6pbB1WKNCQtlai1GGvmq9zUKaUzLaXsXEBYtHxmFbEZ2kJhR164LhWW2Tlp1dhsGE7ZgIWRBOx3Zcu2DxgH+G83WTPceKG0TgQKKiiNNOlWgvqNEbnrk6fVD+AqRam2OguZb0YWSTX88N+i/ELSxbaUUpPx4vJUzYg/WonSeA8xUK6u7DPHgpqWpEe6D4cXg5uK9FIYVba47V/nb+wyOtk+zG8RrS4EA0ouwa04iByRLSvoJA2FzaobbZtXnq8GdbfqEp5I2dpfpj59TCVif6+E75p665faiX8gS213RqBxTZqfHP46nF6NSenOneuT+vgbLUbdTH2/t0REFXZJOEB6DHvx6N6g9956CYrY/AYcm9gELJXYkrSi+0F0geKDZgOCIYkLU/+GOW5aGj8mvLFgtFH5+XC8hvAE3CvHRfl4ofM/Qwk4x2A+R+nyc9gNu/9Tem7XW4XRnyRymf52z09cTOdr+PG6+P/Vb4QiXlwauc5WB1z3o+IJjlbxI8MyWtSzT+k4sKVbhF3xa+vDts3NxXa87iiu+xRH9cAprnOL2h6vV54iQRXuOAj1s8nLFK8gZ70ThIQcWdF19/2xaJmT0efrkNDkWbpAQPdo92Z8+Hn/aLjbOzB9AI/k12fPs9HhUNDJ1u6ax2VxD3R6PywN7BrLJ26z6s3QoMp76qzzwetrDABKSGkfW5PwS1GvYNUbK6uRqxfyVGNyFB0E+OugMM8kKwmJmupuRWO8XkXXXQECyRVw9UyIrtCtcc4oNqXqr7AURBmKn6Khz3eBN96LwIJrAGP9mr/59uTOSx631suyT+QujDd4beUFpZ0kJEEnjlP+X/Kr2kCKhnENTg4BsMTOmMqlj2WMFLRUlVG0fzdCBgUta9odrJfpVdFomTi6ak0tFjXTcdqqvWBAzjY6hVrH9sbt3Z9gn+AVDpTcQImefbB4edirjzrsNievve4ZT4EUZWV3TxEsIW+9MT/RJoKfZZYSRGfC1CwPG/9rdMOM8qR/LUYvw5f/emUSoD7YSFuOoqchdUg2UePd1eCtFSKgxLSZ764oy4lvRCIH6bowPxZWwxNFctksLeil47pfevcBipkkBIc4ngZG+kxGZ71a72KQ7VaZ6MZOZkQJZXM6kb/Ac0/XkJx8dvyfJcWbI3zONEaEPIW8GbkYjsZcwy+eMoKrYjDmvEEixHzkCSCRPRzhOfJZuLdcbx19EL23MA8rnjTZZ787FGMnkqnpuzB5/90w1gtUSRaWcb0eta8198VEeZMUSfIhyuc4/nywFQ9uqn7jdqXh+5wwv+RK9XouNPbYdoEelNGo34KyySwigsrfCe0v/PlWPvQvQg8R0KgHO18mTVThhQrlbEQ0Kp/JxPdjHyR7E1QPw/ut0r+HDDG7BwZFm9IqEUZRpv2WpzlMkOemeLcAt5CsrzskLGaVOAxyySzZV/D2EY7ydNZMf8e8VhHcKGHAWNszf1EOq8fNstijMY4JXyATwTdncFFqcNDfDo+mWFvxJJpc4sEZtjXyBdoFcxbUmniCoKq5jydUHNjYJxMqN1KzYV62MugcELVhS3Bnd+TLLOh7dws/zSXWzxEb4Nj4aFun5x4kDWLK5TUF/yCXB/cZYvI9kPgVsG2jShtXkxfgT+xzjJofXqPEnIXIQ1lnIdmVzBOM90EXvJUW6a0nZ/7XjJGl8ToO3H/fdxnxmTNKBZxnkpXLVgLXCZywGT3YyS75w/PAH5I/jMuRspej8xZObU9kREbRA+kqjmKRFaKGWAmFQspC+QLbKPf0RaK3OXvBSWqo46p70ws/eZpu6jCtZUgQy6r4tHMPUdAgWGGUYNbuv/1a6K+MVFsd3T183+T8capSo6m0+Sh57fEeG/95dykGJBQMj09DSW2bY0mUonDy9a8trLnnL5B5LW3Nl8rJZNysO8Zb+80zXxqUGFpud3Qzwb7bf+8mq6x0TAnJU9pDQR9YQmZhlna2xuxJt0aCO/f1SU8gblOrbIyMsxTlVUW69VJPzYU2HlRXcqE2lLLxnObZuz2tT9CivfTAUYfmzJlt/lOPgsR6VN64/xQd4Jlk/RV7UKVv2Gx/AWsmTAuCWKhdwC+4HmKEKYZh2Xis4KsUR1BeObs1c13wqFRnocdmuheaTV30gvVXZcouzHKK5zwrN52jXJEuX6dGx3BCpV/++4f3hyaW/cQJLFKqasjsMuO3B3WlMq2gyYfdK1e7L2pO/tRye2mwzwZPfdUMrl5wdLqdd2Kv/wVtnpyWYhd49L6rsOV+8HXPrWH2Kup89l2tz6bf80iYSd+V4LROSOHeamvexR524q4r43rTmtFzQvArpvWfLYFZrbFspBsXNUqqenjxNNsFXatZvlIhk7teUPfK+YL32F8McTnjv0BZNppb+vshoCrtLXjIWq3EJXpVXIlG6ZNL0dh6qEm2WMwDjD3LfOfkGh1/czYc/0qhiD2ozNnH4882MVVt3JbVFkbwowNCO3KL5IoYW5wlVeGCViOuv1svZx7FbzxKzA4zGqBlRRaRWCobXaVq4yYCWbZf8eiJwt3OY+MFiSJengcFP2t0JMfzOiJ7cECvpx7neg1Rc5x+7myPJOXt2FohVRyXtD+/rDoTOyGYInJelZMjolecVHUhUNqvdZWg2J2t0jPmiLFeRD/8fOT4o+NGILb+TufCo9ceBBm3JLVn+MO2675n7qiEX/6W+188cYg3Zn5NSTjgOKfWFSAANa6raCxSoVU851oJLY11WIoYK0du0ec5E4tCnAPoKh71riTsjVIp3gKvBbEYQiNYrmH22oLQWA2AdwMnID6PX9b58dR2QKo4qag1D1Z+L/FwEKTR7osOZPWECPJIHQqPUsM5i/CH5YupVPfFA5pHUBcsesh8eO5YhyWnaVRPZn/BmdXVumZWPxMP5e28zm2uqHgFoT9CymHYNNrzrrjlXZM06HnzDxYNlI5b/QosxLmmrqDFqmogQdqk0WLkUceoAvQxHgkIyvWU69BPFr24VB6+lx75Rna6dGtrmOxDnvBojvi1/4dHjVeg8owofPe1cOnxU1ioh016s/Vudv9mhV9f35At+Sh28h1bpp8xhr09+vf47Elx3Ms6hyp6QvB3t0vnLbOhwo660cp7K0vvepabK7YJfxEWWfrC2YzJfYOjygPwfwd/1amTqa0hZ5ueebhWYVMubRTwIjj+0Oq0ohU3zfRfuL8gt59XsHdwKtxTQQ4Y2qz6gisxnm2UdlmpEkgOsZz7iEk6QOt8BuPwr+NR01LTqXmJo1C76o1N274twJvl+I069TiLpenK/miRxhyY8jvYV6W1WuSwhH9q7kuwnJMtm7IWcqs7HsnyHSqWXLSpYtZGaR1V3t0gauninFPZGtWskF65rtti48UV9uV9KM8kfDYs0pgB00S+TlzTXV6P8mxq15b9En8sz3jWSszcifZa/NuufPNnNTb031pptt0+sRSH/7UG8pzbsgtt3OG3ut7B9JzDMt2mTZuyRNIV8D54TuTrpNcHtgmMlYJeiY9XS83NYJicjRjtJSf9BZLsQv629QdDsKQhTK5CnXhpk7vMNkHzPhm0ExW/VCGApHfPyBagtZQTQmPHx7g5IXXsrQDPzIVhv2LB6Ih138iSDww1JNHrDvzUxvp73MsQBVhW8EbrReaVUcLB1R3PUXyaYG4HpJUcLVxMgDxcPkVRQpL7VTAGabDzbKcvg12t5P8TSGQkrj/gOrpnbiDHwluA73xbXts/L7u468cRWSWRtgTwlQnA47EKg0OiZDgFxAKQQUcsbGomITgeXUAAyKe03eA7Mp4gnyKQmm0LXJtEk6ddksMJCuxDmmHzmVhO+XaN2A54MIh3niw5CF7PwiXFZrnA8wOdeHLvvhdoqIDG9PDI7UnWWHq526T8y6ixJPhkuVKZnoUruOpUgOOp3iIKBjk+yi1vHo5cItHXb1PIKzGaZlRS0g5d3MV2pD8FQdGYLZ73aae/eEIUePMc4NFz8pIUfLCrrF4jVWH5gQneN3S8vANBmUXrEcKGn6hIUN95y1vpsvLwbGpzV9L0ZKTan6TDXM05236uLJcIEMKVAxKNT0K8WljuwNny3BNQRfzovA85beI9zr1AGNYnYCVkR1aGngWURUrgqR+gRrQhxW81l3CHevjvGEPzPMTxdsIfB9dfGRbZU0cg/1mcubtECX4tvaedmNAvTxCJtc2QaoUalGfENCGK7IS/O8CRpdOVca8EWCRwv2sSWE8CJPW5PCugjCXPd3h6U60cPD+bdhtXZuYB6stcoveE7Sm5MM2yvfUHXFSW7KzLmi7/EeEWL0wqcOH9MOSKjhCHHmw+JGLcYE/7SBZQCRggox0ZZTAxrlzNNXYXL5fNIjkdT4YMqVUz6p8YDt049v4OXGdg3qTrtLBUXOZf7ahPlZAY/O+7Sp0bvGSHdyQ8B1LOsplqMb9Se8VAE7gIdSZvxbRSrfl+Lk5Qaqi5QJceqjitdErcHXg/3MryljPSIAMaaloFm1cVwBJ8DNmkDqoGROSHFetrgjQ5CahuKkdH5pRPigMrgTtlFI8ufJPJSUlGgTjbBSvpRc0zypiUn6U5KZqcRoyrtzhmJ7/caeZkmVRwJQeLOG8LY6vP5ChpKhc8Js0El+n6FXqbx9ItdtLtYP92kKfaTLtCi8StLZdENJa9Ex1nOoz1kQ7qxoiZFKRyLf4O4CHRT0T/0W9F8epNKVoeyxUXhy3sQMMsJjQJEyMOjmOhMFgOmmlscV4eFi1CldU92yjwleirEKPW3bPAuEhRZV7JsKV3Lr5cETAiFuX5Nw5UlF7d2HZ96Bh0sgFIL5KGaKSoVYVlvdKpZJVP5+NZ7xDEkQhmDgsDKciazJCXJ6ZN2B3FY2f6VZyGl/t4aunGIAk/BHaS+i+SpdRfnB/OktOvyjinWNfM9Ksr6WwtCa1hCmeRI6icpFM4o8quCLsikU0tMoZI/9EqXRMpKGaWzofl4nQuVQm17d5fU5qXCQeCDqVaL9XJ9qJ08n3G3EFZS28SHEb3cdRBdtO0YcTzil3QknNKEe/smQ1fTb0XbpyNB5xAeuIlf+5KWlEY0DqJbsnzJlQxJPOVyHiKMx5Xu9FcEv1Fbg6Fhm4t+Jyy5JC1W3YO8dYLsO0PXPbxodBgttTbH3rt9Cp1lJIk2r3O1Zqu94eRbnIz2f50lWolYzuKsj4PMok4abHLO8NAC884hiXx5Fy5pWKO0bWL7uEGXaJCtznhP67SlQ4xjWIfgq6EpZ28QMtuZK7JC0RGbl9nA4XtFLug/NLMoH1pGt9IonAJqcEDLyH6TDROcbsmGPaGIxMo41IUAnQVPMPGByp4mOmh9ZQMkBAcksUK55LsZj7E5z5XuZoyWCKu6nHmDq22xI/9Z8YdxJy4kWpD16jLVrpwGLWfyOD0Wd+cBzFBxVaGv7S5k9qwh/5t/LQEXsRqI3Q9Rm3QIoaZW9GlsDaKOUyykyWuhNOprSEi0s1G4rgoiX1V743EELti+pJu5og6X0g6oTynUqlhH9k6ezyRi05NGZHz0nvp3HOJr7ebrAUFrDjbkFBObEvdQWkkUbL0pEvMU46X58vF9j9F3j6kpyetNUBItrEubW9ZvMPM4qNqLlsSBJqOH3XbNwv/cXDXNxN8iFLzUhteisYY+RlHYOuP29/Cb+L+xv+35Rv7xudnZ6ohK4cMPfCG8KI7dNmjNk/H4e84pOxn/sZHK9psfvj8ncA8qJz7O8xqbxESDivGJOZzF7o5PJLQ7g34qAWoyuA+x3btU98LT6ZyGyceIXjrqob2CAVql4VOTQPUQYvHV/g4zAuCZGvYQBtf0wmd5lilrvuEn1BXLny01B4h4SMDlYsnNpm9d7m9h578ufpef9Z4WplqWQvqo52fyUA7J24eZD5av6SyGIV9kpmHNqyvdfzcpEMw97BvknV2fq+MFHun9BT3Lsf8pbzvisWiIQvYkng+8Vxk1V+dli1u56kY50LRjaPdotvT5BwqtwyF+emo/z9J3yVUVGfKrxQtJMOAQWoQii/4dp9wgybSa5mkucmRLtEQZ/pz0tL/NVcgWAd95nEQ3Tg6tNbuyn3Iepz65L3huMUUBntllWuu4DbtOFSMSbpILV4fy6wlM0SOvi6CpLh81c1LreIvKd61uEWBcDw1lUBUW1I0Z+m/PaRlX+PQ/oxg0Ye6KUiIiTF4ADNk59Ydpt5/rkxmq9tV5Kcp/eQLUVVmBzQNVuytQCP6Ezd0G8eLxWyHpmZWJ3bAzkWTtg4lZlw42SQezEmiUPaJUuR/qklVA/87S4ArFCpALdY3QRdUw3G3XbWUp6aq9z0zUizcPa7351p9JXOZyfdZBFnqt90VzQndXB/mwf8LC9STj5kenVpNuqOQQP3mIRJj7eV21FxG8VAxKrEn3c+XfmZ800EPb9/5lIlijscUbB6da0RQaMook0zug1G0tKi/JBC4rw7/D3m4ARzAkzMcVrDcT2SyFtUdWAsFlsPDFqV3N+EjyXaoEePwroaZCiLqEzb8MW+PNE9TmTC01EzWli51PzZvUqkmyuROU+V6ik+Le/9qT6nwzUzf9tP68tYei0YaDGx6kAd7jn1cKqOCuYbiELH9zYqcc4MnRJjkeGiqaGwLImhyeKs+xKJMBlOJ05ow9gGCKZ1VpnMKoSCTbMS+X+23y042zOb5MtcY/6oBeAo1Vy89OTyhpavFP78jXCcFH0t7Gx24hMEOm2gsEfGabVpQgvFqbQKMsknFRRmuPHcZu0Su/WMFphZvB2r/EGbG72rpGGho3h+Msz0uGzJ7hNK2uqQiE1qmn0zgacKYYZBCqsxV+sjbpoVdSilW/b94n2xNb648VmNIoizqEWhBnsen+d0kbCPmRItfWqSBeOd9Wne3c6bcd6uvXOJ6WdiSsuXq0ndhqrQ4QoWUjCjYtZ0EAhnSOP1m44xkf0O7jXghrzSJWxP4a/t72jU29Vu2rvu4n7HfHkkmQOMGSS+NPeLGO5I73mC2B7+lMiBQQZRM9/9liLIfowupUFAbPBbR+lxDM6M8Ptgh1paJq5Rvs7yEuLQv/7d1oU2woFSb3FMPWQOKMuCuJ7pDDjpIclus5TeEoMBy2YdVB4fxmesaCeMNsEgTHKS5WDSGyNUOoEpcC2OFWtIRf0w27ck34/DjxRTVIcc9+kqZE6iMSiVDsiKdP/Xz5XfEhm/sBhO50p1rvJDlkyyxuJ9SPgs7YeUJBjXdeAkE+P9OQJm6SZnn1svcduI78dYmbkE2mtziPrcjVisXG78spLvbZaSFx/Rks9zP4LKn0Cdz/3JsetkT06A8f/yCgMO6Mb1Hme0JJ7b2wZz1qleqTuKBGokhPVUZ0dVu+tnQYNEY1fmkZSz6+EGZ5EzL7657mreZGR3jUfaEk458PDniBzsSmBKhDRzfXameryJv9/D5m6HIqZ0R+ouCE54Dzp4IJuuD1e4Dc5i+PpSORJfG23uVgqixAMDvchMR0nZdH5brclYwRoJRWv/rlxGRI5ffD5NPGmIDt7vDE1434pYdVZIFh89Bs94HGGJbTwrN8T6lh1HZFTOB4lWzWj6EVqxSMvC0/ljWBQ3F2kc/mO2b6tWonT2JEqEwFts8rz2h+oWNds9ceR2cb7zZvJTDppHaEhK5avWqsseWa2Dt5BBhabdWSktS80oMQrL4TvAM9b5HMmyDnO+OkkbMXfUJG7eXqTIG6lqSOEbqVR+qYdP7uWb57WEJqzyh411GAVsDinPs7KvUeXItlcMdOUWzXBH6zscymV1LLVCtc8IePojzXHF9m5b5zGwBRdzcyUJkiu938ApmAayRdJrX1PmVguWUvt2ThQ62czItTyWJMW2An/hdDfMK7SiFQlGIdAbltHz3ycoh7j9V7GxNWBpbtcSdqm4XxRwTawc3cbZ+xfSv9qQfEkDKfZTwCkqWGI/ur250ItXlMlh6vUNWEYIg9A3GzbgmbqvTN8js2YMo87CU5y6nZ4dbJLDQJj9fc7yM7tZzJDZFtqOcU8+mZjYlq4VmifI23iHb1ZoT9E+kT2dolnP1AfiOkt7PQCSykBiXy5mv637IegWSKj9IKrYZf4Lu9+I7ub+mkRdlvYzehh/jaJ9n7HUH5b2IbgeNdkY7wx1yVzxS7pbvky6+nmVUtRllEFfweUQ0/nG017WoUYSxs+j2B4FV/F62EtHlMWZXYrjGHpthnNb1x66LKZ0Qe92INWHdfR/vqp02wMS8r1G4dJqHok8KmQ7947G13a4YXbsGgHcBvRuVu1eAi4/A5+ZixmdSXM73LupB/LH7O9yxLTVXJTyBbI1S49TIROrfVCOb/czZ9pM4JsZx8kUz8dQGv7gUWKxXvTH7QM/3J2OuXXgciUhqY+cgtaOliQQVOYthBLV3xpESZT3rmfEYNZxmpBbb24CRao86prn+i9TNOh8VxRJGXJfXHATJHs1T5txgc/opYrY8XjlGQQbRcoxIBcnVsMjmU1ymmIUL4dviJXndMAJ0Yet+c7O52/p98ytlmAsGBaTAmMhimAnvp1TWNGM9BpuitGj+t810CU2UhorrjPKGtThVC8WaXw04WFnT5fTjqmPyrQ0tN3CkLsctVy2xr0ZWgiWVZ1OrlFjjxJYsOiZv2cAoOvE+7sY0I/TwWcZqMoyIKNOftwP7w++Rfg67ljfovKYa50if3fzE/8aPYVey/Nq35+nH2sLPh/fP5TsylSKGOZ4k69d2PnH43+kq++sRXHQqGArWdwhx+hpwQC6JgT2uxehYU4Zbw7oNb6/HLikPyJROGK2ouyr+vzseESp9G50T4AyFrSqOQ0rroCYP4sMDFBrHn342EyZTMlSyk47rHSq89Y9/nI3zG5lX16Z5lxphguLOcZUndL8wNcrkyjH82jqg8Bo8OYkynrxZvbFno5lUS3OPr8Ko3mX9NoRPdYOKKjD07bvgFgpZ/RF+YzkWvJ/Hs/tUbfeGzGWLxNAjfDzHHMVSDwB5SabQLsIZHiBp43FjGkaienYoDd18hu2BGwOK7U3o70K/WY/kuuKdmdrykIBUdG2mvE91L1JtTbh20mOLbk1vCAamu7utlXeGU2ooVikbU/actcgmsC1FKk2qmj3GWeIWbj4tGIxE7BLcBWUvvcnd/lYxsMV4F917fWeFB/XbINN3qGvIyTpCalz1lVewdIGqeAS/gB8Mi+sA+BqDiX3VGD2eUunTRbSY+AuDy4E3Qx3hAhwnSXX+B0zuj3eQ1miS8Vux2z/l6/BkWtjKGU72aJkOCWhGcSf3+kFkkB15vGOsQrSdFr6qTj0gBYiOlnBO41170gOWHSUoBVRU2JjwppYdhIFDfu7tIRHccSNM5KZOFDPz0TGMAjzzEpeLwTWp+kn201kU6NjbiMQJx83+LX1e1tZ10kuChJZ/XBUQ1dwaBHjTDJDqOympEk8X2M3VtVw21JksChA8w1tTefO3RJ1FMbqZ01bHHkudDB/OhLfe7P5GOHaI28ZXKTMuqo0hLWQ4HabBsGG7NbP1RiXtETz074er6w/OerJWEqjmkq2y51q1BVI+JUudnVa3ogBpzdhFE7fC7kybrAt2Z6RqDjATAUEYeYK45WMupBKQRtQlU+uNsjnzj6ZmGrezA+ASrWxQ6LMkHRXqXwNq7ftv28dUx/ZSJciDXP2SWJsWaN0FjPX9Yko6LobZ7aYW/IdUktI9apTLyHS8DyWPyuoZyxN1TK/vtfxk3HwWh6JczZC8Ftn0bIJay2g+n5wd7lm9rEsKO+svqVmi+c1j88hSCxbzrg4+HEP0Nt1/B6YW1XVm09T1CpAKjc9n18hjqsaFGdfyva1ZG0Xu3ip6N6JGpyTSqY5h4BOlpLPaOnyw45PdXTN+DtAKg7DLrLFTnWusoSBHk3s0d7YouJHq85/R09Tfc37ENXZF48eAYLnq9GLioNcwDZrC6FW6godB8JnqYUPvn0pWLfQz0lM0Yy8Mybgn84Ds3Q9bDP10bLyOV+qzxa4Rd9Dhu7cju8mMaONXK3UqmBQ9qIg7etIwEqM/kECk/Dzja4Bs1xR+Q/tCbc8IKrSGsTdJJ0vge7IG20W687uVmK6icWQ6cD3lwFzgNMGtFvO5qyJeKflGLAAcQZOrkxVwy3cWvqlGpvjmf9Qe6Ap20MPbV92DPV0OhFM4kz8Yr0ffC2zLWSQ1kqY6QdQrttR3kh1YLtQd1kCEv5hVoPIRWl5ERcUTttBIrWp6Xs5Ehh5OUUwI5aEBvuiDmUoENmnVw1FohCrbRp1A1E+XSlWVOTi7ADW+5Ohb9z1vK4qx5R5lPdGCPBJZ00mC+Ssp8VUbgpGAvXWMuWQQRbCqI6Rr2jtxZxtfP7W/8onz+yz0Gs76LaT5HX9ecyiZCB/ZR/gFtMxPsDwohoeCRtiuLxE1GM1vUEUgBv86+eehL58/P56QFGQ/MqOe/vC76L63jzmeax4exd/OKTUvkXg+fOJUHych9xt/9goJMrapSgvXrj8+8vk/N80f22Sewj6cyGqt1B6mztoeklVHHraouhvHJaG/OuBz6DHKMpFmQULU1bRWlyYE0RPXYYkUycIemN7TLtgNCJX6BqdyxDKkegO7nJK5xQ7OVYDZTMf9bVHidtk6DQX9Et+V9M7esgbsYBdEeUpsB0Xvw2kd9+rI7V+m47u+O/tq7mw7262HU1WlS9uFzsV6JxIHNmUCy0QS9e077JGRFbG65z3/dOKB/Zk+yDdKpUmdXjn/aS3N5nv4fK7bMHHmPlHd4E2+iTbV5rpzScRnxk6KARuDTJ8Q1LpK2mP8gj1EbuJ9RIyY+EWK4hCiIDBAS1Tm2IEXAFfgKPgdL9O6mAa06wjCcUAL6EsxPQWO9VNegBPm/0GgkZbDxCynxujX/92vmGcjZRMAY45puak2sFLCLSwXpEsyy5fnF0jGJBhm+fNSHKKUUfy+276A7/feLOFxxUuHRNJI2Osenxyvf8DAGObT60pfTTlhEg9u/KKkhJqm5U1/+BEcSkpFDA5XeCqxwXmPac1jcuZ3JWQ+p0NdWzb/5v1ZvF8GtMTFFEdQjpLO0bwPb0BHNWnip3liDXI2fXf05jjvfJ0NpjLCUgfTh9CMFYVFKEd4Z/OG/2C+N435mnK+9t1gvCiVcaaH7rK4+PjCvpVNiz+t2QyqH1O8x3JKZVl6Q+Lp/XK8wMjVMslOq9FdSw5FtUs/CptXH9PW+wbWHgrV17R5jTVOtGtKFu3nb80T+E0tv9QkzW3J2dbaw/8ddAKZ0pxIaEqLjlPrji3VgJ3GvdFvlqD8075woxh4fVt0JZE0KVFsAvqhe0dqN9b35jtSpnYMXkU+vZq+IAHad3IHc2s/LYrnD1anfG46IFiMIr9oNbZDWvwthqYNqOigaKd/XlLU4XHfk/PXIjPsLy/9/kAtQ+/wKH+hI/IROWj5FPvTZAT9f7j4ZXQyG4M0TujMAFXYkKvEHv1xhySekgXGGqNxWeWKlf8dDAlLuB1cb/qOD+rk7cmwt+1yKpk9cudqBanTi6zTbXRtV8qylNtjyOVKy1HTz0GW9rjt6sSjAZcT5R+KdtyYb0zyqG9pSLuCw5WBwAn7fjBjKLLoxLXMI+52L9cLwIR2B6OllJZLHJ8vDxmWdtF+QJnmt1rsHPIWY20lftk8fYePkAIg6Hgn532QoIpegMxiWgAOfe5/U44APR8Ac0NeZrVh3gEhs12W+tVSiWiUQekf/YBECUy5fdYbA08dd7VzPAP9aiVcIB9k6tY7WdJ1wNV+bHeydNtmC6G5ICtFC1ZwmJU/j8hf0I8TRVKSiz5oYIa93EpUI78X8GYIAZabx47/n8LDAAJ0nNtP1rpROprqKMBRecShca6qXuTSI3jZBLOB3Vp381B5rCGhjSvh/NSVkYp2qIdP/Bg=";
          },
          5139: (Se, W, a) => {
            var x = a(5340);
            (W.init = function () {
              W.dictionary = x.init();
            }),
              (W.offsetsByLength = new Uint32Array([
                0, 0, 0, 0, 0, 4096, 9216, 21504, 35840, 44032, 53248, 63488,
                74752, 87040, 93696, 100864, 104704, 106752, 108928, 113536,
                115968, 118528, 119872, 121280, 122016,
              ])),
              (W.sizeBitsByLength = new Uint8Array([
                0, 0, 0, 0, 10, 10, 11, 11, 10, 10, 10, 10, 10, 9, 9, 8, 7, 7,
                8, 7, 7, 6, 6, 5, 5,
              ])),
              (W.minDictionaryWordLength = 4),
              (W.maxDictionaryWordLength = 24);
          },
          966: (Se, W) => {
            function a(d, h) {
              (this.bits = d), (this.value = h);
            }
            W.h = a;
            var x = 15;
            function T(d, h) {
              for (var f = 1 << (h - 1); d & f; ) f >>= 1;
              return (d & (f - 1)) + f;
            }
            function g(d, h, f, s, l) {
              do (s -= f), (d[h + s] = new a(l.bits, l.value));
              while (s > 0);
            }
            function c(d, h, f) {
              for (var s = 1 << (h - f); h < x && ((s -= d[h]), !(s <= 0)); )
                ++h, (s <<= 1);
              return h - f;
            }
            W.g = function (d, h, f, s, l) {
              var n = h,
                o,
                i,
                e,
                t,
                r,
                u,
                y,
                p,
                _,
                m,
                E,
                v = new Int32Array(x + 1),
                P = new Int32Array(x + 1);
              for (E = new Int32Array(l), e = 0; e < l; e++) v[s[e]]++;
              for (P[1] = 0, i = 1; i < x; i++) P[i + 1] = P[i] + v[i];
              for (e = 0; e < l; e++) s[e] !== 0 && (E[P[s[e]]++] = e);
              if (((p = f), (_ = 1 << p), (m = _), P[x] === 1)) {
                for (t = 0; t < m; ++t) d[h + t] = new a(0, E[0] & 65535);
                return m;
              }
              for (t = 0, e = 0, i = 1, r = 2; i <= f; ++i, r <<= 1)
                for (; v[i] > 0; --v[i])
                  (o = new a(i & 255, E[e++] & 65535)),
                    g(d, h + t, r, _, o),
                    (t = T(t, i));
              for (y = m - 1, u = -1, i = f + 1, r = 2; i <= x; ++i, r <<= 1)
                for (; v[i] > 0; --v[i])
                  (t & y) !== u &&
                    ((h += _),
                    (p = c(v, i, f)),
                    (_ = 1 << p),
                    (m += _),
                    (u = t & y),
                    (d[n + u] = new a((p + f) & 255, (h - n - u) & 65535))),
                    (o = new a((i - f) & 255, E[e++] & 65535)),
                    g(d, h + (t >> f), r, _, o),
                    (t = T(t, i));
              return m;
            };
          },
          8435: (Se, W) => {
            function a(x, T) {
              (this.offset = x), (this.nbits = T);
            }
            (W.kBlockLengthPrefixCode = [
              new a(1, 2),
              new a(5, 2),
              new a(9, 2),
              new a(13, 2),
              new a(17, 3),
              new a(25, 3),
              new a(33, 3),
              new a(41, 3),
              new a(49, 4),
              new a(65, 4),
              new a(81, 4),
              new a(97, 4),
              new a(113, 5),
              new a(145, 5),
              new a(177, 5),
              new a(209, 5),
              new a(241, 6),
              new a(305, 6),
              new a(369, 7),
              new a(497, 8),
              new a(753, 9),
              new a(1265, 10),
              new a(2289, 11),
              new a(4337, 12),
              new a(8433, 13),
              new a(16625, 24),
            ]),
              (W.kInsertLengthPrefixCode = [
                new a(0, 0),
                new a(1, 0),
                new a(2, 0),
                new a(3, 0),
                new a(4, 0),
                new a(5, 0),
                new a(6, 1),
                new a(8, 1),
                new a(10, 2),
                new a(14, 2),
                new a(18, 3),
                new a(26, 3),
                new a(34, 4),
                new a(50, 4),
                new a(66, 5),
                new a(98, 5),
                new a(130, 6),
                new a(194, 7),
                new a(322, 8),
                new a(578, 9),
                new a(1090, 10),
                new a(2114, 12),
                new a(6210, 14),
                new a(22594, 24),
              ]),
              (W.kCopyLengthPrefixCode = [
                new a(2, 0),
                new a(3, 0),
                new a(4, 0),
                new a(5, 0),
                new a(6, 0),
                new a(7, 0),
                new a(8, 0),
                new a(9, 0),
                new a(10, 1),
                new a(12, 1),
                new a(14, 2),
                new a(18, 2),
                new a(22, 3),
                new a(30, 3),
                new a(38, 4),
                new a(54, 4),
                new a(70, 5),
                new a(102, 5),
                new a(134, 6),
                new a(198, 7),
                new a(326, 8),
                new a(582, 9),
                new a(1094, 10),
                new a(2118, 24),
              ]),
              (W.kInsertRangeLut = [0, 0, 8, 8, 0, 16, 8, 16, 16]),
              (W.kCopyRangeLut = [0, 8, 0, 8, 16, 0, 16, 8, 16]);
          },
          6154: (Se, W) => {
            function a(T) {
              (this.buffer = T), (this.pos = 0);
            }
            (a.prototype.read = function (T, g, c) {
              this.pos + c > this.buffer.length &&
                (c = this.buffer.length - this.pos);
              for (var d = 0; d < c; d++) T[g + d] = this.buffer[this.pos + d];
              return (this.pos += c), c;
            }),
              (W.g = a);
            function x(T) {
              (this.buffer = T), (this.pos = 0);
            }
            (x.prototype.write = function (T, g) {
              if (this.pos + g > this.buffer.length)
                throw new Error("Output buffer is not large enough");
              return (
                this.buffer.set(T.subarray(0, g), this.pos), (this.pos += g), g
              );
            }),
              (W.j = x);
          },
          2973: (Se, W, a) => {
            var x = a(5139),
              T = 0,
              g = 1,
              c = 2,
              d = 3,
              h = 4,
              f = 5,
              s = 6,
              l = 7,
              n = 8,
              o = 9,
              i = 10,
              e = 11,
              t = 12,
              r = 13,
              u = 14,
              y = 15,
              p = 16,
              _ = 17,
              m = 18,
              E = 19,
              v = 20;
            function P(B, C, w) {
              (this.prefix = new Uint8Array(B.length)),
                (this.transform = C),
                (this.suffix = new Uint8Array(w.length));
              for (var k = 0; k < B.length; k++)
                this.prefix[k] = B.charCodeAt(k);
              for (var k = 0; k < w.length; k++)
                this.suffix[k] = w.charCodeAt(k);
            }
            var I = [
              new P("", T, ""),
              new P("", T, " "),
              new P(" ", T, " "),
              new P("", t, ""),
              new P("", i, " "),
              new P("", T, " the "),
              new P(" ", T, ""),
              new P("s ", T, " "),
              new P("", T, " of "),
              new P("", i, ""),
              new P("", T, " and "),
              new P("", r, ""),
              new P("", g, ""),
              new P(", ", T, " "),
              new P("", T, ", "),
              new P(" ", i, " "),
              new P("", T, " in "),
              new P("", T, " to "),
              new P("e ", T, " "),
              new P("", T, '"'),
              new P("", T, "."),
              new P("", T, '">'),
              new P(
                "",
                T,
                `
`
              ),
              new P("", d, ""),
              new P("", T, "]"),
              new P("", T, " for "),
              new P("", u, ""),
              new P("", c, ""),
              new P("", T, " a "),
              new P("", T, " that "),
              new P(" ", i, ""),
              new P("", T, ". "),
              new P(".", T, ""),
              new P(" ", T, ", "),
              new P("", y, ""),
              new P("", T, " with "),
              new P("", T, "'"),
              new P("", T, " from "),
              new P("", T, " by "),
              new P("", p, ""),
              new P("", _, ""),
              new P(" the ", T, ""),
              new P("", h, ""),
              new P("", T, ". The "),
              new P("", e, ""),
              new P("", T, " on "),
              new P("", T, " as "),
              new P("", T, " is "),
              new P("", l, ""),
              new P("", g, "ing "),
              new P(
                "",
                T,
                `
	`
              ),
              new P("", T, ":"),
              new P(" ", T, ". "),
              new P("", T, "ed "),
              new P("", v, ""),
              new P("", m, ""),
              new P("", s, ""),
              new P("", T, "("),
              new P("", i, ", "),
              new P("", n, ""),
              new P("", T, " at "),
              new P("", T, "ly "),
              new P(" the ", T, " of "),
              new P("", f, ""),
              new P("", o, ""),
              new P(" ", i, ", "),
              new P("", i, '"'),
              new P(".", T, "("),
              new P("", e, " "),
              new P("", i, '">'),
              new P("", T, '="'),
              new P(" ", T, "."),
              new P(".com/", T, ""),
              new P(" the ", T, " of the "),
              new P("", i, "'"),
              new P("", T, ". This "),
              new P("", T, ","),
              new P(".", T, " "),
              new P("", i, "("),
              new P("", i, "."),
              new P("", T, " not "),
              new P(" ", T, '="'),
              new P("", T, "er "),
              new P(" ", e, " "),
              new P("", T, "al "),
              new P(" ", e, ""),
              new P("", T, "='"),
              new P("", e, '"'),
              new P("", i, ". "),
              new P(" ", T, "("),
              new P("", T, "ful "),
              new P(" ", i, ". "),
              new P("", T, "ive "),
              new P("", T, "less "),
              new P("", e, "'"),
              new P("", T, "est "),
              new P(" ", i, "."),
              new P("", e, '">'),
              new P(" ", T, "='"),
              new P("", i, ","),
              new P("", T, "ize "),
              new P("", e, "."),
              new P("\xC2\xA0", T, ""),
              new P(" ", T, ","),
              new P("", i, '="'),
              new P("", e, '="'),
              new P("", T, "ous "),
              new P("", e, ", "),
              new P("", i, "='"),
              new P(" ", i, ","),
              new P(" ", e, '="'),
              new P(" ", e, ", "),
              new P("", e, ","),
              new P("", e, "("),
              new P("", e, ". "),
              new P(" ", e, "."),
              new P("", e, "='"),
              new P(" ", e, ". "),
              new P(" ", i, '="'),
              new P(" ", e, "='"),
              new P(" ", i, "='"),
            ];
            (W.kTransforms = I), (W.kNumTransforms = I.length);
            function A(B, C) {
              return B[C] < 192
                ? (B[C] >= 97 && B[C] <= 122 && (B[C] ^= 32), 1)
                : B[C] < 224
                ? ((B[C + 1] ^= 32), 2)
                : ((B[C + 2] ^= 5), 3);
            }
            W.transformDictionaryWord = function (B, C, w, k, K) {
              var te = I[K].prefix,
                X = I[K].suffix,
                $ = I[K].transform,
                ne = $ < t ? 0 : $ - (t - 1),
                Y = 0,
                Z = C,
                ye;
              ne > k && (ne = k);
              for (var pe = 0; pe < te.length; ) B[C++] = te[pe++];
              for (w += ne, k -= ne, $ <= o && (k -= $), Y = 0; Y < k; Y++)
                B[C++] = x.dictionary[w + Y];
              if (((ye = C - k), $ === i)) A(B, ye);
              else if ($ === e)
                for (; k > 0; ) {
                  var O = A(B, ye);
                  (ye += O), (k -= O);
                }
              for (var me = 0; me < X.length; ) B[C++] = X[me++];
              return C - Z;
            };
          },
          8764: (Se, W, a) => {
            "use strict";
            var x;
            /*!
             * The buffer module from node.js, for the browser.
             *
             * @author   Feross Aboukhadijeh <https://feross.org>
             * @license  MIT
             */ const T = a(9742),
              g = a(645),
              c =
                typeof Symbol == "function" && typeof Symbol.for == "function"
                  ? Symbol.for("nodejs.util.inspect.custom")
                  : null;
            (W.lW = s), (x = _), (W.h2 = 50);
            const d = 2147483647;
            (x = d),
              (s.TYPED_ARRAY_SUPPORT = h()),
              !s.TYPED_ARRAY_SUPPORT &&
                typeof console != "undefined" &&
                typeof console.error == "function" &&
                console.error(
                  "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
                );
            function h() {
              try {
                const _e = new Uint8Array(1),
                  U = {
                    foo: function () {
                      return 42;
                    },
                  };
                return (
                  Object.setPrototypeOf(U, Uint8Array.prototype),
                  Object.setPrototypeOf(_e, U),
                  _e.foo() === 42
                );
              } catch (_e) {
                return !1;
              }
            }
            Object.defineProperty(s.prototype, "parent", {
              enumerable: !0,
              get: function () {
                if (s.isBuffer(this)) return this.buffer;
              },
            }),
              Object.defineProperty(s.prototype, "offset", {
                enumerable: !0,
                get: function () {
                  if (s.isBuffer(this)) return this.byteOffset;
                },
              });
            function f(_e) {
              if (_e > d)
                throw new RangeError(
                  'The value "' + _e + '" is invalid for option "size"'
                );
              const U = new Uint8Array(_e);
              return Object.setPrototypeOf(U, s.prototype), U;
            }
            function s(_e, U, H) {
              if (typeof _e == "number") {
                if (typeof U == "string")
                  throw new TypeError(
                    'The "string" argument must be of type string. Received type number'
                  );
                return i(_e);
              }
              return l(_e, U, H);
            }
            s.poolSize = 8192;
            function l(_e, U, H) {
              if (typeof _e == "string") return e(_e, U);
              if (ArrayBuffer.isView(_e)) return r(_e);
              if (_e == null)
                throw new TypeError(
                  "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
                    typeof _e
                );
              if (
                Te(_e, ArrayBuffer) ||
                (_e && Te(_e.buffer, ArrayBuffer)) ||
                (typeof SharedArrayBuffer != "undefined" &&
                  (Te(_e, SharedArrayBuffer) ||
                    (_e && Te(_e.buffer, SharedArrayBuffer))))
              )
                return u(_e, U, H);
              if (typeof _e == "number")
                throw new TypeError(
                  'The "value" argument must not be of type number. Received type number'
                );
              const Ee = _e.valueOf && _e.valueOf();
              if (Ee != null && Ee !== _e) return s.from(Ee, U, H);
              const G = y(_e);
              if (G) return G;
              if (
                typeof Symbol != "undefined" &&
                Symbol.toPrimitive != null &&
                typeof _e[Symbol.toPrimitive] == "function"
              )
                return s.from(_e[Symbol.toPrimitive]("string"), U, H);
              throw new TypeError(
                "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
                  typeof _e
              );
            }
            (s.from = function (_e, U, H) {
              return l(_e, U, H);
            }),
              Object.setPrototypeOf(s.prototype, Uint8Array.prototype),
              Object.setPrototypeOf(s, Uint8Array);
            function n(_e) {
              if (typeof _e != "number")
                throw new TypeError('"size" argument must be of type number');
              if (_e < 0)
                throw new RangeError(
                  'The value "' + _e + '" is invalid for option "size"'
                );
            }
            function o(_e, U, H) {
              return (
                n(_e),
                _e <= 0
                  ? f(_e)
                  : U !== void 0
                  ? typeof H == "string"
                    ? f(_e).fill(U, H)
                    : f(_e).fill(U)
                  : f(_e)
              );
            }
            s.alloc = function (_e, U, H) {
              return o(_e, U, H);
            };
            function i(_e) {
              return n(_e), f(_e < 0 ? 0 : p(_e) | 0);
            }
            (s.allocUnsafe = function (_e) {
              return i(_e);
            }),
              (s.allocUnsafeSlow = function (_e) {
                return i(_e);
              });
            function e(_e, U) {
              if (
                ((typeof U != "string" || U === "") && (U = "utf8"),
                !s.isEncoding(U))
              )
                throw new TypeError("Unknown encoding: " + U);
              const H = m(_e, U) | 0;
              let Ee = f(H);
              const G = Ee.write(_e, U);
              return G !== H && (Ee = Ee.slice(0, G)), Ee;
            }
            function t(_e) {
              const U = _e.length < 0 ? 0 : p(_e.length) | 0,
                H = f(U);
              for (let Ee = 0; Ee < U; Ee += 1) H[Ee] = _e[Ee] & 255;
              return H;
            }
            function r(_e) {
              if (Te(_e, Uint8Array)) {
                const U = new Uint8Array(_e);
                return u(U.buffer, U.byteOffset, U.byteLength);
              }
              return t(_e);
            }
            function u(_e, U, H) {
              if (U < 0 || _e.byteLength < U)
                throw new RangeError('"offset" is outside of buffer bounds');
              if (_e.byteLength < U + (H || 0))
                throw new RangeError('"length" is outside of buffer bounds');
              let Ee;
              return (
                U === void 0 && H === void 0
                  ? (Ee = new Uint8Array(_e))
                  : H === void 0
                  ? (Ee = new Uint8Array(_e, U))
                  : (Ee = new Uint8Array(_e, U, H)),
                Object.setPrototypeOf(Ee, s.prototype),
                Ee
              );
            }
            function y(_e) {
              if (s.isBuffer(_e)) {
                const U = p(_e.length) | 0,
                  H = f(U);
                return H.length === 0 || _e.copy(H, 0, 0, U), H;
              }
              if (_e.length !== void 0)
                return typeof _e.length != "number" || Ne(_e.length)
                  ? f(0)
                  : t(_e);
              if (_e.type === "Buffer" && Array.isArray(_e.data))
                return t(_e.data);
            }
            function p(_e) {
              if (_e >= d)
                throw new RangeError(
                  "Attempt to allocate Buffer larger than maximum size: 0x" +
                    d.toString(16) +
                    " bytes"
                );
              return _e | 0;
            }
            function _(_e) {
              return +_e != _e && (_e = 0), s.alloc(+_e);
            }
            (s.isBuffer = function (U) {
              return U != null && U._isBuffer === !0 && U !== s.prototype;
            }),
              (s.compare = function (U, H) {
                if (
                  (Te(U, Uint8Array) && (U = s.from(U, U.offset, U.byteLength)),
                  Te(H, Uint8Array) && (H = s.from(H, H.offset, H.byteLength)),
                  !s.isBuffer(U) || !s.isBuffer(H))
                )
                  throw new TypeError(
                    'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
                  );
                if (U === H) return 0;
                let Ee = U.length,
                  G = H.length;
                for (let Q = 0, q = Math.min(Ee, G); Q < q; ++Q)
                  if (U[Q] !== H[Q]) {
                    (Ee = U[Q]), (G = H[Q]);
                    break;
                  }
                return Ee < G ? -1 : G < Ee ? 1 : 0;
              }),
              (s.isEncoding = function (U) {
                switch (String(U).toLowerCase()) {
                  case "hex":
                  case "utf8":
                  case "utf-8":
                  case "ascii":
                  case "latin1":
                  case "binary":
                  case "base64":
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return !0;
                  default:
                    return !1;
                }
              }),
              (s.concat = function (U, H) {
                if (!Array.isArray(U))
                  throw new TypeError(
                    '"list" argument must be an Array of Buffers'
                  );
                if (U.length === 0) return s.alloc(0);
                let Ee;
                if (H === void 0)
                  for (H = 0, Ee = 0; Ee < U.length; ++Ee) H += U[Ee].length;
                const G = s.allocUnsafe(H);
                let Q = 0;
                for (Ee = 0; Ee < U.length; ++Ee) {
                  let q = U[Ee];
                  if (Te(q, Uint8Array))
                    Q + q.length > G.length
                      ? (s.isBuffer(q) || (q = s.from(q)), q.copy(G, Q))
                      : Uint8Array.prototype.set.call(G, q, Q);
                  else if (s.isBuffer(q)) q.copy(G, Q);
                  else
                    throw new TypeError(
                      '"list" argument must be an Array of Buffers'
                    );
                  Q += q.length;
                }
                return G;
              });
            function m(_e, U) {
              if (s.isBuffer(_e)) return _e.length;
              if (ArrayBuffer.isView(_e) || Te(_e, ArrayBuffer))
                return _e.byteLength;
              if (typeof _e != "string")
                throw new TypeError(
                  'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
                    typeof _e
                );
              const H = _e.length,
                Ee = arguments.length > 2 && arguments[2] === !0;
              if (!Ee && H === 0) return 0;
              let G = !1;
              for (;;)
                switch (U) {
                  case "ascii":
                  case "latin1":
                  case "binary":
                    return H;
                  case "utf8":
                  case "utf-8":
                    return z(_e).length;
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return H * 2;
                  case "hex":
                    return H >>> 1;
                  case "base64":
                    return ge(_e).length;
                  default:
                    if (G) return Ee ? -1 : z(_e).length;
                    (U = ("" + U).toLowerCase()), (G = !0);
                }
            }
            s.byteLength = m;
            function E(_e, U, H) {
              let Ee = !1;
              if (
                ((U === void 0 || U < 0) && (U = 0),
                U > this.length ||
                  ((H === void 0 || H > this.length) && (H = this.length),
                  H <= 0) ||
                  ((H >>>= 0), (U >>>= 0), H <= U))
              )
                return "";
              for (_e || (_e = "utf8"); ; )
                switch (_e) {
                  case "hex":
                    return Z(this, U, H);
                  case "utf8":
                  case "utf-8":
                    return te(this, U, H);
                  case "ascii":
                    return ne(this, U, H);
                  case "latin1":
                  case "binary":
                    return Y(this, U, H);
                  case "base64":
                    return K(this, U, H);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return ye(this, U, H);
                  default:
                    if (Ee) throw new TypeError("Unknown encoding: " + _e);
                    (_e = (_e + "").toLowerCase()), (Ee = !0);
                }
            }
            s.prototype._isBuffer = !0;
            function v(_e, U, H) {
              const Ee = _e[U];
              (_e[U] = _e[H]), (_e[H] = Ee);
            }
            (s.prototype.swap16 = function () {
              const U = this.length;
              if (U % 2 !== 0)
                throw new RangeError(
                  "Buffer size must be a multiple of 16-bits"
                );
              for (let H = 0; H < U; H += 2) v(this, H, H + 1);
              return this;
            }),
              (s.prototype.swap32 = function () {
                const U = this.length;
                if (U % 4 !== 0)
                  throw new RangeError(
                    "Buffer size must be a multiple of 32-bits"
                  );
                for (let H = 0; H < U; H += 4)
                  v(this, H, H + 3), v(this, H + 1, H + 2);
                return this;
              }),
              (s.prototype.swap64 = function () {
                const U = this.length;
                if (U % 8 !== 0)
                  throw new RangeError(
                    "Buffer size must be a multiple of 64-bits"
                  );
                for (let H = 0; H < U; H += 8)
                  v(this, H, H + 7),
                    v(this, H + 1, H + 6),
                    v(this, H + 2, H + 5),
                    v(this, H + 3, H + 4);
                return this;
              }),
              (s.prototype.toString = function () {
                const U = this.length;
                return U === 0
                  ? ""
                  : arguments.length === 0
                  ? te(this, 0, U)
                  : E.apply(this, arguments);
              }),
              (s.prototype.toLocaleString = s.prototype.toString),
              (s.prototype.equals = function (U) {
                if (!s.isBuffer(U))
                  throw new TypeError("Argument must be a Buffer");
                return this === U ? !0 : s.compare(this, U) === 0;
              }),
              (s.prototype.inspect = function () {
                let U = "";
                const H = W.h2;
                return (
                  (U = this.toString("hex", 0, H)
                    .replace(/(.{2})/g, "$1 ")
                    .trim()),
                  this.length > H && (U += " ... "),
                  "<Buffer " + U + ">"
                );
              }),
              c && (s.prototype[c] = s.prototype.inspect),
              (s.prototype.compare = function (U, H, Ee, G, Q) {
                if (
                  (Te(U, Uint8Array) && (U = s.from(U, U.offset, U.byteLength)),
                  !s.isBuffer(U))
                )
                  throw new TypeError(
                    'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
                      typeof U
                  );
                if (
                  (H === void 0 && (H = 0),
                  Ee === void 0 && (Ee = U ? U.length : 0),
                  G === void 0 && (G = 0),
                  Q === void 0 && (Q = this.length),
                  H < 0 || Ee > U.length || G < 0 || Q > this.length)
                )
                  throw new RangeError("out of range index");
                if (G >= Q && H >= Ee) return 0;
                if (G >= Q) return -1;
                if (H >= Ee) return 1;
                if (
                  ((H >>>= 0), (Ee >>>= 0), (G >>>= 0), (Q >>>= 0), this === U)
                )
                  return 0;
                let q = Q - G,
                  xe = Ee - H;
                const be = Math.min(q, xe),
                  Pe = this.slice(G, Q),
                  we = U.slice(H, Ee);
                for (let Oe = 0; Oe < be; ++Oe)
                  if (Pe[Oe] !== we[Oe]) {
                    (q = Pe[Oe]), (xe = we[Oe]);
                    break;
                  }
                return q < xe ? -1 : xe < q ? 1 : 0;
              });
            function P(_e, U, H, Ee, G) {
              if (_e.length === 0) return -1;
              if (
                (typeof H == "string"
                  ? ((Ee = H), (H = 0))
                  : H > 2147483647
                  ? (H = 2147483647)
                  : H < -2147483648 && (H = -2147483648),
                (H = +H),
                Ne(H) && (H = G ? 0 : _e.length - 1),
                H < 0 && (H = _e.length + H),
                H >= _e.length)
              ) {
                if (G) return -1;
                H = _e.length - 1;
              } else if (H < 0)
                if (G) H = 0;
                else return -1;
              if ((typeof U == "string" && (U = s.from(U, Ee)), s.isBuffer(U)))
                return U.length === 0 ? -1 : I(_e, U, H, Ee, G);
              if (typeof U == "number")
                return (
                  (U = U & 255),
                  typeof Uint8Array.prototype.indexOf == "function"
                    ? G
                      ? Uint8Array.prototype.indexOf.call(_e, U, H)
                      : Uint8Array.prototype.lastIndexOf.call(_e, U, H)
                    : I(_e, [U], H, Ee, G)
                );
              throw new TypeError("val must be string, number or Buffer");
            }
            function I(_e, U, H, Ee, G) {
              let Q = 1,
                q = _e.length,
                xe = U.length;
              if (
                Ee !== void 0 &&
                ((Ee = String(Ee).toLowerCase()),
                Ee === "ucs2" ||
                  Ee === "ucs-2" ||
                  Ee === "utf16le" ||
                  Ee === "utf-16le")
              ) {
                if (_e.length < 2 || U.length < 2) return -1;
                (Q = 2), (q /= 2), (xe /= 2), (H /= 2);
              }
              function be(we, Oe) {
                return Q === 1 ? we[Oe] : we.readUInt16BE(Oe * Q);
              }
              let Pe;
              if (G) {
                let we = -1;
                for (Pe = H; Pe < q; Pe++)
                  if (be(_e, Pe) === be(U, we === -1 ? 0 : Pe - we)) {
                    if ((we === -1 && (we = Pe), Pe - we + 1 === xe))
                      return we * Q;
                  } else we !== -1 && (Pe -= Pe - we), (we = -1);
              } else
                for (H + xe > q && (H = q - xe), Pe = H; Pe >= 0; Pe--) {
                  let we = !0;
                  for (let Oe = 0; Oe < xe; Oe++)
                    if (be(_e, Pe + Oe) !== be(U, Oe)) {
                      we = !1;
                      break;
                    }
                  if (we) return Pe;
                }
              return -1;
            }
            (s.prototype.includes = function (U, H, Ee) {
              return this.indexOf(U, H, Ee) !== -1;
            }),
              (s.prototype.indexOf = function (U, H, Ee) {
                return P(this, U, H, Ee, !0);
              }),
              (s.prototype.lastIndexOf = function (U, H, Ee) {
                return P(this, U, H, Ee, !1);
              });
            function A(_e, U, H, Ee) {
              H = Number(H) || 0;
              const G = _e.length - H;
              Ee ? ((Ee = Number(Ee)), Ee > G && (Ee = G)) : (Ee = G);
              const Q = U.length;
              Ee > Q / 2 && (Ee = Q / 2);
              let q;
              for (q = 0; q < Ee; ++q) {
                const xe = parseInt(U.substr(q * 2, 2), 16);
                if (Ne(xe)) return q;
                _e[H + q] = xe;
              }
              return q;
            }
            function B(_e, U, H, Ee) {
              return Re(z(U, _e.length - H), _e, H, Ee);
            }
            function C(_e, U, H, Ee) {
              return Re(oe(U), _e, H, Ee);
            }
            function w(_e, U, H, Ee) {
              return Re(ge(U), _e, H, Ee);
            }
            function k(_e, U, H, Ee) {
              return Re(de(U, _e.length - H), _e, H, Ee);
            }
            (s.prototype.write = function (U, H, Ee, G) {
              if (H === void 0) (G = "utf8"), (Ee = this.length), (H = 0);
              else if (Ee === void 0 && typeof H == "string")
                (G = H), (Ee = this.length), (H = 0);
              else if (isFinite(H))
                (H = H >>> 0),
                  isFinite(Ee)
                    ? ((Ee = Ee >>> 0), G === void 0 && (G = "utf8"))
                    : ((G = Ee), (Ee = void 0));
              else
                throw new Error(
                  "Buffer.write(string, encoding, offset[, length]) is no longer supported"
                );
              const Q = this.length - H;
              if (
                ((Ee === void 0 || Ee > Q) && (Ee = Q),
                (U.length > 0 && (Ee < 0 || H < 0)) || H > this.length)
              )
                throw new RangeError("Attempt to write outside buffer bounds");
              G || (G = "utf8");
              let q = !1;
              for (;;)
                switch (G) {
                  case "hex":
                    return A(this, U, H, Ee);
                  case "utf8":
                  case "utf-8":
                    return B(this, U, H, Ee);
                  case "ascii":
                  case "latin1":
                  case "binary":
                    return C(this, U, H, Ee);
                  case "base64":
                    return w(this, U, H, Ee);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return k(this, U, H, Ee);
                  default:
                    if (q) throw new TypeError("Unknown encoding: " + G);
                    (G = ("" + G).toLowerCase()), (q = !0);
                }
            }),
              (s.prototype.toJSON = function () {
                return {
                  type: "Buffer",
                  data: Array.prototype.slice.call(this._arr || this, 0),
                };
              });
            function K(_e, U, H) {
              return U === 0 && H === _e.length
                ? T.fromByteArray(_e)
                : T.fromByteArray(_e.slice(U, H));
            }
            function te(_e, U, H) {
              H = Math.min(_e.length, H);
              const Ee = [];
              let G = U;
              for (; G < H; ) {
                const Q = _e[G];
                let q = null,
                  xe = Q > 239 ? 4 : Q > 223 ? 3 : Q > 191 ? 2 : 1;
                if (G + xe <= H) {
                  let be, Pe, we, Oe;
                  switch (xe) {
                    case 1:
                      Q < 128 && (q = Q);
                      break;
                    case 2:
                      (be = _e[G + 1]),
                        (be & 192) === 128 &&
                          ((Oe = ((Q & 31) << 6) | (be & 63)),
                          Oe > 127 && (q = Oe));
                      break;
                    case 3:
                      (be = _e[G + 1]),
                        (Pe = _e[G + 2]),
                        (be & 192) === 128 &&
                          (Pe & 192) === 128 &&
                          ((Oe =
                            ((Q & 15) << 12) | ((be & 63) << 6) | (Pe & 63)),
                          Oe > 2047 && (Oe < 55296 || Oe > 57343) && (q = Oe));
                      break;
                    case 4:
                      (be = _e[G + 1]),
                        (Pe = _e[G + 2]),
                        (we = _e[G + 3]),
                        (be & 192) === 128 &&
                          (Pe & 192) === 128 &&
                          (we & 192) === 128 &&
                          ((Oe =
                            ((Q & 15) << 18) |
                            ((be & 63) << 12) |
                            ((Pe & 63) << 6) |
                            (we & 63)),
                          Oe > 65535 && Oe < 1114112 && (q = Oe));
                  }
                }
                q === null
                  ? ((q = 65533), (xe = 1))
                  : q > 65535 &&
                    ((q -= 65536),
                    Ee.push(((q >>> 10) & 1023) | 55296),
                    (q = 56320 | (q & 1023))),
                  Ee.push(q),
                  (G += xe);
              }
              return $(Ee);
            }
            const X = 4096;
            function $(_e) {
              const U = _e.length;
              if (U <= X) return String.fromCharCode.apply(String, _e);
              let H = "",
                Ee = 0;
              for (; Ee < U; )
                H += String.fromCharCode.apply(String, _e.slice(Ee, (Ee += X)));
              return H;
            }
            function ne(_e, U, H) {
              let Ee = "";
              H = Math.min(_e.length, H);
              for (let G = U; G < H; ++G)
                Ee += String.fromCharCode(_e[G] & 127);
              return Ee;
            }
            function Y(_e, U, H) {
              let Ee = "";
              H = Math.min(_e.length, H);
              for (let G = U; G < H; ++G) Ee += String.fromCharCode(_e[G]);
              return Ee;
            }
            function Z(_e, U, H) {
              const Ee = _e.length;
              (!U || U < 0) && (U = 0), (!H || H < 0 || H > Ee) && (H = Ee);
              let G = "";
              for (let Q = U; Q < H; ++Q) G += Le[_e[Q]];
              return G;
            }
            function ye(_e, U, H) {
              const Ee = _e.slice(U, H);
              let G = "";
              for (let Q = 0; Q < Ee.length - 1; Q += 2)
                G += String.fromCharCode(Ee[Q] + Ee[Q + 1] * 256);
              return G;
            }
            s.prototype.slice = function (U, H) {
              const Ee = this.length;
              (U = ~~U),
                (H = H === void 0 ? Ee : ~~H),
                U < 0 ? ((U += Ee), U < 0 && (U = 0)) : U > Ee && (U = Ee),
                H < 0 ? ((H += Ee), H < 0 && (H = 0)) : H > Ee && (H = Ee),
                H < U && (H = U);
              const G = this.subarray(U, H);
              return Object.setPrototypeOf(G, s.prototype), G;
            };
            function pe(_e, U, H) {
              if (_e % 1 !== 0 || _e < 0)
                throw new RangeError("offset is not uint");
              if (_e + U > H)
                throw new RangeError("Trying to access beyond buffer length");
            }
            (s.prototype.readUintLE = s.prototype.readUIntLE =
              function (U, H, Ee) {
                (U = U >>> 0), (H = H >>> 0), Ee || pe(U, H, this.length);
                let G = this[U],
                  Q = 1,
                  q = 0;
                for (; ++q < H && (Q *= 256); ) G += this[U + q] * Q;
                return G;
              }),
              (s.prototype.readUintBE = s.prototype.readUIntBE =
                function (U, H, Ee) {
                  (U = U >>> 0), (H = H >>> 0), Ee || pe(U, H, this.length);
                  let G = this[U + --H],
                    Q = 1;
                  for (; H > 0 && (Q *= 256); ) G += this[U + --H] * Q;
                  return G;
                }),
              (s.prototype.readUint8 = s.prototype.readUInt8 =
                function (U, H) {
                  return (U = U >>> 0), H || pe(U, 1, this.length), this[U];
                }),
              (s.prototype.readUint16LE = s.prototype.readUInt16LE =
                function (U, H) {
                  return (
                    (U = U >>> 0),
                    H || pe(U, 2, this.length),
                    this[U] | (this[U + 1] << 8)
                  );
                }),
              (s.prototype.readUint16BE = s.prototype.readUInt16BE =
                function (U, H) {
                  return (
                    (U = U >>> 0),
                    H || pe(U, 2, this.length),
                    (this[U] << 8) | this[U + 1]
                  );
                }),
              (s.prototype.readUint32LE = s.prototype.readUInt32LE =
                function (U, H) {
                  return (
                    (U = U >>> 0),
                    H || pe(U, 4, this.length),
                    (this[U] | (this[U + 1] << 8) | (this[U + 2] << 16)) +
                      this[U + 3] * 16777216
                  );
                }),
              (s.prototype.readUint32BE = s.prototype.readUInt32BE =
                function (U, H) {
                  return (
                    (U = U >>> 0),
                    H || pe(U, 4, this.length),
                    this[U] * 16777216 +
                      ((this[U + 1] << 16) | (this[U + 2] << 8) | this[U + 3])
                  );
                }),
              (s.prototype.readBigUInt64LE = ke(function (U) {
                (U = U >>> 0), ie(U, "offset");
                const H = this[U],
                  Ee = this[U + 7];
                (H === void 0 || Ee === void 0) && b(U, this.length - 8);
                const G =
                    H +
                    this[++U] * Cs(2, 8) +
                    this[++U] * Cs(2, 16) +
                    this[++U] * Cs(2, 24),
                  Q =
                    this[++U] +
                    this[++U] * Cs(2, 8) +
                    this[++U] * Cs(2, 16) +
                    Ee * Cs(2, 24);
                return BigInt(G) + (BigInt(Q) << BigInt(32));
              })),
              (s.prototype.readBigUInt64BE = ke(function (U) {
                (U = U >>> 0), ie(U, "offset");
                const H = this[U],
                  Ee = this[U + 7];
                (H === void 0 || Ee === void 0) && b(U, this.length - 8);
                const G =
                    H * Cs(2, 24) +
                    this[++U] * Cs(2, 16) +
                    this[++U] * Cs(2, 8) +
                    this[++U],
                  Q =
                    this[++U] * Cs(2, 24) +
                    this[++U] * Cs(2, 16) +
                    this[++U] * Cs(2, 8) +
                    Ee;
                return (BigInt(G) << BigInt(32)) + BigInt(Q);
              })),
              (s.prototype.readIntLE = function (U, H, Ee) {
                (U = U >>> 0), (H = H >>> 0), Ee || pe(U, H, this.length);
                let G = this[U],
                  Q = 1,
                  q = 0;
                for (; ++q < H && (Q *= 256); ) G += this[U + q] * Q;
                return (Q *= 128), G >= Q && (G -= Math.pow(2, 8 * H)), G;
              }),
              (s.prototype.readIntBE = function (U, H, Ee) {
                (U = U >>> 0), (H = H >>> 0), Ee || pe(U, H, this.length);
                let G = H,
                  Q = 1,
                  q = this[U + --G];
                for (; G > 0 && (Q *= 256); ) q += this[U + --G] * Q;
                return (Q *= 128), q >= Q && (q -= Math.pow(2, 8 * H)), q;
              }),
              (s.prototype.readInt8 = function (U, H) {
                return (
                  (U = U >>> 0),
                  H || pe(U, 1, this.length),
                  this[U] & 128 ? (255 - this[U] + 1) * -1 : this[U]
                );
              }),
              (s.prototype.readInt16LE = function (U, H) {
                (U = U >>> 0), H || pe(U, 2, this.length);
                const Ee = this[U] | (this[U + 1] << 8);
                return Ee & 32768 ? Ee | 4294901760 : Ee;
              }),
              (s.prototype.readInt16BE = function (U, H) {
                (U = U >>> 0), H || pe(U, 2, this.length);
                const Ee = this[U + 1] | (this[U] << 8);
                return Ee & 32768 ? Ee | 4294901760 : Ee;
              }),
              (s.prototype.readInt32LE = function (U, H) {
                return (
                  (U = U >>> 0),
                  H || pe(U, 4, this.length),
                  this[U] |
                    (this[U + 1] << 8) |
                    (this[U + 2] << 16) |
                    (this[U + 3] << 24)
                );
              }),
              (s.prototype.readInt32BE = function (U, H) {
                return (
                  (U = U >>> 0),
                  H || pe(U, 4, this.length),
                  (this[U] << 24) |
                    (this[U + 1] << 16) |
                    (this[U + 2] << 8) |
                    this[U + 3]
                );
              }),
              (s.prototype.readBigInt64LE = ke(function (U) {
                (U = U >>> 0), ie(U, "offset");
                const H = this[U],
                  Ee = this[U + 7];
                (H === void 0 || Ee === void 0) && b(U, this.length - 8);
                const G =
                  this[U + 4] +
                  this[U + 5] * Cs(2, 8) +
                  this[U + 6] * Cs(2, 16) +
                  (Ee << 24);
                return (
                  (BigInt(G) << BigInt(32)) +
                  BigInt(
                    H +
                      this[++U] * 256 +
                      this[++U] * 65536 +
                      this[++U] * 16777216
                  )
                );
              })),
              (s.prototype.readBigInt64BE = ke(function (U) {
                (U = U >>> 0), ie(U, "offset");
                const H = this[U],
                  Ee = this[U + 7];
                (H === void 0 || Ee === void 0) && b(U, this.length - 8);
                const G =
                  (H << 24) +
                  this[++U] * Cs(2, 16) +
                  this[++U] * Cs(2, 8) +
                  this[++U];
                return (
                  (BigInt(G) << BigInt(32)) +
                  BigInt(
                    this[++U] * 16777216 +
                      this[++U] * 65536 +
                      this[++U] * 256 +
                      Ee
                  )
                );
              })),
              (s.prototype.readFloatLE = function (U, H) {
                return (
                  (U = U >>> 0),
                  H || pe(U, 4, this.length),
                  g.read(this, U, !0, 23, 4)
                );
              }),
              (s.prototype.readFloatBE = function (U, H) {
                return (
                  (U = U >>> 0),
                  H || pe(U, 4, this.length),
                  g.read(this, U, !1, 23, 4)
                );
              }),
              (s.prototype.readDoubleLE = function (U, H) {
                return (
                  (U = U >>> 0),
                  H || pe(U, 8, this.length),
                  g.read(this, U, !0, 52, 8)
                );
              }),
              (s.prototype.readDoubleBE = function (U, H) {
                return (
                  (U = U >>> 0),
                  H || pe(U, 8, this.length),
                  g.read(this, U, !1, 52, 8)
                );
              });
            function O(_e, U, H, Ee, G, Q) {
              if (!s.isBuffer(_e))
                throw new TypeError(
                  '"buffer" argument must be a Buffer instance'
                );
              if (U > G || U < Q)
                throw new RangeError('"value" argument is out of bounds');
              if (H + Ee > _e.length)
                throw new RangeError("Index out of range");
            }
            (s.prototype.writeUintLE = s.prototype.writeUIntLE =
              function (U, H, Ee, G) {
                if (((U = +U), (H = H >>> 0), (Ee = Ee >>> 0), !G)) {
                  const xe = Math.pow(2, 8 * Ee) - 1;
                  O(this, U, H, Ee, xe, 0);
                }
                let Q = 1,
                  q = 0;
                for (this[H] = U & 255; ++q < Ee && (Q *= 256); )
                  this[H + q] = (U / Q) & 255;
                return H + Ee;
              }),
              (s.prototype.writeUintBE = s.prototype.writeUIntBE =
                function (U, H, Ee, G) {
                  if (((U = +U), (H = H >>> 0), (Ee = Ee >>> 0), !G)) {
                    const xe = Math.pow(2, 8 * Ee) - 1;
                    O(this, U, H, Ee, xe, 0);
                  }
                  let Q = Ee - 1,
                    q = 1;
                  for (this[H + Q] = U & 255; --Q >= 0 && (q *= 256); )
                    this[H + Q] = (U / q) & 255;
                  return H + Ee;
                }),
              (s.prototype.writeUint8 = s.prototype.writeUInt8 =
                function (U, H, Ee) {
                  return (
                    (U = +U),
                    (H = H >>> 0),
                    Ee || O(this, U, H, 1, 255, 0),
                    (this[H] = U & 255),
                    H + 1
                  );
                }),
              (s.prototype.writeUint16LE = s.prototype.writeUInt16LE =
                function (U, H, Ee) {
                  return (
                    (U = +U),
                    (H = H >>> 0),
                    Ee || O(this, U, H, 2, 65535, 0),
                    (this[H] = U & 255),
                    (this[H + 1] = U >>> 8),
                    H + 2
                  );
                }),
              (s.prototype.writeUint16BE = s.prototype.writeUInt16BE =
                function (U, H, Ee) {
                  return (
                    (U = +U),
                    (H = H >>> 0),
                    Ee || O(this, U, H, 2, 65535, 0),
                    (this[H] = U >>> 8),
                    (this[H + 1] = U & 255),
                    H + 2
                  );
                }),
              (s.prototype.writeUint32LE = s.prototype.writeUInt32LE =
                function (U, H, Ee) {
                  return (
                    (U = +U),
                    (H = H >>> 0),
                    Ee || O(this, U, H, 4, 4294967295, 0),
                    (this[H + 3] = U >>> 24),
                    (this[H + 2] = U >>> 16),
                    (this[H + 1] = U >>> 8),
                    (this[H] = U & 255),
                    H + 4
                  );
                }),
              (s.prototype.writeUint32BE = s.prototype.writeUInt32BE =
                function (U, H, Ee) {
                  return (
                    (U = +U),
                    (H = H >>> 0),
                    Ee || O(this, U, H, 4, 4294967295, 0),
                    (this[H] = U >>> 24),
                    (this[H + 1] = U >>> 16),
                    (this[H + 2] = U >>> 8),
                    (this[H + 3] = U & 255),
                    H + 4
                  );
                });
            function me(_e, U, H, Ee, G) {
              ce(U, Ee, G, _e, H, 7);
              let Q = Number(U & BigInt(4294967295));
              (_e[H++] = Q),
                (Q = Q >> 8),
                (_e[H++] = Q),
                (Q = Q >> 8),
                (_e[H++] = Q),
                (Q = Q >> 8),
                (_e[H++] = Q);
              let q = Number((U >> BigInt(32)) & BigInt(4294967295));
              return (
                (_e[H++] = q),
                (q = q >> 8),
                (_e[H++] = q),
                (q = q >> 8),
                (_e[H++] = q),
                (q = q >> 8),
                (_e[H++] = q),
                H
              );
            }
            function N(_e, U, H, Ee, G) {
              ce(U, Ee, G, _e, H, 7);
              let Q = Number(U & BigInt(4294967295));
              (_e[H + 7] = Q),
                (Q = Q >> 8),
                (_e[H + 6] = Q),
                (Q = Q >> 8),
                (_e[H + 5] = Q),
                (Q = Q >> 8),
                (_e[H + 4] = Q);
              let q = Number((U >> BigInt(32)) & BigInt(4294967295));
              return (
                (_e[H + 3] = q),
                (q = q >> 8),
                (_e[H + 2] = q),
                (q = q >> 8),
                (_e[H + 1] = q),
                (q = q >> 8),
                (_e[H] = q),
                H + 8
              );
            }
            (s.prototype.writeBigUInt64LE = ke(function (U, H = 0) {
              return me(this, U, H, BigInt(0), BigInt("0xffffffffffffffff"));
            })),
              (s.prototype.writeBigUInt64BE = ke(function (U, H = 0) {
                return N(this, U, H, BigInt(0), BigInt("0xffffffffffffffff"));
              })),
              (s.prototype.writeIntLE = function (U, H, Ee, G) {
                if (((U = +U), (H = H >>> 0), !G)) {
                  const be = Math.pow(2, 8 * Ee - 1);
                  O(this, U, H, Ee, be - 1, -be);
                }
                let Q = 0,
                  q = 1,
                  xe = 0;
                for (this[H] = U & 255; ++Q < Ee && (q *= 256); )
                  U < 0 && xe === 0 && this[H + Q - 1] !== 0 && (xe = 1),
                    (this[H + Q] = (((U / q) >> 0) - xe) & 255);
                return H + Ee;
              }),
              (s.prototype.writeIntBE = function (U, H, Ee, G) {
                if (((U = +U), (H = H >>> 0), !G)) {
                  const be = Math.pow(2, 8 * Ee - 1);
                  O(this, U, H, Ee, be - 1, -be);
                }
                let Q = Ee - 1,
                  q = 1,
                  xe = 0;
                for (this[H + Q] = U & 255; --Q >= 0 && (q *= 256); )
                  U < 0 && xe === 0 && this[H + Q + 1] !== 0 && (xe = 1),
                    (this[H + Q] = (((U / q) >> 0) - xe) & 255);
                return H + Ee;
              }),
              (s.prototype.writeInt8 = function (U, H, Ee) {
                return (
                  (U = +U),
                  (H = H >>> 0),
                  Ee || O(this, U, H, 1, 127, -128),
                  U < 0 && (U = 255 + U + 1),
                  (this[H] = U & 255),
                  H + 1
                );
              }),
              (s.prototype.writeInt16LE = function (U, H, Ee) {
                return (
                  (U = +U),
                  (H = H >>> 0),
                  Ee || O(this, U, H, 2, 32767, -32768),
                  (this[H] = U & 255),
                  (this[H + 1] = U >>> 8),
                  H + 2
                );
              }),
              (s.prototype.writeInt16BE = function (U, H, Ee) {
                return (
                  (U = +U),
                  (H = H >>> 0),
                  Ee || O(this, U, H, 2, 32767, -32768),
                  (this[H] = U >>> 8),
                  (this[H + 1] = U & 255),
                  H + 2
                );
              }),
              (s.prototype.writeInt32LE = function (U, H, Ee) {
                return (
                  (U = +U),
                  (H = H >>> 0),
                  Ee || O(this, U, H, 4, 2147483647, -2147483648),
                  (this[H] = U & 255),
                  (this[H + 1] = U >>> 8),
                  (this[H + 2] = U >>> 16),
                  (this[H + 3] = U >>> 24),
                  H + 4
                );
              }),
              (s.prototype.writeInt32BE = function (U, H, Ee) {
                return (
                  (U = +U),
                  (H = H >>> 0),
                  Ee || O(this, U, H, 4, 2147483647, -2147483648),
                  U < 0 && (U = 4294967295 + U + 1),
                  (this[H] = U >>> 24),
                  (this[H + 1] = U >>> 16),
                  (this[H + 2] = U >>> 8),
                  (this[H + 3] = U & 255),
                  H + 4
                );
              }),
              (s.prototype.writeBigInt64LE = ke(function (U, H = 0) {
                return me(
                  this,
                  U,
                  H,
                  -BigInt("0x8000000000000000"),
                  BigInt("0x7fffffffffffffff")
                );
              })),
              (s.prototype.writeBigInt64BE = ke(function (U, H = 0) {
                return N(
                  this,
                  U,
                  H,
                  -BigInt("0x8000000000000000"),
                  BigInt("0x7fffffffffffffff")
                );
              }));
            function V(_e, U, H, Ee, G, Q) {
              if (H + Ee > _e.length)
                throw new RangeError("Index out of range");
              if (H < 0) throw new RangeError("Index out of range");
            }
            function L(_e, U, H, Ee, G) {
              return (
                (U = +U),
                (H = H >>> 0),
                G ||
                  V(_e, U, H, 4, 34028234663852886e22, -34028234663852886e22),
                g.write(_e, U, H, Ee, 23, 4),
                H + 4
              );
            }
            (s.prototype.writeFloatLE = function (U, H, Ee) {
              return L(this, U, H, !0, Ee);
            }),
              (s.prototype.writeFloatBE = function (U, H, Ee) {
                return L(this, U, H, !1, Ee);
              });
            function J(_e, U, H, Ee, G) {
              return (
                (U = +U),
                (H = H >>> 0),
                G ||
                  V(_e, U, H, 8, 17976931348623157e292, -17976931348623157e292),
                g.write(_e, U, H, Ee, 52, 8),
                H + 8
              );
            }
            (s.prototype.writeDoubleLE = function (U, H, Ee) {
              return J(this, U, H, !0, Ee);
            }),
              (s.prototype.writeDoubleBE = function (U, H, Ee) {
                return J(this, U, H, !1, Ee);
              }),
              (s.prototype.copy = function (U, H, Ee, G) {
                if (!s.isBuffer(U))
                  throw new TypeError("argument should be a Buffer");
                if (
                  (Ee || (Ee = 0),
                  !G && G !== 0 && (G = this.length),
                  H >= U.length && (H = U.length),
                  H || (H = 0),
                  G > 0 && G < Ee && (G = Ee),
                  G === Ee || U.length === 0 || this.length === 0)
                )
                  return 0;
                if (H < 0) throw new RangeError("targetStart out of bounds");
                if (Ee < 0 || Ee >= this.length)
                  throw new RangeError("Index out of range");
                if (G < 0) throw new RangeError("sourceEnd out of bounds");
                G > this.length && (G = this.length),
                  U.length - H < G - Ee && (G = U.length - H + Ee);
                const Q = G - Ee;
                return (
                  this === U &&
                  typeof Uint8Array.prototype.copyWithin == "function"
                    ? this.copyWithin(H, Ee, G)
                    : Uint8Array.prototype.set.call(U, this.subarray(Ee, G), H),
                  Q
                );
              }),
              (s.prototype.fill = function (U, H, Ee, G) {
                if (typeof U == "string") {
                  if (
                    (typeof H == "string"
                      ? ((G = H), (H = 0), (Ee = this.length))
                      : typeof Ee == "string" && ((G = Ee), (Ee = this.length)),
                    G !== void 0 && typeof G != "string")
                  )
                    throw new TypeError("encoding must be a string");
                  if (typeof G == "string" && !s.isEncoding(G))
                    throw new TypeError("Unknown encoding: " + G);
                  if (U.length === 1) {
                    const q = U.charCodeAt(0);
                    ((G === "utf8" && q < 128) || G === "latin1") && (U = q);
                  }
                } else
                  typeof U == "number"
                    ? (U = U & 255)
                    : typeof U == "boolean" && (U = Number(U));
                if (H < 0 || this.length < H || this.length < Ee)
                  throw new RangeError("Out of range index");
                if (Ee <= H) return this;
                (H = H >>> 0),
                  (Ee = Ee === void 0 ? this.length : Ee >>> 0),
                  U || (U = 0);
                let Q;
                if (typeof U == "number") for (Q = H; Q < Ee; ++Q) this[Q] = U;
                else {
                  const q = s.isBuffer(U) ? U : s.from(U, G),
                    xe = q.length;
                  if (xe === 0)
                    throw new TypeError(
                      'The value "' + U + '" is invalid for argument "value"'
                    );
                  for (Q = 0; Q < Ee - H; ++Q) this[Q + H] = q[Q % xe];
                }
                return this;
              });
            const ae = {};
            function R(_e, U, H) {
              ae[_e] = class extends H {
                constructor() {
                  super(),
                    Object.defineProperty(this, "message", {
                      value: U.apply(this, arguments),
                      writable: !0,
                      configurable: !0,
                    }),
                    (this.name = `${this.name} [${_e}]`),
                    this.stack,
                    delete this.name;
                }
                get code() {
                  return _e;
                }
                set code(G) {
                  Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: G,
                    writable: !0,
                  });
                }
                toString() {
                  return `${this.name} [${_e}]: ${this.message}`;
                }
              };
            }
            R(
              "ERR_BUFFER_OUT_OF_BOUNDS",
              function (_e) {
                return _e
                  ? `${_e} is outside of buffer bounds`
                  : "Attempt to access memory outside buffer bounds";
              },
              RangeError
            ),
              R(
                "ERR_INVALID_ARG_TYPE",
                function (_e, U) {
                  return `The "${_e}" argument must be of type number. Received type ${typeof U}`;
                },
                TypeError
              ),
              R(
                "ERR_OUT_OF_RANGE",
                function (_e, U, H) {
                  let Ee = `The value of "${_e}" is out of range.`,
                    G = H;
                  return (
                    Number.isInteger(H) && Math.abs(H) > 4294967296
                      ? (G = j(String(H)))
                      : typeof H == "bigint" &&
                        ((G = String(H)),
                        (H > Cs(BigInt(2), BigInt(32)) ||
                          H < -Cs(BigInt(2), BigInt(32))) &&
                          (G = j(G)),
                        (G += "n")),
                    (Ee += ` It must be ${U}. Received ${G}`),
                    Ee
                  );
                },
                RangeError
              );
            function j(_e) {
              let U = "",
                H = _e.length;
              const Ee = _e[0] === "-" ? 1 : 0;
              for (; H >= Ee + 4; H -= 3) U = `_${_e.slice(H - 3, H)}${U}`;
              return `${_e.slice(0, H)}${U}`;
            }
            function se(_e, U, H) {
              ie(U, "offset"),
                (_e[U] === void 0 || _e[U + H] === void 0) &&
                  b(U, _e.length - (H + 1));
            }
            function ce(_e, U, H, Ee, G, Q) {
              if (_e > H || _e < U) {
                const q = typeof U == "bigint" ? "n" : "";
                let xe;
                throw (
                  (Q > 3
                    ? U === 0 || U === BigInt(0)
                      ? (xe = `>= 0${q} and < 2${q} ** ${(Q + 1) * 8}${q}`)
                      : (xe = `>= -(2${q} ** ${
                          (Q + 1) * 8 - 1
                        }${q}) and < 2 ** ${(Q + 1) * 8 - 1}${q}`)
                    : (xe = `>= ${U}${q} and <= ${H}${q}`),
                  new ae.ERR_OUT_OF_RANGE("value", xe, _e))
                );
              }
              se(Ee, G, Q);
            }
            function ie(_e, U) {
              if (typeof _e != "number")
                throw new ae.ERR_INVALID_ARG_TYPE(U, "number", _e);
            }
            function b(_e, U, H) {
              throw Math.floor(_e) !== _e
                ? (ie(_e, H),
                  new ae.ERR_OUT_OF_RANGE(H || "offset", "an integer", _e))
                : U < 0
                ? new ae.ERR_BUFFER_OUT_OF_BOUNDS()
                : new ae.ERR_OUT_OF_RANGE(
                    H || "offset",
                    `>= ${H ? 1 : 0} and <= ${U}`,
                    _e
                  );
            }
            const M = /[^+/0-9A-Za-z-_]/g;
            function F(_e) {
              if (
                ((_e = _e.split("=")[0]),
                (_e = _e.trim().replace(M, "")),
                _e.length < 2)
              )
                return "";
              for (; _e.length % 4 !== 0; ) _e = _e + "=";
              return _e;
            }
            function z(_e, U) {
              U = U || 1 / 0;
              let H;
              const Ee = _e.length;
              let G = null;
              const Q = [];
              for (let q = 0; q < Ee; ++q) {
                if (((H = _e.charCodeAt(q)), H > 55295 && H < 57344)) {
                  if (!G) {
                    if (H > 56319) {
                      (U -= 3) > -1 && Q.push(239, 191, 189);
                      continue;
                    } else if (q + 1 === Ee) {
                      (U -= 3) > -1 && Q.push(239, 191, 189);
                      continue;
                    }
                    G = H;
                    continue;
                  }
                  if (H < 56320) {
                    (U -= 3) > -1 && Q.push(239, 191, 189), (G = H);
                    continue;
                  }
                  H = (((G - 55296) << 10) | (H - 56320)) + 65536;
                } else G && (U -= 3) > -1 && Q.push(239, 191, 189);
                if (((G = null), H < 128)) {
                  if ((U -= 1) < 0) break;
                  Q.push(H);
                } else if (H < 2048) {
                  if ((U -= 2) < 0) break;
                  Q.push((H >> 6) | 192, (H & 63) | 128);
                } else if (H < 65536) {
                  if ((U -= 3) < 0) break;
                  Q.push(
                    (H >> 12) | 224,
                    ((H >> 6) & 63) | 128,
                    (H & 63) | 128
                  );
                } else if (H < 1114112) {
                  if ((U -= 4) < 0) break;
                  Q.push(
                    (H >> 18) | 240,
                    ((H >> 12) & 63) | 128,
                    ((H >> 6) & 63) | 128,
                    (H & 63) | 128
                  );
                } else throw new Error("Invalid code point");
              }
              return Q;
            }
            function oe(_e) {
              const U = [];
              for (let H = 0; H < _e.length; ++H)
                U.push(_e.charCodeAt(H) & 255);
              return U;
            }
            function de(_e, U) {
              let H, Ee, G;
              const Q = [];
              for (let q = 0; q < _e.length && !((U -= 2) < 0); ++q)
                (H = _e.charCodeAt(q)),
                  (Ee = H >> 8),
                  (G = H % 256),
                  Q.push(G),
                  Q.push(Ee);
              return Q;
            }
            function ge(_e) {
              return T.toByteArray(F(_e));
            }
            function Re(_e, U, H, Ee) {
              let G;
              for (G = 0; G < Ee && !(G + H >= U.length || G >= _e.length); ++G)
                U[G + H] = _e[G];
              return G;
            }
            function Te(_e, U) {
              return (
                _e instanceof U ||
                (_e != null &&
                  _e.constructor != null &&
                  _e.constructor.name != null &&
                  _e.constructor.name === U.name)
              );
            }
            function Ne(_e) {
              return _e !== _e;
            }
            const Le = (function () {
              const _e = "0123456789abcdef",
                U = new Array(256);
              for (let H = 0; H < 16; ++H) {
                const Ee = H * 16;
                for (let G = 0; G < 16; ++G) U[Ee + G] = _e[H] + _e[G];
              }
              return U;
            })();
            function ke(_e) {
              return typeof BigInt == "undefined" ? ht : _e;
            }
            function ht() {
              throw new Error("BigInt not supported");
            }
          },
          7187: (Se) => {
            "use strict";
            var W = typeof Reflect == "object" ? Reflect : null,
              a =
                W && typeof W.apply == "function"
                  ? W.apply
                  : function (m, E, v) {
                      return Function.prototype.apply.call(m, E, v);
                    },
              x;
            W && typeof W.ownKeys == "function"
              ? (x = W.ownKeys)
              : Object.getOwnPropertySymbols
              ? (x = function (m) {
                  return Object.getOwnPropertyNames(m).concat(
                    Object.getOwnPropertySymbols(m)
                  );
                })
              : (x = function (m) {
                  return Object.getOwnPropertyNames(m);
                });
            function T(_) {
              console && console.warn && console.warn(_);
            }
            var g =
              Number.isNaN ||
              function (m) {
                return m !== m;
              };
            function c() {
              c.init.call(this);
            }
            (Se.exports = c),
              (Se.exports.once = u),
              (c.EventEmitter = c),
              (c.prototype._events = void 0),
              (c.prototype._eventsCount = 0),
              (c.prototype._maxListeners = void 0);
            var d = 10;
            function h(_) {
              if (typeof _ != "function")
                throw new TypeError(
                  'The "listener" argument must be of type Function. Received type ' +
                    typeof _
                );
            }
            Object.defineProperty(c, "defaultMaxListeners", {
              enumerable: !0,
              get: function () {
                return d;
              },
              set: function (_) {
                if (typeof _ != "number" || _ < 0 || g(_))
                  throw new RangeError(
                    'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
                      _ +
                      "."
                  );
                d = _;
              },
            }),
              (c.init = function () {
                (this._events === void 0 ||
                  this._events === Object.getPrototypeOf(this)._events) &&
                  ((this._events = Object.create(null)),
                  (this._eventsCount = 0)),
                  (this._maxListeners = this._maxListeners || void 0);
              }),
              (c.prototype.setMaxListeners = function (m) {
                if (typeof m != "number" || m < 0 || g(m))
                  throw new RangeError(
                    'The value of "n" is out of range. It must be a non-negative number. Received ' +
                      m +
                      "."
                  );
                return (this._maxListeners = m), this;
              });
            function f(_) {
              return _._maxListeners === void 0
                ? c.defaultMaxListeners
                : _._maxListeners;
            }
            (c.prototype.getMaxListeners = function () {
              return f(this);
            }),
              (c.prototype.emit = function (m) {
                for (var E = [], v = 1; v < arguments.length; v++)
                  E.push(arguments[v]);
                var P = m === "error",
                  I = this._events;
                if (I !== void 0) P = P && I.error === void 0;
                else if (!P) return !1;
                if (P) {
                  var A;
                  if ((E.length > 0 && (A = E[0]), A instanceof Error)) throw A;
                  var B = new Error(
                    "Unhandled error." + (A ? " (" + A.message + ")" : "")
                  );
                  throw ((B.context = A), B);
                }
                var C = I[m];
                if (C === void 0) return !1;
                if (typeof C == "function") a(C, this, E);
                else
                  for (var w = C.length, k = e(C, w), v = 0; v < w; ++v)
                    a(k[v], this, E);
                return !0;
              });
            function s(_, m, E, v) {
              var P, I, A;
              if (
                (h(E),
                (I = _._events),
                I === void 0
                  ? ((I = _._events = Object.create(null)),
                    (_._eventsCount = 0))
                  : (I.newListener !== void 0 &&
                      (_.emit("newListener", m, E.listener ? E.listener : E),
                      (I = _._events)),
                    (A = I[m])),
                A === void 0)
              )
                (A = I[m] = E), ++_._eventsCount;
              else if (
                (typeof A == "function"
                  ? (A = I[m] = v ? [E, A] : [A, E])
                  : v
                  ? A.unshift(E)
                  : A.push(E),
                (P = f(_)),
                P > 0 && A.length > P && !A.warned)
              ) {
                A.warned = !0;
                var B = new Error(
                  "Possible EventEmitter memory leak detected. " +
                    A.length +
                    " " +
                    String(m) +
                    " listeners added. Use emitter.setMaxListeners() to increase limit"
                );
                (B.name = "MaxListenersExceededWarning"),
                  (B.emitter = _),
                  (B.type = m),
                  (B.count = A.length),
                  T(B);
              }
              return _;
            }
            (c.prototype.addListener = function (m, E) {
              return s(this, m, E, !1);
            }),
              (c.prototype.on = c.prototype.addListener),
              (c.prototype.prependListener = function (m, E) {
                return s(this, m, E, !0);
              });
            function l() {
              if (!this.fired)
                return (
                  this.target.removeListener(this.type, this.wrapFn),
                  (this.fired = !0),
                  arguments.length === 0
                    ? this.listener.call(this.target)
                    : this.listener.apply(this.target, arguments)
                );
            }
            function n(_, m, E) {
              var v = {
                  fired: !1,
                  wrapFn: void 0,
                  target: _,
                  type: m,
                  listener: E,
                },
                P = l.bind(v);
              return (P.listener = E), (v.wrapFn = P), P;
            }
            (c.prototype.once = function (m, E) {
              return h(E), this.on(m, n(this, m, E)), this;
            }),
              (c.prototype.prependOnceListener = function (m, E) {
                return h(E), this.prependListener(m, n(this, m, E)), this;
              }),
              (c.prototype.removeListener = function (m, E) {
                var v, P, I, A, B;
                if ((h(E), (P = this._events), P === void 0)) return this;
                if (((v = P[m]), v === void 0)) return this;
                if (v === E || v.listener === E)
                  --this._eventsCount === 0
                    ? (this._events = Object.create(null))
                    : (delete P[m],
                      P.removeListener &&
                        this.emit("removeListener", m, v.listener || E));
                else if (typeof v != "function") {
                  for (I = -1, A = v.length - 1; A >= 0; A--)
                    if (v[A] === E || v[A].listener === E) {
                      (B = v[A].listener), (I = A);
                      break;
                    }
                  if (I < 0) return this;
                  I === 0 ? v.shift() : t(v, I),
                    v.length === 1 && (P[m] = v[0]),
                    P.removeListener !== void 0 &&
                      this.emit("removeListener", m, B || E);
                }
                return this;
              }),
              (c.prototype.off = c.prototype.removeListener),
              (c.prototype.removeAllListeners = function (m) {
                var E, v, P;
                if (((v = this._events), v === void 0)) return this;
                if (v.removeListener === void 0)
                  return (
                    arguments.length === 0
                      ? ((this._events = Object.create(null)),
                        (this._eventsCount = 0))
                      : v[m] !== void 0 &&
                        (--this._eventsCount === 0
                          ? (this._events = Object.create(null))
                          : delete v[m]),
                    this
                  );
                if (arguments.length === 0) {
                  var I = Object.keys(v),
                    A;
                  for (P = 0; P < I.length; ++P)
                    (A = I[P]),
                      A !== "removeListener" && this.removeAllListeners(A);
                  return (
                    this.removeAllListeners("removeListener"),
                    (this._events = Object.create(null)),
                    (this._eventsCount = 0),
                    this
                  );
                }
                if (((E = v[m]), typeof E == "function"))
                  this.removeListener(m, E);
                else if (E !== void 0)
                  for (P = E.length - 1; P >= 0; P--)
                    this.removeListener(m, E[P]);
                return this;
              });
            function o(_, m, E) {
              var v = _._events;
              if (v === void 0) return [];
              var P = v[m];
              return P === void 0
                ? []
                : typeof P == "function"
                ? E
                  ? [P.listener || P]
                  : [P]
                : E
                ? r(P)
                : e(P, P.length);
            }
            (c.prototype.listeners = function (m) {
              return o(this, m, !0);
            }),
              (c.prototype.rawListeners = function (m) {
                return o(this, m, !1);
              }),
              (c.listenerCount = function (_, m) {
                return typeof _.listenerCount == "function"
                  ? _.listenerCount(m)
                  : i.call(_, m);
              }),
              (c.prototype.listenerCount = i);
            function i(_) {
              var m = this._events;
              if (m !== void 0) {
                var E = m[_];
                if (typeof E == "function") return 1;
                if (E !== void 0) return E.length;
              }
              return 0;
            }
            c.prototype.eventNames = function () {
              return this._eventsCount > 0 ? x(this._events) : [];
            };
            function e(_, m) {
              for (var E = new Array(m), v = 0; v < m; ++v) E[v] = _[v];
              return E;
            }
            function t(_, m) {
              for (; m + 1 < _.length; m++) _[m] = _[m + 1];
              _.pop();
            }
            function r(_) {
              for (var m = new Array(_.length), E = 0; E < m.length; ++E)
                m[E] = _[E].listener || _[E];
              return m;
            }
            function u(_, m) {
              return new Promise(function (E, v) {
                function P(A) {
                  _.removeListener(m, I), v(A);
                }
                function I() {
                  typeof _.removeListener == "function" &&
                    _.removeListener("error", P),
                    E([].slice.call(arguments));
                }
                p(_, m, I, { once: !0 }),
                  m !== "error" && y(_, P, { once: !0 });
              });
            }
            function y(_, m, E) {
              typeof _.on == "function" && p(_, "error", m, E);
            }
            function p(_, m, E, v) {
              if (typeof _.on == "function") v.once ? _.once(m, E) : _.on(m, E);
              else if (typeof _.addEventListener == "function")
                _.addEventListener(m, function P(I) {
                  v.once && _.removeEventListener(m, P), E(I);
                });
              else
                throw new TypeError(
                  'The "emitter" argument must be of type EventEmitter. Received type ' +
                    typeof _
                );
            }
          },
          1766: (Se, W, a) => {
            var x, T;
            /*!
             *  howler.js v2.2.3
             *  howlerjs.com
             *
             *  (c) 2013-2020, James Simpson of GoldFire Studios
             *  goldfirestudios.com
             *
             *  MIT License
             */ (function () {
              "use strict";
              var g = function () {
                this.init();
              };
              g.prototype = {
                init: function () {
                  var e = this || c;
                  return (
                    (e._counter = 1e3),
                    (e._html5AudioPool = []),
                    (e.html5PoolSize = 10),
                    (e._codecs = {}),
                    (e._howls = []),
                    (e._muted = !1),
                    (e._volume = 1),
                    (e._canPlayEvent = "canplaythrough"),
                    (e._navigator =
                      typeof window != "undefined" && window.navigator
                        ? window.navigator
                        : null),
                    (e.masterGain = null),
                    (e.noAudio = !1),
                    (e.usingWebAudio = !0),
                    (e.autoSuspend = !0),
                    (e.ctx = null),
                    (e.autoUnlock = !0),
                    e._setup(),
                    e
                  );
                },
                volume: function (e) {
                  var t = this || c;
                  if (
                    ((e = parseFloat(e)),
                    t.ctx || i(),
                    typeof e != "undefined" && e >= 0 && e <= 1)
                  ) {
                    if (((t._volume = e), t._muted)) return t;
                    t.usingWebAudio &&
                      t.masterGain.gain.setValueAtTime(e, c.ctx.currentTime);
                    for (var r = 0; r < t._howls.length; r++)
                      if (!t._howls[r]._webAudio)
                        for (
                          var u = t._howls[r]._getSoundIds(), y = 0;
                          y < u.length;
                          y++
                        ) {
                          var p = t._howls[r]._soundById(u[y]);
                          p && p._node && (p._node.volume = p._volume * e);
                        }
                    return t;
                  }
                  return t._volume;
                },
                mute: function (e) {
                  var t = this || c;
                  t.ctx || i(),
                    (t._muted = e),
                    t.usingWebAudio &&
                      t.masterGain.gain.setValueAtTime(
                        e ? 0 : t._volume,
                        c.ctx.currentTime
                      );
                  for (var r = 0; r < t._howls.length; r++)
                    if (!t._howls[r]._webAudio)
                      for (
                        var u = t._howls[r]._getSoundIds(), y = 0;
                        y < u.length;
                        y++
                      ) {
                        var p = t._howls[r]._soundById(u[y]);
                        p && p._node && (p._node.muted = e ? !0 : p._muted);
                      }
                  return t;
                },
                stop: function () {
                  for (var e = this || c, t = 0; t < e._howls.length; t++)
                    e._howls[t].stop();
                  return e;
                },
                unload: function () {
                  for (var e = this || c, t = e._howls.length - 1; t >= 0; t--)
                    e._howls[t].unload();
                  return (
                    e.usingWebAudio &&
                      e.ctx &&
                      typeof e.ctx.close != "undefined" &&
                      (e.ctx.close(), (e.ctx = null), i()),
                    e
                  );
                },
                codecs: function (e) {
                  return (this || c)._codecs[e.replace(/^x-/, "")];
                },
                _setup: function () {
                  var e = this || c;
                  if (
                    ((e.state = (e.ctx && e.ctx.state) || "suspended"),
                    e._autoSuspend(),
                    !e.usingWebAudio)
                  )
                    if (typeof Audio != "undefined")
                      try {
                        var t = new Audio();
                        typeof t.oncanplaythrough == "undefined" &&
                          (e._canPlayEvent = "canplay");
                      } catch (r) {
                        e.noAudio = !0;
                      }
                    else e.noAudio = !0;
                  try {
                    var t = new Audio();
                    t.muted && (e.noAudio = !0);
                  } catch (r) {}
                  return e.noAudio || e._setupCodecs(), e;
                },
                _setupCodecs: function () {
                  var e = this || c,
                    t = null;
                  try {
                    t = typeof Audio != "undefined" ? new Audio() : null;
                  } catch (v) {
                    return e;
                  }
                  if (!t || typeof t.canPlayType != "function") return e;
                  var r = t.canPlayType("audio/mpeg;").replace(/^no$/, ""),
                    u = e._navigator ? e._navigator.userAgent : "",
                    y = u.match(/OPR\/([0-6].)/g),
                    p = y && parseInt(y[0].split("/")[1], 10) < 33,
                    _ =
                      u.indexOf("Safari") !== -1 && u.indexOf("Chrome") === -1,
                    m = u.match(/Version\/(.*?) /),
                    E = _ && m && parseInt(m[1], 10) < 15;
                  return (
                    (e._codecs = {
                      mp3: !!(
                        !p &&
                        (r || t.canPlayType("audio/mp3;").replace(/^no$/, ""))
                      ),
                      mpeg: !!r,
                      opus: !!t
                        .canPlayType('audio/ogg; codecs="opus"')
                        .replace(/^no$/, ""),
                      ogg: !!t
                        .canPlayType('audio/ogg; codecs="vorbis"')
                        .replace(/^no$/, ""),
                      oga: !!t
                        .canPlayType('audio/ogg; codecs="vorbis"')
                        .replace(/^no$/, ""),
                      wav: !!(
                        t.canPlayType('audio/wav; codecs="1"') ||
                        t.canPlayType("audio/wav")
                      ).replace(/^no$/, ""),
                      aac: !!t.canPlayType("audio/aac;").replace(/^no$/, ""),
                      caf: !!t.canPlayType("audio/x-caf;").replace(/^no$/, ""),
                      m4a: !!(
                        t.canPlayType("audio/x-m4a;") ||
                        t.canPlayType("audio/m4a;") ||
                        t.canPlayType("audio/aac;")
                      ).replace(/^no$/, ""),
                      m4b: !!(
                        t.canPlayType("audio/x-m4b;") ||
                        t.canPlayType("audio/m4b;") ||
                        t.canPlayType("audio/aac;")
                      ).replace(/^no$/, ""),
                      mp4: !!(
                        t.canPlayType("audio/x-mp4;") ||
                        t.canPlayType("audio/mp4;") ||
                        t.canPlayType("audio/aac;")
                      ).replace(/^no$/, ""),
                      weba: !!(
                        !E &&
                        t
                          .canPlayType('audio/webm; codecs="vorbis"')
                          .replace(/^no$/, "")
                      ),
                      webm: !!(
                        !E &&
                        t
                          .canPlayType('audio/webm; codecs="vorbis"')
                          .replace(/^no$/, "")
                      ),
                      dolby: !!t
                        .canPlayType('audio/mp4; codecs="ec-3"')
                        .replace(/^no$/, ""),
                      flac: !!(
                        t.canPlayType("audio/x-flac;") ||
                        t.canPlayType("audio/flac;")
                      ).replace(/^no$/, ""),
                    }),
                    e
                  );
                },
                _unlockAudio: function () {
                  var e = this || c;
                  if (!(e._audioUnlocked || !e.ctx)) {
                    (e._audioUnlocked = !1),
                      (e.autoUnlock = !1),
                      !e._mobileUnloaded &&
                        e.ctx.sampleRate !== 44100 &&
                        ((e._mobileUnloaded = !0), e.unload()),
                      (e._scratchBuffer = e.ctx.createBuffer(1, 1, 22050));
                    var t = function (r) {
                      for (; e._html5AudioPool.length < e.html5PoolSize; )
                        try {
                          var u = new Audio();
                          (u._unlocked = !0), e._releaseHtml5Audio(u);
                        } catch (v) {
                          e.noAudio = !0;
                          break;
                        }
                      for (var y = 0; y < e._howls.length; y++)
                        if (!e._howls[y]._webAudio)
                          for (
                            var p = e._howls[y]._getSoundIds(), _ = 0;
                            _ < p.length;
                            _++
                          ) {
                            var m = e._howls[y]._soundById(p[_]);
                            m &&
                              m._node &&
                              !m._node._unlocked &&
                              ((m._node._unlocked = !0), m._node.load());
                          }
                      e._autoResume();
                      var E = e.ctx.createBufferSource();
                      (E.buffer = e._scratchBuffer),
                        E.connect(e.ctx.destination),
                        typeof E.start == "undefined"
                          ? E.noteOn(0)
                          : E.start(0),
                        typeof e.ctx.resume == "function" && e.ctx.resume(),
                        (E.onended = function () {
                          E.disconnect(0),
                            (e._audioUnlocked = !0),
                            document.removeEventListener("touchstart", t, !0),
                            document.removeEventListener("touchend", t, !0),
                            document.removeEventListener("click", t, !0),
                            document.removeEventListener("keydown", t, !0);
                          for (var v = 0; v < e._howls.length; v++)
                            e._howls[v]._emit("unlock");
                        });
                    };
                    return (
                      document.addEventListener("touchstart", t, !0),
                      document.addEventListener("touchend", t, !0),
                      document.addEventListener("click", t, !0),
                      document.addEventListener("keydown", t, !0),
                      e
                    );
                  }
                },
                _obtainHtml5Audio: function () {
                  var e = this || c;
                  if (e._html5AudioPool.length) return e._html5AudioPool.pop();
                  var t = new Audio().play();
                  return (
                    t &&
                      typeof Promise != "undefined" &&
                      (t instanceof Promise || typeof t.then == "function") &&
                      t.catch(function () {
                        console.warn(
                          "HTML5 Audio pool exhausted, returning potentially locked audio object."
                        );
                      }),
                    new Audio()
                  );
                },
                _releaseHtml5Audio: function (e) {
                  var t = this || c;
                  return e._unlocked && t._html5AudioPool.push(e), t;
                },
                _autoSuspend: function () {
                  var e = this;
                  if (
                    !(
                      !e.autoSuspend ||
                      !e.ctx ||
                      typeof e.ctx.suspend == "undefined" ||
                      !c.usingWebAudio
                    )
                  ) {
                    for (var t = 0; t < e._howls.length; t++)
                      if (e._howls[t]._webAudio) {
                        for (var r = 0; r < e._howls[t]._sounds.length; r++)
                          if (!e._howls[t]._sounds[r]._paused) return e;
                      }
                    return (
                      e._suspendTimer && clearTimeout(e._suspendTimer),
                      (e._suspendTimer = setTimeout(function () {
                        if (e.autoSuspend) {
                          (e._suspendTimer = null), (e.state = "suspending");
                          var u = function () {
                            (e.state = "suspended"),
                              e._resumeAfterSuspend &&
                                (delete e._resumeAfterSuspend, e._autoResume());
                          };
                          e.ctx.suspend().then(u, u);
                        }
                      }, 3e4)),
                      e
                    );
                  }
                },
                _autoResume: function () {
                  var e = this;
                  if (
                    !(
                      !e.ctx ||
                      typeof e.ctx.resume == "undefined" ||
                      !c.usingWebAudio
                    )
                  )
                    return (
                      e.state === "running" &&
                      e.ctx.state !== "interrupted" &&
                      e._suspendTimer
                        ? (clearTimeout(e._suspendTimer),
                          (e._suspendTimer = null))
                        : e.state === "suspended" ||
                          (e.state === "running" &&
                            e.ctx.state === "interrupted")
                        ? (e.ctx.resume().then(function () {
                            e.state = "running";
                            for (var t = 0; t < e._howls.length; t++)
                              e._howls[t]._emit("resume");
                          }),
                          e._suspendTimer &&
                            (clearTimeout(e._suspendTimer),
                            (e._suspendTimer = null)))
                        : e.state === "suspending" &&
                          (e._resumeAfterSuspend = !0),
                      e
                    );
                },
              };
              var c = new g(),
                d = function (e) {
                  var t = this;
                  if (!e.src || e.src.length === 0) {
                    console.error(
                      "An array of source files must be passed with any new Howl."
                    );
                    return;
                  }
                  t.init(e);
                };
              d.prototype = {
                init: function (e) {
                  var t = this;
                  return (
                    c.ctx || i(),
                    (t._autoplay = e.autoplay || !1),
                    (t._format =
                      typeof e.format != "string" ? e.format : [e.format]),
                    (t._html5 = e.html5 || !1),
                    (t._muted = e.mute || !1),
                    (t._loop = e.loop || !1),
                    (t._pool = e.pool || 5),
                    (t._preload =
                      typeof e.preload == "boolean" || e.preload === "metadata"
                        ? e.preload
                        : !0),
                    (t._rate = e.rate || 1),
                    (t._sprite = e.sprite || {}),
                    (t._src = typeof e.src != "string" ? e.src : [e.src]),
                    (t._volume = e.volume !== void 0 ? e.volume : 1),
                    (t._xhr = {
                      method: e.xhr && e.xhr.method ? e.xhr.method : "GET",
                      headers: e.xhr && e.xhr.headers ? e.xhr.headers : null,
                      withCredentials:
                        e.xhr && e.xhr.withCredentials
                          ? e.xhr.withCredentials
                          : !1,
                    }),
                    (t._duration = 0),
                    (t._state = "unloaded"),
                    (t._sounds = []),
                    (t._endTimers = {}),
                    (t._queue = []),
                    (t._playLock = !1),
                    (t._onend = e.onend ? [{ fn: e.onend }] : []),
                    (t._onfade = e.onfade ? [{ fn: e.onfade }] : []),
                    (t._onload = e.onload ? [{ fn: e.onload }] : []),
                    (t._onloaderror = e.onloaderror
                      ? [{ fn: e.onloaderror }]
                      : []),
                    (t._onplayerror = e.onplayerror
                      ? [{ fn: e.onplayerror }]
                      : []),
                    (t._onpause = e.onpause ? [{ fn: e.onpause }] : []),
                    (t._onplay = e.onplay ? [{ fn: e.onplay }] : []),
                    (t._onstop = e.onstop ? [{ fn: e.onstop }] : []),
                    (t._onmute = e.onmute ? [{ fn: e.onmute }] : []),
                    (t._onvolume = e.onvolume ? [{ fn: e.onvolume }] : []),
                    (t._onrate = e.onrate ? [{ fn: e.onrate }] : []),
                    (t._onseek = e.onseek ? [{ fn: e.onseek }] : []),
                    (t._onunlock = e.onunlock ? [{ fn: e.onunlock }] : []),
                    (t._onresume = []),
                    (t._webAudio = c.usingWebAudio && !t._html5),
                    typeof c.ctx != "undefined" &&
                      c.ctx &&
                      c.autoUnlock &&
                      c._unlockAudio(),
                    c._howls.push(t),
                    t._autoplay &&
                      t._queue.push({
                        event: "play",
                        action: function () {
                          t.play();
                        },
                      }),
                    t._preload && t._preload !== "none" && t.load(),
                    t
                  );
                },
                load: function () {
                  var e = this,
                    t = null;
                  if (c.noAudio) {
                    e._emit("loaderror", null, "No audio support.");
                    return;
                  }
                  typeof e._src == "string" && (e._src = [e._src]);
                  for (var r = 0; r < e._src.length; r++) {
                    var u, y;
                    if (e._format && e._format[r]) u = e._format[r];
                    else {
                      if (((y = e._src[r]), typeof y != "string")) {
                        e._emit(
                          "loaderror",
                          null,
                          "Non-string found in selected audio sources - ignoring."
                        );
                        continue;
                      }
                      (u = /^data:audio\/([^;,]+);/i.exec(y)),
                        u || (u = /\.([^.]+)$/.exec(y.split("?", 1)[0])),
                        u && (u = u[1].toLowerCase());
                    }
                    if (
                      (u ||
                        console.warn(
                          'No file extension was found. Consider using the "format" property or specify an extension.'
                        ),
                      u && c.codecs(u))
                    ) {
                      t = e._src[r];
                      break;
                    }
                  }
                  if (!t) {
                    e._emit(
                      "loaderror",
                      null,
                      "No codec support for selected audio sources."
                    );
                    return;
                  }
                  return (
                    (e._src = t),
                    (e._state = "loading"),
                    window.location.protocol === "https:" &&
                      t.slice(0, 5) === "http:" &&
                      ((e._html5 = !0), (e._webAudio = !1)),
                    new h(e),
                    e._webAudio && s(e),
                    e
                  );
                },
                play: function (e, t) {
                  var r = this,
                    u = null;
                  if (typeof e == "number") (u = e), (e = null);
                  else {
                    if (
                      typeof e == "string" &&
                      r._state === "loaded" &&
                      !r._sprite[e]
                    )
                      return null;
                    if (
                      typeof e == "undefined" &&
                      ((e = "__default"), !r._playLock)
                    ) {
                      for (var y = 0, p = 0; p < r._sounds.length; p++)
                        r._sounds[p]._paused &&
                          !r._sounds[p]._ended &&
                          (y++, (u = r._sounds[p]._id));
                      y === 1 ? (e = null) : (u = null);
                    }
                  }
                  var _ = u ? r._soundById(u) : r._inactiveSound();
                  if (!_) return null;
                  if (
                    (u && !e && (e = _._sprite || "__default"),
                    r._state !== "loaded")
                  ) {
                    (_._sprite = e), (_._ended = !1);
                    var m = _._id;
                    return (
                      r._queue.push({
                        event: "play",
                        action: function () {
                          r.play(m);
                        },
                      }),
                      m
                    );
                  }
                  if (u && !_._paused) return t || r._loadQueue("play"), _._id;
                  r._webAudio && c._autoResume();
                  var E = Math.max(
                      0,
                      _._seek > 0 ? _._seek : r._sprite[e][0] / 1e3
                    ),
                    v = Math.max(
                      0,
                      (r._sprite[e][0] + r._sprite[e][1]) / 1e3 - E
                    ),
                    P = (v * 1e3) / Math.abs(_._rate),
                    I = r._sprite[e][0] / 1e3,
                    A = (r._sprite[e][0] + r._sprite[e][1]) / 1e3;
                  (_._sprite = e), (_._ended = !1);
                  var B = function () {
                    (_._paused = !1),
                      (_._seek = E),
                      (_._start = I),
                      (_._stop = A),
                      (_._loop = !!(_._loop || r._sprite[e][2]));
                  };
                  if (E >= A) {
                    r._ended(_);
                    return;
                  }
                  var C = _._node;
                  if (r._webAudio) {
                    var w = function () {
                      (r._playLock = !1), B(), r._refreshBuffer(_);
                      var X = _._muted || r._muted ? 0 : _._volume;
                      C.gain.setValueAtTime(X, c.ctx.currentTime),
                        (_._playStart = c.ctx.currentTime),
                        typeof C.bufferSource.start == "undefined"
                          ? _._loop
                            ? C.bufferSource.noteGrainOn(0, E, 86400)
                            : C.bufferSource.noteGrainOn(0, E, v)
                          : _._loop
                          ? C.bufferSource.start(0, E, 86400)
                          : C.bufferSource.start(0, E, v),
                        P !== 1 / 0 &&
                          (r._endTimers[_._id] = setTimeout(
                            r._ended.bind(r, _),
                            P
                          )),
                        t ||
                          setTimeout(function () {
                            r._emit("play", _._id), r._loadQueue();
                          }, 0);
                    };
                    c.state === "running" && c.ctx.state !== "interrupted"
                      ? w()
                      : ((r._playLock = !0),
                        r.once("resume", w),
                        r._clearTimer(_._id));
                  } else {
                    var k = function () {
                      (C.currentTime = E),
                        (C.muted = _._muted || r._muted || c._muted || C.muted),
                        (C.volume = _._volume * c.volume()),
                        (C.playbackRate = _._rate);
                      try {
                        var X = C.play();
                        if (
                          (X &&
                          typeof Promise != "undefined" &&
                          (X instanceof Promise || typeof X.then == "function")
                            ? ((r._playLock = !0),
                              B(),
                              X.then(function () {
                                (r._playLock = !1),
                                  (C._unlocked = !0),
                                  t ? r._loadQueue() : r._emit("play", _._id);
                              }).catch(function () {
                                (r._playLock = !1),
                                  r._emit(
                                    "playerror",
                                    _._id,
                                    "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."
                                  ),
                                  (_._ended = !0),
                                  (_._paused = !0);
                              }))
                            : t ||
                              ((r._playLock = !1), B(), r._emit("play", _._id)),
                          (C.playbackRate = _._rate),
                          C.paused)
                        ) {
                          r._emit(
                            "playerror",
                            _._id,
                            "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."
                          );
                          return;
                        }
                        e !== "__default" || _._loop
                          ? (r._endTimers[_._id] = setTimeout(
                              r._ended.bind(r, _),
                              P
                            ))
                          : ((r._endTimers[_._id] = function () {
                              r._ended(_),
                                C.removeEventListener(
                                  "ended",
                                  r._endTimers[_._id],
                                  !1
                                );
                            }),
                            C.addEventListener(
                              "ended",
                              r._endTimers[_._id],
                              !1
                            ));
                      } catch ($) {
                        r._emit("playerror", _._id, $);
                      }
                    };
                    C.src ===
                      "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" &&
                      ((C.src = r._src), C.load());
                    var K =
                      (window && window.ejecta) ||
                      (!C.readyState && c._navigator.isCocoonJS);
                    if (C.readyState >= 3 || K) k();
                    else {
                      (r._playLock = !0), (r._state = "loading");
                      var te = function () {
                        (r._state = "loaded"),
                          k(),
                          C.removeEventListener(c._canPlayEvent, te, !1);
                      };
                      C.addEventListener(c._canPlayEvent, te, !1),
                        r._clearTimer(_._id);
                    }
                  }
                  return _._id;
                },
                pause: function (e) {
                  var t = this;
                  if (t._state !== "loaded" || t._playLock)
                    return (
                      t._queue.push({
                        event: "pause",
                        action: function () {
                          t.pause(e);
                        },
                      }),
                      t
                    );
                  for (var r = t._getSoundIds(e), u = 0; u < r.length; u++) {
                    t._clearTimer(r[u]);
                    var y = t._soundById(r[u]);
                    if (
                      y &&
                      !y._paused &&
                      ((y._seek = t.seek(r[u])),
                      (y._rateSeek = 0),
                      (y._paused = !0),
                      t._stopFade(r[u]),
                      y._node)
                    )
                      if (t._webAudio) {
                        if (!y._node.bufferSource) continue;
                        typeof y._node.bufferSource.stop == "undefined"
                          ? y._node.bufferSource.noteOff(0)
                          : y._node.bufferSource.stop(0),
                          t._cleanBuffer(y._node);
                      } else
                        (!isNaN(y._node.duration) ||
                          y._node.duration === 1 / 0) &&
                          y._node.pause();
                    arguments[1] || t._emit("pause", y ? y._id : null);
                  }
                  return t;
                },
                stop: function (e, t) {
                  var r = this;
                  if (r._state !== "loaded" || r._playLock)
                    return (
                      r._queue.push({
                        event: "stop",
                        action: function () {
                          r.stop(e);
                        },
                      }),
                      r
                    );
                  for (var u = r._getSoundIds(e), y = 0; y < u.length; y++) {
                    r._clearTimer(u[y]);
                    var p = r._soundById(u[y]);
                    p &&
                      ((p._seek = p._start || 0),
                      (p._rateSeek = 0),
                      (p._paused = !0),
                      (p._ended = !0),
                      r._stopFade(u[y]),
                      p._node &&
                        (r._webAudio
                          ? p._node.bufferSource &&
                            (typeof p._node.bufferSource.stop == "undefined"
                              ? p._node.bufferSource.noteOff(0)
                              : p._node.bufferSource.stop(0),
                            r._cleanBuffer(p._node))
                          : (!isNaN(p._node.duration) ||
                              p._node.duration === 1 / 0) &&
                            ((p._node.currentTime = p._start || 0),
                            p._node.pause(),
                            p._node.duration === 1 / 0 &&
                              r._clearSound(p._node))),
                      t || r._emit("stop", p._id));
                  }
                  return r;
                },
                mute: function (e, t) {
                  var r = this;
                  if (r._state !== "loaded" || r._playLock)
                    return (
                      r._queue.push({
                        event: "mute",
                        action: function () {
                          r.mute(e, t);
                        },
                      }),
                      r
                    );
                  if (typeof t == "undefined")
                    if (typeof e == "boolean") r._muted = e;
                    else return r._muted;
                  for (var u = r._getSoundIds(t), y = 0; y < u.length; y++) {
                    var p = r._soundById(u[y]);
                    p &&
                      ((p._muted = e),
                      p._interval && r._stopFade(p._id),
                      r._webAudio && p._node
                        ? p._node.gain.setValueAtTime(
                            e ? 0 : p._volume,
                            c.ctx.currentTime
                          )
                        : p._node && (p._node.muted = c._muted ? !0 : e),
                      r._emit("mute", p._id));
                  }
                  return r;
                },
                volume: function () {
                  var e = this,
                    t = arguments,
                    r,
                    u;
                  if (t.length === 0) return e._volume;
                  if (
                    t.length === 1 ||
                    (t.length === 2 && typeof t[1] == "undefined")
                  ) {
                    var y = e._getSoundIds(),
                      p = y.indexOf(t[0]);
                    p >= 0 ? (u = parseInt(t[0], 10)) : (r = parseFloat(t[0]));
                  } else
                    t.length >= 2 &&
                      ((r = parseFloat(t[0])), (u = parseInt(t[1], 10)));
                  var _;
                  if (typeof r != "undefined" && r >= 0 && r <= 1) {
                    if (e._state !== "loaded" || e._playLock)
                      return (
                        e._queue.push({
                          event: "volume",
                          action: function () {
                            e.volume.apply(e, t);
                          },
                        }),
                        e
                      );
                    typeof u == "undefined" && (e._volume = r),
                      (u = e._getSoundIds(u));
                    for (var m = 0; m < u.length; m++)
                      (_ = e._soundById(u[m])),
                        _ &&
                          ((_._volume = r),
                          t[2] || e._stopFade(u[m]),
                          e._webAudio && _._node && !_._muted
                            ? _._node.gain.setValueAtTime(r, c.ctx.currentTime)
                            : _._node &&
                              !_._muted &&
                              (_._node.volume = r * c.volume()),
                          e._emit("volume", _._id));
                  } else
                    return (
                      (_ = u ? e._soundById(u) : e._sounds[0]),
                      _ ? _._volume : 0
                    );
                  return e;
                },
                fade: function (e, t, r, u) {
                  var y = this;
                  if (y._state !== "loaded" || y._playLock)
                    return (
                      y._queue.push({
                        event: "fade",
                        action: function () {
                          y.fade(e, t, r, u);
                        },
                      }),
                      y
                    );
                  (e = Math.min(Math.max(0, parseFloat(e)), 1)),
                    (t = Math.min(Math.max(0, parseFloat(t)), 1)),
                    (r = parseFloat(r)),
                    y.volume(e, u);
                  for (var p = y._getSoundIds(u), _ = 0; _ < p.length; _++) {
                    var m = y._soundById(p[_]);
                    if (m) {
                      if ((u || y._stopFade(p[_]), y._webAudio && !m._muted)) {
                        var E = c.ctx.currentTime,
                          v = E + r / 1e3;
                        (m._volume = e),
                          m._node.gain.setValueAtTime(e, E),
                          m._node.gain.linearRampToValueAtTime(t, v);
                      }
                      y._startFadeInterval(
                        m,
                        e,
                        t,
                        r,
                        p[_],
                        typeof u == "undefined"
                      );
                    }
                  }
                  return y;
                },
                _startFadeInterval: function (e, t, r, u, y, p) {
                  var _ = this,
                    m = t,
                    E = r - t,
                    v = Math.abs(E / 0.01),
                    P = Math.max(4, v > 0 ? u / v : u),
                    I = Date.now();
                  (e._fadeTo = r),
                    (e._interval = setInterval(function () {
                      var A = (Date.now() - I) / u;
                      (I = Date.now()),
                        (m += E * A),
                        (m = Math.round(m * 100) / 100),
                        E < 0 ? (m = Math.max(r, m)) : (m = Math.min(r, m)),
                        _._webAudio ? (e._volume = m) : _.volume(m, e._id, !0),
                        p && (_._volume = m),
                        ((r < t && m <= r) || (r > t && m >= r)) &&
                          (clearInterval(e._interval),
                          (e._interval = null),
                          (e._fadeTo = null),
                          _.volume(r, e._id),
                          _._emit("fade", e._id));
                    }, P));
                },
                _stopFade: function (e) {
                  var t = this,
                    r = t._soundById(e);
                  return (
                    r &&
                      r._interval &&
                      (t._webAudio &&
                        r._node.gain.cancelScheduledValues(c.ctx.currentTime),
                      clearInterval(r._interval),
                      (r._interval = null),
                      t.volume(r._fadeTo, e),
                      (r._fadeTo = null),
                      t._emit("fade", e)),
                    t
                  );
                },
                loop: function () {
                  var e = this,
                    t = arguments,
                    r,
                    u,
                    y;
                  if (t.length === 0) return e._loop;
                  if (t.length === 1)
                    if (typeof t[0] == "boolean") (r = t[0]), (e._loop = r);
                    else
                      return (
                        (y = e._soundById(parseInt(t[0], 10))), y ? y._loop : !1
                      );
                  else t.length === 2 && ((r = t[0]), (u = parseInt(t[1], 10)));
                  for (var p = e._getSoundIds(u), _ = 0; _ < p.length; _++)
                    (y = e._soundById(p[_])),
                      y &&
                        ((y._loop = r),
                        e._webAudio &&
                          y._node &&
                          y._node.bufferSource &&
                          ((y._node.bufferSource.loop = r),
                          r &&
                            ((y._node.bufferSource.loopStart = y._start || 0),
                            (y._node.bufferSource.loopEnd = y._stop),
                            e.playing(p[_]) &&
                              (e.pause(p[_], !0), e.play(p[_], !0)))));
                  return e;
                },
                rate: function () {
                  var e = this,
                    t = arguments,
                    r,
                    u;
                  if (t.length === 0) u = e._sounds[0]._id;
                  else if (t.length === 1) {
                    var y = e._getSoundIds(),
                      p = y.indexOf(t[0]);
                    p >= 0 ? (u = parseInt(t[0], 10)) : (r = parseFloat(t[0]));
                  } else
                    t.length === 2 &&
                      ((r = parseFloat(t[0])), (u = parseInt(t[1], 10)));
                  var _;
                  if (typeof r == "number") {
                    if (e._state !== "loaded" || e._playLock)
                      return (
                        e._queue.push({
                          event: "rate",
                          action: function () {
                            e.rate.apply(e, t);
                          },
                        }),
                        e
                      );
                    typeof u == "undefined" && (e._rate = r),
                      (u = e._getSoundIds(u));
                    for (var m = 0; m < u.length; m++)
                      if (((_ = e._soundById(u[m])), _)) {
                        e.playing(u[m]) &&
                          ((_._rateSeek = e.seek(u[m])),
                          (_._playStart = e._webAudio
                            ? c.ctx.currentTime
                            : _._playStart)),
                          (_._rate = r),
                          e._webAudio && _._node && _._node.bufferSource
                            ? _._node.bufferSource.playbackRate.setValueAtTime(
                                r,
                                c.ctx.currentTime
                              )
                            : _._node && (_._node.playbackRate = r);
                        var E = e.seek(u[m]),
                          v =
                            (e._sprite[_._sprite][0] +
                              e._sprite[_._sprite][1]) /
                              1e3 -
                            E,
                          P = (v * 1e3) / Math.abs(_._rate);
                        (e._endTimers[u[m]] || !_._paused) &&
                          (e._clearTimer(u[m]),
                          (e._endTimers[u[m]] = setTimeout(
                            e._ended.bind(e, _),
                            P
                          ))),
                          e._emit("rate", _._id);
                      }
                  } else return (_ = e._soundById(u)), _ ? _._rate : e._rate;
                  return e;
                },
                seek: function () {
                  var e = this,
                    t = arguments,
                    r,
                    u;
                  if (t.length === 0)
                    e._sounds.length && (u = e._sounds[0]._id);
                  else if (t.length === 1) {
                    var y = e._getSoundIds(),
                      p = y.indexOf(t[0]);
                    p >= 0
                      ? (u = parseInt(t[0], 10))
                      : e._sounds.length &&
                        ((u = e._sounds[0]._id), (r = parseFloat(t[0])));
                  } else
                    t.length === 2 &&
                      ((r = parseFloat(t[0])), (u = parseInt(t[1], 10)));
                  if (typeof u == "undefined") return 0;
                  if (
                    typeof r == "number" &&
                    (e._state !== "loaded" || e._playLock)
                  )
                    return (
                      e._queue.push({
                        event: "seek",
                        action: function () {
                          e.seek.apply(e, t);
                        },
                      }),
                      e
                    );
                  var _ = e._soundById(u);
                  if (_)
                    if (typeof r == "number" && r >= 0) {
                      var m = e.playing(u);
                      m && e.pause(u, !0),
                        (_._seek = r),
                        (_._ended = !1),
                        e._clearTimer(u),
                        !e._webAudio &&
                          _._node &&
                          !isNaN(_._node.duration) &&
                          (_._node.currentTime = r);
                      var E = function () {
                        m && e.play(u, !0), e._emit("seek", u);
                      };
                      if (m && !e._webAudio) {
                        var v = function () {
                          e._playLock ? setTimeout(v, 0) : E();
                        };
                        setTimeout(v, 0);
                      } else E();
                    } else if (e._webAudio) {
                      var P = e.playing(u)
                          ? c.ctx.currentTime - _._playStart
                          : 0,
                        I = _._rateSeek ? _._rateSeek - _._seek : 0;
                      return _._seek + (I + P * Math.abs(_._rate));
                    } else return _._node.currentTime;
                  return e;
                },
                playing: function (e) {
                  var t = this;
                  if (typeof e == "number") {
                    var r = t._soundById(e);
                    return r ? !r._paused : !1;
                  }
                  for (var u = 0; u < t._sounds.length; u++)
                    if (!t._sounds[u]._paused) return !0;
                  return !1;
                },
                duration: function (e) {
                  var t = this,
                    r = t._duration,
                    u = t._soundById(e);
                  return u && (r = t._sprite[u._sprite][1] / 1e3), r;
                },
                state: function () {
                  return this._state;
                },
                unload: function () {
                  for (var e = this, t = e._sounds, r = 0; r < t.length; r++)
                    t[r]._paused || e.stop(t[r]._id),
                      e._webAudio ||
                        (e._clearSound(t[r]._node),
                        t[r]._node.removeEventListener(
                          "error",
                          t[r]._errorFn,
                          !1
                        ),
                        t[r]._node.removeEventListener(
                          c._canPlayEvent,
                          t[r]._loadFn,
                          !1
                        ),
                        t[r]._node.removeEventListener(
                          "ended",
                          t[r]._endFn,
                          !1
                        ),
                        c._releaseHtml5Audio(t[r]._node)),
                      delete t[r]._node,
                      e._clearTimer(t[r]._id);
                  var u = c._howls.indexOf(e);
                  u >= 0 && c._howls.splice(u, 1);
                  var y = !0;
                  for (r = 0; r < c._howls.length; r++)
                    if (
                      c._howls[r]._src === e._src ||
                      e._src.indexOf(c._howls[r]._src) >= 0
                    ) {
                      y = !1;
                      break;
                    }
                  return (
                    f && y && delete f[e._src],
                    (c.noAudio = !1),
                    (e._state = "unloaded"),
                    (e._sounds = []),
                    (e = null),
                    null
                  );
                },
                on: function (e, t, r, u) {
                  var y = this,
                    p = y["_on" + e];
                  return (
                    typeof t == "function" &&
                      p.push(u ? { id: r, fn: t, once: u } : { id: r, fn: t }),
                    y
                  );
                },
                off: function (e, t, r) {
                  var u = this,
                    y = u["_on" + e],
                    p = 0;
                  if ((typeof t == "number" && ((r = t), (t = null)), t || r))
                    for (p = 0; p < y.length; p++) {
                      var _ = r === y[p].id;
                      if ((t === y[p].fn && _) || (!t && _)) {
                        y.splice(p, 1);
                        break;
                      }
                    }
                  else if (e) u["_on" + e] = [];
                  else {
                    var m = Object.keys(u);
                    for (p = 0; p < m.length; p++)
                      m[p].indexOf("_on") === 0 &&
                        Array.isArray(u[m[p]]) &&
                        (u[m[p]] = []);
                  }
                  return u;
                },
                once: function (e, t, r) {
                  var u = this;
                  return u.on(e, t, r, 1), u;
                },
                _emit: function (e, t, r) {
                  for (
                    var u = this, y = u["_on" + e], p = y.length - 1;
                    p >= 0;
                    p--
                  )
                    (!y[p].id || y[p].id === t || e === "load") &&
                      (setTimeout(
                        function (_) {
                          _.call(this, t, r);
                        }.bind(u, y[p].fn),
                        0
                      ),
                      y[p].once && u.off(e, y[p].fn, y[p].id));
                  return u._loadQueue(e), u;
                },
                _loadQueue: function (e) {
                  var t = this;
                  if (t._queue.length > 0) {
                    var r = t._queue[0];
                    r.event === e && (t._queue.shift(), t._loadQueue()),
                      e || r.action();
                  }
                  return t;
                },
                _ended: function (e) {
                  var t = this,
                    r = e._sprite;
                  if (
                    !t._webAudio &&
                    e._node &&
                    !e._node.paused &&
                    !e._node.ended &&
                    e._node.currentTime < e._stop
                  )
                    return setTimeout(t._ended.bind(t, e), 100), t;
                  var u = !!(e._loop || t._sprite[r][2]);
                  if (
                    (t._emit("end", e._id),
                    !t._webAudio && u && t.stop(e._id, !0).play(e._id),
                    t._webAudio && u)
                  ) {
                    t._emit("play", e._id),
                      (e._seek = e._start || 0),
                      (e._rateSeek = 0),
                      (e._playStart = c.ctx.currentTime);
                    var y = ((e._stop - e._start) * 1e3) / Math.abs(e._rate);
                    t._endTimers[e._id] = setTimeout(t._ended.bind(t, e), y);
                  }
                  return (
                    t._webAudio &&
                      !u &&
                      ((e._paused = !0),
                      (e._ended = !0),
                      (e._seek = e._start || 0),
                      (e._rateSeek = 0),
                      t._clearTimer(e._id),
                      t._cleanBuffer(e._node),
                      c._autoSuspend()),
                    !t._webAudio && !u && t.stop(e._id, !0),
                    t
                  );
                },
                _clearTimer: function (e) {
                  var t = this;
                  if (t._endTimers[e]) {
                    if (typeof t._endTimers[e] != "function")
                      clearTimeout(t._endTimers[e]);
                    else {
                      var r = t._soundById(e);
                      r &&
                        r._node &&
                        r._node.removeEventListener(
                          "ended",
                          t._endTimers[e],
                          !1
                        );
                    }
                    delete t._endTimers[e];
                  }
                  return t;
                },
                _soundById: function (e) {
                  for (var t = this, r = 0; r < t._sounds.length; r++)
                    if (e === t._sounds[r]._id) return t._sounds[r];
                  return null;
                },
                _inactiveSound: function () {
                  var e = this;
                  e._drain();
                  for (var t = 0; t < e._sounds.length; t++)
                    if (e._sounds[t]._ended) return e._sounds[t].reset();
                  return new h(e);
                },
                _drain: function () {
                  var e = this,
                    t = e._pool,
                    r = 0,
                    u = 0;
                  if (!(e._sounds.length < t)) {
                    for (u = 0; u < e._sounds.length; u++)
                      e._sounds[u]._ended && r++;
                    for (u = e._sounds.length - 1; u >= 0; u--) {
                      if (r <= t) return;
                      e._sounds[u]._ended &&
                        (e._webAudio &&
                          e._sounds[u]._node &&
                          e._sounds[u]._node.disconnect(0),
                        e._sounds.splice(u, 1),
                        r--);
                    }
                  }
                },
                _getSoundIds: function (e) {
                  var t = this;
                  if (typeof e == "undefined") {
                    for (var r = [], u = 0; u < t._sounds.length; u++)
                      r.push(t._sounds[u]._id);
                    return r;
                  } else return [e];
                },
                _refreshBuffer: function (e) {
                  var t = this;
                  return (
                    (e._node.bufferSource = c.ctx.createBufferSource()),
                    (e._node.bufferSource.buffer = f[t._src]),
                    e._panner
                      ? e._node.bufferSource.connect(e._panner)
                      : e._node.bufferSource.connect(e._node),
                    (e._node.bufferSource.loop = e._loop),
                    e._loop &&
                      ((e._node.bufferSource.loopStart = e._start || 0),
                      (e._node.bufferSource.loopEnd = e._stop || 0)),
                    e._node.bufferSource.playbackRate.setValueAtTime(
                      e._rate,
                      c.ctx.currentTime
                    ),
                    t
                  );
                },
                _cleanBuffer: function (e) {
                  var t = this,
                    r =
                      c._navigator && c._navigator.vendor.indexOf("Apple") >= 0;
                  if (
                    c._scratchBuffer &&
                    e.bufferSource &&
                    ((e.bufferSource.onended = null),
                    e.bufferSource.disconnect(0),
                    r)
                  )
                    try {
                      e.bufferSource.buffer = c._scratchBuffer;
                    } catch (u) {}
                  return (e.bufferSource = null), t;
                },
                _clearSound: function (e) {
                  var t = /MSIE |Trident\//.test(
                    c._navigator && c._navigator.userAgent
                  );
                  t ||
                    (e.src =
                      "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA");
                },
              };
              var h = function (e) {
                (this._parent = e), this.init();
              };
              h.prototype = {
                init: function () {
                  var e = this,
                    t = e._parent;
                  return (
                    (e._muted = t._muted),
                    (e._loop = t._loop),
                    (e._volume = t._volume),
                    (e._rate = t._rate),
                    (e._seek = 0),
                    (e._paused = !0),
                    (e._ended = !0),
                    (e._sprite = "__default"),
                    (e._id = ++c._counter),
                    t._sounds.push(e),
                    e.create(),
                    e
                  );
                },
                create: function () {
                  var e = this,
                    t = e._parent,
                    r =
                      c._muted || e._muted || e._parent._muted ? 0 : e._volume;
                  return (
                    t._webAudio
                      ? ((e._node =
                          typeof c.ctx.createGain == "undefined"
                            ? c.ctx.createGainNode()
                            : c.ctx.createGain()),
                        e._node.gain.setValueAtTime(r, c.ctx.currentTime),
                        (e._node.paused = !0),
                        e._node.connect(c.masterGain))
                      : c.noAudio ||
                        ((e._node = c._obtainHtml5Audio()),
                        (e._errorFn = e._errorListener.bind(e)),
                        e._node.addEventListener("error", e._errorFn, !1),
                        (e._loadFn = e._loadListener.bind(e)),
                        e._node.addEventListener(
                          c._canPlayEvent,
                          e._loadFn,
                          !1
                        ),
                        (e._endFn = e._endListener.bind(e)),
                        e._node.addEventListener("ended", e._endFn, !1),
                        (e._node.src = t._src),
                        (e._node.preload =
                          t._preload === !0 ? "auto" : t._preload),
                        (e._node.volume = r * c.volume()),
                        e._node.load()),
                    e
                  );
                },
                reset: function () {
                  var e = this,
                    t = e._parent;
                  return (
                    (e._muted = t._muted),
                    (e._loop = t._loop),
                    (e._volume = t._volume),
                    (e._rate = t._rate),
                    (e._seek = 0),
                    (e._rateSeek = 0),
                    (e._paused = !0),
                    (e._ended = !0),
                    (e._sprite = "__default"),
                    (e._id = ++c._counter),
                    e
                  );
                },
                _errorListener: function () {
                  var e = this;
                  e._parent._emit(
                    "loaderror",
                    e._id,
                    e._node.error ? e._node.error.code : 0
                  ),
                    e._node.removeEventListener("error", e._errorFn, !1);
                },
                _loadListener: function () {
                  var e = this,
                    t = e._parent;
                  (t._duration = Math.ceil(e._node.duration * 10) / 10),
                    Object.keys(t._sprite).length === 0 &&
                      (t._sprite = { __default: [0, t._duration * 1e3] }),
                    t._state !== "loaded" &&
                      ((t._state = "loaded"), t._emit("load"), t._loadQueue()),
                    e._node.removeEventListener(c._canPlayEvent, e._loadFn, !1);
                },
                _endListener: function () {
                  var e = this,
                    t = e._parent;
                  t._duration === 1 / 0 &&
                    ((t._duration = Math.ceil(e._node.duration * 10) / 10),
                    t._sprite.__default[1] === 1 / 0 &&
                      (t._sprite.__default[1] = t._duration * 1e3),
                    t._ended(e)),
                    e._node.removeEventListener("ended", e._endFn, !1);
                },
              };
              var f = {},
                s = function (e) {
                  var t = e._src;
                  if (f[t]) {
                    (e._duration = f[t].duration), o(e);
                    return;
                  }
                  if (/^data:[^;]+;base64,/.test(t)) {
                    for (
                      var r = atob(t.split(",")[1]),
                        u = new Uint8Array(r.length),
                        y = 0;
                      y < r.length;
                      ++y
                    )
                      u[y] = r.charCodeAt(y);
                    n(u.buffer, e);
                  } else {
                    var p = new XMLHttpRequest();
                    p.open(e._xhr.method, t, !0),
                      (p.withCredentials = e._xhr.withCredentials),
                      (p.responseType = "arraybuffer"),
                      e._xhr.headers &&
                        Object.keys(e._xhr.headers).forEach(function (_) {
                          p.setRequestHeader(_, e._xhr.headers[_]);
                        }),
                      (p.onload = function () {
                        var _ = (p.status + "")[0];
                        if (_ !== "0" && _ !== "2" && _ !== "3") {
                          e._emit(
                            "loaderror",
                            null,
                            "Failed loading audio file with status: " +
                              p.status +
                              "."
                          );
                          return;
                        }
                        n(p.response, e);
                      }),
                      (p.onerror = function () {
                        e._webAudio &&
                          ((e._html5 = !0),
                          (e._webAudio = !1),
                          (e._sounds = []),
                          delete f[t],
                          e.load());
                      }),
                      l(p);
                  }
                },
                l = function (e) {
                  try {
                    e.send();
                  } catch (t) {
                    e.onerror();
                  }
                },
                n = function (e, t) {
                  var r = function () {
                      t._emit("loaderror", null, "Decoding audio data failed.");
                    },
                    u = function (y) {
                      y && t._sounds.length > 0
                        ? ((f[t._src] = y), o(t, y))
                        : r();
                    };
                  typeof Promise != "undefined" &&
                  c.ctx.decodeAudioData.length === 1
                    ? c.ctx.decodeAudioData(e).then(u).catch(r)
                    : c.ctx.decodeAudioData(e, u, r);
                },
                o = function (e, t) {
                  t && !e._duration && (e._duration = t.duration),
                    Object.keys(e._sprite).length === 0 &&
                      (e._sprite = { __default: [0, e._duration * 1e3] }),
                    e._state !== "loaded" &&
                      ((e._state = "loaded"), e._emit("load"), e._loadQueue());
                },
                i = function () {
                  if (c.usingWebAudio) {
                    try {
                      typeof AudioContext != "undefined"
                        ? (c.ctx = new AudioContext())
                        : typeof webkitAudioContext != "undefined"
                        ? (c.ctx = new webkitAudioContext())
                        : (c.usingWebAudio = !1);
                    } catch (y) {
                      c.usingWebAudio = !1;
                    }
                    c.ctx || (c.usingWebAudio = !1);
                    var e = /iP(hone|od|ad)/.test(
                        c._navigator && c._navigator.platform
                      ),
                      t =
                        c._navigator &&
                        c._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),
                      r = t ? parseInt(t[1], 10) : null;
                    if (e && r && r < 9) {
                      var u = /safari/.test(
                        c._navigator && c._navigator.userAgent.toLowerCase()
                      );
                      c._navigator && !u && (c.usingWebAudio = !1);
                    }
                    c.usingWebAudio &&
                      ((c.masterGain =
                        typeof c.ctx.createGain == "undefined"
                          ? c.ctx.createGainNode()
                          : c.ctx.createGain()),
                      c.masterGain.gain.setValueAtTime(
                        c._muted ? 0 : c._volume,
                        c.ctx.currentTime
                      ),
                      c.masterGain.connect(c.ctx.destination)),
                      c._setup();
                  }
                };
              (x = []),
                (T = function () {
                  return { Howler: c, Howl: d };
                }.apply(W, x)),
                T !== void 0 && (Se.exports = T),
                (W.Howler = c),
                (W.Howl = d),
                typeof a.g != "undefined"
                  ? ((a.g.HowlerGlobal = g),
                    (a.g.Howler = c),
                    (a.g.Howl = d),
                    (a.g.Sound = h))
                  : typeof window != "undefined" &&
                    ((window.HowlerGlobal = g),
                    (window.Howler = c),
                    (window.Howl = d),
                    (window.Sound = h));
            })();
            /*!
             *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
             *
             *  howler.js v2.2.3
             *  howlerjs.com
             *
             *  (c) 2013-2020, James Simpson of GoldFire Studios
             *  goldfirestudios.com
             *
             *  MIT License
             */ (function () {
              "use strict";
              (HowlerGlobal.prototype._pos = [0, 0, 0]),
                (HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0]),
                (HowlerGlobal.prototype.stereo = function (c) {
                  var d = this;
                  if (!d.ctx || !d.ctx.listener) return d;
                  for (var h = d._howls.length - 1; h >= 0; h--)
                    d._howls[h].stereo(c);
                  return d;
                }),
                (HowlerGlobal.prototype.pos = function (c, d, h) {
                  var f = this;
                  if (!f.ctx || !f.ctx.listener) return f;
                  if (
                    ((d = typeof d != "number" ? f._pos[1] : d),
                    (h = typeof h != "number" ? f._pos[2] : h),
                    typeof c == "number")
                  )
                    (f._pos = [c, d, h]),
                      typeof f.ctx.listener.positionX != "undefined"
                        ? (f.ctx.listener.positionX.setTargetAtTime(
                            f._pos[0],
                            Howler.ctx.currentTime,
                            0.1
                          ),
                          f.ctx.listener.positionY.setTargetAtTime(
                            f._pos[1],
                            Howler.ctx.currentTime,
                            0.1
                          ),
                          f.ctx.listener.positionZ.setTargetAtTime(
                            f._pos[2],
                            Howler.ctx.currentTime,
                            0.1
                          ))
                        : f.ctx.listener.setPosition(
                            f._pos[0],
                            f._pos[1],
                            f._pos[2]
                          );
                  else return f._pos;
                  return f;
                }),
                (HowlerGlobal.prototype.orientation = function (
                  c,
                  d,
                  h,
                  f,
                  s,
                  l
                ) {
                  var n = this;
                  if (!n.ctx || !n.ctx.listener) return n;
                  var o = n._orientation;
                  if (
                    ((d = typeof d != "number" ? o[1] : d),
                    (h = typeof h != "number" ? o[2] : h),
                    (f = typeof f != "number" ? o[3] : f),
                    (s = typeof s != "number" ? o[4] : s),
                    (l = typeof l != "number" ? o[5] : l),
                    typeof c == "number")
                  )
                    (n._orientation = [c, d, h, f, s, l]),
                      typeof n.ctx.listener.forwardX != "undefined"
                        ? (n.ctx.listener.forwardX.setTargetAtTime(
                            c,
                            Howler.ctx.currentTime,
                            0.1
                          ),
                          n.ctx.listener.forwardY.setTargetAtTime(
                            d,
                            Howler.ctx.currentTime,
                            0.1
                          ),
                          n.ctx.listener.forwardZ.setTargetAtTime(
                            h,
                            Howler.ctx.currentTime,
                            0.1
                          ),
                          n.ctx.listener.upX.setTargetAtTime(
                            f,
                            Howler.ctx.currentTime,
                            0.1
                          ),
                          n.ctx.listener.upY.setTargetAtTime(
                            s,
                            Howler.ctx.currentTime,
                            0.1
                          ),
                          n.ctx.listener.upZ.setTargetAtTime(
                            l,
                            Howler.ctx.currentTime,
                            0.1
                          ))
                        : n.ctx.listener.setOrientation(c, d, h, f, s, l);
                  else return o;
                  return n;
                }),
                (Howl.prototype.init = (function (c) {
                  return function (d) {
                    var h = this;
                    return (
                      (h._orientation = d.orientation || [1, 0, 0]),
                      (h._stereo = d.stereo || null),
                      (h._pos = d.pos || null),
                      (h._pannerAttr = {
                        coneInnerAngle:
                          typeof d.coneInnerAngle != "undefined"
                            ? d.coneInnerAngle
                            : 360,
                        coneOuterAngle:
                          typeof d.coneOuterAngle != "undefined"
                            ? d.coneOuterAngle
                            : 360,
                        coneOuterGain:
                          typeof d.coneOuterGain != "undefined"
                            ? d.coneOuterGain
                            : 0,
                        distanceModel:
                          typeof d.distanceModel != "undefined"
                            ? d.distanceModel
                            : "inverse",
                        maxDistance:
                          typeof d.maxDistance != "undefined"
                            ? d.maxDistance
                            : 1e4,
                        panningModel:
                          typeof d.panningModel != "undefined"
                            ? d.panningModel
                            : "HRTF",
                        refDistance:
                          typeof d.refDistance != "undefined"
                            ? d.refDistance
                            : 1,
                        rolloffFactor:
                          typeof d.rolloffFactor != "undefined"
                            ? d.rolloffFactor
                            : 1,
                      }),
                      (h._onstereo = d.onstereo ? [{ fn: d.onstereo }] : []),
                      (h._onpos = d.onpos ? [{ fn: d.onpos }] : []),
                      (h._onorientation = d.onorientation
                        ? [{ fn: d.onorientation }]
                        : []),
                      c.call(this, d)
                    );
                  };
                })(Howl.prototype.init)),
                (Howl.prototype.stereo = function (c, d) {
                  var h = this;
                  if (!h._webAudio) return h;
                  if (h._state !== "loaded")
                    return (
                      h._queue.push({
                        event: "stereo",
                        action: function () {
                          h.stereo(c, d);
                        },
                      }),
                      h
                    );
                  var f =
                    typeof Howler.ctx.createStereoPanner == "undefined"
                      ? "spatial"
                      : "stereo";
                  if (typeof d == "undefined")
                    if (typeof c == "number")
                      (h._stereo = c), (h._pos = [c, 0, 0]);
                    else return h._stereo;
                  for (var s = h._getSoundIds(d), l = 0; l < s.length; l++) {
                    var n = h._soundById(s[l]);
                    if (n)
                      if (typeof c == "number")
                        (n._stereo = c),
                          (n._pos = [c, 0, 0]),
                          n._node &&
                            ((n._pannerAttr.panningModel = "equalpower"),
                            (!n._panner || !n._panner.pan) && g(n, f),
                            f === "spatial"
                              ? typeof n._panner.positionX != "undefined"
                                ? (n._panner.positionX.setValueAtTime(
                                    c,
                                    Howler.ctx.currentTime
                                  ),
                                  n._panner.positionY.setValueAtTime(
                                    0,
                                    Howler.ctx.currentTime
                                  ),
                                  n._panner.positionZ.setValueAtTime(
                                    0,
                                    Howler.ctx.currentTime
                                  ))
                                : n._panner.setPosition(c, 0, 0)
                              : n._panner.pan.setValueAtTime(
                                  c,
                                  Howler.ctx.currentTime
                                )),
                          h._emit("stereo", n._id);
                      else return n._stereo;
                  }
                  return h;
                }),
                (Howl.prototype.pos = function (c, d, h, f) {
                  var s = this;
                  if (!s._webAudio) return s;
                  if (s._state !== "loaded")
                    return (
                      s._queue.push({
                        event: "pos",
                        action: function () {
                          s.pos(c, d, h, f);
                        },
                      }),
                      s
                    );
                  if (
                    ((d = typeof d != "number" ? 0 : d),
                    (h = typeof h != "number" ? -0.5 : h),
                    typeof f == "undefined")
                  )
                    if (typeof c == "number") s._pos = [c, d, h];
                    else return s._pos;
                  for (var l = s._getSoundIds(f), n = 0; n < l.length; n++) {
                    var o = s._soundById(l[n]);
                    if (o)
                      if (typeof c == "number")
                        (o._pos = [c, d, h]),
                          o._node &&
                            ((!o._panner || o._panner.pan) && g(o, "spatial"),
                            typeof o._panner.positionX != "undefined"
                              ? (o._panner.positionX.setValueAtTime(
                                  c,
                                  Howler.ctx.currentTime
                                ),
                                o._panner.positionY.setValueAtTime(
                                  d,
                                  Howler.ctx.currentTime
                                ),
                                o._panner.positionZ.setValueAtTime(
                                  h,
                                  Howler.ctx.currentTime
                                ))
                              : o._panner.setPosition(c, d, h)),
                          s._emit("pos", o._id);
                      else return o._pos;
                  }
                  return s;
                }),
                (Howl.prototype.orientation = function (c, d, h, f) {
                  var s = this;
                  if (!s._webAudio) return s;
                  if (s._state !== "loaded")
                    return (
                      s._queue.push({
                        event: "orientation",
                        action: function () {
                          s.orientation(c, d, h, f);
                        },
                      }),
                      s
                    );
                  if (
                    ((d = typeof d != "number" ? s._orientation[1] : d),
                    (h = typeof h != "number" ? s._orientation[2] : h),
                    typeof f == "undefined")
                  )
                    if (typeof c == "number") s._orientation = [c, d, h];
                    else return s._orientation;
                  for (var l = s._getSoundIds(f), n = 0; n < l.length; n++) {
                    var o = s._soundById(l[n]);
                    if (o)
                      if (typeof c == "number")
                        (o._orientation = [c, d, h]),
                          o._node &&
                            (o._panner ||
                              (o._pos || (o._pos = s._pos || [0, 0, -0.5]),
                              g(o, "spatial")),
                            typeof o._panner.orientationX != "undefined"
                              ? (o._panner.orientationX.setValueAtTime(
                                  c,
                                  Howler.ctx.currentTime
                                ),
                                o._panner.orientationY.setValueAtTime(
                                  d,
                                  Howler.ctx.currentTime
                                ),
                                o._panner.orientationZ.setValueAtTime(
                                  h,
                                  Howler.ctx.currentTime
                                ))
                              : o._panner.setOrientation(c, d, h)),
                          s._emit("orientation", o._id);
                      else return o._orientation;
                  }
                  return s;
                }),
                (Howl.prototype.pannerAttr = function () {
                  var c = this,
                    d = arguments,
                    h,
                    f,
                    s;
                  if (!c._webAudio) return c;
                  if (d.length === 0) return c._pannerAttr;
                  if (d.length === 1)
                    if (typeof d[0] == "object")
                      (h = d[0]),
                        typeof f == "undefined" &&
                          (h.pannerAttr ||
                            (h.pannerAttr = {
                              coneInnerAngle: h.coneInnerAngle,
                              coneOuterAngle: h.coneOuterAngle,
                              coneOuterGain: h.coneOuterGain,
                              distanceModel: h.distanceModel,
                              maxDistance: h.maxDistance,
                              refDistance: h.refDistance,
                              rolloffFactor: h.rolloffFactor,
                              panningModel: h.panningModel,
                            }),
                          (c._pannerAttr = {
                            coneInnerAngle:
                              typeof h.pannerAttr.coneInnerAngle != "undefined"
                                ? h.pannerAttr.coneInnerAngle
                                : c._coneInnerAngle,
                            coneOuterAngle:
                              typeof h.pannerAttr.coneOuterAngle != "undefined"
                                ? h.pannerAttr.coneOuterAngle
                                : c._coneOuterAngle,
                            coneOuterGain:
                              typeof h.pannerAttr.coneOuterGain != "undefined"
                                ? h.pannerAttr.coneOuterGain
                                : c._coneOuterGain,
                            distanceModel:
                              typeof h.pannerAttr.distanceModel != "undefined"
                                ? h.pannerAttr.distanceModel
                                : c._distanceModel,
                            maxDistance:
                              typeof h.pannerAttr.maxDistance != "undefined"
                                ? h.pannerAttr.maxDistance
                                : c._maxDistance,
                            refDistance:
                              typeof h.pannerAttr.refDistance != "undefined"
                                ? h.pannerAttr.refDistance
                                : c._refDistance,
                            rolloffFactor:
                              typeof h.pannerAttr.rolloffFactor != "undefined"
                                ? h.pannerAttr.rolloffFactor
                                : c._rolloffFactor,
                            panningModel:
                              typeof h.pannerAttr.panningModel != "undefined"
                                ? h.pannerAttr.panningModel
                                : c._panningModel,
                          }));
                    else
                      return (
                        (s = c._soundById(parseInt(d[0], 10))),
                        s ? s._pannerAttr : c._pannerAttr
                      );
                  else d.length === 2 && ((h = d[0]), (f = parseInt(d[1], 10)));
                  for (var l = c._getSoundIds(f), n = 0; n < l.length; n++)
                    if (((s = c._soundById(l[n])), s)) {
                      var o = s._pannerAttr;
                      o = {
                        coneInnerAngle:
                          typeof h.coneInnerAngle != "undefined"
                            ? h.coneInnerAngle
                            : o.coneInnerAngle,
                        coneOuterAngle:
                          typeof h.coneOuterAngle != "undefined"
                            ? h.coneOuterAngle
                            : o.coneOuterAngle,
                        coneOuterGain:
                          typeof h.coneOuterGain != "undefined"
                            ? h.coneOuterGain
                            : o.coneOuterGain,
                        distanceModel:
                          typeof h.distanceModel != "undefined"
                            ? h.distanceModel
                            : o.distanceModel,
                        maxDistance:
                          typeof h.maxDistance != "undefined"
                            ? h.maxDistance
                            : o.maxDistance,
                        refDistance:
                          typeof h.refDistance != "undefined"
                            ? h.refDistance
                            : o.refDistance,
                        rolloffFactor:
                          typeof h.rolloffFactor != "undefined"
                            ? h.rolloffFactor
                            : o.rolloffFactor,
                        panningModel:
                          typeof h.panningModel != "undefined"
                            ? h.panningModel
                            : o.panningModel,
                      };
                      var i = s._panner;
                      i
                        ? ((i.coneInnerAngle = o.coneInnerAngle),
                          (i.coneOuterAngle = o.coneOuterAngle),
                          (i.coneOuterGain = o.coneOuterGain),
                          (i.distanceModel = o.distanceModel),
                          (i.maxDistance = o.maxDistance),
                          (i.refDistance = o.refDistance),
                          (i.rolloffFactor = o.rolloffFactor),
                          (i.panningModel = o.panningModel))
                        : (s._pos || (s._pos = c._pos || [0, 0, -0.5]),
                          g(s, "spatial"));
                    }
                  return c;
                }),
                (Sound.prototype.init = (function (c) {
                  return function () {
                    var d = this,
                      h = d._parent;
                    (d._orientation = h._orientation),
                      (d._stereo = h._stereo),
                      (d._pos = h._pos),
                      (d._pannerAttr = h._pannerAttr),
                      c.call(this),
                      d._stereo
                        ? h.stereo(d._stereo)
                        : d._pos &&
                          h.pos(d._pos[0], d._pos[1], d._pos[2], d._id);
                  };
                })(Sound.prototype.init)),
                (Sound.prototype.reset = (function (c) {
                  return function () {
                    var d = this,
                      h = d._parent;
                    return (
                      (d._orientation = h._orientation),
                      (d._stereo = h._stereo),
                      (d._pos = h._pos),
                      (d._pannerAttr = h._pannerAttr),
                      d._stereo
                        ? h.stereo(d._stereo)
                        : d._pos
                        ? h.pos(d._pos[0], d._pos[1], d._pos[2], d._id)
                        : d._panner &&
                          (d._panner.disconnect(0),
                          (d._panner = void 0),
                          h._refreshBuffer(d)),
                      c.call(this)
                    );
                  };
                })(Sound.prototype.reset));
              var g = function (c, d) {
                (d = d || "spatial"),
                  d === "spatial"
                    ? ((c._panner = Howler.ctx.createPanner()),
                      (c._panner.coneInnerAngle = c._pannerAttr.coneInnerAngle),
                      (c._panner.coneOuterAngle = c._pannerAttr.coneOuterAngle),
                      (c._panner.coneOuterGain = c._pannerAttr.coneOuterGain),
                      (c._panner.distanceModel = c._pannerAttr.distanceModel),
                      (c._panner.maxDistance = c._pannerAttr.maxDistance),
                      (c._panner.refDistance = c._pannerAttr.refDistance),
                      (c._panner.rolloffFactor = c._pannerAttr.rolloffFactor),
                      (c._panner.panningModel = c._pannerAttr.panningModel),
                      typeof c._panner.positionX != "undefined"
                        ? (c._panner.positionX.setValueAtTime(
                            c._pos[0],
                            Howler.ctx.currentTime
                          ),
                          c._panner.positionY.setValueAtTime(
                            c._pos[1],
                            Howler.ctx.currentTime
                          ),
                          c._panner.positionZ.setValueAtTime(
                            c._pos[2],
                            Howler.ctx.currentTime
                          ))
                        : c._panner.setPosition(
                            c._pos[0],
                            c._pos[1],
                            c._pos[2]
                          ),
                      typeof c._panner.orientationX != "undefined"
                        ? (c._panner.orientationX.setValueAtTime(
                            c._orientation[0],
                            Howler.ctx.currentTime
                          ),
                          c._panner.orientationY.setValueAtTime(
                            c._orientation[1],
                            Howler.ctx.currentTime
                          ),
                          c._panner.orientationZ.setValueAtTime(
                            c._orientation[2],
                            Howler.ctx.currentTime
                          ))
                        : c._panner.setOrientation(
                            c._orientation[0],
                            c._orientation[1],
                            c._orientation[2]
                          ))
                    : ((c._panner = Howler.ctx.createStereoPanner()),
                      c._panner.pan.setValueAtTime(
                        c._stereo,
                        Howler.ctx.currentTime
                      )),
                  c._panner.connect(c._node),
                  c._paused || c._parent.pause(c._id, !0).play(c._id, !0);
              };
            })();
          },
          645: (Se, W) => {
            /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ (W.read =
              function (a, x, T, g, c) {
                var d,
                  h,
                  f = c * 8 - g - 1,
                  s = (1 << f) - 1,
                  l = s >> 1,
                  n = -7,
                  o = T ? c - 1 : 0,
                  i = T ? -1 : 1,
                  e = a[x + o];
                for (
                  o += i, d = e & ((1 << -n) - 1), e >>= -n, n += f;
                  n > 0;
                  d = d * 256 + a[x + o], o += i, n -= 8
                );
                for (
                  h = d & ((1 << -n) - 1), d >>= -n, n += g;
                  n > 0;
                  h = h * 256 + a[x + o], o += i, n -= 8
                );
                if (d === 0) d = 1 - l;
                else {
                  if (d === s) return h ? NaN : (e ? -1 : 1) * (1 / 0);
                  (h = h + Math.pow(2, g)), (d = d - l);
                }
                return (e ? -1 : 1) * h * Math.pow(2, d - g);
              }),
              (W.write = function (a, x, T, g, c, d) {
                var h,
                  f,
                  s,
                  l = d * 8 - c - 1,
                  n = (1 << l) - 1,
                  o = n >> 1,
                  i = c === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                  e = g ? 0 : d - 1,
                  t = g ? 1 : -1,
                  r = x < 0 || (x === 0 && 1 / x < 0) ? 1 : 0;
                for (
                  x = Math.abs(x),
                    isNaN(x) || x === 1 / 0
                      ? ((f = isNaN(x) ? 1 : 0), (h = n))
                      : ((h = Math.floor(Math.log(x) / Math.LN2)),
                        x * (s = Math.pow(2, -h)) < 1 && (h--, (s *= 2)),
                        h + o >= 1
                          ? (x += i / s)
                          : (x += i * Math.pow(2, 1 - o)),
                        x * s >= 2 && (h++, (s /= 2)),
                        h + o >= n
                          ? ((f = 0), (h = n))
                          : h + o >= 1
                          ? ((f = (x * s - 1) * Math.pow(2, c)), (h = h + o))
                          : ((f = x * Math.pow(2, o - 1) * Math.pow(2, c)),
                            (h = 0)));
                  c >= 8;
                  a[T + e] = f & 255, e += t, f /= 256, c -= 8
                );
                for (
                  h = (h << c) | f, l += c;
                  l > 0;
                  a[T + e] = h & 255, e += t, h /= 256, l -= 8
                );
                a[T + e - t] |= r * 128;
              });
          },
          9078: (Se, W, a) => {
            "use strict";
            a.d(W, { g: () => x });
            function x() {
              return (
                (x = Object.assign
                  ? Object.assign.bind()
                  : function (T) {
                      for (var g = 1; g < arguments.length; g++) {
                        var c = arguments[g];
                        for (var d in c)
                          Object.prototype.hasOwnProperty.call(c, d) &&
                            (T[d] = c[d]);
                      }
                      return T;
                    }),
                x.apply(this, arguments)
              );
            }
          },
          2200: (Se, W, a) => {
            "use strict";
            a.d(W, {
              $T: () => l,
              AB: () => _,
              Bw: () => x,
              Jg: () => t,
              M0: () => u,
              Mm: () => r,
              OJ: () => c,
              OR: () => f,
              P2: () => h,
              Rd: () => y,
              Rv: () => e,
              Se: () => o,
              W1: () => g,
              WS: () => p,
              YH: () => n,
              e9: () => d,
              gs: () => T,
              hB: () => i,
              io: () => s,
              wf: () => m,
            });
            const x = "RenderFrame",
              T = "RenderFrameTime",
              g = "RenderPass",
              c = "RenderPassDetail",
              d = "RenderAction",
              h = "RenderTargetAlloc",
              f = "TextureAlloc",
              s = "ShaderAlloc",
              l = "ShaderCompile",
              n = "VRAM.Texture",
              o = "VRAM.Vb",
              i = "VRAM.Ib",
              e = "BindGroupAlloc",
              t = "BindGroupFormatAlloc",
              r = "RenderPipelineAlloc",
              u = "PipelineLayoutAlloc",
              y = "Element",
              p = "Textures",
              _ = "RenderQueue",
              m = "GpuTimings";
          },
          9795: (Se, W, a) => {
            "use strict";
            a.d(W, {
              LB: () => T,
              aT: () => h,
              dt: () => s,
              hO: () => d,
              i8: () => x,
              l7: () => l,
              vc: () => g,
              y0: () => c,
            });
            const x = "1.65.4",
              T = "02ba39454",
              g = {},
              c = {},
              d = {},
              h = {},
              f = (function () {
                const n = {},
                  o = [
                    "Array",
                    "Object",
                    "Function",
                    "Date",
                    "RegExp",
                    "Float32Array",
                  ];
                for (let i = 0; i < o.length; i++)
                  n["[object " + o[i] + "]"] = o[i].toLowerCase();
                return n;
              })();
            function s(n) {
              if (n === null) return "null";
              const o = typeof n;
              return o === "undefined" ||
                o === "number" ||
                o === "string" ||
                o === "boolean"
                ? o
                : f[Object.prototype.toString.call(n)];
            }
            function l(n, o) {
              for (const i in o) {
                const e = o[i];
                s(e) === "object"
                  ? (n[i] = l({}, e))
                  : s(e) === "array"
                  ? (n[i] = l([], e))
                  : (n[i] = e);
              }
              return n;
            }
          },
          5338: (Se, W, a) => {
            "use strict";
            a.d(W, { b: () => x });
            class x {
              constructor() {
                (this._callbacks = new Map()),
                  (this._callbackActive = new Map());
              }
              initEventHandler() {
                (this._callbacks = new Map()),
                  (this._callbackActive = new Map());
              }
              _addCallback(g, c, d, h) {
                if (!(!g || typeof g != "string" || !c)) {
                  if (
                    (this._callbacks.has(g) || this._callbacks.set(g, []),
                    this._callbackActive.has(g))
                  ) {
                    const f = this._callbackActive.get(g);
                    f &&
                      f === this._callbacks.get(g) &&
                      this._callbackActive.set(g, f.slice());
                  }
                  this._callbacks
                    .get(g)
                    .push({ callback: c, scope: d, once: h });
                }
              }
              on(g, c, d = this) {
                return this._addCallback(g, c, d, !1), this;
              }
              once(g, c, d = this) {
                return this._addCallback(g, c, d, !0), this;
              }
              off(g, c, d) {
                if (g)
                  this._callbackActive.has(g) &&
                    this._callbackActive.get(g) === this._callbacks.get(g) &&
                    this._callbackActive.set(
                      g,
                      this._callbackActive.get(g).slice()
                    );
                else
                  for (const [h, f] of this._callbackActive)
                    this._callbacks.has(h) &&
                      this._callbacks.get(h) === f &&
                      this._callbackActive.set(h, f.slice());
                if (!g) this._callbacks.clear();
                else if (!c)
                  this._callbacks.has(g) && this._callbacks.delete(g);
                else {
                  const h = this._callbacks.get(g);
                  if (!h) return this;
                  let f = h.length;
                  for (let s = 0; s < f; s++)
                    h[s].callback === c &&
                      ((d && h[s].scope !== d) || (h[s--] = h[--f]));
                  (h.length = f), h.length === 0 && this._callbacks.delete(g);
                }
                return this;
              }
              fire(g, c, d, h, f, s, l, n, o) {
                if (!g) return this;
                const i = this._callbacks.get(g);
                if (!i) return this;
                let e;
                this._callbackActive.has(g)
                  ? this._callbackActive.get(g) !== i && (e = i.slice())
                  : this._callbackActive.set(g, i);
                for (
                  let t = 0;
                  (e || this._callbackActive.get(g)) &&
                  t < (e || this._callbackActive.get(g)).length;
                  t++
                ) {
                  const r = (e || this._callbackActive.get(g))[t];
                  if (
                    (r.callback.call(r.scope, c, d, h, f, s, l, n, o), r.once)
                  ) {
                    const u = this._callbacks.get(g),
                      y = u ? u.indexOf(r) : -1;
                    if (y !== -1) {
                      this._callbackActive.get(g) === u &&
                        this._callbackActive.set(
                          g,
                          this._callbackActive.get(g).slice()
                        );
                      const p = this._callbacks.get(g);
                      if (!p) continue;
                      p.splice(y, 1),
                        p.length === 0 && this._callbacks.delete(g);
                    }
                  }
                }
                return e || this._callbackActive.delete(g), this;
              }
              hasEvent(g) {
                var c;
                return !!((c = this._callbacks.get(g)) != null && c.length);
              }
            }
          },
          5843: (Se, W, a) => {
            "use strict";
            a.d(W, { U: () => T });
            var x = a(5338);
            const T = {
              attach: function (g) {
                const c = T;
                return (
                  (g._addCallback = c._addCallback),
                  (g.on = c.on),
                  (g.off = c.off),
                  (g.fire = c.fire),
                  (g.once = c.once),
                  (g.hasEvent = c.hasEvent),
                  x.b.prototype.initEventHandler.call(g),
                  g
                );
              },
              _addCallback: x.b.prototype._addCallback,
              on: x.b.prototype.on,
              off: x.b.prototype.off,
              fire: x.b.prototype.fire,
              once: x.b.prototype.once,
              hasEvent: x.b.prototype.hasEvent,
            };
          },
          6724: (Se, W, a) => {
            "use strict";
            a.d(W, { M: () => x });
            const x = {
              create: function () {
                return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
                  /[xy]/g,
                  function (T) {
                    const g = (Math.random() * 16) | 0;
                    return (T === "x" ? g : (g & 3) | 8).toString(16);
                  }
                );
              },
            };
          },
          2752: (Se, W, a) => {
            "use strict";
            a.d(W, { A: () => T, u: () => x });
            function x(g) {
              let c = 0;
              for (let d = 0, h = g.length; d < h; d++)
                (c = (c << 5) - c + g.charCodeAt(d)), (c |= 0);
              return c;
            }
            function T(g) {
              let d = 2166136261;
              for (let h = 0; h < g.length; h++) (d ^= g[h]), (d *= 16777619);
              return d >>> 0;
            }
          },
          743: (Se, W, a) => {
            "use strict";
            a.d(W, { _: () => x });
            class x {
              constructor() {
                (this._list = []), (this._index = {});
              }
              push(g, c) {
                if (this._index[g]) throw Error("Key already in index " + g);
                const d = this._list.push(c) - 1;
                this._index[g] = d;
              }
              has(g) {
                return this._index[g] !== void 0;
              }
              get(g) {
                const c = this._index[g];
                return c !== void 0 ? this._list[c] : null;
              }
              remove(g) {
                const c = this._index[g];
                if (c !== void 0) {
                  this._list.splice(c, 1), delete this._index[g];
                  for (g in this._index) {
                    const d = this._index[g];
                    d > c && (this._index[g] = d - 1);
                  }
                  return !0;
                }
                return !1;
              }
              list() {
                return this._list;
              }
              clear() {
                this._list.length = 0;
                for (const g in this._index) delete this._index[g];
              }
            }
          },
          4475: (Se, W, a) => {
            "use strict";
            a.d(W, { u: () => x });
            const x = {
              set: function (T, g, c, d = 1) {
                return (T & ~(d << c)) | (g << c);
              },
              get: function (T, g, c = 1) {
                return (T >> g) & c;
              },
              all: function (T, g, c = 1) {
                const d = c << g;
                return (T & d) === d;
              },
              any: function (T, g, c = 1) {
                return (T & (c << g)) !== 0;
              },
            };
          },
          1367: (Se, W, a) => {
            "use strict";
            a.d(W, { I: () => T });
            var x = a(4585);
            class T {
              constructor(c = 0, d = 0, h = 0, f = 1) {
                (this.r = void 0),
                  (this.g = void 0),
                  (this.b = void 0),
                  (this.a = void 0);
                const s = c.length;
                s === 3 || s === 4
                  ? ((this.r = c[0]),
                    (this.g = c[1]),
                    (this.b = c[2]),
                    (this.a = c[3] !== void 0 ? c[3] : 1))
                  : ((this.r = c), (this.g = d), (this.b = h), (this.a = f));
              }
              clone() {
                const c = this.constructor;
                return new c(this.r, this.g, this.b, this.a);
              }
              copy(c) {
                return (
                  (this.r = c.r),
                  (this.g = c.g),
                  (this.b = c.b),
                  (this.a = c.a),
                  this
                );
              }
              equals(c) {
                return (
                  this.r === c.r &&
                  this.g === c.g &&
                  this.b === c.b &&
                  this.a === c.a
                );
              }
              set(c, d, h, f = 1) {
                return (
                  (this.r = c), (this.g = d), (this.b = h), (this.a = f), this
                );
              }
              lerp(c, d, h) {
                return (
                  (this.r = c.r + h * (d.r - c.r)),
                  (this.g = c.g + h * (d.g - c.g)),
                  (this.b = c.b + h * (d.b - c.b)),
                  (this.a = c.a + h * (d.a - c.a)),
                  this
                );
              }
              fromString(c) {
                const d = parseInt(c.replace("#", "0x"), 16);
                let h;
                return (
                  c.length > 7
                    ? (h = x.m.intToBytes32(d))
                    : ((h = x.m.intToBytes24(d)), (h[3] = 255)),
                  this.set(h[0] / 255, h[1] / 255, h[2] / 255, h[3] / 255),
                  this
                );
              }
              toString(c) {
                let d =
                  "#" +
                  (
                    16777216 +
                    (Math.round(this.r * 255) << 16) +
                    (Math.round(this.g * 255) << 8) +
                    Math.round(this.b * 255)
                  )
                    .toString(16)
                    .slice(1);
                if (c === !0) {
                  const h = Math.round(this.a * 255).toString(16);
                  this.a < 0.06274509803921569 ? (d += "0" + h) : (d += h);
                }
                return d;
              }
            }
            (T.BLACK = Object.freeze(new T(0, 0, 0, 1))),
              (T.BLUE = Object.freeze(new T(0, 0, 1, 1))),
              (T.CYAN = Object.freeze(new T(0, 1, 1, 1))),
              (T.GRAY = Object.freeze(new T(0.5, 0.5, 0.5, 1))),
              (T.GREEN = Object.freeze(new T(0, 1, 0, 1))),
              (T.MAGENTA = Object.freeze(new T(1, 0, 1, 1))),
              (T.RED = Object.freeze(new T(1, 0, 0, 1))),
              (T.WHITE = Object.freeze(new T(1, 1, 1, 1))),
              (T.YELLOW = Object.freeze(new T(1, 1, 0, 1)));
          },
          3996: (Se, W, a) => {
            "use strict";
            a.d(W, {
              C0: () => c,
              Tr: () => x,
              X3: () => g,
              ZP: () => h,
              pj: () => d,
              xS: () => T,
            });
            const x = 0,
              T = 1,
              g = 2,
              c = 3,
              d = 4,
              h = 5;
          },
          5733: (Se, W, a) => {
            "use strict";
            a.d(W, { W: () => g });
            var x = a(3996),
              T = a(4585);
            class g {
              constructor(d, h = 0) {
                (this._curve = void 0),
                  (this._left = -1 / 0),
                  (this._right = 1 / 0),
                  (this._recip = 0),
                  (this._p0 = 0),
                  (this._p1 = 0),
                  (this._m0 = 0),
                  (this._m1 = 0),
                  (this._curve = d),
                  this._reset(h);
              }
              evaluate(d, h = !1) {
                (h || d < this._left || d >= this._right) && this._reset(d);
                let f;
                const s = this._curve.type;
                if (s === x.ZP) f = this._p0;
                else {
                  const l =
                    this._recip === 0 ? 0 : (d - this._left) * this._recip;
                  s === x.Tr
                    ? (f = T.m.lerp(this._p0, this._p1, l))
                    : s === x.xS
                    ? (f = T.m.lerp(this._p0, this._p1, l * l * (3 - 2 * l)))
                    : (f = this._evaluateHermite(
                        this._p0,
                        this._p1,
                        this._m0,
                        this._m1,
                        l
                      ));
                }
                return f;
              }
              _reset(d) {
                const h = this._curve.keys,
                  f = h.length;
                if (!f)
                  (this._left = -1 / 0),
                    (this._right = 1 / 0),
                    (this._recip = 0),
                    (this._p0 = this._p1 = this._m0 = this._m1 = 0);
                else if (d < h[0][0])
                  (this._left = -1 / 0),
                    (this._right = h[0][0]),
                    (this._recip = 0),
                    (this._p0 = this._p1 = h[0][1]),
                    (this._m0 = this._m1 = 0);
                else if (d >= h[f - 1][0])
                  (this._left = h[f - 1][0]),
                    (this._right = 1 / 0),
                    (this._recip = 0),
                    (this._p0 = this._p1 = h[f - 1][1]),
                    (this._m0 = this._m1 = 0);
                else {
                  let s = 0;
                  for (; d >= h[s + 1][0]; ) s++;
                  (this._left = h[s][0]), (this._right = h[s + 1][0]);
                  const l = 1 / (this._right - this._left);
                  (this._recip = isFinite(l) ? l : 0),
                    (this._p0 = h[s][1]),
                    (this._p1 = h[s + 1][1]),
                    this._isHermite() && this._calcTangents(h, s);
                }
              }
              _isHermite() {
                return (
                  this._curve.type === x.X3 ||
                  this._curve.type === x.C0 ||
                  this._curve.type === x.pj
                );
              }
              _calcTangents(d, h) {
                let f;
                const s = d[h],
                  l = d[h + 1];
                let n;
                if (
                  (h === 0
                    ? (f = [
                        d[0][0] + (d[0][0] - d[1][0]),
                        d[0][1] + (d[0][1] - d[1][1]),
                      ])
                    : (f = d[h - 1]),
                  h === d.length - 2
                    ? (n = [
                        d[h + 1][0] + (d[h + 1][0] - d[h][0]),
                        d[h + 1][1] + (d[h + 1][1] - d[h][1]),
                      ])
                    : (n = d[h + 2]),
                  this._curve.type === x.pj)
                ) {
                  const o = (2 * (l[0] - s[0])) / (l[0] - f[0]),
                    i = (2 * (l[0] - s[0])) / (n[0] - s[0]);
                  (this._m0 =
                    this._curve.tension *
                    (isFinite(o) ? o : 0) *
                    (l[1] - f[1])),
                    (this._m1 =
                      this._curve.tension *
                      (isFinite(i) ? i : 0) *
                      (n[1] - s[1]));
                } else {
                  const o = (l[0] - s[0]) / (s[0] - f[0]),
                    i = (l[0] - s[0]) / (n[0] - l[0]),
                    e = s[1] + (f[1] - s[1]) * (isFinite(o) ? o : 0),
                    t = l[1] + (n[1] - l[1]) * (isFinite(i) ? i : 0),
                    r = this._curve.type === x.X3 ? 0.5 : this._curve.tension;
                  (this._m0 = r * (l[1] - e)), (this._m1 = r * (t - s[1]));
                }
              }
              _evaluateHermite(d, h, f, s, l) {
                const n = l * l,
                  o = l + l,
                  i = 1 - l,
                  e = i * i;
                return (
                  d * ((1 + o) * e) +
                  f * (l * e) +
                  h * (n * (3 - o)) +
                  s * (n * (l - 1))
                );
              }
            }
          },
          1239: (Se, W, a) => {
            "use strict";
            a.d(W, { e: () => c });
            var x = a(3996),
              T = a(429),
              g = a(5733);
            class c {
              constructor() {
                if (
                  ((this.curves = []),
                  (this._type = x.xS),
                  arguments.length > 1)
                )
                  for (let h = 0; h < arguments.length; h++)
                    this.curves.push(new T.H(arguments[h]));
                else if (arguments.length === 0) this.curves.push(new T.H());
                else {
                  const h = arguments[0];
                  if (typeof h == "number")
                    for (let f = 0; f < h; f++) this.curves.push(new T.H());
                  else
                    for (let f = 0; f < h.length; f++)
                      this.curves.push(new T.H(h[f]));
                }
              }
              get length() {
                return this.curves.length;
              }
              set type(h) {
                this._type = h;
                for (let f = 0; f < this.curves.length; f++)
                  this.curves[f].type = h;
              }
              get type() {
                return this._type;
              }
              get(h) {
                return this.curves[h];
              }
              value(h, f = []) {
                const s = this.curves.length;
                f.length = s;
                for (let l = 0; l < s; l++) f[l] = this.curves[l].value(h);
                return f;
              }
              clone() {
                const h = new this.constructor();
                h.curves = [];
                for (let f = 0; f < this.curves.length; f++)
                  h.curves.push(this.curves[f].clone());
                return (h._type = this._type), h;
              }
              quantize(h) {
                h = Math.max(h, 2);
                const f = this.curves.length,
                  s = new Float32Array(h * f),
                  l = 1 / (h - 1);
                for (let n = 0; n < f; n++) {
                  const o = new g.W(this.curves[n]);
                  for (let i = 0; i < h; i++) s[i * f + n] = o.evaluate(l * i);
                }
                return s;
              }
              quantizeClamped(h, f, s) {
                const l = this.quantize(h);
                for (let n = 0; n < l.length; ++n)
                  l[n] = Math.min(s, Math.max(f, l[n]));
                return l;
              }
            }
          },
          429: (Se, W, a) => {
            "use strict";
            a.d(W, { H: () => c });
            var x = a(9795),
              T = a(3996),
              g = a(5733);
            class c {
              constructor(h) {
                if (
                  ((this.keys = []),
                  (this.type = T.xS),
                  (this.tension = 0.5),
                  (this._eval = new g.W(this)),
                  h)
                )
                  for (let f = 0; f < h.length - 1; f += 2)
                    this.keys.push([h[f], h[f + 1]]);
                this.sort();
              }
              get length() {
                return this.keys.length;
              }
              add(h, f) {
                const s = this.keys,
                  l = s.length;
                let n = 0;
                for (; n < l && !(s[n][0] > h); n++);
                const o = [h, f];
                return this.keys.splice(n, 0, o), o;
              }
              get(h) {
                return this.keys[h];
              }
              sort() {
                this.keys.sort(function (h, f) {
                  return h[0] - f[0];
                });
              }
              value(h) {
                return this._eval.evaluate(h, !0);
              }
              closest(h) {
                const f = this.keys,
                  s = f.length;
                let l = 2,
                  n = null;
                for (let o = 0; o < s; o++) {
                  const i = Math.abs(h - f[o][0]);
                  if (l >= i) (l = i), (n = f[o]);
                  else break;
                }
                return n;
              }
              clone() {
                const h = new this.constructor();
                return (
                  (h.keys = (0, x.l7)(h.keys, this.keys)),
                  (h.type = this.type),
                  (h.tension = this.tension),
                  h
                );
              }
              quantize(h) {
                h = Math.max(h, 2);
                const f = new Float32Array(h),
                  s = 1 / (h - 1);
                f[0] = this._eval.evaluate(0, !0);
                for (let l = 1; l < h; l++) f[l] = this._eval.evaluate(s * l);
                return f;
              }
              quantizeClamped(h, f, s) {
                const l = this.quantize(h);
                for (let n = 0; n < l.length; ++n)
                  l[n] = Math.min(s, Math.max(f, l[n]));
                return l;
              }
            }
          },
          1110: (Se, W, a) => {
            "use strict";
            a.d(W, { b: () => d });
            var x = a(4585);
            const T = 1 / 255,
              g = new Float32Array(1),
              c = new Int32Array(g.buffer);
            class d {
              static float2Half(f) {
                g[0] = f;
                const s = c[0];
                let l = (s >> 16) & 32768,
                  n = (s >> 12) & 2047;
                const o = (s >> 23) & 255;
                return o < 103
                  ? l
                  : o > 142
                  ? ((l |= 31744), (l |= (o === 255 ? 0 : 1) && s & 8388607), l)
                  : o < 113
                  ? ((n |= 2048),
                    (l |= (n >> (114 - o)) + ((n >> (113 - o)) & 1)),
                    l)
                  : ((l |= ((o - 112) << 10) | (n >> 1)), (l += n & 1), l);
              }
              static float2Bytes(f, s, l, n) {
                const o = (255 * f) % 1;
                if (((s[l + 0] = Math.round(((f % 1) - T * o) * 255)), n > 1)) {
                  const i = (65025 * f) % 1;
                  if (((s[l + 1] = Math.round((o - T * i) * 255)), n > 2)) {
                    const e = (16581375 * f) % 1;
                    (s[l + 2] = Math.round((i - T * e) * 255)),
                      n > 3 && (s[l + 3] = Math.round(e * 255));
                  }
                }
              }
              static float2BytesRange(f, s, l, n, o, i) {
                (f = x.m.clamp((f - n) / (o - n), 0, 1)),
                  d.float2Bytes(f, s, l, i);
              }
              static float2MantissaExponent(f, s, l, n) {
                const o = Math.floor(Math.log2(Math.abs(f))) + 1;
                (f /= Math.pow(2, o)),
                  d.float2BytesRange(f, s, l, -1, 1, n - 1),
                  (s[l + n - 1] = Math.round(o + 127));
              }
            }
          },
          4486: (Se, W, a) => {
            "use strict";
            a.d(W, { T: () => T });
            var x = a(6556);
            class T {
              constructor() {
                (this.data = new Float32Array(9)),
                  (this.data[0] = this.data[4] = this.data[8] = 1);
              }
              clone() {
                const c = this.constructor;
                return new c().copy(this);
              }
              copy(c) {
                const d = c.data,
                  h = this.data;
                return (
                  (h[0] = d[0]),
                  (h[1] = d[1]),
                  (h[2] = d[2]),
                  (h[3] = d[3]),
                  (h[4] = d[4]),
                  (h[5] = d[5]),
                  (h[6] = d[6]),
                  (h[7] = d[7]),
                  (h[8] = d[8]),
                  this
                );
              }
              set(c) {
                const d = this.data;
                return (
                  (d[0] = c[0]),
                  (d[1] = c[1]),
                  (d[2] = c[2]),
                  (d[3] = c[3]),
                  (d[4] = c[4]),
                  (d[5] = c[5]),
                  (d[6] = c[6]),
                  (d[7] = c[7]),
                  (d[8] = c[8]),
                  this
                );
              }
              equals(c) {
                const d = this.data,
                  h = c.data;
                return (
                  d[0] === h[0] &&
                  d[1] === h[1] &&
                  d[2] === h[2] &&
                  d[3] === h[3] &&
                  d[4] === h[4] &&
                  d[5] === h[5] &&
                  d[6] === h[6] &&
                  d[7] === h[7] &&
                  d[8] === h[8]
                );
              }
              isIdentity() {
                const c = this.data;
                return (
                  c[0] === 1 &&
                  c[1] === 0 &&
                  c[2] === 0 &&
                  c[3] === 0 &&
                  c[4] === 1 &&
                  c[5] === 0 &&
                  c[6] === 0 &&
                  c[7] === 0 &&
                  c[8] === 1
                );
              }
              setIdentity() {
                const c = this.data;
                return (
                  (c[0] = 1),
                  (c[1] = 0),
                  (c[2] = 0),
                  (c[3] = 0),
                  (c[4] = 1),
                  (c[5] = 0),
                  (c[6] = 0),
                  (c[7] = 0),
                  (c[8] = 1),
                  this
                );
              }
              toString() {
                return "[" + this.data.join(", ") + "]";
              }
              transpose() {
                const c = this.data;
                let d;
                return (
                  (d = c[1]),
                  (c[1] = c[3]),
                  (c[3] = d),
                  (d = c[2]),
                  (c[2] = c[6]),
                  (c[6] = d),
                  (d = c[5]),
                  (c[5] = c[7]),
                  (c[7] = d),
                  this
                );
              }
              setFromMat4(c) {
                const d = c.data,
                  h = this.data;
                return (
                  (h[0] = d[0]),
                  (h[1] = d[1]),
                  (h[2] = d[2]),
                  (h[3] = d[4]),
                  (h[4] = d[5]),
                  (h[5] = d[6]),
                  (h[6] = d[8]),
                  (h[7] = d[9]),
                  (h[8] = d[10]),
                  this
                );
              }
              transformVector(c, d = new x.A()) {
                const h = this.data,
                  f = c.x,
                  s = c.y,
                  l = c.z;
                return (
                  (d.x = f * h[0] + s * h[3] + l * h[6]),
                  (d.y = f * h[1] + s * h[4] + l * h[7]),
                  (d.z = f * h[2] + s * h[5] + l * h[8]),
                  d
                );
              }
            }
            (T.IDENTITY = Object.freeze(new T())),
              (T.ZERO = Object.freeze(
                new T().set([0, 0, 0, 0, 0, 0, 0, 0, 0])
              ));
          },
          9758: (Se, W, a) => {
            "use strict";
            a.d(W, { y: () => n });
            var x = a(4585),
              T = a(2978),
              g = a(6556),
              c = a(6630);
            const d = new T.S(),
              h = new g.A(),
              f = new g.A(),
              s = new g.A(),
              l = new g.A();
            class n {
              constructor() {
                (this.data = new Float32Array(16)),
                  (this.data[0] =
                    this.data[5] =
                    this.data[10] =
                    this.data[15] =
                      1);
              }
              static _getPerspectiveHalfSize(i, e, t, r, u) {
                u
                  ? ((i.x = r * Math.tan((e * Math.PI) / 360)), (i.y = i.x / t))
                  : ((i.y = r * Math.tan((e * Math.PI) / 360)),
                    (i.x = i.y * t));
              }
              add2(i, e) {
                const t = i.data,
                  r = e.data,
                  u = this.data;
                return (
                  (u[0] = t[0] + r[0]),
                  (u[1] = t[1] + r[1]),
                  (u[2] = t[2] + r[2]),
                  (u[3] = t[3] + r[3]),
                  (u[4] = t[4] + r[4]),
                  (u[5] = t[5] + r[5]),
                  (u[6] = t[6] + r[6]),
                  (u[7] = t[7] + r[7]),
                  (u[8] = t[8] + r[8]),
                  (u[9] = t[9] + r[9]),
                  (u[10] = t[10] + r[10]),
                  (u[11] = t[11] + r[11]),
                  (u[12] = t[12] + r[12]),
                  (u[13] = t[13] + r[13]),
                  (u[14] = t[14] + r[14]),
                  (u[15] = t[15] + r[15]),
                  this
                );
              }
              add(i) {
                return this.add2(this, i);
              }
              clone() {
                const i = this.constructor;
                return new i().copy(this);
              }
              copy(i) {
                const e = i.data,
                  t = this.data;
                return (
                  (t[0] = e[0]),
                  (t[1] = e[1]),
                  (t[2] = e[2]),
                  (t[3] = e[3]),
                  (t[4] = e[4]),
                  (t[5] = e[5]),
                  (t[6] = e[6]),
                  (t[7] = e[7]),
                  (t[8] = e[8]),
                  (t[9] = e[9]),
                  (t[10] = e[10]),
                  (t[11] = e[11]),
                  (t[12] = e[12]),
                  (t[13] = e[13]),
                  (t[14] = e[14]),
                  (t[15] = e[15]),
                  this
                );
              }
              equals(i) {
                const e = this.data,
                  t = i.data;
                return (
                  e[0] === t[0] &&
                  e[1] === t[1] &&
                  e[2] === t[2] &&
                  e[3] === t[3] &&
                  e[4] === t[4] &&
                  e[5] === t[5] &&
                  e[6] === t[6] &&
                  e[7] === t[7] &&
                  e[8] === t[8] &&
                  e[9] === t[9] &&
                  e[10] === t[10] &&
                  e[11] === t[11] &&
                  e[12] === t[12] &&
                  e[13] === t[13] &&
                  e[14] === t[14] &&
                  e[15] === t[15]
                );
              }
              isIdentity() {
                const i = this.data;
                return (
                  i[0] === 1 &&
                  i[1] === 0 &&
                  i[2] === 0 &&
                  i[3] === 0 &&
                  i[4] === 0 &&
                  i[5] === 1 &&
                  i[6] === 0 &&
                  i[7] === 0 &&
                  i[8] === 0 &&
                  i[9] === 0 &&
                  i[10] === 1 &&
                  i[11] === 0 &&
                  i[12] === 0 &&
                  i[13] === 0 &&
                  i[14] === 0 &&
                  i[15] === 1
                );
              }
              mul2(i, e) {
                const t = i.data,
                  r = e.data,
                  u = this.data,
                  y = t[0],
                  p = t[1],
                  _ = t[2],
                  m = t[3],
                  E = t[4],
                  v = t[5],
                  P = t[6],
                  I = t[7],
                  A = t[8],
                  B = t[9],
                  C = t[10],
                  w = t[11],
                  k = t[12],
                  K = t[13],
                  te = t[14],
                  X = t[15];
                let $, ne, Y, Z;
                return (
                  ($ = r[0]),
                  (ne = r[1]),
                  (Y = r[2]),
                  (Z = r[3]),
                  (u[0] = y * $ + E * ne + A * Y + k * Z),
                  (u[1] = p * $ + v * ne + B * Y + K * Z),
                  (u[2] = _ * $ + P * ne + C * Y + te * Z),
                  (u[3] = m * $ + I * ne + w * Y + X * Z),
                  ($ = r[4]),
                  (ne = r[5]),
                  (Y = r[6]),
                  (Z = r[7]),
                  (u[4] = y * $ + E * ne + A * Y + k * Z),
                  (u[5] = p * $ + v * ne + B * Y + K * Z),
                  (u[6] = _ * $ + P * ne + C * Y + te * Z),
                  (u[7] = m * $ + I * ne + w * Y + X * Z),
                  ($ = r[8]),
                  (ne = r[9]),
                  (Y = r[10]),
                  (Z = r[11]),
                  (u[8] = y * $ + E * ne + A * Y + k * Z),
                  (u[9] = p * $ + v * ne + B * Y + K * Z),
                  (u[10] = _ * $ + P * ne + C * Y + te * Z),
                  (u[11] = m * $ + I * ne + w * Y + X * Z),
                  ($ = r[12]),
                  (ne = r[13]),
                  (Y = r[14]),
                  (Z = r[15]),
                  (u[12] = y * $ + E * ne + A * Y + k * Z),
                  (u[13] = p * $ + v * ne + B * Y + K * Z),
                  (u[14] = _ * $ + P * ne + C * Y + te * Z),
                  (u[15] = m * $ + I * ne + w * Y + X * Z),
                  this
                );
              }
              mulAffine2(i, e) {
                const t = i.data,
                  r = e.data,
                  u = this.data,
                  y = t[0],
                  p = t[1],
                  _ = t[2],
                  m = t[4],
                  E = t[5],
                  v = t[6],
                  P = t[8],
                  I = t[9],
                  A = t[10],
                  B = t[12],
                  C = t[13],
                  w = t[14];
                let k, K, te;
                return (
                  (k = r[0]),
                  (K = r[1]),
                  (te = r[2]),
                  (u[0] = y * k + m * K + P * te),
                  (u[1] = p * k + E * K + I * te),
                  (u[2] = _ * k + v * K + A * te),
                  (u[3] = 0),
                  (k = r[4]),
                  (K = r[5]),
                  (te = r[6]),
                  (u[4] = y * k + m * K + P * te),
                  (u[5] = p * k + E * K + I * te),
                  (u[6] = _ * k + v * K + A * te),
                  (u[7] = 0),
                  (k = r[8]),
                  (K = r[9]),
                  (te = r[10]),
                  (u[8] = y * k + m * K + P * te),
                  (u[9] = p * k + E * K + I * te),
                  (u[10] = _ * k + v * K + A * te),
                  (u[11] = 0),
                  (k = r[12]),
                  (K = r[13]),
                  (te = r[14]),
                  (u[12] = y * k + m * K + P * te + B),
                  (u[13] = p * k + E * K + I * te + C),
                  (u[14] = _ * k + v * K + A * te + w),
                  (u[15] = 1),
                  this
                );
              }
              mul(i) {
                return this.mul2(this, i);
              }
              transformPoint(i, e = new g.A()) {
                const t = this.data,
                  r = i.x,
                  u = i.y,
                  y = i.z;
                return (
                  (e.x = r * t[0] + u * t[4] + y * t[8] + t[12]),
                  (e.y = r * t[1] + u * t[5] + y * t[9] + t[13]),
                  (e.z = r * t[2] + u * t[6] + y * t[10] + t[14]),
                  e
                );
              }
              transformVector(i, e = new g.A()) {
                const t = this.data,
                  r = i.x,
                  u = i.y,
                  y = i.z;
                return (
                  (e.x = r * t[0] + u * t[4] + y * t[8]),
                  (e.y = r * t[1] + u * t[5] + y * t[9]),
                  (e.z = r * t[2] + u * t[6] + y * t[10]),
                  e
                );
              }
              transformVec4(i, e = new c.T()) {
                const t = this.data,
                  r = i.x,
                  u = i.y,
                  y = i.z,
                  p = i.w;
                return (
                  (e.x = r * t[0] + u * t[4] + y * t[8] + p * t[12]),
                  (e.y = r * t[1] + u * t[5] + y * t[9] + p * t[13]),
                  (e.z = r * t[2] + u * t[6] + y * t[10] + p * t[14]),
                  (e.w = r * t[3] + u * t[7] + y * t[11] + p * t[15]),
                  e
                );
              }
              setLookAt(i, e, t) {
                s.sub2(i, e).normalize(),
                  f.copy(t).normalize(),
                  h.cross(f, s).normalize(),
                  f.cross(s, h);
                const r = this.data;
                return (
                  (r[0] = h.x),
                  (r[1] = h.y),
                  (r[2] = h.z),
                  (r[3] = 0),
                  (r[4] = f.x),
                  (r[5] = f.y),
                  (r[6] = f.z),
                  (r[7] = 0),
                  (r[8] = s.x),
                  (r[9] = s.y),
                  (r[10] = s.z),
                  (r[11] = 0),
                  (r[12] = i.x),
                  (r[13] = i.y),
                  (r[14] = i.z),
                  (r[15] = 1),
                  this
                );
              }
              setFrustum(i, e, t, r, u, y) {
                const p = 2 * u,
                  _ = e - i,
                  m = r - t,
                  E = y - u,
                  v = this.data;
                return (
                  (v[0] = p / _),
                  (v[1] = 0),
                  (v[2] = 0),
                  (v[3] = 0),
                  (v[4] = 0),
                  (v[5] = p / m),
                  (v[6] = 0),
                  (v[7] = 0),
                  (v[8] = (e + i) / _),
                  (v[9] = (r + t) / m),
                  (v[10] = (-y - u) / E),
                  (v[11] = -1),
                  (v[12] = 0),
                  (v[13] = 0),
                  (v[14] = (-p * y) / E),
                  (v[15] = 0),
                  this
                );
              }
              setPerspective(i, e, t, r, u) {
                return (
                  n._getPerspectiveHalfSize(d, i, e, t, u),
                  this.setFrustum(-d.x, d.x, -d.y, d.y, t, r)
                );
              }
              setOrtho(i, e, t, r, u, y) {
                const p = this.data;
                return (
                  (p[0] = 2 / (e - i)),
                  (p[1] = 0),
                  (p[2] = 0),
                  (p[3] = 0),
                  (p[4] = 0),
                  (p[5] = 2 / (r - t)),
                  (p[6] = 0),
                  (p[7] = 0),
                  (p[8] = 0),
                  (p[9] = 0),
                  (p[10] = -2 / (y - u)),
                  (p[11] = 0),
                  (p[12] = -(e + i) / (e - i)),
                  (p[13] = -(r + t) / (r - t)),
                  (p[14] = -(y + u) / (y - u)),
                  (p[15] = 1),
                  this
                );
              }
              setFromAxisAngle(i, e) {
                e *= x.m.DEG_TO_RAD;
                const t = i.x,
                  r = i.y,
                  u = i.z,
                  y = Math.cos(e),
                  p = Math.sin(e),
                  _ = 1 - y,
                  m = _ * t,
                  E = _ * r,
                  v = this.data;
                return (
                  (v[0] = m * t + y),
                  (v[1] = m * r + p * u),
                  (v[2] = m * u - p * r),
                  (v[3] = 0),
                  (v[4] = m * r - p * u),
                  (v[5] = E * r + y),
                  (v[6] = E * u + p * t),
                  (v[7] = 0),
                  (v[8] = m * u + p * r),
                  (v[9] = E * u - t * p),
                  (v[10] = _ * u * u + y),
                  (v[11] = 0),
                  (v[12] = 0),
                  (v[13] = 0),
                  (v[14] = 0),
                  (v[15] = 1),
                  this
                );
              }
              setTranslate(i, e, t) {
                const r = this.data;
                return (
                  (r[0] = 1),
                  (r[1] = 0),
                  (r[2] = 0),
                  (r[3] = 0),
                  (r[4] = 0),
                  (r[5] = 1),
                  (r[6] = 0),
                  (r[7] = 0),
                  (r[8] = 0),
                  (r[9] = 0),
                  (r[10] = 1),
                  (r[11] = 0),
                  (r[12] = i),
                  (r[13] = e),
                  (r[14] = t),
                  (r[15] = 1),
                  this
                );
              }
              setScale(i, e, t) {
                const r = this.data;
                return (
                  (r[0] = i),
                  (r[1] = 0),
                  (r[2] = 0),
                  (r[3] = 0),
                  (r[4] = 0),
                  (r[5] = e),
                  (r[6] = 0),
                  (r[7] = 0),
                  (r[8] = 0),
                  (r[9] = 0),
                  (r[10] = t),
                  (r[11] = 0),
                  (r[12] = 0),
                  (r[13] = 0),
                  (r[14] = 0),
                  (r[15] = 1),
                  this
                );
              }
              setViewport(i, e, t, r) {
                const u = this.data;
                return (
                  (u[0] = t * 0.5),
                  (u[1] = 0),
                  (u[2] = 0),
                  (u[3] = 0),
                  (u[4] = 0),
                  (u[5] = r * 0.5),
                  (u[6] = 0),
                  (u[7] = 0),
                  (u[8] = 0),
                  (u[9] = 0),
                  (u[10] = 0.5),
                  (u[11] = 0),
                  (u[12] = i + t * 0.5),
                  (u[13] = e + r * 0.5),
                  (u[14] = 0.5),
                  (u[15] = 1),
                  this
                );
              }
              setReflection(i, e) {
                const t = i.x,
                  r = i.y,
                  u = i.z,
                  y = this.data;
                return (
                  (y[0] = 1 - 2 * t * t),
                  (y[1] = -2 * t * r),
                  (y[2] = -2 * t * u),
                  (y[3] = 0),
                  (y[4] = -2 * t * r),
                  (y[5] = 1 - 2 * r * r),
                  (y[6] = -2 * r * u),
                  (y[7] = 0),
                  (y[8] = -2 * t * u),
                  (y[9] = -2 * r * u),
                  (y[10] = 1 - 2 * u * u),
                  (y[11] = 0),
                  (y[12] = -2 * t * e),
                  (y[13] = -2 * r * e),
                  (y[14] = -2 * u * e),
                  (y[15] = 1),
                  this
                );
              }
              invert() {
                const i = this.data,
                  e = i[0],
                  t = i[1],
                  r = i[2],
                  u = i[3],
                  y = i[4],
                  p = i[5],
                  _ = i[6],
                  m = i[7],
                  E = i[8],
                  v = i[9],
                  P = i[10],
                  I = i[11],
                  A = i[12],
                  B = i[13],
                  C = i[14],
                  w = i[15],
                  k = e * p - t * y,
                  K = e * _ - r * y,
                  te = e * m - u * y,
                  X = t * _ - r * p,
                  $ = t * m - u * p,
                  ne = r * m - u * _,
                  Y = E * B - v * A,
                  Z = E * C - P * A,
                  ye = E * w - I * A,
                  pe = v * C - P * B,
                  O = v * w - I * B,
                  me = P * w - I * C,
                  N = k * me - K * O + te * pe + X * ye - $ * Z + ne * Y;
                if (N === 0) this.setIdentity();
                else {
                  const V = 1 / N;
                  (i[0] = (p * me - _ * O + m * pe) * V),
                    (i[1] = (-t * me + r * O - u * pe) * V),
                    (i[2] = (B * ne - C * $ + w * X) * V),
                    (i[3] = (-v * ne + P * $ - I * X) * V),
                    (i[4] = (-y * me + _ * ye - m * Z) * V),
                    (i[5] = (e * me - r * ye + u * Z) * V),
                    (i[6] = (-A * ne + C * te - w * K) * V),
                    (i[7] = (E * ne - P * te + I * K) * V),
                    (i[8] = (y * O - p * ye + m * Y) * V),
                    (i[9] = (-e * O + t * ye - u * Y) * V),
                    (i[10] = (A * $ - B * te + w * k) * V),
                    (i[11] = (-E * $ + v * te - I * k) * V),
                    (i[12] = (-y * pe + p * Z - _ * Y) * V),
                    (i[13] = (e * pe - t * Z + r * Y) * V),
                    (i[14] = (-A * X + B * K - C * k) * V),
                    (i[15] = (E * X - v * K + P * k) * V);
                }
                return this;
              }
              set(i) {
                const e = this.data;
                return (
                  (e[0] = i[0]),
                  (e[1] = i[1]),
                  (e[2] = i[2]),
                  (e[3] = i[3]),
                  (e[4] = i[4]),
                  (e[5] = i[5]),
                  (e[6] = i[6]),
                  (e[7] = i[7]),
                  (e[8] = i[8]),
                  (e[9] = i[9]),
                  (e[10] = i[10]),
                  (e[11] = i[11]),
                  (e[12] = i[12]),
                  (e[13] = i[13]),
                  (e[14] = i[14]),
                  (e[15] = i[15]),
                  this
                );
              }
              setIdentity() {
                const i = this.data;
                return (
                  (i[0] = 1),
                  (i[1] = 0),
                  (i[2] = 0),
                  (i[3] = 0),
                  (i[4] = 0),
                  (i[5] = 1),
                  (i[6] = 0),
                  (i[7] = 0),
                  (i[8] = 0),
                  (i[9] = 0),
                  (i[10] = 1),
                  (i[11] = 0),
                  (i[12] = 0),
                  (i[13] = 0),
                  (i[14] = 0),
                  (i[15] = 1),
                  this
                );
              }
              setTRS(i, e, t) {
                const r = e.x,
                  u = e.y,
                  y = e.z,
                  p = e.w,
                  _ = t.x,
                  m = t.y,
                  E = t.z,
                  v = r + r,
                  P = u + u,
                  I = y + y,
                  A = r * v,
                  B = r * P,
                  C = r * I,
                  w = u * P,
                  k = u * I,
                  K = y * I,
                  te = p * v,
                  X = p * P,
                  $ = p * I,
                  ne = this.data;
                return (
                  (ne[0] = (1 - (w + K)) * _),
                  (ne[1] = (B + $) * _),
                  (ne[2] = (C - X) * _),
                  (ne[3] = 0),
                  (ne[4] = (B - $) * m),
                  (ne[5] = (1 - (A + K)) * m),
                  (ne[6] = (k + te) * m),
                  (ne[7] = 0),
                  (ne[8] = (C + X) * E),
                  (ne[9] = (k - te) * E),
                  (ne[10] = (1 - (A + w)) * E),
                  (ne[11] = 0),
                  (ne[12] = i.x),
                  (ne[13] = i.y),
                  (ne[14] = i.z),
                  (ne[15] = 1),
                  this
                );
              }
              transpose() {
                let i;
                const e = this.data;
                return (
                  (i = e[1]),
                  (e[1] = e[4]),
                  (e[4] = i),
                  (i = e[2]),
                  (e[2] = e[8]),
                  (e[8] = i),
                  (i = e[3]),
                  (e[3] = e[12]),
                  (e[12] = i),
                  (i = e[6]),
                  (e[6] = e[9]),
                  (e[9] = i),
                  (i = e[7]),
                  (e[7] = e[13]),
                  (e[13] = i),
                  (i = e[11]),
                  (e[11] = e[14]),
                  (e[14] = i),
                  this
                );
              }
              invertTo3x3(i) {
                const e = this.data,
                  t = i.data,
                  r = e[0],
                  u = e[1],
                  y = e[2],
                  p = e[4],
                  _ = e[5],
                  m = e[6],
                  E = e[8],
                  v = e[9],
                  P = e[10],
                  I = P * _ - m * v,
                  A = -P * u + y * v,
                  B = m * u - y * _,
                  C = -P * p + m * E,
                  w = P * r - y * E,
                  k = -m * r + y * p,
                  K = v * p - _ * E,
                  te = -v * r + u * E,
                  X = _ * r - u * p,
                  $ = r * I + u * C + y * K;
                if ($ === 0) return this;
                const ne = 1 / $;
                return (
                  (t[0] = ne * I),
                  (t[1] = ne * A),
                  (t[2] = ne * B),
                  (t[3] = ne * C),
                  (t[4] = ne * w),
                  (t[5] = ne * k),
                  (t[6] = ne * K),
                  (t[7] = ne * te),
                  (t[8] = ne * X),
                  this
                );
              }
              getTranslation(i = new g.A()) {
                return i.set(this.data[12], this.data[13], this.data[14]);
              }
              getX(i = new g.A()) {
                return i.set(this.data[0], this.data[1], this.data[2]);
              }
              getY(i = new g.A()) {
                return i.set(this.data[4], this.data[5], this.data[6]);
              }
              getZ(i = new g.A()) {
                return i.set(this.data[8], this.data[9], this.data[10]);
              }
              getScale(i = new g.A()) {
                return (
                  this.getX(h),
                  this.getY(f),
                  this.getZ(s),
                  i.set(h.length(), f.length(), s.length()),
                  i
                );
              }
              get scaleSign() {
                return (
                  this.getX(h),
                  this.getY(f),
                  this.getZ(s),
                  h.cross(h, f),
                  h.dot(s) < 0 ? -1 : 1
                );
              }
              setFromEulerAngles(i, e, t) {
                (i *= x.m.DEG_TO_RAD),
                  (e *= x.m.DEG_TO_RAD),
                  (t *= x.m.DEG_TO_RAD);
                const r = Math.sin(-i),
                  u = Math.cos(-i),
                  y = Math.sin(-e),
                  p = Math.cos(-e),
                  _ = Math.sin(-t),
                  m = Math.cos(-t),
                  E = this.data;
                return (
                  (E[0] = p * m),
                  (E[1] = -p * _),
                  (E[2] = y),
                  (E[3] = 0),
                  (E[4] = u * _ + m * r * y),
                  (E[5] = u * m - r * y * _),
                  (E[6] = -p * r),
                  (E[7] = 0),
                  (E[8] = r * _ - u * m * y),
                  (E[9] = m * r + u * y * _),
                  (E[10] = u * p),
                  (E[11] = 0),
                  (E[12] = 0),
                  (E[13] = 0),
                  (E[14] = 0),
                  (E[15] = 1),
                  this
                );
              }
              getEulerAngles(i = new g.A()) {
                this.getScale(l);
                const e = l.x,
                  t = l.y,
                  r = l.z;
                if (e === 0 || t === 0 || r === 0) return i.set(0, 0, 0);
                const u = this.data,
                  y = Math.asin(-u[2] / e),
                  p = Math.PI * 0.5;
                let _, m;
                return (
                  y < p
                    ? y > -p
                      ? ((_ = Math.atan2(u[6] / t, u[10] / r)),
                        (m = Math.atan2(u[1] / e, u[0] / e)))
                      : ((m = 0), (_ = -Math.atan2(u[4] / t, u[5] / t)))
                    : ((m = 0), (_ = Math.atan2(u[4] / t, u[5] / t))),
                  i.set(_, y, m).mulScalar(x.m.RAD_TO_DEG)
                );
              }
              toString() {
                return "[" + this.data.join(", ") + "]";
              }
            }
            (n.IDENTITY = Object.freeze(new n())),
              (n.ZERO = Object.freeze(
                new n().set([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
              ));
          },
          4585: (Se, W, a) => {
            "use strict";
            a.d(W, { m: () => x });
            const x = {
              DEG_TO_RAD: Math.PI / 180,
              RAD_TO_DEG: 180 / Math.PI,
              clamp: function (T, g, c) {
                return T >= c ? c : T <= g ? g : T;
              },
              intToBytes24: function (T) {
                const g = (T >> 16) & 255,
                  c = (T >> 8) & 255,
                  d = T & 255;
                return [g, c, d];
              },
              intToBytes32: function (T) {
                const g = (T >> 24) & 255,
                  c = (T >> 16) & 255,
                  d = (T >> 8) & 255,
                  h = T & 255;
                return [g, c, d, h];
              },
              bytesToInt24: function (T, g, c) {
                return (
                  T.length && ((c = T[2]), (g = T[1]), (T = T[0])),
                  (T << 16) | (g << 8) | c
                );
              },
              bytesToInt32: function (T, g, c, d) {
                return (
                  T.length && ((d = T[3]), (c = T[2]), (g = T[1]), (T = T[0])),
                  ((T << 24) | (g << 16) | (c << 8) | d) >>> 0
                );
              },
              lerp: function (T, g, c) {
                return T + (g - T) * x.clamp(c, 0, 1);
              },
              lerpAngle: function (T, g, c) {
                return (
                  g - T > 180 && (g -= 360),
                  g - T < -180 && (g += 360),
                  x.lerp(T, g, x.clamp(c, 0, 1))
                );
              },
              powerOfTwo: function (T) {
                return T !== 0 && !(T & (T - 1));
              },
              nextPowerOfTwo: function (T) {
                return (
                  T--,
                  (T |= T >> 1),
                  (T |= T >> 2),
                  (T |= T >> 4),
                  (T |= T >> 8),
                  (T |= T >> 16),
                  T++,
                  T
                );
              },
              nearestPowerOfTwo: function (T) {
                return Math.pow(2, Math.round(Math.log(T) / Math.log(2)));
              },
              random: function (T, g) {
                const c = g - T;
                return Math.random() * c + T;
              },
              smoothstep: function (T, g, c) {
                return c <= T
                  ? 0
                  : c >= g
                  ? 1
                  : ((c = (c - T) / (g - T)), c * c * (3 - 2 * c));
              },
              smootherstep: function (T, g, c) {
                return c <= T
                  ? 0
                  : c >= g
                  ? 1
                  : ((c = (c - T) / (g - T)),
                    c * c * c * (c * (c * 6 - 15) + 10));
              },
              roundUp: function (T, g) {
                return g === 0 ? T : Math.ceil(T / g) * g;
              },
              between: function (T, g, c, d) {
                const h = Math.min(g, c),
                  f = Math.max(g, c);
                return d ? T >= h && T <= f : T > h && T < f;
              },
            };
          },
          6847: (Se, W, a) => {
            "use strict";
            a.d(W, { D: () => g });
            var x = a(4585),
              T = a(6556);
            class g {
              constructor(d = 0, h = 0, f = 0, s = 1) {
                (this.x = void 0),
                  (this.y = void 0),
                  (this.z = void 0),
                  (this.w = void 0),
                  d.length === 4
                    ? ((this.x = d[0]),
                      (this.y = d[1]),
                      (this.z = d[2]),
                      (this.w = d[3]))
                    : ((this.x = d), (this.y = h), (this.z = f), (this.w = s));
              }
              clone() {
                const d = this.constructor;
                return new d(this.x, this.y, this.z, this.w);
              }
              conjugate() {
                return (this.x *= -1), (this.y *= -1), (this.z *= -1), this;
              }
              copy(d) {
                return (
                  (this.x = d.x),
                  (this.y = d.y),
                  (this.z = d.z),
                  (this.w = d.w),
                  this
                );
              }
              equals(d) {
                return (
                  this.x === d.x &&
                  this.y === d.y &&
                  this.z === d.z &&
                  this.w === d.w
                );
              }
              equalsApprox(d, h = 1e-6) {
                return (
                  Math.abs(this.x - d.x) < h &&
                  Math.abs(this.y - d.y) < h &&
                  Math.abs(this.z - d.z) < h &&
                  Math.abs(this.w - d.w) < h
                );
              }
              getAxisAngle(d) {
                let h = Math.acos(this.w) * 2;
                const f = Math.sin(h / 2);
                return (
                  f !== 0
                    ? ((d.x = this.x / f),
                      (d.y = this.y / f),
                      (d.z = this.z / f),
                      (d.x < 0 || d.y < 0 || d.z < 0) &&
                        ((d.x *= -1), (d.y *= -1), (d.z *= -1), (h *= -1)))
                    : ((d.x = 1), (d.y = 0), (d.z = 0)),
                  h * x.m.RAD_TO_DEG
                );
              }
              getEulerAngles(d = new T.A()) {
                let h, f, s;
                const l = this.x,
                  n = this.y,
                  o = this.z,
                  i = this.w,
                  e = 2 * (i * n - l * o);
                return (
                  e <= -0.99999
                    ? ((h = 2 * Math.atan2(l, i)), (f = -Math.PI / 2), (s = 0))
                    : e >= 0.99999
                    ? ((h = 2 * Math.atan2(l, i)), (f = Math.PI / 2), (s = 0))
                    : ((h = Math.atan2(
                        2 * (i * l + n * o),
                        1 - 2 * (l * l + n * n)
                      )),
                      (f = Math.asin(e)),
                      (s = Math.atan2(
                        2 * (i * o + l * n),
                        1 - 2 * (n * n + o * o)
                      ))),
                  d.set(h, f, s).mulScalar(x.m.RAD_TO_DEG)
                );
              }
              invert() {
                return this.conjugate().normalize();
              }
              length() {
                return Math.sqrt(
                  this.x * this.x +
                    this.y * this.y +
                    this.z * this.z +
                    this.w * this.w
                );
              }
              lengthSq() {
                return (
                  this.x * this.x +
                  this.y * this.y +
                  this.z * this.z +
                  this.w * this.w
                );
              }
              mul(d) {
                const h = this.x,
                  f = this.y,
                  s = this.z,
                  l = this.w,
                  n = d.x,
                  o = d.y,
                  i = d.z,
                  e = d.w;
                return (
                  (this.x = l * n + h * e + f * i - s * o),
                  (this.y = l * o + f * e + s * n - h * i),
                  (this.z = l * i + s * e + h * o - f * n),
                  (this.w = l * e - h * n - f * o - s * i),
                  this
                );
              }
              mul2(d, h) {
                const f = d.x,
                  s = d.y,
                  l = d.z,
                  n = d.w,
                  o = h.x,
                  i = h.y,
                  e = h.z,
                  t = h.w;
                return (
                  (this.x = n * o + f * t + s * e - l * i),
                  (this.y = n * i + s * t + l * o - f * e),
                  (this.z = n * e + l * t + f * i - s * o),
                  (this.w = n * t - f * o - s * i - l * e),
                  this
                );
              }
              normalize() {
                let d = this.length();
                return (
                  d === 0
                    ? ((this.x = this.y = this.z = 0), (this.w = 1))
                    : ((d = 1 / d),
                      (this.x *= d),
                      (this.y *= d),
                      (this.z *= d),
                      (this.w *= d)),
                  this
                );
              }
              set(d, h, f, s) {
                return (
                  (this.x = d), (this.y = h), (this.z = f), (this.w = s), this
                );
              }
              setFromAxisAngle(d, h) {
                h *= 0.5 * x.m.DEG_TO_RAD;
                const f = Math.sin(h),
                  s = Math.cos(h);
                return (
                  (this.x = f * d.x),
                  (this.y = f * d.y),
                  (this.z = f * d.z),
                  (this.w = s),
                  this
                );
              }
              setFromEulerAngles(d, h, f) {
                if (d instanceof T.A) {
                  const r = d;
                  (d = r.x), (h = r.y), (f = r.z);
                }
                const s = 0.5 * x.m.DEG_TO_RAD;
                (d *= s), (h *= s), (f *= s);
                const l = Math.sin(d),
                  n = Math.cos(d),
                  o = Math.sin(h),
                  i = Math.cos(h),
                  e = Math.sin(f),
                  t = Math.cos(f);
                return (
                  (this.x = l * i * t - n * o * e),
                  (this.y = n * o * t + l * i * e),
                  (this.z = n * i * e - l * o * t),
                  (this.w = n * i * t + l * o * e),
                  this
                );
              }
              setFromMat4(d) {
                let h, f, s, l, n, o, i, e, t, r, u, y, p, _;
                if (
                  ((d = d.data),
                  (h = d[0]),
                  (f = d[1]),
                  (s = d[2]),
                  (l = d[4]),
                  (n = d[5]),
                  (o = d[6]),
                  (i = d[8]),
                  (e = d[9]),
                  (t = d[10]),
                  (y = h * h + f * f + s * s),
                  y === 0)
                )
                  return this;
                if (
                  ((y = 1 / Math.sqrt(y)), (p = l * l + n * n + o * o), p === 0)
                )
                  return this;
                if (
                  ((p = 1 / Math.sqrt(p)), (_ = i * i + e * e + t * t), _ === 0)
                )
                  return this;
                (_ = 1 / Math.sqrt(_)),
                  (h *= y),
                  (f *= y),
                  (s *= y),
                  (l *= p),
                  (n *= p),
                  (o *= p),
                  (i *= _),
                  (e *= _),
                  (t *= _);
                const m = h + n + t;
                return (
                  m >= 0
                    ? ((r = Math.sqrt(m + 1)),
                      (this.w = r * 0.5),
                      (r = 0.5 / r),
                      (this.x = (o - e) * r),
                      (this.y = (i - s) * r),
                      (this.z = (f - l) * r))
                    : h > n
                    ? h > t
                      ? ((u = h - (n + t) + 1),
                        (u = Math.sqrt(u)),
                        (this.x = u * 0.5),
                        (u = 0.5 / u),
                        (this.w = (o - e) * u),
                        (this.y = (f + l) * u),
                        (this.z = (s + i) * u))
                      : ((u = t - (h + n) + 1),
                        (u = Math.sqrt(u)),
                        (this.z = u * 0.5),
                        (u = 0.5 / u),
                        (this.w = (f - l) * u),
                        (this.x = (i + s) * u),
                        (this.y = (e + o) * u))
                    : n > t
                    ? ((u = n - (t + h) + 1),
                      (u = Math.sqrt(u)),
                      (this.y = u * 0.5),
                      (u = 0.5 / u),
                      (this.w = (i - s) * u),
                      (this.z = (o + e) * u),
                      (this.x = (l + f) * u))
                    : ((u = t - (h + n) + 1),
                      (u = Math.sqrt(u)),
                      (this.z = u * 0.5),
                      (u = 0.5 / u),
                      (this.w = (f - l) * u),
                      (this.x = (i + s) * u),
                      (this.y = (e + o) * u)),
                  this
                );
              }
              setFromDirections(d, h) {
                const f = 1 + d.dot(h);
                return (
                  f < Number.EPSILON
                    ? Math.abs(d.x) > Math.abs(d.y)
                      ? ((this.x = -d.z),
                        (this.y = 0),
                        (this.z = d.x),
                        (this.w = 0))
                      : ((this.x = 0),
                        (this.y = -d.z),
                        (this.z = d.y),
                        (this.w = 0))
                    : ((this.x = d.y * h.z - d.z * h.y),
                      (this.y = d.z * h.x - d.x * h.z),
                      (this.z = d.x * h.y - d.y * h.x),
                      (this.w = f)),
                  this.normalize()
                );
              }
              slerp(d, h, f) {
                const s = d.x,
                  l = d.y,
                  n = d.z,
                  o = d.w;
                let i = h.x,
                  e = h.y,
                  t = h.z,
                  r = h.w,
                  u = o * r + s * i + l * e + n * t;
                if (
                  (u < 0 && ((r = -r), (i = -i), (e = -e), (t = -t), (u = -u)),
                  Math.abs(u) >= 1)
                )
                  return (
                    (this.w = o), (this.x = s), (this.y = l), (this.z = n), this
                  );
                const y = Math.acos(u),
                  p = Math.sqrt(1 - u * u);
                if (Math.abs(p) < 0.001)
                  return (
                    (this.w = o * 0.5 + r * 0.5),
                    (this.x = s * 0.5 + i * 0.5),
                    (this.y = l * 0.5 + e * 0.5),
                    (this.z = n * 0.5 + t * 0.5),
                    this
                  );
                const _ = Math.sin((1 - f) * y) / p,
                  m = Math.sin(f * y) / p;
                return (
                  (this.w = o * _ + r * m),
                  (this.x = s * _ + i * m),
                  (this.y = l * _ + e * m),
                  (this.z = n * _ + t * m),
                  this
                );
              }
              transformVector(d, h = new T.A()) {
                const f = d.x,
                  s = d.y,
                  l = d.z,
                  n = this.x,
                  o = this.y,
                  i = this.z,
                  e = this.w,
                  t = e * f + o * l - i * s,
                  r = e * s + i * f - n * l,
                  u = e * l + n * s - o * f,
                  y = -n * f - o * s - i * l;
                return (
                  (h.x = t * e + y * -n + r * -i - u * -o),
                  (h.y = r * e + y * -o + u * -n - t * -i),
                  (h.z = u * e + y * -i + t * -o - r * -n),
                  h
                );
              }
              toString() {
                return `[${this.x}, ${this.y}, ${this.z}, ${this.w}]`;
              }
            }
            (g.IDENTITY = Object.freeze(new g(0, 0, 0, 1))),
              (g.ZERO = Object.freeze(new g(0, 0, 0, 0)));
          },
          14: (Se, W, a) => {
            "use strict";
            a.d(W, { M: () => g });
            var x = a(4585);
            const T = 2.399963229728653,
              g = {
                circlePoint: function (c) {
                  const d = Math.sqrt(Math.random()),
                    h = Math.random() * 2 * Math.PI;
                  (c.x = d * Math.cos(h)), (c.y = d * Math.sin(h));
                },
                circlePointDeterministic: function (c, d, h) {
                  const f = d * T,
                    s = Math.sqrt(d) / Math.sqrt(h);
                  (c.x = s * Math.cos(f)), (c.y = s * Math.sin(f));
                },
                spherePointDeterministic: function (c, d, h, f = 0, s = 1) {
                  (f = 1 - 2 * f), (s = 1 - 2 * s);
                  const l = x.m.lerp(f, s, d / h),
                    n = Math.sqrt(1 - l * l),
                    o = T * d;
                  (c.x = Math.cos(o) * n), (c.y = l), (c.z = Math.sin(o) * n);
                },
                radicalInverse: function (c) {
                  let d = ((c << 16) | (c >>> 16)) >>> 0;
                  return (
                    (d =
                      (((d & 1431655765) << 1) | ((d & 2863311530) >>> 1)) >>>
                      0),
                    (d =
                      (((d & 858993459) << 2) | ((d & 3435973836) >>> 2)) >>>
                      0),
                    (d =
                      (((d & 252645135) << 4) | ((d & 4042322160) >>> 4)) >>>
                      0),
                    (d =
                      (((d & 16711935) << 8) | ((d & 4278255360) >>> 8)) >>> 0),
                    d * 23283064365386963e-26
                  );
                },
              };
          },
          2978: (Se, W, a) => {
            "use strict";
            a.d(W, { S: () => x });
            class x {
              constructor(g = 0, c = 0) {
                (this.x = void 0),
                  (this.y = void 0),
                  g.length === 2
                    ? ((this.x = g[0]), (this.y = g[1]))
                    : ((this.x = g), (this.y = c));
              }
              add(g) {
                return (this.x += g.x), (this.y += g.y), this;
              }
              add2(g, c) {
                return (this.x = g.x + c.x), (this.y = g.y + c.y), this;
              }
              addScalar(g) {
                return (this.x += g), (this.y += g), this;
              }
              clone() {
                const g = this.constructor;
                return new g(this.x, this.y);
              }
              copy(g) {
                return (this.x = g.x), (this.y = g.y), this;
              }
              cross(g) {
                return this.x * g.y - this.y * g.x;
              }
              distance(g) {
                const c = this.x - g.x,
                  d = this.y - g.y;
                return Math.sqrt(c * c + d * d);
              }
              div(g) {
                return (this.x /= g.x), (this.y /= g.y), this;
              }
              div2(g, c) {
                return (this.x = g.x / c.x), (this.y = g.y / c.y), this;
              }
              divScalar(g) {
                return (this.x /= g), (this.y /= g), this;
              }
              dot(g) {
                return this.x * g.x + this.y * g.y;
              }
              equals(g) {
                return this.x === g.x && this.y === g.y;
              }
              length() {
                return Math.sqrt(this.x * this.x + this.y * this.y);
              }
              lengthSq() {
                return this.x * this.x + this.y * this.y;
              }
              lerp(g, c, d) {
                return (
                  (this.x = g.x + d * (c.x - g.x)),
                  (this.y = g.y + d * (c.y - g.y)),
                  this
                );
              }
              mul(g) {
                return (this.x *= g.x), (this.y *= g.y), this;
              }
              mul2(g, c) {
                return (this.x = g.x * c.x), (this.y = g.y * c.y), this;
              }
              mulScalar(g) {
                return (this.x *= g), (this.y *= g), this;
              }
              normalize() {
                const g = this.x * this.x + this.y * this.y;
                if (g > 0) {
                  const c = 1 / Math.sqrt(g);
                  (this.x *= c), (this.y *= c);
                }
                return this;
              }
              floor() {
                return (
                  (this.x = Math.floor(this.x)),
                  (this.y = Math.floor(this.y)),
                  this
                );
              }
              ceil() {
                return (
                  (this.x = Math.ceil(this.x)),
                  (this.y = Math.ceil(this.y)),
                  this
                );
              }
              round() {
                return (
                  (this.x = Math.round(this.x)),
                  (this.y = Math.round(this.y)),
                  this
                );
              }
              min(g) {
                return (
                  g.x < this.x && (this.x = g.x),
                  g.y < this.y && (this.y = g.y),
                  this
                );
              }
              max(g) {
                return (
                  g.x > this.x && (this.x = g.x),
                  g.y > this.y && (this.y = g.y),
                  this
                );
              }
              set(g, c) {
                return (this.x = g), (this.y = c), this;
              }
              sub(g) {
                return (this.x -= g.x), (this.y -= g.y), this;
              }
              sub2(g, c) {
                return (this.x = g.x - c.x), (this.y = g.y - c.y), this;
              }
              subScalar(g) {
                return (this.x -= g), (this.y -= g), this;
              }
              toString() {
                return `[${this.x}, ${this.y}]`;
              }
              static angleRad(g, c) {
                return Math.atan2(g.x * c.y - g.y * c.x, g.x * c.x + g.y * c.y);
              }
            }
            (x.ZERO = Object.freeze(new x(0, 0))),
              (x.ONE = Object.freeze(new x(1, 1))),
              (x.UP = Object.freeze(new x(0, 1))),
              (x.DOWN = Object.freeze(new x(0, -1))),
              (x.RIGHT = Object.freeze(new x(1, 0))),
              (x.LEFT = Object.freeze(new x(-1, 0)));
          },
          6556: (Se, W, a) => {
            "use strict";
            a.d(W, { A: () => x });
            class x {
              constructor(g = 0, c = 0, d = 0) {
                (this.x = void 0),
                  (this.y = void 0),
                  (this.z = void 0),
                  g.length === 3
                    ? ((this.x = g[0]), (this.y = g[1]), (this.z = g[2]))
                    : ((this.x = g), (this.y = c), (this.z = d));
              }
              add(g) {
                return (this.x += g.x), (this.y += g.y), (this.z += g.z), this;
              }
              add2(g, c) {
                return (
                  (this.x = g.x + c.x),
                  (this.y = g.y + c.y),
                  (this.z = g.z + c.z),
                  this
                );
              }
              addScalar(g) {
                return (this.x += g), (this.y += g), (this.z += g), this;
              }
              clone() {
                const g = this.constructor;
                return new g(this.x, this.y, this.z);
              }
              copy(g) {
                return (this.x = g.x), (this.y = g.y), (this.z = g.z), this;
              }
              cross(g, c) {
                const d = g.x,
                  h = g.y,
                  f = g.z,
                  s = c.x,
                  l = c.y,
                  n = c.z;
                return (
                  (this.x = h * n - l * f),
                  (this.y = f * s - n * d),
                  (this.z = d * l - s * h),
                  this
                );
              }
              distance(g) {
                const c = this.x - g.x,
                  d = this.y - g.y,
                  h = this.z - g.z;
                return Math.sqrt(c * c + d * d + h * h);
              }
              div(g) {
                return (this.x /= g.x), (this.y /= g.y), (this.z /= g.z), this;
              }
              div2(g, c) {
                return (
                  (this.x = g.x / c.x),
                  (this.y = g.y / c.y),
                  (this.z = g.z / c.z),
                  this
                );
              }
              divScalar(g) {
                return (this.x /= g), (this.y /= g), (this.z /= g), this;
              }
              dot(g) {
                return this.x * g.x + this.y * g.y + this.z * g.z;
              }
              equals(g) {
                return this.x === g.x && this.y === g.y && this.z === g.z;
              }
              length() {
                return Math.sqrt(
                  this.x * this.x + this.y * this.y + this.z * this.z
                );
              }
              lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z;
              }
              lerp(g, c, d) {
                return (
                  (this.x = g.x + d * (c.x - g.x)),
                  (this.y = g.y + d * (c.y - g.y)),
                  (this.z = g.z + d * (c.z - g.z)),
                  this
                );
              }
              mul(g) {
                return (this.x *= g.x), (this.y *= g.y), (this.z *= g.z), this;
              }
              mul2(g, c) {
                return (
                  (this.x = g.x * c.x),
                  (this.y = g.y * c.y),
                  (this.z = g.z * c.z),
                  this
                );
              }
              mulScalar(g) {
                return (this.x *= g), (this.y *= g), (this.z *= g), this;
              }
              normalize() {
                const g = this.x * this.x + this.y * this.y + this.z * this.z;
                if (g > 0) {
                  const c = 1 / Math.sqrt(g);
                  (this.x *= c), (this.y *= c), (this.z *= c);
                }
                return this;
              }
              floor() {
                return (
                  (this.x = Math.floor(this.x)),
                  (this.y = Math.floor(this.y)),
                  (this.z = Math.floor(this.z)),
                  this
                );
              }
              ceil() {
                return (
                  (this.x = Math.ceil(this.x)),
                  (this.y = Math.ceil(this.y)),
                  (this.z = Math.ceil(this.z)),
                  this
                );
              }
              round() {
                return (
                  (this.x = Math.round(this.x)),
                  (this.y = Math.round(this.y)),
                  (this.z = Math.round(this.z)),
                  this
                );
              }
              min(g) {
                return (
                  g.x < this.x && (this.x = g.x),
                  g.y < this.y && (this.y = g.y),
                  g.z < this.z && (this.z = g.z),
                  this
                );
              }
              max(g) {
                return (
                  g.x > this.x && (this.x = g.x),
                  g.y > this.y && (this.y = g.y),
                  g.z > this.z && (this.z = g.z),
                  this
                );
              }
              project(g) {
                const c = this.x * g.x + this.y * g.y + this.z * g.z,
                  d = g.x * g.x + g.y * g.y + g.z * g.z,
                  h = c / d;
                return (
                  (this.x = g.x * h),
                  (this.y = g.y * h),
                  (this.z = g.z * h),
                  this
                );
              }
              set(g, c, d) {
                return (this.x = g), (this.y = c), (this.z = d), this;
              }
              sub(g) {
                return (this.x -= g.x), (this.y -= g.y), (this.z -= g.z), this;
              }
              sub2(g, c) {
                return (
                  (this.x = g.x - c.x),
                  (this.y = g.y - c.y),
                  (this.z = g.z - c.z),
                  this
                );
              }
              subScalar(g) {
                return (this.x -= g), (this.y -= g), (this.z -= g), this;
              }
              toString() {
                return `[${this.x}, ${this.y}, ${this.z}]`;
              }
            }
            (x.ZERO = Object.freeze(new x(0, 0, 0))),
              (x.ONE = Object.freeze(new x(1, 1, 1))),
              (x.UP = Object.freeze(new x(0, 1, 0))),
              (x.DOWN = Object.freeze(new x(0, -1, 0))),
              (x.RIGHT = Object.freeze(new x(1, 0, 0))),
              (x.LEFT = Object.freeze(new x(-1, 0, 0))),
              (x.FORWARD = Object.freeze(new x(0, 0, -1))),
              (x.BACK = Object.freeze(new x(0, 0, 1)));
          },
          6630: (Se, W, a) => {
            "use strict";
            a.d(W, { T: () => x });
            class x {
              constructor(g = 0, c = 0, d = 0, h = 0) {
                (this.x = void 0),
                  (this.y = void 0),
                  (this.z = void 0),
                  (this.w = void 0),
                  g.length === 4
                    ? ((this.x = g[0]),
                      (this.y = g[1]),
                      (this.z = g[2]),
                      (this.w = g[3]))
                    : ((this.x = g), (this.y = c), (this.z = d), (this.w = h));
              }
              add(g) {
                return (
                  (this.x += g.x),
                  (this.y += g.y),
                  (this.z += g.z),
                  (this.w += g.w),
                  this
                );
              }
              add2(g, c) {
                return (
                  (this.x = g.x + c.x),
                  (this.y = g.y + c.y),
                  (this.z = g.z + c.z),
                  (this.w = g.w + c.w),
                  this
                );
              }
              addScalar(g) {
                return (
                  (this.x += g),
                  (this.y += g),
                  (this.z += g),
                  (this.w += g),
                  this
                );
              }
              clone() {
                const g = this.constructor;
                return new g(this.x, this.y, this.z, this.w);
              }
              copy(g) {
                return (
                  (this.x = g.x),
                  (this.y = g.y),
                  (this.z = g.z),
                  (this.w = g.w),
                  this
                );
              }
              div(g) {
                return (
                  (this.x /= g.x),
                  (this.y /= g.y),
                  (this.z /= g.z),
                  (this.w /= g.w),
                  this
                );
              }
              div2(g, c) {
                return (
                  (this.x = g.x / c.x),
                  (this.y = g.y / c.y),
                  (this.z = g.z / c.z),
                  (this.w = g.w / c.w),
                  this
                );
              }
              divScalar(g) {
                return (
                  (this.x /= g),
                  (this.y /= g),
                  (this.z /= g),
                  (this.w /= g),
                  this
                );
              }
              dot(g) {
                return (
                  this.x * g.x + this.y * g.y + this.z * g.z + this.w * g.w
                );
              }
              equals(g) {
                return (
                  this.x === g.x &&
                  this.y === g.y &&
                  this.z === g.z &&
                  this.w === g.w
                );
              }
              length() {
                return Math.sqrt(
                  this.x * this.x +
                    this.y * this.y +
                    this.z * this.z +
                    this.w * this.w
                );
              }
              lengthSq() {
                return (
                  this.x * this.x +
                  this.y * this.y +
                  this.z * this.z +
                  this.w * this.w
                );
              }
              lerp(g, c, d) {
                return (
                  (this.x = g.x + d * (c.x - g.x)),
                  (this.y = g.y + d * (c.y - g.y)),
                  (this.z = g.z + d * (c.z - g.z)),
                  (this.w = g.w + d * (c.w - g.w)),
                  this
                );
              }
              mul(g) {
                return (
                  (this.x *= g.x),
                  (this.y *= g.y),
                  (this.z *= g.z),
                  (this.w *= g.w),
                  this
                );
              }
              mul2(g, c) {
                return (
                  (this.x = g.x * c.x),
                  (this.y = g.y * c.y),
                  (this.z = g.z * c.z),
                  (this.w = g.w * c.w),
                  this
                );
              }
              mulScalar(g) {
                return (
                  (this.x *= g),
                  (this.y *= g),
                  (this.z *= g),
                  (this.w *= g),
                  this
                );
              }
              normalize() {
                const g =
                  this.x * this.x +
                  this.y * this.y +
                  this.z * this.z +
                  this.w * this.w;
                if (g > 0) {
                  const c = 1 / Math.sqrt(g);
                  (this.x *= c), (this.y *= c), (this.z *= c), (this.w *= c);
                }
                return this;
              }
              floor() {
                return (
                  (this.x = Math.floor(this.x)),
                  (this.y = Math.floor(this.y)),
                  (this.z = Math.floor(this.z)),
                  (this.w = Math.floor(this.w)),
                  this
                );
              }
              ceil() {
                return (
                  (this.x = Math.ceil(this.x)),
                  (this.y = Math.ceil(this.y)),
                  (this.z = Math.ceil(this.z)),
                  (this.w = Math.ceil(this.w)),
                  this
                );
              }
              round() {
                return (
                  (this.x = Math.round(this.x)),
                  (this.y = Math.round(this.y)),
                  (this.z = Math.round(this.z)),
                  (this.w = Math.round(this.w)),
                  this
                );
              }
              min(g) {
                return (
                  g.x < this.x && (this.x = g.x),
                  g.y < this.y && (this.y = g.y),
                  g.z < this.z && (this.z = g.z),
                  g.w < this.w && (this.w = g.w),
                  this
                );
              }
              max(g) {
                return (
                  g.x > this.x && (this.x = g.x),
                  g.y > this.y && (this.y = g.y),
                  g.z > this.z && (this.z = g.z),
                  g.w > this.w && (this.w = g.w),
                  this
                );
              }
              set(g, c, d, h) {
                return (
                  (this.x = g), (this.y = c), (this.z = d), (this.w = h), this
                );
              }
              sub(g) {
                return (
                  (this.x -= g.x),
                  (this.y -= g.y),
                  (this.z -= g.z),
                  (this.w -= g.w),
                  this
                );
              }
              sub2(g, c) {
                return (
                  (this.x = g.x - c.x),
                  (this.y = g.y - c.y),
                  (this.z = g.z - c.z),
                  (this.w = g.w - c.w),
                  this
                );
              }
              subScalar(g) {
                return (
                  (this.x -= g),
                  (this.y -= g),
                  (this.z -= g),
                  (this.w -= g),
                  this
                );
              }
              toString() {
                return `[${this.x}, ${this.y}, ${this.z}, ${this.w}]`;
              }
            }
            (x.ZERO = Object.freeze(new x(0, 0, 0, 0))),
              (x.ONE = Object.freeze(new x(1, 1, 1, 1)));
          },
          9296: (Se, W, a) => {
            "use strict";
            a.d(W, { E: () => x });
            const x = {
              delimiter: "/",
              join: function () {
                const T = arguments.length;
                let g = arguments[0];
                for (let c = 0; c < T - 1; ++c) {
                  const d = arguments[c],
                    h = arguments[c + 1];
                  if (h[0] === x.delimiter) {
                    g = h;
                    continue;
                  }
                  d &&
                  h &&
                  d[d.length - 1] !== x.delimiter &&
                  h[0] !== x.delimiter
                    ? (g += x.delimiter + h)
                    : (g += h);
                }
                return g;
              },
              normalize: function (T) {
                const g = T.startsWith(x.delimiter),
                  c = T.endsWith(x.delimiter),
                  d = T.split("/");
                let h = "",
                  f = [];
                for (let s = 0; s < d.length; s++)
                  if (d[s] !== "" && d[s] !== ".") {
                    if (d[s] === ".." && f.length > 0) {
                      f = f.slice(0, f.length - 2);
                      continue;
                    }
                    s > 0 && f.push(x.delimiter), f.push(d[s]);
                  }
                return (
                  (h = f.join("")),
                  !g && h[0] === x.delimiter && (h = h.slice(1)),
                  c && h[h.length - 1] !== x.delimiter && (h += x.delimiter),
                  h
                );
              },
              split: function (T) {
                const g = T.lastIndexOf(x.delimiter);
                return g !== -1
                  ? [T.substring(0, g), T.substring(g + 1)]
                  : ["", T];
              },
              getBasename: function (T) {
                return x.split(T)[1];
              },
              getDirectory: function (T) {
                return x.split(T)[0];
              },
              getExtension: function (T) {
                const g = T.split("?")[0].split(".").pop();
                return g !== T ? "." + g : "";
              },
              isRelativePath: function (T) {
                return T.charAt(0) !== "/" && T.match(/:\/\//) === null;
              },
              extractPath: function (T) {
                let g = "";
                const c = T.split("/");
                let d = 0;
                if (c.length > 1)
                  if (x.isRelativePath(T))
                    if (c[0] === ".")
                      for (d = 0; d < c.length - 1; ++d)
                        g += d === 0 ? c[d] : "/" + c[d];
                    else if (c[0] === "..")
                      for (d = 0; d < c.length - 1; ++d)
                        g += d === 0 ? c[d] : "/" + c[d];
                    else
                      for (g = ".", d = 0; d < c.length - 1; ++d)
                        g += "/" + c[d];
                  else
                    for (d = 0; d < c.length - 1; ++d)
                      g += d === 0 ? c[d] : "/" + c[d];
                return g;
              },
            };
          },
          4444: (Se, W, a) => {
            "use strict";
            a.d(W, { J: () => o });
            const x = () => {
                let i = !1;
                try {
                  const e = Object.defineProperty({}, "passive", {
                    get: function () {
                      return (i = !0), !1;
                    },
                  });
                  window.addEventListener("testpassive", null, e),
                    window.removeEventListener("testpassive", null, e);
                } catch (e) {}
                return i;
              },
              T = typeof navigator != "undefined" ? navigator.userAgent : "",
              g = typeof window != "undefined" ? "browser" : "node",
              c = /android/i.test(T)
                ? "android"
                : /ip([ao]d|hone)/i.test(T)
                ? "ios"
                : /windows/i.test(T)
                ? "windows"
                : /mac os/i.test(T)
                ? "osx"
                : /linux/i.test(T)
                ? "linux"
                : /cros/i.test(T)
                ? "cros"
                : null,
              d =
                g !== "browser"
                  ? null
                  : /(Chrome\/|Chromium\/|Edg.*\/)/.test(T)
                  ? "chrome"
                  : /Safari\//.test(T)
                  ? "safari"
                  : /Firefox\//.test(T)
                  ? "firefox"
                  : "other",
              h = /xbox/i.test(T),
              f =
                g === "browser" &&
                ("ontouchstart" in window ||
                  ("maxTouchPoints" in navigator &&
                    navigator.maxTouchPoints > 0)),
              s =
                g === "browser" &&
                (!!navigator.getGamepads || !!navigator.webkitGetGamepads),
              l = typeof Worker != "undefined",
              n = x(),
              o = {
                environment: g,
                global: g === "browser" ? window : a.g,
                browser: g === "browser",
                desktop: ["windows", "osx", "linux", "cros"].includes(c),
                mobile: ["android", "ios"].includes(c),
                ios: c === "ios",
                android: c === "android",
                xbox: h,
                gamepads: s,
                touch: f,
                workers: l,
                passiveEvents: n,
                browserName: d,
              };
          },
          6458: (Se, W, a) => {
            "use strict";
            a.d(W, { H: () => x });
            class x {
              constructor(g) {
                (this.arraybuffer = g),
                  (this.dataView = new DataView(g)),
                  (this.offset = 0),
                  (this.stack = []);
              }
              get remainingBytes() {
                return this.dataView.byteLength - this.offset;
              }
              reset(g = 0) {
                this.offset = g;
              }
              skip(g) {
                this.offset += g;
              }
              align(g) {
                this.offset = (this.offset + g - 1) & ~(g - 1);
              }
              _inc(g) {
                return (this.offset += g), this.offset - g;
              }
              readChar() {
                return String.fromCharCode(
                  this.dataView.getUint8(this.offset++)
                );
              }
              readChars(g) {
                let c = "";
                for (let d = 0; d < g; ++d) c += this.readChar();
                return c;
              }
              readU8() {
                return this.dataView.getUint8(this.offset++);
              }
              readU16() {
                return this.dataView.getUint16(this._inc(2), !0);
              }
              readU32() {
                return this.dataView.getUint32(this._inc(4), !0);
              }
              readU64() {
                return this.readU32() + 4294967296 * this.readU32();
              }
              readU32be() {
                return this.dataView.getUint32(this._inc(4), !1);
              }
              readArray(g) {
                for (let c = 0; c < g.length; ++c) g[c] = this.readU8();
              }
              readLine() {
                const g = this.dataView;
                let c = "";
                for (; !(this.offset >= g.byteLength); ) {
                  const d = String.fromCharCode(this.readU8());
                  if (
                    d ===
                    `
`
                  )
                    break;
                  c += d;
                }
                return c;
              }
            }
          },
          6602: (Se, W, a) => {
            "use strict";
            a.d(W, { M: () => x });
            class x {
              constructor() {
                this._refCount = 0;
              }
              incRefCount() {
                this._refCount++;
              }
              decRefCount() {
                this._refCount--;
              }
              get refCount() {
                return this._refCount;
              }
            }
          },
          3148: (Se, W, a) => {
            "use strict";
            a.d(W, { k: () => f });
            var x = a(6556);
            const T = new x.A(),
              g = new x.A(),
              c = new x.A(),
              d = new x.A(),
              h = new x.A();
            class f {
              constructor(l = new x.A(), n = new x.A(0.5, 0.5, 0.5)) {
                (this.center = void 0),
                  (this.halfExtents = void 0),
                  (this._min = new x.A()),
                  (this._max = new x.A()),
                  (this.center = l),
                  (this.halfExtents = n);
              }
              add(l) {
                const n = this.center,
                  o = n.x,
                  i = n.y,
                  e = n.z,
                  t = this.halfExtents,
                  r = t.x,
                  u = t.y,
                  y = t.z;
                let p = o - r,
                  _ = o + r,
                  m = i - u,
                  E = i + u,
                  v = e - y,
                  P = e + y;
                const I = l.center,
                  A = I.x,
                  B = I.y,
                  C = I.z,
                  w = l.halfExtents,
                  k = w.x,
                  K = w.y,
                  te = w.z,
                  X = A - k,
                  $ = A + k,
                  ne = B - K,
                  Y = B + K,
                  Z = C - te,
                  ye = C + te;
                X < p && (p = X),
                  $ > _ && (_ = $),
                  ne < m && (m = ne),
                  Y > E && (E = Y),
                  Z < v && (v = Z),
                  ye > P && (P = ye),
                  (n.x = (p + _) * 0.5),
                  (n.y = (m + E) * 0.5),
                  (n.z = (v + P) * 0.5),
                  (t.x = (_ - p) * 0.5),
                  (t.y = (E - m) * 0.5),
                  (t.z = (P - v) * 0.5);
              }
              copy(l) {
                this.center.copy(l.center),
                  this.halfExtents.copy(l.halfExtents);
              }
              clone() {
                return new f(this.center.clone(), this.halfExtents.clone());
              }
              intersects(l) {
                const n = this.getMax(),
                  o = this.getMin(),
                  i = l.getMax(),
                  e = l.getMin();
                return (
                  o.x <= i.x &&
                  n.x >= e.x &&
                  o.y <= i.y &&
                  n.y >= e.y &&
                  o.z <= i.z &&
                  n.z >= e.z
                );
              }
              _intersectsRay(l, n) {
                const o = T.copy(this.getMin()).sub(l.origin),
                  i = g.copy(this.getMax()).sub(l.origin),
                  e = l.direction;
                e.x === 0
                  ? ((o.x = o.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE),
                    (i.x = i.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE))
                  : ((o.x /= e.x), (i.x /= e.x)),
                  e.y === 0
                    ? ((o.y = o.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE),
                      (i.y = i.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE))
                    : ((o.y /= e.y), (i.y /= e.y)),
                  e.z === 0
                    ? ((o.z = o.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE),
                      (i.z = i.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE))
                    : ((o.z /= e.z), (i.z /= e.z));
                const t = c.set(
                    Math.min(o.x, i.x),
                    Math.min(o.y, i.y),
                    Math.min(o.z, i.z)
                  ),
                  r = d.set(
                    Math.max(o.x, i.x),
                    Math.max(o.y, i.y),
                    Math.max(o.z, i.z)
                  ),
                  u = Math.min(Math.min(r.x, r.y), r.z),
                  y = Math.max(Math.max(t.x, t.y), t.z),
                  p = u >= y && y >= 0;
                return p && n.copy(l.direction).mulScalar(y).add(l.origin), p;
              }
              _fastIntersectsRay(l) {
                const n = T,
                  o = g,
                  i = c,
                  e = d,
                  t = h,
                  r = l.direction;
                return (
                  n.sub2(l.origin, this.center),
                  e.set(Math.abs(n.x), Math.abs(n.y), Math.abs(n.z)),
                  i.mul2(n, r),
                  !(
                    (e.x > this.halfExtents.x && i.x >= 0) ||
                    (e.y > this.halfExtents.y && i.y >= 0) ||
                    (e.z > this.halfExtents.z && i.z >= 0) ||
                    (t.set(Math.abs(r.x), Math.abs(r.y), Math.abs(r.z)),
                    o.cross(r, n),
                    o.set(Math.abs(o.x), Math.abs(o.y), Math.abs(o.z)),
                    o.x >
                      this.halfExtents.y * t.z + this.halfExtents.z * t.y) ||
                    o.y > this.halfExtents.x * t.z + this.halfExtents.z * t.x ||
                    o.z > this.halfExtents.x * t.y + this.halfExtents.y * t.x
                  )
                );
              }
              intersectsRay(l, n) {
                return n
                  ? this._intersectsRay(l, n)
                  : this._fastIntersectsRay(l);
              }
              setMinMax(l, n) {
                this.center.add2(n, l).mulScalar(0.5),
                  this.halfExtents.sub2(n, l).mulScalar(0.5);
              }
              getMin() {
                return this._min.copy(this.center).sub(this.halfExtents);
              }
              getMax() {
                return this._max.copy(this.center).add(this.halfExtents);
              }
              containsPoint(l) {
                const n = this.getMin(),
                  o = this.getMax();
                return !(
                  l.x < n.x ||
                  l.x > o.x ||
                  l.y < n.y ||
                  l.y > o.y ||
                  l.z < n.z ||
                  l.z > o.z
                );
              }
              setFromTransformedAabb(l, n, o = !1) {
                const i = l.center,
                  e = l.halfExtents,
                  t = n.data;
                let r = t[0],
                  u = t[4],
                  y = t[8],
                  p = t[1],
                  _ = t[5],
                  m = t[9],
                  E = t[2],
                  v = t[6],
                  P = t[10];
                if (o) {
                  let I = r * r + u * u + y * y;
                  if (I > 0) {
                    const A = 1 / Math.sqrt(I);
                    (r *= A), (u *= A), (y *= A);
                  }
                  if (((I = p * p + _ * _ + m * m), I > 0)) {
                    const A = 1 / Math.sqrt(I);
                    (p *= A), (_ *= A), (m *= A);
                  }
                  if (((I = E * E + v * v + P * P), I > 0)) {
                    const A = 1 / Math.sqrt(I);
                    (E *= A), (v *= A), (P *= A);
                  }
                }
                this.center.set(
                  t[12] + r * i.x + u * i.y + y * i.z,
                  t[13] + p * i.x + _ * i.y + m * i.z,
                  t[14] + E * i.x + v * i.y + P * i.z
                ),
                  this.halfExtents.set(
                    Math.abs(r) * e.x + Math.abs(u) * e.y + Math.abs(y) * e.z,
                    Math.abs(p) * e.x + Math.abs(_) * e.y + Math.abs(m) * e.z,
                    Math.abs(E) * e.x + Math.abs(v) * e.y + Math.abs(P) * e.z
                  );
              }
              static computeMinMax(l, n, o, i = l.length / 3) {
                if (i > 0) {
                  let e = l[0],
                    t = l[1],
                    r = l[2],
                    u = e,
                    y = t,
                    p = r;
                  const _ = i * 3;
                  for (let m = 3; m < _; m += 3) {
                    const E = l[m],
                      v = l[m + 1],
                      P = l[m + 2];
                    E < e && (e = E),
                      v < t && (t = v),
                      P < r && (r = P),
                      E > u && (u = E),
                      v > y && (y = v),
                      P > p && (p = P);
                  }
                  n.set(e, t, r), o.set(u, y, p);
                }
              }
              compute(l, n) {
                f.computeMinMax(l, T, g, n), this.setMinMax(T, g);
              }
              intersectsBoundingSphere(l) {
                return (
                  this._distanceToBoundingSphereSq(l) <= l.radius * l.radius
                );
              }
              _distanceToBoundingSphereSq(l) {
                const n = this.getMin(),
                  o = this.getMax();
                let i = 0;
                const e = ["x", "y", "z"];
                for (let t = 0; t < 3; ++t) {
                  let r = 0;
                  const u = l.center[e[t]],
                    y = n[e[t]],
                    p = o[e[t]];
                  let _ = 0;
                  u < y && ((_ = y - u), (r += _ * _)),
                    u > p && ((_ = u - p), (r += _ * _)),
                    (i += r);
                }
                return i;
              }
              _expand(l, n) {
                T.add2(this.getMin(), l),
                  g.add2(this.getMax(), n),
                  this.setMinMax(T, g);
              }
            }
          },
          4633: (Se, W, a) => {
            "use strict";
            a.d(W, { K: () => c });
            var x = a(6556);
            const T = new x.A(),
              g = new x.A();
            class c {
              constructor(h = new x.A(), f = 0.5) {
                (this.center = void 0),
                  (this.radius = void 0),
                  (this.center = h),
                  (this.radius = f);
              }
              containsPoint(h) {
                const f = T.sub2(h, this.center).lengthSq(),
                  s = this.radius;
                return f < s * s;
              }
              intersectsRay(h, f) {
                const s = T.copy(h.origin).sub(this.center),
                  l = s.dot(g.copy(h.direction).normalize()),
                  n = s.dot(s) - this.radius * this.radius;
                if (n > 0 && l > 0) return !1;
                const o = l * l - n;
                if (o < 0) return !1;
                const i = Math.abs(-l - Math.sqrt(o));
                return f && f.copy(h.direction).mulScalar(i).add(h.origin), !0;
              }
              intersectsBoundingSphere(h) {
                T.sub2(h.center, this.center);
                const f = h.radius + this.radius;
                return T.lengthSq() <= f * f;
              }
            }
          },
          5230: (Se, W, a) => {
            "use strict";
            a.d(W, { i: () => x });
            class x {
              constructor() {
                this.planes = [];
                for (let g = 0; g < 6; g++) this.planes[g] = [];
              }
              setFromMat4(g) {
                const c = g.data;
                let d;
                const h = this.planes;
                (d = h[0]),
                  (d[0] = c[3] - c[0]),
                  (d[1] = c[7] - c[4]),
                  (d[2] = c[11] - c[8]),
                  (d[3] = c[15] - c[12]);
                let f = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
                (d[0] /= f),
                  (d[1] /= f),
                  (d[2] /= f),
                  (d[3] /= f),
                  (d = h[1]),
                  (d[0] = c[3] + c[0]),
                  (d[1] = c[7] + c[4]),
                  (d[2] = c[11] + c[8]),
                  (d[3] = c[15] + c[12]),
                  (f = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2])),
                  (d[0] /= f),
                  (d[1] /= f),
                  (d[2] /= f),
                  (d[3] /= f),
                  (d = h[2]),
                  (d[0] = c[3] + c[1]),
                  (d[1] = c[7] + c[5]),
                  (d[2] = c[11] + c[9]),
                  (d[3] = c[15] + c[13]),
                  (f = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2])),
                  (d[0] /= f),
                  (d[1] /= f),
                  (d[2] /= f),
                  (d[3] /= f),
                  (d = h[3]),
                  (d[0] = c[3] - c[1]),
                  (d[1] = c[7] - c[5]),
                  (d[2] = c[11] - c[9]),
                  (d[3] = c[15] - c[13]),
                  (f = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2])),
                  (d[0] /= f),
                  (d[1] /= f),
                  (d[2] /= f),
                  (d[3] /= f),
                  (d = h[4]),
                  (d[0] = c[3] - c[2]),
                  (d[1] = c[7] - c[6]),
                  (d[2] = c[11] - c[10]),
                  (d[3] = c[15] - c[14]),
                  (f = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2])),
                  (d[0] /= f),
                  (d[1] /= f),
                  (d[2] /= f),
                  (d[3] /= f),
                  (d = h[5]),
                  (d[0] = c[3] + c[2]),
                  (d[1] = c[7] + c[6]),
                  (d[2] = c[11] + c[10]),
                  (d[3] = c[15] + c[14]),
                  (f = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2])),
                  (d[0] /= f),
                  (d[1] /= f),
                  (d[2] /= f),
                  (d[3] /= f);
              }
              containsPoint(g) {
                let c, d;
                for (c = 0; c < 6; c++)
                  if (
                    ((d = this.planes[c]),
                    d[0] * g.x + d[1] * g.y + d[2] * g.z + d[3] <= 0)
                  )
                    return !1;
                return !0;
              }
              containsSphere(g) {
                let c = 0,
                  d,
                  h;
                const f = g.radius,
                  s = g.center,
                  l = s.x,
                  n = s.y,
                  o = s.z,
                  i = this.planes;
                let e;
                for (h = 0; h < 6; h++) {
                  if (
                    ((e = i[h]),
                    (d = e[0] * l + e[1] * n + e[2] * o + e[3]),
                    d <= -f)
                  )
                    return 0;
                  d > f && c++;
                }
                return c === 6 ? 2 : 1;
              }
            }
          },
          6251: (Se, W, a) => {
            "use strict";
            a.d(W, { J: () => T });
            var x = a(6556);
            class T {
              constructor(c = x.A.UP, d = 0) {
                (this.normal = new x.A()),
                  (this.distance = void 0),
                  this.normal.copy(c),
                  (this.distance = d);
              }
              setFromPointNormal(c, d) {
                return (
                  this.normal.copy(d),
                  (this.distance = -this.normal.dot(c)),
                  this
                );
              }
              intersectsLine(c, d, h) {
                const f = this.distance,
                  s = this.normal.dot(c) + f,
                  l = this.normal.dot(d) + f,
                  n = s / (s - l),
                  o = n >= 0 && n <= 1;
                return o && h && h.lerp(c, d, n), o;
              }
              intersectsRay(c, d) {
                const h = this.normal.dot(c.direction);
                if (h === 0) return !1;
                const f = -(this.normal.dot(c.origin) + this.distance) / h;
                return (
                  f >= 0 && d && d.copy(c.direction).mulScalar(f).add(c.origin),
                  f >= 0
                );
              }
              copy(c) {
                return (
                  this.normal.copy(c.normal), (this.distance = c.distance), this
                );
              }
              clone() {
                const c = this.constructor;
                return new c().copy(this);
              }
            }
          },
          3028: (Se, W, a) => {
            "use strict";
            a.d(W, { z: () => T });
            var x = a(6556);
            class T {
              constructor(c, d) {
                (this.origin = new x.A()),
                  (this.direction = x.A.FORWARD.clone()),
                  c && this.origin.copy(c),
                  d && this.direction.copy(d);
              }
              set(c, d) {
                return this.origin.copy(c), this.direction.copy(d), this;
              }
              copy(c) {
                return this.set(c.origin, c.direction);
              }
              clone() {
                return new this.constructor(this.origin, this.direction);
              }
            }
          },
          324: (Se, W, a) => {
            "use strict";
            a.d(W, { _: () => T });
            const x = (g, c) => g.priority - c.priority,
              T = (g) => g.sort(x);
          },
          9595: (Se, W, a) => {
            "use strict";
            a.d(W, { _: () => x });
            class x {
              constructor(g) {
                (this.items = []),
                  (this.length = 0),
                  (this.loopIndex = -1),
                  (this._sortBy = void 0),
                  (this._sortHandler = void 0),
                  (this._sortBy = g.sortBy),
                  (this._sortHandler = this._doSort.bind(this));
              }
              _binarySearch(g) {
                let c = 0,
                  d = this.items.length - 1;
                const h = g[this._sortBy];
                let f, s;
                for (; c <= d; )
                  (f = Math.floor((c + d) / 2)),
                    (s = this.items[f][this._sortBy]),
                    s <= h ? (c = f + 1) : s > h && (d = f - 1);
                return c;
              }
              _doSort(g, c) {
                const d = this._sortBy;
                return g[d] - c[d];
              }
              insert(g) {
                const c = this._binarySearch(g);
                this.items.splice(c, 0, g),
                  this.length++,
                  this.loopIndex >= c && this.loopIndex++;
              }
              append(g) {
                this.items.push(g), this.length++;
              }
              remove(g) {
                const c = this.items.indexOf(g);
                c < 0 ||
                  (this.items.splice(c, 1),
                  this.length--,
                  this.loopIndex >= c && this.loopIndex--);
              }
              sort() {
                const g =
                  this.loopIndex >= 0 ? this.items[this.loopIndex] : null;
                this.items.sort(this._sortHandler),
                  g !== null && (this.loopIndex = this.items.indexOf(g));
              }
            }
          },
          576: (Se, W, a) => {
            "use strict";
            a.d(W, { X: () => x });
            class x {
              constructor() {
                (this.map = new Map()), (this.id = 0);
              }
              get(g) {
                let c = this.map.get(g);
                return c === void 0 && ((c = this.id++), this.map.set(g, c)), c;
              }
            }
          },
          9351: (Se, W, a) => {
            "use strict";
            a.d(W, { Z: () => m });
            const x = "abcdefghijklmnopqrstuvwxyz",
              T = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
              g = x + T,
              c = 55296,
              d = 56319,
              h = 56320,
              f = 57343,
              s = 8205,
              l = 127462,
              n = 127487,
              o = 127995,
              i = 127999,
              e = 8400,
              t = 8447,
              r = 65024,
              u = 65039;
            function y(E, v = 0) {
              const P = E.length;
              if (v < 0 || v >= P) return null;
              const I = E.charCodeAt(v);
              if (P > 1 && I >= c && I <= d) {
                const A = E.charCodeAt(v + 1);
                if (A >= h && A <= f)
                  return { code: (I - c) * 1024 + A - h + 65536, long: !0 };
              }
              return { code: I, long: !1 };
            }
            function p(E, v, P) {
              if (!E) return !1;
              const I = y(E);
              if (I) {
                const A = I.code;
                return A >= v && A <= P;
              }
              return !1;
            }
            function _(E, v) {
              if (v === E.length - 1) return 1;
              if (p(E[v], c, d)) {
                const P = E.substring(v, v + 2),
                  I = E.substring(v + 2, v + 4);
                return p(I, o, i) || (p(P, l, n) && p(I, l, n))
                  ? 4
                  : p(I, r, u)
                  ? 3
                  : 2;
              }
              return p(E[v + 1], r, u) ? 2 : 1;
            }
            const m = {
              ASCII_LOWERCASE: x,
              ASCII_UPPERCASE: T,
              ASCII_LETTERS: g,
              format: function (E, ...v) {
                for (let P = 0; P < v.length; P++)
                  E = E.replace(`{${P}}`, v[P]);
                return E;
              },
              getCodePoint: function (E, v) {
                const P = y(E, v);
                return P && P.code;
              },
              getCodePoints: function (E) {
                if (typeof E != "string") throw new TypeError("Not a string");
                let v = 0;
                const P = [];
                let I;
                for (; (I = y(E, v)); ) P.push(I.code), (v += I.long ? 2 : 1);
                return P;
              },
              getSymbols: function (E) {
                if (typeof E != "string") throw new TypeError("Not a string");
                let v = 0;
                const P = E.length,
                  I = [];
                let A = 0,
                  B;
                for (; v < P; ) {
                  if (
                    ((A += _(E, v + A)),
                    (B = E[v + A]),
                    p(B, e, t) && (B = E[v + A++]),
                    p(B, r, u) && (B = E[v + A++]),
                    B && B.charCodeAt(0) === s)
                  ) {
                    B = E[v + A++];
                    continue;
                  }
                  const C = E.substring(v, v + A);
                  I.push(C), (v += A), (A = 0);
                }
                return I;
              },
              fromCodePoint: function () {
                const E = [];
                let v, P, I;
                for (let A = 0; A < arguments.length; ++A)
                  (v = Number(arguments[A])),
                    (P = v - 65536),
                    (I =
                      v > 65535
                        ? [(P >> 10) + 55296, (P % 1024) + 56320]
                        : [v]),
                    E.push(String.fromCharCode.apply(null, I));
                return E.join("");
              },
            };
          },
          6660: (Se, W, a) => {
            "use strict";
            a.d(W, { $: () => T });
            var x = a(5338);
            class T extends x.b {
              constructor(c) {
                super(),
                  (this._index = {}),
                  (this._list = []),
                  (this._parent = c);
              }
              add() {
                let c = !1;
                const d = this._processArguments(arguments, !0);
                if (!d.length) return c;
                for (let h = 0; h < d.length; h++)
                  this._index[d[h]] ||
                    ((c = !0),
                    (this._index[d[h]] = !0),
                    this._list.push(d[h]),
                    this.fire("add", d[h], this._parent));
                return c && this.fire("change", this._parent), c;
              }
              remove() {
                let c = !1;
                if (!this._list.length) return c;
                const d = this._processArguments(arguments, !0);
                if (!d.length) return c;
                for (let h = 0; h < d.length; h++)
                  this._index[d[h]] &&
                    ((c = !0),
                    delete this._index[d[h]],
                    this._list.splice(this._list.indexOf(d[h]), 1),
                    this.fire("remove", d[h], this._parent));
                return c && this.fire("change", this._parent), c;
              }
              clear() {
                if (!this._list.length) return;
                const c = this._list.slice(0);
                (this._list = []), (this._index = {});
                for (let d = 0; d < c.length; d++)
                  this.fire("remove", c[d], this._parent);
                this.fire("change", this._parent);
              }
              has() {
                return this._list.length
                  ? this._has(this._processArguments(arguments))
                  : !1;
              }
              _has(c) {
                if (!this._list.length || !c.length) return !1;
                for (let d = 0; d < c.length; d++)
                  if (c[d].length === 1) {
                    if (this._index[c[d][0]]) return !0;
                  } else {
                    let h = !0;
                    for (let f = 0; f < c[d].length; f++)
                      if (!this._index[c[d][f]]) {
                        h = !1;
                        break;
                      }
                    if (h) return !0;
                  }
                return !1;
              }
              list() {
                return this._list.slice(0);
              }
              _processArguments(c, d) {
                const h = [];
                let f = [];
                if (!c || !c.length) return h;
                for (let s = 0; s < c.length; s++)
                  if (c[s] instanceof Array) {
                    d || (f = []);
                    for (let l = 0; l < c[s].length; l++)
                      typeof c[s][l] == "string" &&
                        (d ? h.push(c[s][l]) : f.push(c[s][l]));
                    !d && f.length && h.push(f);
                  } else
                    typeof c[s] == "string" &&
                      (d ? h.push(c[s]) : h.push([c[s]]));
                return h;
              }
              get size() {
                return this._list.length;
              }
            }
          },
          3821: (Se, W, a) => {
            "use strict";
            a.d(W, { z: () => x });
            const x =
              typeof window != "undefined" &&
              window.performance &&
              window.performance.now
                ? performance.now.bind(performance)
                : Date.now;
          },
          3226: (Se, W, a) => {
            "use strict";
            a.d(W, { $: () => x });
            class x {
              static set(g, c = !0) {}
              static get(g) {
                return x._traceChannels.has(g);
              }
            }
            (x._traceChannels = new Set()), (x.stack = !1);
          },
          959: (Se, W, a) => {
            "use strict";
            a.d(W, { Q: () => x, o: () => g });
            function x(c) {
              let d = "";
              if ((c.authority || c.scheme) && (c.host || c.hostpath))
                throw new Error(
                  "Can't have 'scheme' or 'authority' and 'host' or 'hostpath' option"
                );
              if (c.host && c.hostpath)
                throw new Error("Can't have 'host' and 'hostpath' option");
              if (c.path && c.hostpath)
                throw new Error("Can't have 'path' and 'hostpath' option");
              return (
                c.scheme && (d += c.scheme + ":"),
                c.authority && (d += "//" + c.authority),
                c.host && (d += c.host),
                c.path && (d += c.path),
                c.hostpath && (d += c.hostpath),
                c.query && (d += "?" + c.query),
                c.fragment && (d += "#" + c.fragment),
                d
              );
            }
            const T =
              /^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
            class g {
              constructor(d) {
                (this.scheme = void 0),
                  (this.authority = void 0),
                  (this.path = void 0),
                  (this.query = void 0),
                  (this.fragment = void 0);
                const h = d.match(T);
                (this.scheme = h[2]),
                  (this.authority = h[4]),
                  (this.path = h[5]),
                  (this.query = h[7]),
                  (this.fragment = h[9]);
              }
              toString() {
                let d = "";
                return (
                  this.scheme && (d += this.scheme + ":"),
                  this.authority && (d += "//" + this.authority),
                  (d += this.path),
                  this.query && (d += "?" + this.query),
                  this.fragment && (d += "#" + this.fragment),
                  d
                );
              }
              getQuery() {
                const d = {};
                if (this.query) {
                  const h = decodeURIComponent(this.query).split("&");
                  for (const f of h) {
                    const s = f.split("=");
                    d[s[0]] = s[1];
                  }
                }
                return d;
              }
              setQuery(d) {
                let h = "";
                for (const f in d)
                  d.hasOwnProperty(f) &&
                    (h !== "" && (h += "&"),
                    (h +=
                      encodeURIComponent(f) + "=" + encodeURIComponent(d[f])));
                this.query = h;
              }
            }
          },
          8391: (Se, W, a) => {
            "use strict";
            a.d(W, { F: () => g });
            const x = (c) => {
              const d = {};
              let h = d;
              return () => (h === d && (h = c()), h);
            };
            class T {
              static loadScript(d, h) {
                const f = document.createElement("script");
                f.setAttribute("src", d),
                  (f.onload = () => {
                    h(null);
                  }),
                  (f.onerror = () => {
                    h(`Failed to load script='${d}'`);
                  }),
                  document.body.appendChild(f);
              }
              static loadWasm(d, h, f) {
                const s =
                  T.wasmSupported() && h.glueUrl && h.wasmUrl
                    ? h.glueUrl
                    : h.fallbackUrl;
                s
                  ? T.loadScript(s, (l) => {
                      if (l) f(l, null);
                      else {
                        const n = window[d];
                        (window[d] = void 0),
                          n({
                            locateFile: () => h.wasmUrl,
                            onAbort: () => {
                              f("wasm module aborted.");
                            },
                          }).then((o) => {
                            f(null, o);
                          });
                      }
                    })
                  : f("No supported wasm modules found.", null);
              }
              static getModule(d) {
                return (
                  T.modules.hasOwnProperty(d) ||
                    (T.modules[d] = {
                      config: null,
                      initializing: !1,
                      instance: null,
                      callbacks: [],
                    }),
                  T.modules[d]
                );
              }
              static initialize(d, h) {
                if (h.initializing) return;
                const f = h.config;
                (f.glueUrl || f.wasmUrl || f.fallbackUrl) &&
                  ((h.initializing = !0),
                  T.loadWasm(d, f, (s, l) => {
                    s
                      ? f.errorHandler
                        ? f.errorHandler(s)
                        : console.error(
                            `failed to initialize module=${d} error=${s}`
                          )
                      : ((h.instance = l),
                        h.callbacks.forEach((n) => {
                          n(l);
                        }));
                  }));
              }
            }
            (T.modules = {}),
              (T.wasmSupported = x(() => {
                try {
                  if (
                    typeof WebAssembly == "object" &&
                    typeof WebAssembly.instantiate == "function"
                  ) {
                    const c = new WebAssembly.Module(
                      Uint8Array.of(0, 97, 115, 109, 1, 0, 0, 0)
                    );
                    if (c instanceof WebAssembly.Module)
                      return (
                        new WebAssembly.Instance(c) instanceof
                        WebAssembly.Instance
                      );
                  }
                } catch (c) {}
                return !1;
              }));
            class g {
              static setConfig(d, h) {
                const f = T.getModule(d);
                (f.config = h), f.callbacks.length > 0 && T.initialize(d, f);
              }
              static getConfig(d) {
                var h;
                return (h = T.modules) == null || (h = h[d]) == null
                  ? void 0
                  : h.config;
              }
              static getInstance(d, h) {
                const f = T.getModule(d);
                f.instance
                  ? h(f.instance)
                  : (f.callbacks.push(h), f.config && T.initialize(d, f));
              }
            }
          },
          8433: (Se, W, a) => {
            "use strict";
            a.d(W, {
              $s: () => ue,
              Ah: () => Jt,
              CF: () => ot,
              Gn: () => ks,
              H3: () => fe,
              HR: () => ct,
              IL: () => is,
              Ie: () => Ze,
              JF: () => Lt,
              Js: () => mt,
              Ki: () => he,
              MI: () => Be,
              RF: () => Ss,
              Ri: () => Zs,
              Um: () => pt,
              VL: () => Ye,
              VZ: () => lt,
              W0: () => tt,
              XV: () => Ae,
              XW: () => Xe,
              Xw: () => at,
              Yt: () => et,
              ZI: () => Ft,
              Zz: () => Ie,
              _A: () => Et,
              aZ: () => Ws,
              cM: () => Gt,
              f6: () => He,
              g2: () => ys,
              if: () => ls,
              mC: () => st,
              mF: () => Ve,
              mS: () => Fe,
              n0: () => Es,
              nl: () => Qe,
              op: () => Xs,
              pt: () => Ke,
              q7: () => bs,
              qH: () => hs,
              qJ: () => ws,
              qe: () => ps,
              qx: () => De,
              rF: () => Ns,
              se: () => Yt,
              wj: () => it,
              xN: () => Ys,
              yC: () => je,
              yb: () => zs,
              zx: () => Pt,
            });
            var x = a(9795),
              T = a(9351),
              g = a(3821),
              c = a(4585),
              d = a(1367),
              h = a(9758),
              f = a(2978),
              s = a(6556),
              l = a(6630),
              n = a(3148),
              o = a(4633),
              i = a(5230),
              e = a(6251),
              t = a(7921),
              r = a(2172),
              u = a(464),
              y = a(3200),
              p = a(4738),
              _ = a(9459),
              m = a(1741),
              E = a(3121),
              v = a(3587),
              P = a(192),
              I = a(3412),
              A = a(8298),
              B = a(6977),
              C = a(8483),
              w = a(8869),
              k = a(6615),
              K = a(8385),
              te = a(6938),
              X = a(3862),
              $ = a(7982),
              ne = a(8277),
              Y = a(7013),
              Z = a(3114),
              ye = a(4611),
              pe = a(120),
              O = a(5752),
              me = a(4210),
              N = a(7915),
              V = a(2737),
              L = a(7678),
              J = a(3823),
              ae = a(8792),
              R = a(9915),
              j = a(3241),
              se = a(6604),
              ce = a(7224),
              ie = a(4390),
              b = a(8691),
              M = a(8944),
              F = a(3894),
              z = a(9373),
              oe = a(7474),
              de = a(3054),
              ge = a(7934),
              Re = a(8451),
              Te = a(242),
              Ne = a(6874),
              Le = a(9725),
              ke = a(6389),
              ht = a(9095),
              _e = a(5491),
              U = a(6612),
              H = a(5541),
              Ee = a(9212),
              G = a(6327),
              Q = a(3176),
              q = a(6848),
              xe = a(9818),
              be = a(4094),
              Pe = a(6135),
              we = a(5593),
              Oe = a(4946),
              $e = a(2816),
              gt = a(4355),
              qe = a(4378),
              Tt = a(5719),
              Mt = a(5985),
              Dt = a(8280),
              ut = a(2628),
              At = a(4608),
              xt = a(8069),
              jt = a(3009);
            const Gt = {
              write: function (We) {
                console.log(We);
              },
              open: function () {
                Gt.write("Powered by PlayCanvas " + x.i8 + " " + x.LB);
              },
              info: function (We) {
                console.info("INFO:    " + We);
              },
              debug: function (We) {
                console.debug("DEBUG:   " + We);
              },
              error: function (We) {
                console.error("ERROR:   " + We);
              },
              warning: function (We) {
                console.warn("WARNING: " + We);
              },
              alert: function (We) {
                Gt.write("ALERT:   " + We), alert(We);
              },
              assert: function (We, ft) {
                We === !1 && Gt.write("ASSERT:  " + ft);
              },
            };
            (T.Z.endsWith = function (We, ft) {
              return We.endsWith(ft);
            }),
              (T.Z.startsWith = function (We, ft) {
                return We.startsWith(ft);
              });
            class yt {
              constructor() {
                (this._isRunning = !1), (this._a = 0), (this._b = 0);
              }
              start() {
                (this._isRunning = !0), (this._a = (0, g.z)());
              }
              stop() {
                (this._isRunning = !1), (this._b = (0, g.z)());
              }
              getMilliseconds() {
                return this._b - this._a;
              }
            }
            const Ae = { now: g.z, Timer: yt };
            Object.defineProperty(d.I.prototype, "data", {
              get: function () {
                return (
                  this._data || (this._data = new Float32Array(4)),
                  (this._data[0] = this.r),
                  (this._data[1] = this.g),
                  (this._data[2] = this.b),
                  (this._data[3] = this.a),
                  this._data
                );
              },
            }),
              Object.defineProperty(d.I.prototype, "data3", {
                get: function () {
                  return (
                    this._data3 || (this._data3 = new Float32Array(3)),
                    (this._data3[0] = this.r),
                    (this._data3[1] = this.g),
                    (this._data3[2] = this.b),
                    this._data3
                  );
                },
              });
            function Xe(We, ft) {
              const bt = function () {},
                ts = function (rs, Ps, Ts, ei, Js, ti, Bs, si) {
                  ft.call(this, rs, Ps, Ts, ei, Js, ti, Bs, si),
                    We.call(this, rs, Ps, Ts, ei, Js, ti, Bs, si);
                };
              return (
                (ts._super = ft.prototype),
                (bt.prototype = ft.prototype),
                (ts.prototype = new bt()),
                ts
              );
            }
            function Ye(We) {
              return Array.prototype.slice.call(We);
            }
            function it(We) {
              const ft = document.createElement("style");
              return (
                (ft.type = "text/css"),
                ft.styleSheet
                  ? (ft.styleSheet.cssText = We)
                  : ft.appendChild(document.createTextNode(We)),
                ft
              );
            }
            (c.m.INV_LOG2 = Math.LOG2E),
              (c.m.intToBytes = c.m.intToBytes32),
              (c.m.bytesToInt = c.m.bytesToInt32),
              Object.defineProperty(f.S.prototype, "data", {
                get: function () {
                  return (
                    this._data || (this._data = new Float32Array(2)),
                    (this._data[0] = this.x),
                    (this._data[1] = this.y),
                    this._data
                  );
                },
              }),
              (f.S.prototype.scale = f.S.prototype.mulScalar),
              Object.defineProperty(s.A.prototype, "data", {
                get: function () {
                  return (
                    this._data || (this._data = new Float32Array(3)),
                    (this._data[0] = this.x),
                    (this._data[1] = this.y),
                    (this._data[2] = this.z),
                    this._data
                  );
                },
              }),
              (s.A.prototype.scale = s.A.prototype.mulScalar),
              Object.defineProperty(l.T.prototype, "data", {
                get: function () {
                  return (
                    this._data || (this._data = new Float32Array(4)),
                    (this._data[0] = this.x),
                    (this._data[1] = this.y),
                    (this._data[2] = this.z),
                    (this._data[3] = this.w),
                    this._data
                  );
                },
              }),
              (l.T.prototype.scale = l.T.prototype.mulScalar);
            const st = { Aabb: n.k, Sphere: o.K, Plane: e.J };
            (o.K.prototype.intersectRay = o.K.prototype.intersectsRay),
              (i.i.prototype.update = function (We, ft) {
                const bt = new h.y();
                bt.mul2(We, ft), this.setFromMat4(bt);
              });
            const He = t.NPC,
              at = t.vyI,
              Pt = t.S81,
              he = t.Spw,
              fe = t.$Rf,
              Ie = t.$GK,
              ue = t.r8O,
              De = t.$Op,
              et = t.Rbg,
              Ze = t.BmF,
              Ve = t.UUS,
              tt = t.Hsr,
              Be = t.jKI,
              ot = t.Q8W,
              Qe = t.Ax$,
              mt = t.Q8W,
              je = t.Ax$;
            function lt(We) {
              (this.name = "UnsupportedBrowserError"),
                (this.message = We || "");
            }
            lt.prototype = Error.prototype;
            function Et(We) {
              (this.name = "ContextCreationError"), (this.message = We || "");
            }
            Et.prototype = Error.prototype;
            const ct = {
                begin: r.a7,
                dummyFragmentCode: X.x.dummyFragmentCode,
                end: r.ut,
                fogCode: r.aJ,
                gammaCode: r.li,
                precisionCode: X.x.precisionCode,
                skinCode: r.oY,
                tonemapCode: r.ph,
                versionCode: X.x.versionCode,
              },
              pt = {
                ADDRESS_CLAMP_TO_EDGE: t.uFb,
                ADDRESS_MIRRORED_REPEAT: t.nVg,
                ADDRESS_REPEAT: t.SuC,
                BLENDMODE_ZERO: t.rqb,
                BLENDMODE_ONE: t.NdT,
                BLENDMODE_SRC_COLOR: t.RR1,
                BLENDMODE_ONE_MINUS_SRC_COLOR: t.gXY,
                BLENDMODE_DST_COLOR: t.CZC,
                BLENDMODE_ONE_MINUS_DST_COLOR: t.PDh,
                BLENDMODE_SRC_ALPHA: t._HM,
                BLENDMODE_SRC_ALPHA_SATURATE: t.OVG,
                BLENDMODE_ONE_MINUS_SRC_ALPHA: t.Hiv,
                BLENDMODE_DST_ALPHA: t.liJ,
                BLENDMODE_ONE_MINUS_DST_ALPHA: t.hJD,
                BUFFER_STATIC: t.dxy,
                BUFFER_DYNAMIC: t.AHc,
                BUFFER_STREAM: t.oWk,
                CULLFACE_NONE: t.OL2,
                CULLFACE_BACK: t.Ak1,
                CULLFACE_FRONT: t.TWf,
                CULLFACE_FRONTANDBACK: t.QKK,
                ELEMENTTYPE_INT8: t.NPC,
                ELEMENTTYPE_UINT8: t.vyI,
                ELEMENTTYPE_INT16: t.S81,
                ELEMENTTYPE_UINT16: t.Spw,
                ELEMENTTYPE_INT32: t.$Rf,
                ELEMENTTYPE_UINT32: t.$GK,
                ELEMENTTYPE_FLOAT32: t.r8O,
                FILTER_NEAREST: t.yib,
                FILTER_LINEAR: t.I5X,
                FILTER_NEAREST_MIPMAP_NEAREST: t.Aap,
                FILTER_NEAREST_MIPMAP_LINEAR: t.$_P,
                FILTER_LINEAR_MIPMAP_NEAREST: t.feq,
                FILTER_LINEAR_MIPMAP_LINEAR: t.Snx,
                INDEXFORMAT_UINT8: t.fUD,
                INDEXFORMAT_UINT16: t.q0F,
                INDEXFORMAT_UINT32: t.qCh,
                PIXELFORMAT_RGB565: t.Rbg,
                PIXELFORMAT_RGB8: t.Hsr,
                PIXELFORMAT_RGBA8: t.jKI,
                PRIMITIVE_POINTS: t.KtK,
                PRIMITIVE_LINES: t.Y7R,
                PRIMITIVE_LINELOOP: t.QSU,
                PRIMITIVE_LINESTRIP: t.HWi,
                PRIMITIVE_TRIANGLES: t.LAy,
                PRIMITIVE_TRISTRIP: t.fmY,
                PRIMITIVE_TRIFAN: t.x5Y,
                SEMANTIC_POSITION: t.Q5v,
                SEMANTIC_NORMAL: t.SA$,
                SEMANTIC_COLOR: t.wD$,
                SEMANTIC_TEXCOORD: t.Pd9,
                SEMANTIC_TEXCOORD0: t.$fY,
                SEMANTIC_TEXCOORD1: t.Q0q,
                SEMANTIC_ATTR0: t.CNh,
                SEMANTIC_ATTR1: t.x5T,
                SEMANTIC_ATTR2: t.PBu,
                SEMANTIC_ATTR3: t.PFm,
                TEXTURELOCK_READ: t.Huo,
                TEXTURELOCK_WRITE: t.NTX,
                drawQuadWithShader: u.H,
                programlib: ct,
                shaderChunks: y.n,
                ContextCreationError: Et,
                Device: p.$,
                IndexBuffer: _.G,
                ProgramLibrary: v._,
                RenderTarget: I.A,
                ScopeId: A.q,
                Shader: B.e,
                ShaderInput: C.M,
                Texture: w.x,
                UnsupportedBrowserError: lt,
                VertexBuffer: k.o,
                VertexFormat: K.g,
                VertexIterator: te.O,
              },
              vt = new l.T();
            function Fe(We, ft, bt, ts, Qt) {
              let rs;
              if (Qt) {
                const Ps = ft ? ft.width : We.width,
                  Ts = ft ? ft.height : We.height;
                rs = vt.set(Qt.x * Ps, Qt.y * Ts, Qt.z * Ps, Qt.w * Ts);
              }
              (0, u.H)(We, ft, ts, rs);
            }
            const Yt = {
              createFullscreenQuad: (We) => We.quadVertexBuffer,
              drawFullscreenQuad: Fe,
              PostEffect: m.c,
              PostEffectQueue: E.G,
            };
            Object.defineProperty(y.n, "transformSkinnedVS", {
              get: function () {
                return (
                  `#define SKIN
` + y.n.transformVS
                );
              },
            }),
              Object.keys({
                "ambientPrefilteredCube.frag": "ambientEnv.frag",
                "ambientPrefilteredCubeLod.frag": "ambientEnv.frag",
                "dpAtlasQuad.frag": null,
                "genParaboloid.frag": null,
                "prefilterCubemap.frag": null,
                "reflectionDpAtlas.frag": "reflectionEnv.frag",
                "reflectionPrefilteredCube.frag": "reflectionEnv.frag",
                "reflectionPrefilteredCubeLod.frag": "reflectionEnv.frag",
              }).forEach((We) => {
                Object.defineProperty(y.n, We, {
                  get: function () {
                    return null;
                  },
                  set: function () {},
                });
              }),
              Object.defineProperties(I.A.prototype, {
                _glFrameBuffer: {
                  get: function () {
                    return this.impl._glFrameBuffer;
                  },
                  set: function (We) {},
                },
              }),
              Object.defineProperty(K.g, "defaultInstancingFormat", {
                get: function () {
                  return K.g.getDefaultInstancingFormat($.j.get());
                },
              }),
              Object.defineProperties(w.x.prototype, {
                rgbm: {
                  get: function () {
                    return this.type === t.xIP;
                  },
                  set: function (We) {
                    this.type = We ? t.xIP : t.zZc;
                  },
                },
                swizzleGGGR: {
                  get: function () {
                    return this.type === t.anS;
                  },
                  set: function (We) {
                    this.type = We ? t.anS : t.zZc;
                  },
                },
                _glTexture: {
                  get: function () {
                    return this.impl._glTexture;
                  },
                },
                autoMipmap: {
                  get: function () {
                    return this._mipmaps;
                  },
                  set: function (We) {
                    this._mipmaps = We;
                  },
                },
              }),
              (p.$.prototype.getProgramLibrary = function () {
                return (0, P.N)(this);
              }),
              (p.$.prototype.setProgramLibrary = function (We) {
                (0, P.f)(this, We);
              }),
              (p.$.prototype.removeShaderFromCache = function (We) {
                (0, P.N)(this).removeFromCache(We);
              }),
              (ne.a.DEFAULT = Object.freeze(new ne.a()));
            const Rt = new ne.a(),
              Kt = new Y.b();
            (p.$.prototype.setBlendFunction = function (We, ft) {
              const bt = this.blendState;
              Rt.copy(bt),
                Rt.setColorBlend(bt.colorOp, We, ft),
                Rt.setAlphaBlend(bt.alphaOp, We, ft),
                this.setBlendState(Rt);
            }),
              (p.$.prototype.setBlendFunctionSeparate = function (
                We,
                ft,
                bt,
                ts
              ) {
                const Qt = this.blendState;
                Rt.copy(Qt),
                  Rt.setColorBlend(Qt.colorOp, We, ft),
                  Rt.setAlphaBlend(Qt.alphaOp, bt, ts),
                  this.setBlendState(Rt);
              }),
              (p.$.prototype.setBlendEquation = function (We) {
                const ft = this.blendState;
                Rt.copy(ft),
                  Rt.setColorBlend(We, ft.colorSrcFactor, ft.colorDstFactor),
                  Rt.setAlphaBlend(We, ft.alphaSrcFactor, ft.alphaDstFactor),
                  this.setBlendState(Rt);
              }),
              (p.$.prototype.setBlendEquationSeparate = function (We, ft) {
                const bt = this.blendState;
                Rt.copy(bt),
                  Rt.setColorBlend(We, bt.colorSrcFactor, bt.colorDstFactor),
                  Rt.setAlphaBlend(ft, bt.alphaSrcFactor, bt.alphaDstFactor),
                  this.setBlendState(Rt);
              }),
              (p.$.prototype.setColorWrite = function (We, ft, bt, ts) {
                const Qt = this.blendState;
                Rt.copy(Qt),
                  Rt.setColorWrite(We, ft, bt, ts),
                  this.setBlendState(Rt);
              }),
              (p.$.prototype.getBlending = function () {
                return this.blendState.blend;
              }),
              (p.$.prototype.setBlending = function (We) {
                Rt.copy(this.blendState),
                  (Rt.blend = We),
                  this.setBlendState(Rt);
              }),
              (p.$.prototype.setDepthWrite = function (We) {
                Kt.copy(this.depthState),
                  (Kt.write = We),
                  this.setDepthState(Kt);
              }),
              (p.$.prototype.setDepthFunc = function (We) {
                Kt.copy(this.depthState),
                  (Kt.func = We),
                  this.setDepthState(Kt);
              }),
              (p.$.prototype.setDepthTest = function (We) {
                Kt.copy(this.depthState),
                  (Kt.test = We),
                  this.setDepthState(Kt);
              }),
              (p.$.prototype.getCullMode = function () {
                return this.cullMode;
              });
            const Lt = M.K,
              Ft = de.F,
              Jt = {
                partitionSkin: pe.A,
                procedural: {
                  calculateTangents: ye.bF,
                  createMesh: ye.Ns,
                  createTorus: ye.$w,
                  createCylinder: ye.Y,
                  createCapsule: ye.JL,
                  createCone: ye.VD,
                  createSphere: ye.$R,
                  createPlane: ye.j6,
                  createBox: ye.dO,
                },
                BasicMaterial: O.K,
                Command: ae.m,
                ForwardRenderer: me.g,
                GraphNode: N.A,
                Material: V.F,
                Mesh: L.K,
                MeshInstance: ae.l,
                Model: R.H,
                ParticleEmitter: j.V,
                PhongMaterial: M.K,
                Picker: se.c,
                Projection: { ORTHOGRAPHIC: Z.Uc, PERSPECTIVE: Z.pm },
                Scene: ce.x,
                Skin: ie.Z,
                SkinInstance: b.u,
              };
            Object.defineProperty(ce.x.prototype, "defaultMaterial", {
              get: function () {
                return (0, z.U)((0, gt.i)().graphicsDevice);
              },
            }),
              ["128", "64", "32", "16", "8", "4"].forEach((We, ft) => {
                Object.defineProperty(
                  ce.x.prototype,
                  `skyboxPrefiltered${We}`,
                  {
                    get: function () {
                      return this._prefilteredCubemaps[ft];
                    },
                    set: function (bt) {
                      (this._prefilteredCubemaps[ft] = bt),
                        (this.updateShaders = !0);
                    },
                  }
                );
              }),
              Object.defineProperty(ce.x.prototype, "models", {
                get: function () {
                  return this._models || (this._models = []), this._models;
                },
              }),
              Object.defineProperty(ge.m.prototype, "renderTarget", {
                set: function (We) {
                  (this._renderTarget = We), (this._dirtyCameras = !0);
                },
                get: function () {
                  return this._renderTarget;
                },
              }),
              (ce.x.prototype._updateSkybox = function (We) {
                this._updateSky(We);
              }),
              (ce.x.prototype.addModel = function (We) {
                if (this.containsModel(We)) return;
                const ft = this.layers.getLayerById(Z.kY);
                ft &&
                  (ft.addMeshInstances(We.meshInstances), this.models.push(We));
              }),
              (ce.x.prototype.addShadowCaster = function (We) {
                const ft = this.layers.getLayerById(Z.kY);
                ft && ft.addShadowCasters(We.meshInstances);
              }),
              (ce.x.prototype.removeModel = function (We) {
                const ft = this.models.indexOf(We);
                if (ft !== -1) {
                  const bt = this.layers.getLayerById(Z.kY);
                  if (!bt) return;
                  bt.removeMeshInstances(We.meshInstances),
                    this.models.splice(ft, 1);
                }
              }),
              (ce.x.prototype.removeShadowCasters = function (We) {
                const ft = this.layers.getLayerById(Z.kY);
                ft && ft.removeShadowCasters(We.meshInstances);
              }),
              (ce.x.prototype.containsModel = function (We) {
                return this.models.indexOf(We) >= 0;
              }),
              (ce.x.prototype.getModels = function (We) {
                return this.models;
              }),
              Object.defineProperty(F.E.prototype, "model", {
                get: function () {
                  return null;
                },
              }),
              (me.g.prototype.renderComposition = function (We) {
                (0, gt.i)().renderComposition(We);
              }),
              (ae.l.prototype.syncAabb = function () {}),
              (J._.prototype.getTarget = function (We) {
                return this.targets[We];
              }),
              (N.A.prototype._dirtify = function (We) {
                We ? this._dirtifyLocal() : this._dirtifyWorld();
              }),
              (N.A.prototype.addLabel = function (We) {
                this._labels[We] = !0;
              }),
              (N.A.prototype.getLabels = function () {
                return Object.keys(this._labels);
              }),
              (N.A.prototype.hasLabel = function (We) {
                return !!this._labels[We];
              }),
              (N.A.prototype.removeLabel = function (We) {
                delete this._labels[We];
              }),
              (N.A.prototype.findByLabel = function (We, ft = []) {
                this.hasLabel(We) && ft.push(this);
                for (let bt = 0; bt < this._children.length; ++bt)
                  ft = this._children[bt].findByLabel(We, ft);
                return ft;
              }),
              (N.A.prototype.getChildren = function () {
                return this.children;
              }),
              (N.A.prototype.getName = function () {
                return this.name;
              }),
              (N.A.prototype.getPath = function () {
                return this.path;
              }),
              (N.A.prototype.getRoot = function () {
                return this.root;
              }),
              (N.A.prototype.getParent = function () {
                return this.parent;
              }),
              (N.A.prototype.setName = function (We) {
                this.name = We;
              }),
              (V.F.prototype.getName = function () {
                return this.name;
              }),
              (V.F.prototype.setName = function (We) {
                this.name = We;
              }),
              (V.F.prototype.getShader = function () {
                return this.shader;
              }),
              (V.F.prototype.setShader = function (We) {
                this.shader = We;
              }),
              Object.defineProperty(V.F.prototype, "blend", {
                set: function (We) {
                  this.blendState.blend = We;
                },
                get: function () {
                  return this.blendState.blend;
                },
              }),
              Object.defineProperty(V.F.prototype, "blendSrc", {
                set: function (We) {
                  const ft = this.blendState;
                  Rt.copy(ft),
                    Rt.setColorBlend(ft.colorOp, We, ft.colorDstFactor),
                    Rt.setAlphaBlend(ft.alphaOp, We, ft.alphaDstFactor),
                    (this.blendState = Rt);
                },
                get: function () {
                  return this.blendState.colorSrcFactor;
                },
              }),
              Object.defineProperty(V.F.prototype, "blendDst", {
                set: function (We) {
                  const ft = this.blendState;
                  Rt.copy(ft),
                    Rt.setColorBlend(ft.colorOp, ft.colorSrcFactor, We),
                    Rt.setAlphaBlend(ft.alphaOp, ft.alphaSrcFactor, We),
                    (this.blendState = Rt);
                },
                get: function () {
                  return this.blendState.colorDstFactor;
                },
              }),
              Object.defineProperty(M.K.prototype, "shininess", {
                get: function () {
                  return this.gloss * 100;
                },
                set: function (We) {
                  this.gloss = We * 0.01;
                },
              });
            function zt(We, ft) {
              Object.defineProperty(M.K.prototype, ft, {
                get: function () {
                  return this[We];
                },
                set: function (bt) {
                  this[We] = bt;
                },
              });
            }
            zt("diffuseTint", "diffuseMapTint"),
              zt("specularTint", "specularMapTint"),
              zt("emissiveTint", "emissiveMapTint"),
              zt("aoVertexColor", "aoMapVertexColor"),
              zt("diffuseVertexColor", "diffuseMapVertexColor"),
              zt("specularVertexColor", "specularMapVertexColor"),
              zt("emissiveVertexColor", "emissiveMapVertexColor"),
              zt("metalnessVertexColor", "metalnessMapVertexColor"),
              zt("glossVertexColor", "glossMapVertexColor"),
              zt("opacityVertexColor", "opacityMapVertexColor"),
              zt("lightVertexColor", "lightMapVertexColor"),
              zt("sheenGloss", "sheenGlossiess"),
              zt("clearCoatGloss", "clearCostGlossiness");
            function ss(We, ft) {
              We !== "pass" &&
                Object.defineProperty(oe.J.prototype, We, {
                  get: function () {
                    return this.litOptions[ft || We];
                  },
                  set: function (bt) {
                    this.litOptions[ft || We] = bt;
                  },
                });
            }
            ss("refraction", "useRefraction");
            const qt = new de.F(),
              fs = Object.getOwnPropertyNames(qt);
            for (const We in fs) ss(fs[We]);
            const ls = {
              Animation: Re.fw,
              Key: Re.sr,
              Node: Re.NB,
              Skeleton: Te.O,
            };
            (Re.fw.prototype.getDuration = function () {
              return this.duration;
            }),
              (Re.fw.prototype.getName = function () {
                return this.name;
              }),
              (Re.fw.prototype.getNodes = function () {
                return this.nodes;
              }),
              (Re.fw.prototype.setDuration = function (We) {
                this.duration = We;
              }),
              (Re.fw.prototype.setName = function (We) {
                this.name = We;
              }),
              (Te.O.prototype.getAnimation = function () {
                return this.animation;
              }),
              (Te.O.prototype.getCurrentTime = function () {
                return this.currentTime;
              }),
              (Te.O.prototype.getLooping = function () {
                return this.looping;
              }),
              (Te.O.prototype.getNumNodes = function () {
                return this.numNodes;
              }),
              (Te.O.prototype.setAnimation = function (We) {
                this.animation = We;
              }),
              (Te.O.prototype.setCurrentTime = function (We) {
                this.currentTime = We;
              }),
              (Te.O.prototype.setLooping = function (We) {
                this.looping = We;
              });
            const Es = {
              AudioManager: _e.P,
              Channel: Ne.$,
              Channel3d: Le.b,
              Listener: ke.Y,
              Sound: ht.$,
            };
            (_e.P.prototype.getListener = function () {
              return this.listener;
            }),
              (_e.P.prototype.getVolume = function () {
                return this.volume;
              }),
              (_e.P.prototype.setVolume = function (We) {
                this.volume = We;
              });
            const Ke = {
              ASSET_ANIMATION: "animation",
              ASSET_AUDIO: "audio",
              ASSET_IMAGE: "image",
              ASSET_JSON: "json",
              ASSET_MODEL: "model",
              ASSET_MATERIAL: "material",
              ASSET_TEXT: "text",
              ASSET_TEXTURE: "texture",
              ASSET_CUBEMAP: "cubemap",
              ASSET_SCRIPT: "script",
            };
            (U.o.prototype.getAssetById = function (We) {
              return this.get(We);
            }),
              Object.defineProperty(H.g.prototype, "ray", {
                get: function () {
                  return this._rayLocal;
                },
              }),
              Object.defineProperty(H.g.prototype, "position", {
                get: function () {
                  return this._localPosition;
                },
              }),
              Object.defineProperty(H.g.prototype, "rotation", {
                get: function () {
                  return this._localRotation;
                },
              });
            const hs = {
              getTouchTargetCoords: Oe.kX,
              Controller: Ee.Q,
              GamePads: Q.pF,
              Keyboard: q.N,
              KeyboardEvent: xe._,
              Mouse: be.T,
              MouseEvent: Pe.T,
              Touch: Oe.Xh,
              TouchDevice: we.S,
              TouchEvent: Oe.Wb,
            };
            Object.defineProperty(G.RR.prototype, "wheel", {
              get: function () {
                return this.wheelDelta * -2;
              },
            }),
              Object.defineProperty(Pe.T.prototype, "wheel", {
                get: function () {
                  return this.wheelDelta * -2;
                },
              });
            const is = ut.eg,
              ys = ut.YZ,
              ps = ut.oV,
              Ns = ut.zG,
              zs = ut.tU,
              bs = ut.ge,
              Ws = ut.sc,
              Ss = ut.qi,
              ws = ut.SN,
              ks = ut.Ln,
              Ys = ut.AE;
            ($e.k.prototype.isFullscreen = function () {
              return !!document.fullscreenElement;
            }),
              ($e.k.prototype.enableFullscreen = function (We, ft, bt) {
                We = We || this.graphicsDevice.canvas;
                const ts = function rs() {
                    ft(), document.removeEventListener("fullscreenchange", rs);
                  },
                  Qt = function rs() {
                    bt(), document.removeEventListener("fullscreenerror", rs);
                  };
                ft && document.addEventListener("fullscreenchange", ts, !1),
                  bt && document.addEventListener("fullscreenerror", Qt, !1),
                  We.requestFullscreen
                    ? We.requestFullscreen(Element.ALLOW_KEYBOARD_INPUT)
                    : bt();
              }),
              ($e.k.prototype.disableFullscreen = function (We) {
                const ft = function bt() {
                  We(), document.removeEventListener("fullscreenchange", bt);
                };
                We && document.addEventListener("fullscreenchange", ft, !1),
                  document.exitFullscreen();
              }),
              ($e.k.prototype.getSceneUrl = function (We) {
                const ft = this.scenes.find(We);
                return ft ? ft.url : null;
              }),
              ($e.k.prototype.loadScene = function (We, ft) {
                this.scenes.loadScene(We, ft);
              }),
              ($e.k.prototype.loadSceneHierarchy = function (We, ft) {
                this.scenes.loadSceneHierarchy(We, ft);
              }),
              ($e.k.prototype.loadSceneSettings = function (We, ft) {
                this.scenes.loadSceneSettings(We, ft);
              }),
              ($e.k.prototype.renderMeshInstance = function (We, ft) {
                const bt =
                  ft != null && ft.layer
                    ? ft.layer
                    : this.scene.defaultDrawLayer;
                this.scene.immediate.drawMesh(null, null, null, We, bt);
              }),
              ($e.k.prototype.renderMesh = function (We, ft, bt, ts) {
                const Qt =
                  ts != null && ts.layer
                    ? ts.layer
                    : this.scene.defaultDrawLayer;
                this.scene.immediate.drawMesh(ft, bt, We, null, Qt);
              }),
              ($e.k.prototype._addLines = function (We, ft, bt) {
                const ts =
                    bt && bt.layer
                      ? bt.layer
                      : this.scene.layers.getLayerById(Z.vt),
                  Qt = bt && bt.depthTest !== void 0 ? bt.depthTest : !0;
                this.scene.immediate.getBatch(ts, Qt).addLines(We, ft);
              }),
              ($e.k.prototype.renderLine = function (We, ft, bt) {
                let ts = bt,
                  Qt;
                const rs = arguments[3],
                  Ps = arguments[4];
                rs instanceof d.I
                  ? ((ts = rs),
                    typeof Ps == "number"
                      ? Ps === Z.Pk
                        ? (Qt = {
                            layer: this.scene.layers.getLayerById(Z.vt),
                            depthTest: !1,
                          })
                        : (Qt = {
                            layer: this.scene.layers.getLayerById(Z.vt),
                            depthTest: !0,
                          })
                      : (Qt = Ps))
                  : typeof rs == "number"
                  ? ((ts = bt),
                    rs === Z.Pk
                      ? (Qt = {
                          layer: this.scene.layers.getLayerById(Z.vt),
                          depthTest: !1,
                        })
                      : (Qt = {
                          layer: this.scene.layers.getLayerById(Z.vt),
                          depthTest: !0,
                        }))
                  : rs && (Qt = rs),
                  this._addLines([We, ft], [bt, ts], Qt);
              }),
              ($e.k.prototype.renderLines = function (We, ft, bt) {
                if (
                  (bt
                    ? typeof bt == "number" &&
                      (bt === Z.Pk
                        ? (bt = {
                            layer: this.scene.layers.getLayerById(Z.vt),
                            depthTest: !1,
                          })
                        : (bt = {
                            layer: this.scene.layers.getLayerById(Z.vt),
                            depthTest: !0,
                          }))
                    : (bt = {
                        layer: this.scene.layers.getLayerById(Z.vt),
                        depthTest: !0,
                      }),
                  !!ft.length && We.length !== ft.length)
                ) {
                  console.error(
                    "renderLines: position/color arrays have different lengths"
                  );
                  return;
                }
                if (We.length % 2 !== 0) {
                  console.error(
                    "renderLines: array length is not divisible by 2"
                  );
                  return;
                }
                this._addLines(We, ft, bt);
              }),
              ($e.k.prototype.enableVr = function () {}),
              Object.defineProperty(qe.M.prototype, "node", {
                get: function () {
                  return this.entity;
                },
              }),
              Object.defineProperty(Tt.r0.prototype, "enable", {
                get: function () {
                  return this.enabled;
                },
                set: function (We) {
                  this.enabled = We;
                },
              }),
              (Mt.v.prototype.setVisible = function (We) {
                this.enabled = We;
              }),
              Object.defineProperty(Mt.v.prototype, "aabb", {
                get: function () {
                  return null;
                },
                set: function (We) {},
              }),
              Object.defineProperty(Dt.V.prototype, "aabb", {
                get: function () {
                  return null;
                },
                set: function (We) {},
              }),
              Object.defineProperty(At.D.prototype, "bodyType", {
                get: function () {
                  return this.type;
                },
                set: function (We) {
                  this.type = We;
                },
              }),
              (At.D.prototype.syncBodyToEntity = function () {
                this._updateDynamic();
              }),
              (xt.Lz.prototype.setGravity = function () {
                arguments.length === 1
                  ? this.gravity.copy(arguments[0])
                  : this.gravity.set(arguments[0], arguments[1], arguments[2]);
              });
            function Xs(We, ft, bt) {
              (0, jt.h)({
                glueUrl: We,
                wasmUrl: ft,
                fallbackUrl: bt,
                lazyInit: !0,
              });
            }
            function Zs(We) {}
          },
          7301: (Se, W, a) => {
            "use strict";
            a.d(W, { S: () => x });
            class x {
              static joinPath(g, c) {
                c = c || ".";
                const d = function (f) {
                  return f
                    .replace(/\\/g, "\\\\")
                    .replace(new RegExp("\\" + c, "g"), "\\" + c);
                };
                return g.map(d).join(c);
              }
              static splitPath(g, c) {
                c = c || ".";
                const d = [];
                let h = "",
                  f = 0;
                for (; f < g.length; ) {
                  let s = g[f++];
                  s === "\\" && f < g.length
                    ? ((s = g[f++]),
                      s === "\\" || s === c ? (h += s) : (h += "\\" + s))
                    : s === c
                    ? (d.push(h), (h = ""))
                    : (h += s);
                }
                return h.length > 0 && d.push(h), d;
              }
              static encode(g, c, d) {
                return `${Array.isArray(g) ? g.join("/") : g}/${c}/${
                  Array.isArray(d) ? d.join("/") : d
                }`;
              }
              resolve(g) {
                return null;
              }
              unresolve(g) {}
              update(g) {}
            }
          },
          7122: (Se, W, a) => {
            "use strict";
            a.d(W, { o: () => c });
            var x = a(7301),
              T = a(5440),
              g = a(258);
            class c {
              constructor(h) {
                if (
                  ((this._isPathInMask = (n, o) => {
                    const i = this._mask[n];
                    if (i) {
                      if (i.children || (o && i.value !== !1)) return !0;
                    } else return !1;
                    return !1;
                  }),
                  (this.graph = h),
                  !h)
                )
                  return;
                this._mask = null;
                const f = {};
                (function n(o) {
                  f[o.name] = o;
                  for (let i = 0; i < o.children.length; ++i) n(o.children[i]);
                })(h),
                  (this.nodes = f),
                  (this.targetCache = {});
                const l = function (o) {
                  let i = o;
                  for (; i && !(i instanceof g.J); ) i = i.parent;
                  let e;
                  return (
                    i &&
                      (i.render
                        ? (e = i.render.meshInstances)
                        : i.model && (e = i.model.meshInstances)),
                    e
                  );
                };
                (this.nodeCounts = {}),
                  (this.activeNodes = []),
                  (this.handlers = {
                    localPosition: function (n) {
                      const o = n.localPosition,
                        i = function (t) {
                          o.set(...t);
                        };
                      return c.createAnimTarget(
                        i,
                        "vector",
                        3,
                        n,
                        "localPosition"
                      );
                    },
                    localRotation: function (n) {
                      const o = n.localRotation,
                        i = function (t) {
                          o.set(...t);
                        };
                      return c.createAnimTarget(
                        i,
                        "quaternion",
                        4,
                        n,
                        "localRotation"
                      );
                    },
                    localScale: function (n) {
                      const o = n.localScale,
                        i = function (t) {
                          o.set(...t);
                        };
                      return c.createAnimTarget(
                        i,
                        "vector",
                        3,
                        n,
                        "localScale"
                      );
                    },
                    weight: function (n, o) {
                      o.indexOf("name.") === 0
                        ? (o = o.replace("name.", ""))
                        : (o = Number(o));
                      const i = l(n);
                      let e;
                      if (i) {
                        for (let t = 0; t < i.length; ++t)
                          if (i[t].node.name === n.name && i[t].morphInstance) {
                            const r = i[t].morphInstance,
                              u = (y) => {
                                r.setWeight(o, y[0]);
                              };
                            e || (e = []), e.push(u);
                          }
                      }
                      if (e) {
                        const t = (r) => {
                          for (let u = 0; u < e.length; ++u) e[u](r);
                        };
                        return c.createAnimTarget(
                          t,
                          "number",
                          1,
                          n,
                          `weight.${o}`
                        );
                      }
                      return null;
                    },
                    materialTexture: (n, o) => {
                      const i = l(n);
                      if (i) {
                        let e;
                        for (let t = 0; t < i.length; ++t)
                          if (i[t].node.name === n.name) {
                            e = i[t];
                            break;
                          }
                        if (e) {
                          const t = (r) => {
                            const u = this.animComponent.system.app.assets.get(
                              r[0]
                            );
                            u &&
                              u.resource &&
                              u.type === "texture" &&
                              ((e.material[o] = u.resource),
                              e.material.update());
                          };
                          return c.createAnimTarget(
                            t,
                            "vector",
                            1,
                            n,
                            "materialTexture",
                            "material"
                          );
                        }
                      }
                      return null;
                    },
                  });
              }
              _isPathActive(h) {
                if (!this._mask) return !0;
                const f = [h.entityPath[0], this.graph.name];
                for (let s = 0; s < f.length; ++s) {
                  let l = f[s];
                  if (this._isPathInMask(l, h.entityPath.length === 1))
                    return !0;
                  for (let n = 1; n < h.entityPath.length; n++)
                    if (
                      ((l += "/" + h.entityPath[n]),
                      this._isPathInMask(l, n === h.entityPath.length - 1))
                    )
                      return !0;
                }
                return !1;
              }
              findNode(h) {
                if (!this._isPathActive(h)) return null;
                let f;
                return (
                  this.graph &&
                    ((f = this.graph.findByPath(h.entityPath)),
                    f || (f = this.graph.findByPath(h.entityPath.slice(1)))),
                  f ||
                    (f =
                      this.nodes[h.entityPath[h.entityPath.length - 1] || ""]),
                  f
                );
              }
              static createAnimTarget(h, f, s, l, n, o) {
                const i = x.S.encode(l.path, o || "entity", n);
                return new T.e(h, f, s, i);
              }
              resolve(h) {
                const f = x.S.encode(h.entityPath, h.component, h.propertyPath);
                let s = this.targetCache[f];
                if (s) return s;
                const l = this.findNode(h);
                if (!l) return null;
                const n = this.handlers[h.propertyPath];
                return !n || ((s = n(l)), !s)
                  ? null
                  : ((this.targetCache[f] = s),
                    this.nodeCounts[l.path]
                      ? this.nodeCounts[l.path]++
                      : (this.activeNodes.push(l),
                        (this.nodeCounts[l.path] = 1)),
                    s);
              }
              unresolve(h) {
                if (h.component !== "graph") return;
                const f =
                  this.nodes[h.entityPath[h.entityPath.length - 1] || ""];
                if (
                  (this.nodeCounts[f.path]--, this.nodeCounts[f.path] === 0)
                ) {
                  const s = this.activeNodes,
                    l = s.indexOf(f.node),
                    n = s.length;
                  l < n - 1 && (s[l] = s[n - 1]), s.pop();
                }
              }
              update(h) {
                const f = this.activeNodes;
                for (let s = 0; s < f.length; ++s) f[s]._dirtifyLocal();
              }
              assignMask(h) {
                return h !== this._mask ? ((this._mask = h), !0) : !1;
              }
            }
          },
          3471: (Se, W, a) => {
            "use strict";
            a.d(W, { B3: () => x, NW: () => T, Qf: () => g });
            const x = 0,
              T = 1,
              g = 2;
          },
          9509: (Se, W, a) => {
            "use strict";
            a.d(W, { o: () => u });
            var x = a(9078),
              T = a(324),
              g = a(7968),
              c = a(8949),
              d = a(4585),
              h = a(2978);
            class f {
              constructor(p, _, m, E, v = 1) {
                (this._state = p),
                  (this._parent = _),
                  (this._name = m),
                  Array.isArray(E)
                    ? ((this._point = new h.S(E[0], E[1])),
                      (this._pointLength = this._point.length()))
                    : ((this._point = E), (this._pointLength = E)),
                  (this._speed = v),
                  (this._weightedSpeed = 1),
                  (this._weight = 1),
                  (this._animTrack = null);
              }
              get parent() {
                return this._parent;
              }
              get name() {
                return this._name;
              }
              get path() {
                return this._parent
                  ? this._parent.path + "." + this._name
                  : this._name;
              }
              get point() {
                return this._point;
              }
              get pointLength() {
                return this._pointLength;
              }
              set weight(p) {
                this._weight = p;
              }
              get weight() {
                return this._parent
                  ? this._parent.weight * this._weight
                  : this._weight;
              }
              get normalizedWeight() {
                const p = this._state.totalWeight;
                return p === 0 ? 0 : this.weight / p;
              }
              get speed() {
                return this._weightedSpeed * this._speed;
              }
              get absoluteSpeed() {
                return Math.abs(this._speed);
              }
              set weightedSpeed(p) {
                this._weightedSpeed = p;
              }
              get weightedSpeed() {
                return this._weightedSpeed;
              }
              set animTrack(p) {
                this._animTrack = p;
              }
              get animTrack() {
                return this._animTrack;
              }
            }
            class s extends f {
              constructor(p, _, m, E, v, P, I, A, B) {
                super(p, _, m, E),
                  (this._parameters = v),
                  (this._parameterValues = new Array(v.length)),
                  (this._children = []),
                  (this._findParameter = B),
                  (this._syncAnimations = I !== !1),
                  (this._pointCache = {});
                for (let C = 0; C < P.length; C++) {
                  const w = P[C];
                  w.children
                    ? this._children.push(
                        A(
                          w.type,
                          this,
                          null,
                          m,
                          1,
                          w.parameter ? [w.parameter] : w.parameters,
                          w.children,
                          A,
                          B
                        )
                      )
                    : this._children.push(
                        new f(p, this, w.name, w.point, w.speed)
                      );
                }
              }
              get weight() {
                return (
                  this.calculateWeights(),
                  this._parent
                    ? this._parent.weight * this._weight
                    : this._weight
                );
              }
              get syncAnimations() {
                return this._syncAnimations;
              }
              getChild(p) {
                for (let _ = 0; _ < this._children.length; _++)
                  if (this._children[_].name === p) return this._children[_];
                return null;
              }
              updateParameterValues() {
                let p = !0;
                for (let _ = 0; _ < this._parameterValues.length; _++) {
                  const m = this._findParameter(this._parameters[_]).value;
                  this._parameterValues[_] !== m &&
                    ((this._parameterValues[_] = m), (p = !1));
                }
                return p;
              }
              getNodeWeightedDuration(p) {
                return (
                  (this._children[p].animTrack.duration /
                    this._children[p].speedMultiplier) *
                  this._children[p].weight
                );
              }
              getNodeCount() {
                let p = 0;
                for (let _ = 0; _ < this._children.length; _++)
                  this._children[_].constructor === s
                    ? (p += this._children[_].getNodeCount())
                    : p++;
                return p;
              }
            }
            class l extends s {
              constructor(p, _, m, E, v, P, I, A, B) {
                P.sort((C, w) => C.point - w.point),
                  super(p, _, m, E, v, P, I, A, B);
              }
              calculateWeights() {
                if (this.updateParameterValues()) return;
                let p = 0;
                this._children[0].weight = 0;
                for (let _ = 0; _ < this._children.length; _++) {
                  const m = this._children[_];
                  if (_ !== this._children.length - 1) {
                    const E = this._children[_ + 1];
                    if (m.point === E.point) (m.weight = 0.5), (E.weight = 0.5);
                    else if (
                      d.m.between(
                        this._parameterValues[0],
                        m.point,
                        E.point,
                        !0
                      )
                    ) {
                      const v = Math.abs(m.point - E.point),
                        P = Math.abs(m.point - this._parameterValues[0]),
                        I = (v - P) / v;
                      (m.weight = I), (E.weight = 1 - I);
                    } else E.weight = 0;
                  }
                  this._syncAnimations &&
                    (p += (m.animTrack.duration / m.absoluteSpeed) * m.weight);
                }
                if (this._syncAnimations)
                  for (let _ = 0; _ < this._children.length; _++) {
                    const m = this._children[_];
                    m.weightedSpeed =
                      m.animTrack.duration / m.absoluteSpeed / p;
                  }
              }
            }
            class n extends s {
              pointDistanceCache(p, _) {
                const m = `${p}${_}`;
                return (
                  this._pointCache[m] ||
                    (this._pointCache[m] = this._children[_].point
                      .clone()
                      .sub(this._children[p].point)),
                  this._pointCache[m]
                );
              }
              calculateWeights() {
                if (this.updateParameterValues()) return;
                let p, _;
                n._p.set(...this._parameterValues), (p = 0), (_ = 0);
                for (let m = 0; m < this._children.length; m++) {
                  const E = this._children[m],
                    v = E.point;
                  n._pip.set(n._p.x, n._p.y).sub(v);
                  let P = Number.MAX_VALUE;
                  for (let I = 0; I < this._children.length; I++) {
                    if (m === I) continue;
                    const A = this.pointDistanceCache(m, I),
                      B = d.m.clamp(1 - n._pip.dot(A) / A.lengthSq(), 0, 1);
                    B < P && (P = B);
                  }
                  (E.weight = P),
                    (p += P),
                    this._syncAnimations &&
                      (_ +=
                        (E.animTrack.duration / E.absoluteSpeed) * E.weight);
                }
                for (let m = 0; m < this._children.length; m++) {
                  const E = this._children[m];
                  (E.weight = E._weight / p),
                    this._syncAnimations &&
                      (E.weightedSpeed =
                        E.animTrack.duration / E.absoluteSpeed / _);
                }
              }
            }
            (n._p = new h.S()), (n._pip = new h.S());
            class o extends s {
              pointCache(p, _) {
                const m = `${p}${_}`;
                return (
                  this._pointCache[m] ||
                    (this._pointCache[m] = new h.S(
                      (this._children[_].pointLength -
                        this._children[p].pointLength) /
                        ((this._children[_].pointLength +
                          this._children[p].pointLength) /
                          2),
                      h.S.angleRad(
                        this._children[p].point,
                        this._children[_].point
                      ) * 2
                    )),
                  this._pointCache[m]
                );
              }
              calculateWeights() {
                if (this.updateParameterValues()) return;
                let p, _;
                o._p.set(...this._parameterValues);
                const m = o._p.length();
                (p = 0), (_ = 0);
                for (let E = 0; E < this._children.length; E++) {
                  const v = this._children[E],
                    P = v.point,
                    I = v.pointLength;
                  let A = Number.MAX_VALUE;
                  for (let B = 0; B < this._children.length; B++) {
                    if (E === B) continue;
                    const C = this.pointCache(E, B),
                      w = this._children[B].pointLength;
                    o._pip.set(
                      (m - I) / ((w + I) / 2),
                      h.S.angleRad(P, o._p) * 2
                    );
                    const k = d.m.clamp(
                      1 - Math.abs(o._pip.dot(C) / C.lengthSq()),
                      0,
                      1
                    );
                    k < A && (A = k);
                  }
                  (v.weight = A),
                    (p += A),
                    this._syncAnimations &&
                      (_ +=
                        (v.animTrack.duration / v.absoluteSpeed) * v.weight);
                }
                for (let E = 0; E < this._children.length; E++) {
                  const v = this._children[E];
                  if (((v.weight = v._weight / p), this._syncAnimations)) {
                    const P = (v.animTrack.duration / _) * p;
                    v.weightedSpeed = v.absoluteSpeed * P;
                  }
                }
              }
            }
            (o._p = new h.S()), (o._pip = new h.S());
            class i extends s {
              calculateWeights() {
                if (this.updateParameterValues()) return;
                let p = 0,
                  _ = 0;
                for (let m = 0; m < this._children.length; m++)
                  if (
                    ((p += Math.max(this._parameterValues[m], 0)),
                    this._syncAnimations)
                  ) {
                    const E = this._children[m];
                    _ += (E.animTrack.duration / E.absoluteSpeed) * E.weight;
                  }
                for (let m = 0; m < this._children.length; m++) {
                  const E = this._children[m],
                    v = Math.max(this._parameterValues[m], 0);
                  p
                    ? ((E.weight = v / p),
                      this._syncAnimations &&
                        (E.weightedSpeed =
                          E.animTrack.duration / E.absoluteSpeed / _))
                    : ((E.weight = 0),
                      this._syncAnimations && (E.weightedSpeed = 0));
                }
              }
            }
            var e = a(8250);
            class t {
              constructor(p, _, m = 1, E = !0, v) {
                (this._animations = {}),
                  (this._animationList = []),
                  (this._controller = p),
                  (this._name = _),
                  (this._speed = m),
                  (this._loop = E),
                  (this._hasAnimations = !1),
                  v
                    ? (this._blendTree = this._createTree(
                        v.type,
                        this,
                        null,
                        _,
                        1,
                        v.parameter ? [v.parameter] : v.parameters,
                        v.children,
                        v.syncAnimations,
                        this._createTree,
                        this._controller.findParameter
                      ))
                    : (this._blendTree = new f(this, null, _, 1, m));
              }
              _createTree(p, _, m, E, v, P, I, A, B, C) {
                switch (p) {
                  case e.YB:
                    return new l(_, m, E, v, P, I, A, B, C);
                  case e.Ju:
                    return new n(_, m, E, v, P, I, A, B, C);
                  case e.cV:
                    return new o(_, m, E, v, P, I, A, B, C);
                  case e.Pp:
                    return new i(_, m, E, v, P, I, A, B, C);
                }
              }
              _getNodeFromPath(p) {
                let _ = this._blendTree;
                for (let m = 1; m < p.length; m++) _ = _.getChild(p[m]);
                return _;
              }
              addAnimation(p, _) {
                const m = p.join("."),
                  E = this._animationList.findIndex(function (v) {
                    return v.path === m;
                  });
                if (E >= 0) this._animationList[E].animTrack = _;
                else {
                  const v = this._getNodeFromPath(p);
                  (v.animTrack = _), this._animationList.push(v);
                }
                this._updateHasAnimations();
              }
              _updateHasAnimations() {
                this._hasAnimations =
                  this._animationList.length > 0 &&
                  this._animationList.every(
                    (p) => p.animTrack && p.animTrack !== c.k.EMPTY
                  );
              }
              get name() {
                return this._name;
              }
              set animations(p) {
                (this._animationList = p), this._updateHasAnimations();
              }
              get animations() {
                return this._animationList;
              }
              get hasAnimations() {
                return this._hasAnimations;
              }
              set speed(p) {
                this._speed = p;
              }
              get speed() {
                return this._speed;
              }
              set loop(p) {
                this._loop = p;
              }
              get loop() {
                return this._loop;
              }
              get nodeCount() {
                return !this._blendTree || this._blendTree.constructor === f
                  ? 1
                  : this._blendTree.getNodeCount();
              }
              get playable() {
                return (
                  e.Fw.indexOf(this.name) !== -1 ||
                  this.animations.length === this.nodeCount
                );
              }
              get looping() {
                if (this.animations.length > 0) {
                  const p = this.name + "." + this.animations[0].animTrack.name,
                    _ = this._controller.animEvaluator.findClip(p);
                  if (_) return _.loop;
                }
                return !1;
              }
              get totalWeight() {
                let p = 0;
                for (let _ = 0; _ < this.animations.length; _++)
                  p += this.animations[_].weight;
                return p;
              }
              get timelineDuration() {
                let p = 0;
                for (let _ = 0; _ < this.animations.length; _++) {
                  const m = this.animations[_];
                  m.animTrack.duration > p && (p = m.animTrack.duration);
                }
                return p;
              }
            }
            var r = a(7230);
            class u {
              constructor(p, _, m, E, v, P, I) {
                (this.findParameter = (A) => this._findParameter(A)),
                  (this._animEvaluator = p),
                  (this._states = {}),
                  (this._stateNames = []),
                  (this._eventHandler = v),
                  (this._findParameter = P),
                  (this._consumeTrigger = I);
                for (let A = 0; A < _.length; A++)
                  (this._states[_[A].name] = new t(
                    this,
                    _[A].name,
                    _[A].speed,
                    _[A].loop,
                    _[A].blendTree
                  )),
                    this._stateNames.push(_[A].name);
                (this._transitions = m.map((A) => new r.T((0, x.g)({}, A)))),
                  (this._findTransitionsFromStateCache = {}),
                  (this._findTransitionsBetweenStatesCache = {}),
                  (this._previousStateName = null),
                  (this._activeStateName = e.So),
                  (this._activeStateDuration = 0),
                  (this._activeStateDurationDirty = !0),
                  (this._playing = !1),
                  (this._activate = E),
                  (this._currTransitionTime = 1),
                  (this._totalTransitionTime = 1),
                  (this._isTransitioning = !1),
                  (this._transitionInterruptionSource = e.s6),
                  (this._transitionPreviousStates = []),
                  (this._timeInState = 0),
                  (this._timeInStateBefore = 0);
              }
              get animEvaluator() {
                return this._animEvaluator;
              }
              set activeState(p) {
                this._activeStateName = p;
              }
              get activeState() {
                return this._findState(this._activeStateName);
              }
              get activeStateName() {
                return this._activeStateName;
              }
              get activeStateAnimations() {
                return this.activeState.animations;
              }
              set previousState(p) {
                this._previousStateName = p;
              }
              get previousState() {
                return this._findState(this._previousStateName);
              }
              get previousStateName() {
                return this._previousStateName;
              }
              get playable() {
                let p = !0;
                for (let _ = 0; _ < this._stateNames.length; _++)
                  this._states[this._stateNames[_]].playable || (p = !1);
                return p;
              }
              set playing(p) {
                this._playing = p;
              }
              get playing() {
                return this._playing;
              }
              get activeStateProgress() {
                return this._getActiveStateProgressForTime(this._timeInState);
              }
              get activeStateDuration() {
                if (this._activeStateDurationDirty) {
                  let p = 0;
                  for (let _ = 0; _ < this.activeStateAnimations.length; _++) {
                    const m = this._animEvaluator.findClip(
                      this.activeStateAnimations[_].name
                    );
                    m && (p = Math.max(p, m.track.duration));
                  }
                  (this._activeStateDuration = p),
                    (this._activeStateDurationDirty = !1);
                }
                return this._activeStateDuration;
              }
              set activeStateCurrentTime(p) {
                (this._timeInStateBefore = p), (this._timeInState = p);
                for (let _ = 0; _ < this.activeStateAnimations.length; _++) {
                  const m = this.animEvaluator.findClip(
                    this.activeStateAnimations[_].name
                  );
                  m && (m.time = p);
                }
              }
              get activeStateCurrentTime() {
                return this._timeInState;
              }
              get transitioning() {
                return this._isTransitioning;
              }
              get transitionProgress() {
                return this._currTransitionTime / this._totalTransitionTime;
              }
              get states() {
                return this._stateNames;
              }
              assignMask(p) {
                return this._animEvaluator.assignMask(p);
              }
              _findState(p) {
                return this._states[p];
              }
              _getActiveStateProgressForTime(p) {
                if (
                  this.activeStateName === e.So ||
                  this.activeStateName === e.JK ||
                  this.activeStateName === e.i_
                )
                  return 1;
                const _ = this._animEvaluator.findClip(
                  this.activeStateAnimations[0].name
                );
                return _ ? _.progressForTime(p) : null;
              }
              _findTransitionsFromState(p) {
                let _ = this._findTransitionsFromStateCache[p];
                return (
                  _ ||
                    ((_ = this._transitions.filter(function (m) {
                      return m.from === p;
                    })),
                    (0, T._)(_),
                    (this._findTransitionsFromStateCache[p] = _)),
                  _
                );
              }
              _findTransitionsBetweenStates(p, _) {
                let m = this._findTransitionsBetweenStatesCache[p + "->" + _];
                return (
                  m ||
                    ((m = this._transitions.filter(function (E) {
                      return E.from === p && E.to === _;
                    })),
                    (0, T._)(m),
                    (this._findTransitionsBetweenStatesCache[p + "->" + _] =
                      m)),
                  m
                );
              }
              _transitionHasConditionsMet(p) {
                const _ = p.conditions;
                for (let m = 0; m < _.length; m++) {
                  const E = _[m],
                    v = this._findParameter(E.parameterName);
                  switch (E.predicate) {
                    case e.t1:
                      if (!(v.value > E.value)) return !1;
                      break;
                    case e.RZ:
                      if (!(v.value < E.value)) return !1;
                      break;
                    case e.ju:
                      if (!(v.value >= E.value)) return !1;
                      break;
                    case e.gk:
                      if (!(v.value <= E.value)) return !1;
                      break;
                    case e.j6:
                      if (v.value !== E.value) return !1;
                      break;
                    case e.vT:
                      if (v.value === E.value) return !1;
                      break;
                  }
                }
                return !0;
              }
              _findTransition(p, _) {
                let m = [];
                if (p && _)
                  m = m.concat(this._findTransitionsBetweenStates(p, _));
                else if (!this._isTransitioning)
                  (m = m.concat(
                    this._findTransitionsFromState(this._activeStateName)
                  )),
                    (m = m.concat(this._findTransitionsFromState(e.i_)));
                else
                  switch (this._transitionInterruptionSource) {
                    case e.IF:
                      (m = m.concat(
                        this._findTransitionsFromState(this._previousStateName)
                      )),
                        (m = m.concat(this._findTransitionsFromState(e.i_)));
                      break;
                    case e.Qn:
                      (m = m.concat(
                        this._findTransitionsFromState(this._activeStateName)
                      )),
                        (m = m.concat(this._findTransitionsFromState(e.i_)));
                      break;
                    case e.hq:
                      (m = m.concat(
                        this._findTransitionsFromState(this._previousStateName)
                      )),
                        (m = m.concat(
                          this._findTransitionsFromState(this._activeStateName)
                        )),
                        (m = m.concat(this._findTransitionsFromState(e.i_)));
                      break;
                    case e.lV:
                      (m = m.concat(
                        this._findTransitionsFromState(this._activeStateName)
                      )),
                        (m = m.concat(
                          this._findTransitionsFromState(
                            this._previousStateName
                          )
                        )),
                        (m = m.concat(this._findTransitionsFromState(e.i_)));
                      break;
                  }
                if (
                  ((m = m.filter((E) => {
                    if (E.to === this.activeStateName) return !1;
                    if (E.hasExitTime) {
                      let v = this._getActiveStateProgressForTime(
                          this._timeInStateBefore
                        ),
                        P = this._getActiveStateProgressForTime(
                          this._timeInState
                        );
                      if (
                        (E.exitTime < 1 &&
                          this.activeState.loop &&
                          ((v -= Math.floor(v)), (P -= Math.floor(P))),
                        P === v)
                      ) {
                        if (P !== E.exitTime) return null;
                      } else if (!(E.exitTime > v && E.exitTime <= P))
                        return null;
                    }
                    return this._transitionHasConditionsMet(E);
                  })),
                  m.length > 0)
                ) {
                  const E = m[0];
                  if (E.to === e.JK) {
                    const v = this._findTransitionsFromState(e.So)[0];
                    E.to = v.to;
                  }
                  return E;
                }
                return null;
              }
              updateStateFromTransition(p) {
                let _, m, E;
                (this.previousState = p.from ? this.activeStateName : null),
                  (this.activeState = p.to),
                  (this._activeStateDurationDirty = !0);
                for (let B = 0; B < p.conditions.length; B++) {
                  const C = p.conditions[B];
                  this._findParameter(C.parameterName).type === e.S5 &&
                    this._consumeTrigger(C.parameterName);
                }
                if (this.previousState) {
                  this._isTransitioning ||
                    (this._transitionPreviousStates = []),
                    this._transitionPreviousStates.push({
                      name: this._previousStateName,
                      weight: 1,
                    });
                  const B = Math.min(
                    this._totalTransitionTime !== 0
                      ? this._currTransitionTime / this._totalTransitionTime
                      : 1,
                    1
                  );
                  for (
                    let C = 0;
                    C < this._transitionPreviousStates.length;
                    C++
                  ) {
                    this._isTransitioning
                      ? C !== this._transitionPreviousStates.length - 1
                        ? (this._transitionPreviousStates[C].weight *= 1 - B)
                        : (this._transitionPreviousStates[C].weight = B)
                      : (this._transitionPreviousStates[C].weight = 1),
                      (_ = this._findState(
                        this._transitionPreviousStates[C].name
                      ));
                    for (let w = 0; w < _.animations.length; w++)
                      (m = _.animations[w]),
                        (E = this._animEvaluator.findClip(
                          m.name + ".previous." + C
                        )),
                        E ||
                          ((E = this._animEvaluator.findClip(m.name)),
                          (E.name = m.name + ".previous." + C)),
                        C !== this._transitionPreviousStates.length - 1 &&
                          E.pause();
                  }
                }
                (this._isTransitioning = !0),
                  (this._totalTransitionTime = p.time),
                  (this._currTransitionTime = 0),
                  (this._transitionInterruptionSource = p.interruptionSource);
                const v = this.activeState,
                  P =
                    p.transitionOffset &&
                    p.transitionOffset > 0 &&
                    p.transitionOffset < 1;
                let I = 0,
                  A = 0;
                if (P) {
                  const B = v.timelineDuration * p.transitionOffset;
                  (I = B), (A = B);
                }
                (this._timeInState = I), (this._timeInStateBefore = A);
                for (let B = 0; B < v.animations.length; B++) {
                  if (
                    ((E = this._animEvaluator.findClip(v.animations[B].name)),
                    E)
                  )
                    E.reset();
                  else {
                    const C = Number.isFinite(v.animations[B].speed)
                      ? v.animations[B].speed
                      : v.speed;
                    (E = new g.L(
                      v.animations[B].animTrack,
                      this._timeInState,
                      C,
                      !0,
                      v.loop,
                      this._eventHandler
                    )),
                      (E.name = v.animations[B].name),
                      this._animEvaluator.addClip(E);
                  }
                  if (
                    (p.time > 0
                      ? (E.blendWeight = 0)
                      : (E.blendWeight = v.animations[B].normalizedWeight),
                    E.play(),
                    P)
                  )
                    E.time = v.timelineDuration * p.transitionOffset;
                  else {
                    const C = v.speed >= 0 ? 0 : this.activeStateDuration;
                    E.time = C;
                  }
                }
              }
              _transitionToState(p) {
                if (!this._findState(p)) return;
                let _ = this._findTransition(this._activeStateName, p);
                _ ||
                  (this._animEvaluator.removeClips(),
                  (_ = new r.T({ from: null, to: p }))),
                  this.updateStateFromTransition(_);
              }
              assignAnimation(p, _, m, E) {
                const v = p.split(".");
                let P = this._findState(v[0]);
                P ||
                  ((P = new t(this, v[0], m)),
                  (this._states[v[0]] = P),
                  this._stateNames.push(v[0])),
                  P.addAnimation(v, _),
                  this._animEvaluator.updateClipTrack(P.name, _),
                  m !== void 0 && (P.speed = m),
                  E !== void 0 && (P.loop = E),
                  !this._playing &&
                    this._activate &&
                    this.playable &&
                    this.play(),
                  (this._activeStateDurationDirty = !0);
              }
              removeNodeAnimations(p) {
                if (e.Fw.indexOf(p) !== -1) return !1;
                const _ = this._findState(p);
                return _ ? ((_.animations = []), !0) : !1;
              }
              play(p) {
                p && this._transitionToState(p), (this._playing = !0);
              }
              pause() {
                this._playing = !1;
              }
              reset() {
                (this._previousStateName = null),
                  (this._activeStateName = e.So),
                  (this._playing = !1),
                  (this._currTransitionTime = 1),
                  (this._totalTransitionTime = 1),
                  (this._isTransitioning = !1),
                  (this._timeInState = 0),
                  (this._timeInStateBefore = 0),
                  this._animEvaluator.removeClips();
              }
              rebind() {
                this._animEvaluator.rebind();
              }
              update(p) {
                if (!this._playing) return;
                let _, m, E;
                (this.activeState.loop ||
                  this._timeInState < this.activeStateDuration) &&
                  ((this._timeInStateBefore = this._timeInState),
                  (this._timeInState += p * this.activeState.speed),
                  !this.activeState.loop &&
                    this._timeInState > this.activeStateDuration &&
                    ((this._timeInState = this.activeStateDuration),
                    (p = this.activeStateDuration - this._timeInStateBefore)));
                const v = this._findTransition(this._activeStateName);
                if (
                  (v && this.updateStateFromTransition(v),
                  this._isTransitioning)
                )
                  if (
                    ((this._currTransitionTime += p),
                    this._currTransitionTime <= this._totalTransitionTime)
                  ) {
                    const P =
                      this._totalTransitionTime !== 0
                        ? this._currTransitionTime / this._totalTransitionTime
                        : 1;
                    for (
                      let I = 0;
                      I < this._transitionPreviousStates.length;
                      I++
                    ) {
                      _ = this._findState(
                        this._transitionPreviousStates[I].name
                      );
                      const A = this._transitionPreviousStates[I].weight;
                      for (let B = 0; B < _.animations.length; B++)
                        (m = _.animations[B]),
                          (E = this._animEvaluator.findClip(
                            m.name + ".previous." + I
                          )),
                          E &&
                            (E.blendWeight = (1 - P) * m.normalizedWeight * A);
                    }
                    _ = this.activeState;
                    for (let I = 0; I < _.animations.length; I++)
                      (m = _.animations[I]),
                        (this._animEvaluator.findClip(m.name).blendWeight =
                          P * m.normalizedWeight);
                  } else {
                    this._isTransitioning = !1;
                    const P = this.activeStateAnimations.length,
                      I = this._animEvaluator.clips.length;
                    for (let A = 0; A < I - P; A++)
                      this._animEvaluator.removeClip(0);
                    (this._transitionPreviousStates = []),
                      (_ = this.activeState);
                    for (let A = 0; A < _.animations.length; A++)
                      (m = _.animations[A]),
                        (E = this._animEvaluator.findClip(m.name)),
                        E && (E.blendWeight = m.normalizedWeight);
                  }
                else if (this.activeState._blendTree.constructor !== f) {
                  _ = this.activeState;
                  for (let P = 0; P < _.animations.length; P++)
                    (m = _.animations[P]),
                      (E = this._animEvaluator.findClip(m.name)),
                      E &&
                        ((E.blendWeight = m.normalizedWeight),
                        m.parent.syncAnimations && (E.speed = m.speed));
                }
                this._animEvaluator.update(p, this.activeState.hasAnimations);
              }
            }
          },
          7230: (Se, W, a) => {
            "use strict";
            a.d(W, { T: () => T });
            var x = a(8250);
            class T {
              constructor({
                from: c,
                to: d,
                time: h = 0,
                priority: f = 0,
                conditions: s = [],
                exitTime: l = null,
                transitionOffset: n = null,
                interruptionSource: o = x.s6,
              }) {
                (this._from = c),
                  (this._to = d),
                  (this._time = h),
                  (this._priority = f),
                  (this._conditions = s),
                  (this._exitTime = l),
                  (this._transitionOffset = n),
                  (this._interruptionSource = o);
              }
              get from() {
                return this._from;
              }
              set to(c) {
                this._to = c;
              }
              get to() {
                return this._to;
              }
              get time() {
                return this._time;
              }
              get priority() {
                return this._priority;
              }
              get conditions() {
                return this._conditions;
              }
              get exitTime() {
                return this._exitTime;
              }
              get transitionOffset() {
                return this._transitionOffset;
              }
              get interruptionSource() {
                return this._interruptionSource;
              }
              get hasExitTime() {
                return !!this.exitTime;
              }
            }
          },
          8250: (Se, W, a) => {
            "use strict";
            a.d(W, {
              Fw: () => P,
              IF: () => T,
              JK: () => E,
              Ju: () => p,
              Pp: () => _,
              Qn: () => g,
              RZ: () => f,
              S5: () => r,
              So: () => m,
              YB: () => u,
              cV: () => y,
              gk: () => l,
              hq: () => c,
              i_: () => v,
              j6: () => n,
              ju: () => s,
              lV: () => d,
              p2: () => t,
              qR: () => i,
              s6: () => x,
              t1: () => h,
              v1: () => A,
              vT: () => o,
              xU: () => I,
              yg: () => e,
            });
            const x = "NONE",
              T = "PREV_STATE",
              g = "NEXT_STATE",
              c = "PREV_STATE_NEXT_STATE",
              d = "NEXT_STATE_PREV_STATE",
              h = "GREATER_THAN",
              f = "LESS_THAN",
              s = "GREATER_THAN_EQUAL_TO",
              l = "LESS_THAN_EQUAL_TO",
              n = "EQUAL_TO",
              o = "NOT_EQUAL_TO",
              i = "INTEGER",
              e = "FLOAT",
              t = "BOOLEAN",
              r = "TRIGGER",
              u = "1D",
              y = "2D_DIRECTIONAL",
              p = "2D_CARTESIAN",
              _ = "DIRECT",
              m = "START",
              E = "END",
              v = "ANY",
              P = [m, E, v],
              I = "OVERWRITE",
              A = "ADDITIVE";
          },
          7968: (Se, W, a) => {
            "use strict";
            a.d(W, { L: () => g });
            var x = a(9078),
              T = a(8934);
            class g {
              constructor(d, h, f, s, l, n) {
                (this._name = d.name),
                  (this._track = d),
                  (this._snapshot = new T.e(d)),
                  (this._playing = s),
                  (this._time = h),
                  (this._speed = f),
                  (this._loop = l),
                  (this._blendWeight = 1),
                  (this._blendOrder = 0),
                  (this._eventHandler = n),
                  this.alignCursorToCurrentTime();
              }
              set name(d) {
                this._name = d;
              }
              get name() {
                return this._name;
              }
              set track(d) {
                (this._track = d), (this._snapshot = new T.e(d));
              }
              get track() {
                return this._track;
              }
              get snapshot() {
                return this._snapshot;
              }
              set time(d) {
                (this._time = d), this.alignCursorToCurrentTime();
              }
              get time() {
                return this._time;
              }
              set speed(d) {
                const h = Math.sign(d) !== Math.sign(this._speed);
                (this._speed = d), h && this.alignCursorToCurrentTime();
              }
              get speed() {
                return this._speed;
              }
              set loop(d) {
                this._loop = d;
              }
              get loop() {
                return this._loop;
              }
              set blendWeight(d) {
                this._blendWeight = d;
              }
              get blendWeight() {
                return this._blendWeight;
              }
              set blendOrder(d) {
                this._blendOrder = d;
              }
              get blendOrder() {
                return this._blendOrder;
              }
              set eventCursor(d) {
                this._eventCursor = d;
              }
              get eventCursor() {
                return this._eventCursor;
              }
              get eventCursorEnd() {
                return this.isReverse ? 0 : this._track.events.length - 1;
              }
              get nextEvent() {
                return this._track.events[this._eventCursor];
              }
              get isReverse() {
                return this._speed < 0;
              }
              nextEventAheadOfTime(d) {
                return this.nextEvent
                  ? this.isReverse
                    ? this.nextEvent.time <= d
                    : this.nextEvent.time >= d
                  : !1;
              }
              nextEventBehindTime(d) {
                return this.nextEvent
                  ? d === this.track.duration
                    ? this.isReverse
                      ? this.nextEvent.time >= d
                      : this.nextEvent.time <= d
                    : this.isReverse
                    ? this.nextEvent.time > d
                    : this.nextEvent.time < d
                  : !1;
              }
              resetEventCursor() {
                this._eventCursor = this.isReverse
                  ? this._track.events.length - 1
                  : 0;
              }
              moveEventCursor() {
                (this._eventCursor += this.isReverse ? -1 : 1),
                  this._eventCursor >= this.track.events.length
                    ? (this._eventCursor = 0)
                    : this._eventCursor < 0 &&
                      (this._eventCursor = this.track.events.length - 1);
              }
              clipFrameTime(d) {
                const h = g.eventFrame;
                (h.start = 0),
                  (h.end = d),
                  (h.residual = 0),
                  this.isReverse
                    ? d < 0 &&
                      ((h.start = this.track.duration),
                      (h.end = 0),
                      (h.residual = d + this.track.duration))
                    : d > this.track.duration &&
                      ((h.start = 0),
                      (h.end = this.track.duration),
                      (h.residual = d - this.track.duration));
              }
              alignCursorToCurrentTime() {
                for (
                  this.resetEventCursor();
                  this.nextEventBehindTime(this._time) &&
                  this._eventCursor !== this.eventCursorEnd;

                )
                  this.moveEventCursor();
              }
              fireNextEvent() {
                this._eventHandler.fire(
                  this.nextEvent.name,
                  (0, x.g)({ track: this.track }, this.nextEvent)
                ),
                  this.moveEventCursor();
              }
              fireNextEventInFrame(d, h) {
                return this.nextEventAheadOfTime(d) &&
                  this.nextEventBehindTime(h)
                  ? (this.fireNextEvent(), !0)
                  : !1;
              }
              activeEventsForFrame(d, h) {
                const f = g.eventFrame;
                this.clipFrameTime(h);
                const s = this.eventCursor;
                for (
                  ;
                  this.fireNextEventInFrame(d, f.end) && s !== this.eventCursor;

                );
                this.loop &&
                  Math.abs(f.residual) > 0 &&
                  this.activeEventsForFrame(f.start, f.residual);
              }
              progressForTime(d) {
                return (d * this._speed) / this._track.duration;
              }
              _update(d) {
                if (this._playing) {
                  let h = this._time;
                  const f = this._track.duration,
                    s = this._speed,
                    l = this._loop;
                  this._track.events.length > 0 &&
                    f > 0 &&
                    this.activeEventsForFrame(h, h + s * d),
                    (h += s * d),
                    s >= 0
                      ? h > f &&
                        (l
                          ? (h = h % f || 0)
                          : ((h = this._track.duration), this.pause()))
                      : h < 0 &&
                        (l ? (h = f + (h % f || 0)) : ((h = 0), this.pause())),
                    (this._time = h);
                }
                this._time !== this._snapshot._time &&
                  this._track.eval(this._time, this._snapshot);
              }
              play() {
                (this._playing = !0), (this._time = 0);
              }
              stop() {
                (this._playing = !1), (this._time = 0);
              }
              pause() {
                this._playing = !1;
              }
              resume() {
                this._playing = !0;
              }
              reset() {
                this._time = 0;
              }
            }
            g.eventFrame = { start: 0, end: 0, residual: 0 };
          },
          7061: (Se, W, a) => {
            "use strict";
            a.d(W, { c: () => x });
            class x {
              constructor(g, c, d, h) {
                (this._paths = g),
                  (this._input = c),
                  (this._output = d),
                  (this._interpolation = h);
              }
              get paths() {
                return this._paths;
              }
              get input() {
                return this._input;
              }
              get output() {
                return this._output;
              }
              get interpolation() {
                return this._interpolation;
              }
            }
          },
          3248: (Se, W, a) => {
            "use strict";
            a.d(W, { X: () => x });
            class x {
              constructor(g, c) {
                (this._components = g), (this._data = c);
              }
              get components() {
                return this._components;
              }
              get data() {
                return this._data;
              }
            }
          },
          7570: (Se, W, a) => {
            "use strict";
            a.d(W, { g: () => h });
            var x = a(6847),
              T = a(8250);
            class g {
              static dot(s, l) {
                const n = s.length;
                let o = 0;
                for (let i = 0; i < n; ++i) o += s[i] * l[i];
                return o;
              }
              static normalize(s) {
                let l = g.dot(s, s);
                if (l > 0) {
                  l = 1 / Math.sqrt(l);
                  const n = s.length;
                  for (let o = 0; o < n; ++o) s[o] *= l;
                }
              }
              static set(s, l, n) {
                const o = s.length;
                if (n === "quaternion") {
                  let i = g.dot(l, l);
                  i > 0 && (i = 1 / Math.sqrt(i));
                  for (let e = 0; e < o; ++e) s[e] = l[e] * i;
                } else for (let i = 0; i < o; ++i) s[i] = l[i];
              }
              static blendVec(s, l, n, o) {
                const i = o ? 1 : 1 - n,
                  e = s.length;
                for (let t = 0; t < e; ++t) s[t] = s[t] * i + l[t] * n;
              }
              static blendQuat(s, l, n, o) {
                const i = s.length,
                  e = o ? 1 : 1 - n;
                g.dot(s, l) < 0 && (n = -n);
                for (let t = 0; t < i; ++t) s[t] = s[t] * e + l[t] * n;
                o || g.normalize(s);
              }
              static blend(s, l, n, o, i) {
                o === "quaternion"
                  ? g.blendQuat(s, l, n, i)
                  : g.blendVec(s, l, n, i);
              }
              static stableSort(s, l) {
                const n = s.length;
                for (let o = 0; o < n - 1; ++o)
                  for (let i = o + 1; i < n; ++i)
                    if (l(s[i], s[o])) {
                      const e = s[o];
                      (s[o] = s[i]), (s[i] = e);
                    }
              }
            }
            var c = a(4585);
            class d {
              constructor(s, l) {
                (this._component = s),
                  (this.mask = new Int8Array(s.layers.length)),
                  (this.weights = new Float32Array(s.layers.length)),
                  (this.totalWeight = 0),
                  (this.counter = 0),
                  (this.layerCounter = 0),
                  (this.valueType = l),
                  (this.dirty = !0),
                  (this.value = l === d.TYPE_QUAT ? [0, 0, 0, 1] : [0, 0, 0]),
                  (this.baseValue = null),
                  (this.setter = null);
              }
              get _normalizeWeights() {
                return this._component.normalizeWeights;
              }
              getWeight(s) {
                return (
                  this.dirty && this.updateWeights(),
                  (this._normalizeWeights && this.totalWeight === 0) ||
                  !this.mask[s]
                    ? 0
                    : this._normalizeWeights
                    ? this.weights[s] / this.totalWeight
                    : c.m.clamp(this.weights[s], 0, 1)
                );
              }
              _layerBlendType(s) {
                return this._component.layers[s].blendType;
              }
              setMask(s, l) {
                (this.mask[s] = l),
                  this._normalizeWeights &&
                    (this._component.layers[s].blendType === T.xU &&
                      (this.mask = this.mask.fill(0, 0, s)),
                    (this.dirty = !0));
              }
              updateWeights() {
                this.totalWeight = 0;
                for (let s = 0; s < this.weights.length; s++)
                  (this.weights[s] = this._component.layers[s].weight),
                    (this.totalWeight += this.mask[s] * this.weights[s]);
                this.dirty = !1;
              }
              updateValue(s, l) {
                if (
                  (this.counter === 0 &&
                    (g.set(this.value, d.IDENTITY_QUAT_ARR, this.valueType),
                    this._normalizeWeights ||
                      g.blend(this.value, this.baseValue, 1, this.valueType)),
                  !(!this.mask[s] || this.getWeight(s) === 0))
                ) {
                  if (
                    this._layerBlendType(s) === T.v1 &&
                    !this._normalizeWeights
                  )
                    if (this.valueType === d.TYPE_QUAT) {
                      const n = d.q1.set(
                          this.value[0],
                          this.value[1],
                          this.value[2],
                          this.value[3]
                        ),
                        o = d.q2.set(
                          this.baseValue[0],
                          this.baseValue[1],
                          this.baseValue[2],
                          this.baseValue[3]
                        ),
                        i = d.q3.set(l[0], l[1], l[2], l[3]),
                        e = o.invert().mul(i);
                      e.slerp(x.D.IDENTITY, e, this.getWeight(s)),
                        n.mul(e),
                        (d.quatArr[0] = n.x),
                        (d.quatArr[1] = n.y),
                        (d.quatArr[2] = n.z),
                        (d.quatArr[3] = n.w),
                        g.set(this.value, d.quatArr, this.valueType);
                    } else
                      (d.vecArr[0] = l[0] - this.baseValue[0]),
                        (d.vecArr[1] = l[1] - this.baseValue[1]),
                        (d.vecArr[2] = l[2] - this.baseValue[2]),
                        g.blend(
                          this.value,
                          d.vecArr,
                          this.getWeight(s),
                          this.valueType,
                          !0
                        );
                  else
                    g.blend(this.value, l, this.getWeight(s), this.valueType);
                  this.setter && this.setter(this.value);
                }
              }
              unbind() {
                this.setter && this.setter(this.baseValue);
              }
            }
            (d.TYPE_QUAT = "quaternion"),
              (d.TYPE_VEC3 = "vector3"),
              (d.q1 = new x.D()),
              (d.q2 = new x.D()),
              (d.q3 = new x.D()),
              (d.quatArr = [0, 0, 0, 1]),
              (d.vecArr = [0, 0, 0]),
              (d.IDENTITY_QUAT_ARR = [0, 0, 0, 1]);
            class h {
              constructor(s) {
                (this._binder = s),
                  (this._clips = []),
                  (this._inputs = []),
                  (this._outputs = []),
                  (this._targets = {});
              }
              get clips() {
                return this._clips;
              }
              addClip(s) {
                const l = this._targets,
                  n = this._binder,
                  o = s.track.curves,
                  i = s.snapshot,
                  e = [],
                  t = [];
                for (let r = 0; r < o.length; ++r) {
                  const y = o[r].paths;
                  for (let p = 0; p < y.length; ++p) {
                    const _ = y[p],
                      m = n.resolve(_);
                    let E = l[(m && m.targetPath) || null];
                    if (!E && m) {
                      E = { target: m, value: [], curves: 0, blendCounter: 0 };
                      for (let v = 0; v < E.target.components; ++v)
                        E.value.push(0);
                      if (((l[m.targetPath] = E), n.animComponent)) {
                        if (!n.animComponent.targets[m.targetPath]) {
                          let v;
                          m.targetPath.substring(m.targetPath.length - 13) ===
                          "localRotation"
                            ? (v = d.TYPE_QUAT)
                            : (v = d.TYPE_VEC3),
                            (n.animComponent.targets[m.targetPath] = new d(
                              n.animComponent,
                              v
                            ));
                        }
                        n.animComponent.targets[m.targetPath].layerCounter++,
                          n.animComponent.targets[m.targetPath].setMask(
                            n.layerIndex,
                            1
                          );
                      }
                    }
                    E && (E.curves++, e.push(i._results[r]), t.push(E));
                  }
                }
                this._clips.push(s),
                  this._inputs.push(e),
                  this._outputs.push(t);
              }
              removeClip(s) {
                const l = this._targets,
                  n = this._binder,
                  o = this._clips,
                  e = o[s].track.curves;
                for (let t = 0; t < e.length; ++t) {
                  const u = e[t].paths;
                  for (let y = 0; y < u.length; ++y) {
                    const p = u[y],
                      _ = this._binder.resolve(p);
                    _ &&
                      (_.curves--,
                      _.curves === 0 &&
                        (n.unresolve(p),
                        delete l[_.targetPath],
                        n.animComponent &&
                          n.animComponent.targets[_.targetPath]
                            .layerCounter--));
                  }
                }
                o.splice(s, 1),
                  this._inputs.splice(s, 1),
                  this._outputs.splice(s, 1);
              }
              removeClips() {
                for (; this._clips.length > 0; ) this.removeClip(0);
              }
              updateClipTrack(s, l) {
                this._clips.forEach((n) => {
                  n.name.includes(s) && (n.track = l);
                }),
                  this.rebind();
              }
              findClip(s) {
                const l = this._clips;
                for (let n = 0; n < l.length; ++n) {
                  const o = l[n];
                  if (o.name === s) return o;
                }
                return null;
              }
              rebind() {
                this._binder.rebind(), (this._targets = {});
                const s = [...this.clips];
                this.removeClips(),
                  s.forEach((l) => {
                    this.addClip(l);
                  });
              }
              assignMask(s) {
                return this._binder.assignMask(s);
              }
              update(s, l = !0) {
                const n = this._clips,
                  o = n.map(function (t, r) {
                    return r;
                  });
                g.stableSort(o, function (t, r) {
                  return n[t].blendOrder < n[r].blendOrder;
                });
                for (let t = 0; t < o.length; ++t) {
                  const r = o[t],
                    u = n[r],
                    y = this._inputs[r],
                    p = this._outputs[r],
                    _ = u.blendWeight;
                  if ((_ > 0 && u._update(s), !l)) break;
                  let m, E, v;
                  if (_ >= 1)
                    for (let P = 0; P < y.length; ++P)
                      (m = y[P]),
                        (E = p[P]),
                        (v = E.value),
                        g.set(v, m, E.target.type),
                        E.blendCounter++;
                  else if (_ > 0)
                    for (let P = 0; P < y.length; ++P)
                      (m = y[P]),
                        (E = p[P]),
                        (v = E.value),
                        E.blendCounter === 0
                          ? g.set(v, m, E.target.type)
                          : g.blend(v, m, _, E.target.type),
                        E.blendCounter++;
                }
                const i = this._targets,
                  e = this._binder;
                for (const t in i)
                  if (i.hasOwnProperty(t)) {
                    const r = i[t];
                    if (e.animComponent && r.target.isTransform) {
                      const u = e.animComponent.targets[t];
                      u.counter === u.layerCounter && (u.counter = 0),
                        u.path ||
                          ((u.path = t),
                          (u.baseValue = r.target.get()),
                          (u.setter = r.target.set)),
                        u.updateValue(e.layerIndex, r.value),
                        u.counter++;
                    } else r.target.set(r.value);
                    r.blendCounter = 0;
                  }
                this._binder.update(s);
              }
            }
          },
          2761: (Se, W, a) => {
            "use strict";
            a.d(W, { D: () => x });
            class x {
              constructor(g) {
                (this._events = [...g]),
                  this._events.sort((c, d) => c.time - d.time);
              }
              get events() {
                return this._events;
              }
            }
          },
          8934: (Se, W, a) => {
            "use strict";
            a.d(W, { e: () => c });
            var x = a(4585),
              T = a(3471);
            class g {
              constructor() {
                (this._left = 1 / 0),
                  (this._right = -1 / 0),
                  (this._len = 0),
                  (this._recip = 0),
                  (this._p0 = 0),
                  (this._p1 = 0),
                  (this._t = 0),
                  (this._hermite = { valid: !1, p0: 0, m0: 0, p1: 0, m1: 0 });
              }
              update(h, f) {
                if (h < this._left || h >= this._right) {
                  const s = f.length;
                  if (!s)
                    (this._left = -1 / 0),
                      (this._right = 1 / 0),
                      (this._len = 0),
                      (this._recip = 0),
                      (this._p0 = this._p1 = 0);
                  else if (h < f[0])
                    (this._left = -1 / 0),
                      (this._right = f[0]),
                      (this._len = 0),
                      (this._recip = 0),
                      (this._p0 = this._p1 = 0);
                  else if (h >= f[s - 1])
                    (this._left = f[s - 1]),
                      (this._right = 1 / 0),
                      (this._len = 0),
                      (this._recip = 0),
                      (this._p0 = this._p1 = s - 1);
                  else {
                    const l = this._findKey(h, f);
                    (this._left = f[l]),
                      (this._right = f[l + 1]),
                      (this._len = this._right - this._left);
                    const n = 1 / this._len;
                    (this._recip = isFinite(n) ? n : 0),
                      (this._p0 = l),
                      (this._p1 = l + 1);
                  }
                }
                (this._t =
                  this._recip === 0 ? 0 : (h - this._left) * this._recip),
                  (this._hermite.valid = !1);
              }
              _findKey(h, f) {
                let s = 0;
                for (; h >= f[s + 1]; ) s++;
                return s;
              }
              eval(h, f, s) {
                const l = s._data,
                  n = s._components,
                  o = this._p0 * n;
                if (f === T.B3) for (let i = 0; i < n; ++i) h[i] = l[o + i];
                else {
                  const i = this._t,
                    e = this._p1 * n;
                  switch (f) {
                    case T.NW:
                      for (let t = 0; t < n; ++t)
                        h[t] = x.m.lerp(l[o + t], l[e + t], i);
                      break;
                    case T.Qf: {
                      const t = this._hermite;
                      if (!t.valid) {
                        const _ = i * i,
                          m = i + i,
                          E = 1 - i,
                          v = E * E;
                        (t.valid = !0),
                          (t.p0 = (1 + m) * v),
                          (t.m0 = i * v),
                          (t.p1 = _ * (3 - m)),
                          (t.m1 = _ * (i - 1));
                      }
                      const r = (this._p0 * 3 + 1) * n,
                        u = (this._p0 * 3 + 2) * n,
                        y = (this._p1 * 3 + 1) * n,
                        p = (this._p1 * 3 + 0) * n;
                      for (let _ = 0; _ < n; ++_)
                        h[_] =
                          t.p0 * l[r + _] +
                          t.m0 * l[u + _] * this._len +
                          t.p1 * l[y + _] +
                          t.m1 * l[p + _] * this._len;
                      break;
                    }
                  }
                }
              }
            }
            class c {
              constructor(h) {
                (this._name = h.name + "Snapshot"),
                  (this._time = -1),
                  (this._cache = []),
                  (this._results = []);
                for (let l = 0; l < h._inputs.length; ++l)
                  this._cache[l] = new g();
                const f = h._curves,
                  s = h._outputs;
                for (let l = 0; l < f.length; ++l) {
                  const n = f[l],
                    o = s[n._output],
                    i = [];
                  for (let e = 0; e < o._components; ++e) i[e] = 0;
                  this._results[l] = i;
                }
              }
            }
          },
          5440: (Se, W, a) => {
            "use strict";
            a.d(W, { e: () => x });
            class x {
              constructor(g, c, d, h) {
                g.set
                  ? ((this._set = g.set), (this._get = g.get))
                  : (this._set = g),
                  (this._type = c),
                  (this._components = d),
                  (this._targetPath = h),
                  (this._isTransform =
                    this._targetPath.substring(this._targetPath.length - 13) ===
                      "localRotation" ||
                    this._targetPath.substring(this._targetPath.length - 13) ===
                      "localPosition" ||
                    this._targetPath.substring(this._targetPath.length - 10) ===
                      "localScale");
              }
              get set() {
                return this._set;
              }
              get get() {
                return this._get;
              }
              get type() {
                return this._type;
              }
              get components() {
                return this._components;
              }
              get targetPath() {
                return this._targetPath;
              }
              get isTransform() {
                return this._isTransform;
              }
            }
          },
          8949: (Se, W, a) => {
            "use strict";
            a.d(W, { k: () => T });
            var x = a(2761);
            class T {
              constructor(c, d, h, f, s, l = new x.D([])) {
                (this._name = c),
                  (this._duration = d),
                  (this._inputs = h),
                  (this._outputs = f),
                  (this._curves = s),
                  (this._animEvents = l);
              }
              get name() {
                return this._name;
              }
              get duration() {
                return this._duration;
              }
              get inputs() {
                return this._inputs;
              }
              get outputs() {
                return this._outputs;
              }
              get curves() {
                return this._curves;
              }
              set events(c) {
                this._animEvents = c;
              }
              get events() {
                return this._animEvents.events;
              }
              eval(c, d) {
                d._time = c;
                const h = this._inputs,
                  f = this._outputs,
                  s = this._curves,
                  l = d._cache,
                  n = d._results;
                for (let o = 0; o < h.length; ++o) l[o].update(c, h[o]._data);
                for (let o = 0; o < s.length; ++o) {
                  const i = s[o],
                    e = f[i._output],
                    t = n[o];
                  l[i._input].eval(t, i._interpolation, e);
                }
              }
            }
            T.EMPTY = Object.freeze(
              new T("empty", Number.MAX_VALUE, [], [], [])
            );
          },
          6608: (Se, W, a) => {
            "use strict";
            a.d(W, { Z: () => x });
            class x {
              constructor(g) {
                if (
                  ((this._layers = []),
                  (this._parameters = {}),
                  Array.isArray(g.layers))
                )
                  this._layers = g.layers;
                else
                  for (const c in g.layers) {
                    const d = g.layers[c],
                      h = {
                        name: d.name,
                        blendType: d.blendType,
                        weight: d.weight,
                        states: [],
                        transitions: [],
                      };
                    for (let f = 0; f < d.states.length; f++)
                      h.states.push(g.states[d.states[f]]);
                    for (let f = 0; f < d.transitions.length; f++) {
                      const s = g.transitions[d.transitions[f]];
                      if (s.conditions && !Array.isArray(s.conditions)) {
                        const l = Object.keys(s.conditions),
                          n = [];
                        for (let o = 0; o < l.length; o++) {
                          const i = s.conditions[l[o]];
                          i.parameterName && n.push(i);
                        }
                        s.conditions = n;
                      }
                      Number.isInteger(s.from) &&
                        (s.from = g.states[s.from].name),
                        Number.isInteger(s.to) && (s.to = g.states[s.to].name),
                        h.transitions.push(s);
                    }
                    this._layers.push(h);
                  }
                for (const c in g.parameters) {
                  const d = g.parameters[c];
                  this._parameters[d.name] = { type: d.type, value: d.value };
                }
              }
              get parameters() {
                return Object.assign({}, this._parameters);
              }
              get layers() {
                return this._layers;
              }
            }
          },
          2816: (Se, W, a) => {
            "use strict";
            a.d(W, { k: () => se, l: () => j });
            var x = a(4444),
              T = a(3821),
              g = a(9296),
              c = a(5338),
              d = a(1367),
              h = a(9758),
              f = a(4585),
              s = a(6847),
              l = a(6556),
              n = a(7921),
              o = a(7982),
              i = a(1467),
              e = a(3114),
              t = a(192),
              r = a(3587),
              u = a(4210);
            class y {
              constructor() {
                (this.renderPasses = []), (this.renderTargetMap = new Map());
              }
              addRenderPass(M) {
                this.renderPasses.push(M);
              }
              reset() {
                this.renderPasses.length = 0;
              }
              compile() {
                const M = this.renderTargetMap,
                  F = this.renderPasses;
                for (let de = 0; de < F.length; de++) {
                  const ge = F[de],
                    Re = ge.renderTarget;
                  if (Re !== void 0) {
                    const Te = M.get(Re);
                    if (Te) {
                      const Ne = ge.colorArrayOps.length;
                      for (let Le = 0; Le < Ne; Le++)
                        ge.colorArrayOps[Le].clear ||
                          (Te.colorArrayOps[Le].store = !0);
                      ge.depthStencilOps.clearDepth ||
                        (Te.depthStencilOps.storeDepth = !0),
                        ge.depthStencilOps.clearStencil ||
                          (Te.depthStencilOps.storeStencil = !0);
                    }
                    M.set(Re, ge);
                  }
                }
                let z = null,
                  oe = null;
                for (let de = 0; de < F.length; de++) {
                  const ge = F[de],
                    Re = ge.renderTarget,
                    Te = Re == null ? void 0 : Re.colorBuffer;
                  if (Te != null && Te.cubemap) {
                    if (z === Te) {
                      const Ne = oe.colorArrayOps.length;
                      for (let Le = 0; Le < Ne; Le++)
                        oe.colorArrayOps[Le].mipmaps = !1;
                    }
                    (z = Re.colorBuffer), (oe = ge);
                  } else ge.requiresCubemaps && ((z = null), (oe = null));
                }
                M.forEach((de, ge) => {
                  ge === null &&
                    ((de.colorOps.store = !0),
                    (de.colorOps.resolve = !1),
                    (de.colorOps.mipmaps = !1));
                }),
                  M.clear();
              }
              render(M) {
                this.compile();
                const F = this.renderPasses;
                for (let z = 0; z < F.length; z++) F[z].render();
              }
            }
            var p = a(1110),
              _ = a(8869),
              m = a(7338);
            class E {
              constructor(M, F) {
                (this.texture0 = M), (this.texture1 = F);
              }
              destroy() {
                var M, F;
                (M = this.texture0) == null || M.destroy(),
                  (F = this.texture1) == null || F.destroy();
              }
            }
            const v = new m.c();
            class P {
              static createTexture(M, F, z, oe = "") {
                return new _.x(M, {
                  name: `AreaLightLUT${oe}`,
                  width: z,
                  height: z,
                  format: F,
                  addressU: n.uFb,
                  addressV: n.uFb,
                  type: n.zZc,
                  magFilter: n.I5X,
                  minFilter: n.yib,
                  anisotropy: 1,
                  mipmaps: !1,
                });
              }
              static applyTextures(M, F, z) {
                v.remove(M),
                  v.get(M, () => new E(F, F === z ? null : z)),
                  M.scope.resolve("areaLightsLutTex1").setValue(F),
                  M.scope.resolve("areaLightsLutTex2").setValue(z);
              }
              static createPlaceholder(M) {
                const F = P.createTexture(
                  M,
                  M.areaLightLutFormat,
                  2,
                  "placeholder"
                );
                F.lock().fill(0), F.unlock(), P.applyTextures(M, F, F);
              }
              static set(M, F, z) {
                function oe(H, Ee, G) {
                  const Q = P.createTexture(H, G, 64);
                  return Q.lock().set(Ee), Q.unlock(), Q;
                }
                function de(H, Ee, G) {
                  const Q = H.length,
                    q = new Float32Array(Q);
                  for (let xe = 0; xe < Q; xe++) {
                    const be = xe % 4;
                    q[xe] = (H[xe] + Ee[be]) * G[be];
                  }
                  return q;
                }
                function ge(H) {
                  const Ee = H.length,
                    G = new Uint16Array(Ee),
                    Q = p.b.float2Half;
                  for (let q = 0; q < Ee; q++) G[q] = Q(H[q]);
                  return G;
                }
                function Re(H) {
                  const Ee = H.length,
                    G = new Uint8ClampedArray(Ee);
                  for (let Q = 0; Q < Ee; Q++) G[Q] = H[Q] * 255;
                  return G;
                }
                const Te = F,
                  Ne = z;
                let Le, ke;
                const ht = M.areaLightLutFormat;
                if (ht === n.uC3) (Le = Te), (ke = Ne);
                else if (ht === n.a7f) (Le = ge(Te)), (ke = ge(Ne));
                else {
                  const H = [0, 0.2976, 0.01381, 0],
                    Ee = [0.999, 3.08737, 1.6546, 0.603249],
                    G = [-0.306897, 0, 0, 0],
                    Q = [1.442787, 1, 1, 1];
                  (Le = Re(de(Te, H, Ee))), (ke = Re(de(Ne, G, Q)));
                }
                const _e = oe(M, Le, ht),
                  U = oe(M, ke, ht);
                P.applyTextures(M, _e, U);
              }
            }
            var I = a(7934),
              A = a(6462),
              B = a(7224),
              C = a(2737),
              w = a(8902),
              k = a(8944),
              K = a(9373),
              te = a(6204),
              X = a(6612),
              $ = a(4091),
              ne = a(73),
              Y = a(7900),
              Z = a(8586),
              ye = a(8936),
              pe = a(68),
              O = a(4759),
              me = a(258),
              N = a(590),
              V = a(5751),
              L = a(4355);
            class J {
              constructor(M) {
                (this.frame = {
                  fps: 0,
                  ms: 0,
                  dt: 0,
                  updateStart: 0,
                  updateTime: 0,
                  renderStart: 0,
                  renderTime: 0,
                  physicsStart: 0,
                  physicsTime: 0,
                  cullTime: 0,
                  sortTime: 0,
                  skinTime: 0,
                  morphTime: 0,
                  instancingTime: 0,
                  triangles: 0,
                  otherPrimitives: 0,
                  shaders: 0,
                  materials: 0,
                  cameras: 0,
                  shadowMapUpdates: 0,
                  shadowMapTime: 0,
                  depthMapTime: 0,
                  forwardTime: 0,
                  lightClustersTime: 0,
                  lightClusters: 0,
                  _timeToCountFrames: 0,
                  _fpsAccum: 0,
                }),
                  (this.drawCalls = {
                    forward: 0,
                    depth: 0,
                    shadow: 0,
                    immediate: 0,
                    misc: 0,
                    total: 0,
                    skinned: 0,
                    instanced: 0,
                    removedByInstancing: 0,
                  }),
                  (this.misc = { renderTargetCreationTime: 0 }),
                  (this.particles = {
                    updatesPerFrame: 0,
                    _updatesPerFrame: 0,
                    frameTime: 0,
                    _frameTime: 0,
                  }),
                  (this.shaders = M._shaderStats),
                  (this.vram = M._vram),
                  Object.defineProperty(this.vram, "totalUsed", {
                    get: function () {
                      return this.tex + this.vb + this.ib;
                    },
                  }),
                  Object.defineProperty(this.vram, "geom", {
                    get: function () {
                      return this.vb + this.ib;
                    },
                  });
              }
              get scene() {
                return (0, L.i)().scene._stats;
              }
              get lightmapper() {
                var M;
                return (M = (0, L.i)().lightmapper) == null ? void 0 : M.stats;
              }
              get batcher() {
                const M = (0, L.i)()._batcher;
                return M ? M._stats : null;
              }
            }
            var ae = a(8713);
            class R {
              constructor(M) {
                (this.length = M), (this.count = 0);
              }
              inc() {
                this.count++;
              }
              done() {
                return this.count === this.length;
              }
            }
            let j = null;
            class se extends c.b {
              constructor(M) {
                super(),
                  (se._applications[M.id] = this),
                  (0, L.b)(this),
                  (j = this),
                  (this._destroyRequested = !1),
                  (this._inFrameUpdate = !1),
                  (this._time = 0),
                  (this.timeScale = 1),
                  (this.maxDeltaTime = 0.1),
                  (this.frame = 0),
                  (this.autoRender = !0),
                  (this.renderNextFrame = !1),
                  (this.useLegacyScriptAttributeCloning = V._.legacy),
                  (this._librariesLoaded = !1),
                  (this._fillMode = ae.Wx),
                  (this._resolutionMode = ae.Qx),
                  (this._allowResize = !0),
                  (this.context = this);
              }
              init(M) {
                const F = M.graphicsDevice;
                (this.graphicsDevice = F),
                  o.j.set(F),
                  this._initDefaultMaterial(),
                  this._initProgramLibrary(),
                  (this.stats = new J(F)),
                  (this._soundManager = M.soundManager),
                  (this.loader = new ye.h(this)),
                  w.Q.init(F),
                  (this._entityIndex = {}),
                  (this.scene = new B.x(F)),
                  this._registerSceneImmediate(this.scene),
                  (this.root = new me.J()),
                  (this.root._enabledInHierarchy = !0),
                  (this.assets = new X.o(this.loader)),
                  M.assetPrefix && (this.assets.prefix = M.assetPrefix),
                  (this.bundles = new $.X(this.assets)),
                  (this.enableBundles = typeof TextDecoder != "undefined"),
                  (this.scriptsOrder = M.scriptsOrder || []),
                  (this.scripts = new O.l(this)),
                  (this.i18n = new pe.o(this)),
                  (this.scenes = new N.H(this));
                const z = this;
                (this.defaultLayerWorld = new I.m({ name: "World", id: e.kY })),
                  (this.sceneGrab = new Y.$(this.graphicsDevice, this.scene)),
                  (this.defaultLayerDepth = this.sceneGrab.layer),
                  (this.defaultLayerSkybox = new I.m({
                    enabled: !0,
                    name: "Skybox",
                    id: e.Fk,
                    opaqueSortMode: e.sB,
                  })),
                  (this.defaultLayerUi = new I.m({
                    enabled: !0,
                    name: "UI",
                    id: e.Q7,
                    transparentSortMode: e.Us,
                    passThrough: !1,
                  })),
                  (this.defaultLayerImmediate = new I.m({
                    enabled: !0,
                    name: "Immediate",
                    id: e.vt,
                    opaqueSortMode: e.sB,
                    passThrough: !0,
                  }));
                const oe = new A.d("default");
                oe.pushOpaque(this.defaultLayerWorld),
                  oe.pushOpaque(this.defaultLayerDepth),
                  oe.pushOpaque(this.defaultLayerSkybox),
                  oe.pushTransparent(this.defaultLayerWorld),
                  oe.pushOpaque(this.defaultLayerImmediate),
                  oe.pushTransparent(this.defaultLayerImmediate),
                  oe.pushTransparent(this.defaultLayerUi),
                  (this.scene.layers = oe),
                  this.scene.on("set:layers", function (de, ge) {
                    const Re = ge.layerList;
                    let Te;
                    for (let Ne = 0; Ne < Re.length; Ne++)
                      switch (((Te = Re[Ne]), Te.id)) {
                        case e.Pp:
                          z.sceneGrab.patch(Te);
                          break;
                        case e.Q7:
                          Te.passThrough = z.defaultLayerUi.passThrough;
                          break;
                        case e.vt:
                          Te.passThrough = z.defaultLayerImmediate.passThrough;
                          break;
                      }
                  }),
                  P.createPlaceholder(F),
                  (this.renderer = new u.g(F)),
                  (this.renderer.scene = this.scene),
                  (this.frameGraph = new y()),
                  (this.lightmapper = null),
                  M.lightmapper &&
                    ((this.lightmapper = new M.lightmapper(
                      F,
                      this.root,
                      this.scene,
                      this.renderer,
                      this.assets
                    )),
                    this.once("prerender", this._firstBake, this)),
                  (this._batcher = null),
                  M.batchManager &&
                    ((this._batcher = new M.batchManager(
                      F,
                      this.root,
                      this.scene
                    )),
                    this.once("prerender", this._firstBatch, this)),
                  (this.keyboard = M.keyboard || null),
                  (this.mouse = M.mouse || null),
                  (this.touch = M.touch || null),
                  (this.gamepads = M.gamepads || null),
                  (this.elementInput = M.elementInput || null),
                  this.elementInput && (this.elementInput.app = this),
                  (this.xr = M.xr ? new M.xr(this) : null),
                  this.elementInput && this.elementInput.attachSelectEvents(),
                  (this._inTools = !1),
                  (this._skyboxAsset = null),
                  (this._scriptPrefix = M.scriptPrefix || ""),
                  this.enableBundles &&
                    this.loader.addHandler("bundle", new Z.p(this)),
                  M.resourceHandlers.forEach((de) => {
                    const ge = new de(this);
                    this.loader.addHandler(ge.handlerType, ge);
                  }),
                  (this.systems = new ne.s()),
                  M.componentSystems.forEach((de) => {
                    this.systems.add(new de(this));
                  }),
                  (this._visibilityChangeHandler =
                    this.onVisibilityChange.bind(this)),
                  typeof document != "undefined" &&
                    (document.hidden !== void 0
                      ? ((this._hiddenAttr = "hidden"),
                        document.addEventListener(
                          "visibilitychange",
                          this._visibilityChangeHandler,
                          !1
                        ))
                      : document.mozHidden !== void 0
                      ? ((this._hiddenAttr = "mozHidden"),
                        document.addEventListener(
                          "mozvisibilitychange",
                          this._visibilityChangeHandler,
                          !1
                        ))
                      : document.msHidden !== void 0
                      ? ((this._hiddenAttr = "msHidden"),
                        document.addEventListener(
                          "msvisibilitychange",
                          this._visibilityChangeHandler,
                          !1
                        ))
                      : document.webkitHidden !== void 0 &&
                        ((this._hiddenAttr = "webkitHidden"),
                        document.addEventListener(
                          "webkitvisibilitychange",
                          this._visibilityChangeHandler,
                          !1
                        ))),
                  (this.tick = ie(this));
              }
              static getApplication(M) {
                return M ? se._applications[M] : (0, L.i)();
              }
              _initDefaultMaterial() {
                const M = new k.K();
                (M.name = "Default Material"),
                  (M.shadingModel = e.qT),
                  (0, K.l)(this.graphicsDevice, M);
              }
              _initProgramLibrary() {
                const M = new r._(this.graphicsDevice, new k.K());
                (0, t.f)(this.graphicsDevice, M);
              }
              get soundManager() {
                return this._soundManager;
              }
              get batcher() {
                return this._batcher;
              }
              get fillMode() {
                return this._fillMode;
              }
              get resolutionMode() {
                return this._resolutionMode;
              }
              configure(M, F) {
                i.d.get(M, (z, oe) => {
                  if (z) {
                    F(z);
                    return;
                  }
                  const de = oe.application_properties,
                    ge = oe.scenes,
                    Re = oe.assets;
                  this._parseApplicationProperties(de, (Te) => {
                    this._parseScenes(ge), this._parseAssets(Re), F(Te || null);
                  });
                });
              }
              preload(M) {
                this.fire("preload:start");
                const F = this.assets.list({ preload: !0 }),
                  z = new R(F.length);
                let oe = !1;
                const de = () => {
                    this.graphicsDevice &&
                      !oe &&
                      z.done() &&
                      ((oe = !0), this.fire("preload:end"), M());
                  },
                  ge = F.length;
                if (z.length) {
                  const Re = (Ne) => {
                      z.inc(),
                        this.fire("preload:progress", z.count / ge),
                        z.done() && de();
                    },
                    Te = (Ne, Le) => {
                      z.inc(),
                        this.fire("preload:progress", z.count / ge),
                        z.done() && de();
                    };
                  for (let Ne = 0; Ne < F.length; Ne++)
                    F[Ne].loaded
                      ? (z.inc(),
                        this.fire("preload:progress", z.count / ge),
                        z.done() && de())
                      : (F[Ne].once("load", Re),
                        F[Ne].once("error", Te),
                        this.assets.load(F[Ne]));
                } else de();
              }
              _preloadScripts(M, F) {
                if (!V._.legacy) {
                  F();
                  return;
                }
                this.systems.script.preloading = !0;
                const z = this._getScriptReferences(M),
                  oe = z.length,
                  de = new R(oe),
                  ge = /^http(s)?:\/\//;
                if (oe) {
                  const Re = (Te, Ne) => {
                    Te && console.error(Te),
                      de.inc(),
                      de.done() && ((this.systems.script.preloading = !1), F());
                  };
                  for (let Te = 0; Te < oe; Te++) {
                    let Ne = z[Te];
                    !ge.test(Ne.toLowerCase()) &&
                      this._scriptPrefix &&
                      (Ne = g.E.join(this._scriptPrefix, z[Te])),
                      this.loader.load(Ne, "script", Re);
                  }
                } else (this.systems.script.preloading = !1), F();
              }
              _parseApplicationProperties(M, F) {
                if (
                  (typeof M.maxAssetRetries == "number" &&
                    M.maxAssetRetries > 0 &&
                    this.loader.enableRetry(M.maxAssetRetries),
                  M.useDevicePixelRatio ||
                    (M.useDevicePixelRatio = M.use_device_pixel_ratio),
                  M.resolutionMode || (M.resolutionMode = M.resolution_mode),
                  M.fillMode || (M.fillMode = M.fill_mode),
                  (this._width = M.width),
                  (this._height = M.height),
                  M.useDevicePixelRatio &&
                    (this.graphicsDevice.maxPixelRatio =
                      window.devicePixelRatio),
                  this.setCanvasResolution(
                    M.resolutionMode,
                    this._width,
                    this._height
                  ),
                  this.setCanvasFillMode(M.fillMode, this._width, this._height),
                  M.layers && M.layerOrder)
                ) {
                  const z = new A.d("application"),
                    oe = {};
                  for (const de in M.layers) {
                    const ge = M.layers[de];
                    (ge.id = parseInt(de, 10)),
                      (ge.enabled = ge.id !== e.Pp),
                      (oe[de] = new I.m(ge));
                  }
                  for (let de = 0, ge = M.layerOrder.length; de < ge; de++) {
                    const Re = M.layerOrder[de],
                      Te = oe[Re.layer];
                    Te &&
                      (Re.transparent
                        ? z.pushTransparent(Te)
                        : z.pushOpaque(Te),
                      (z.subLayerEnabled[de] = Re.enabled));
                  }
                  this.scene.layers = z;
                }
                if (M.batchGroups) {
                  const z = this.batcher;
                  if (z)
                    for (let oe = 0, de = M.batchGroups.length; oe < de; oe++) {
                      const ge = M.batchGroups[oe];
                      z.addGroup(
                        ge.name,
                        ge.dynamic,
                        ge.maxAabbSize,
                        ge.id,
                        ge.layers
                      );
                    }
                }
                M.i18nAssets && (this.i18n.assets = M.i18nAssets),
                  this._loadLibraries(M.libraries, F);
              }
              _loadLibraries(M, F) {
                const z = M.length;
                let oe = z;
                const de = /^http(s)?:\/\//;
                if (z) {
                  const ge = (Re, Te) => {
                    oe--,
                      Re
                        ? F(Re)
                        : oe === 0 && (this.onLibrariesLoaded(), F(null));
                  };
                  for (let Re = 0; Re < z; ++Re) {
                    let Te = M[Re];
                    !de.test(Te.toLowerCase()) &&
                      this._scriptPrefix &&
                      (Te = g.E.join(this._scriptPrefix, Te)),
                      this.loader.load(Te, "script", ge);
                  }
                } else this.onLibrariesLoaded(), F(null);
              }
              _parseScenes(M) {
                if (M)
                  for (let F = 0; F < M.length; F++)
                    this.scenes.add(M[F].name, M[F].url);
              }
              _parseAssets(M) {
                const F = [],
                  z = {},
                  oe = {};
                if (V._.legacy) {
                  if (this.enableBundles)
                    for (const de in M)
                      M[de].type === "bundle" && ((oe[de] = !0), F.push(M[de]));
                  for (const de in M) oe[de] || F.push(M[de]);
                } else {
                  for (let de = 0; de < this.scriptsOrder.length; de++) {
                    const ge = this.scriptsOrder[de];
                    M[ge] && ((z[ge] = !0), F.push(M[ge]));
                  }
                  if (this.enableBundles)
                    for (const de in M)
                      M[de].type === "bundle" && ((oe[de] = !0), F.push(M[de]));
                  for (const de in M) z[de] || oe[de] || F.push(M[de]);
                }
                for (let de = 0; de < F.length; de++) {
                  const ge = F[de],
                    Re = new te.x(ge.name, ge.type, ge.file, ge.data);
                  if (
                    ((Re.id = parseInt(ge.id, 10)),
                    (Re.preload = ge.preload ? ge.preload : !1),
                    (Re.loaded =
                      ge.type === "script" &&
                      ge.data &&
                      ge.data.loadingType > 0),
                    Re.tags.add(ge.tags),
                    ge.i18n)
                  )
                    for (const Te in ge.i18n)
                      Re.addLocalizedAssetId(Te, ge.i18n[Te]);
                  this.assets.add(Re);
                }
              }
              _getScriptReferences(M) {
                let F = [];
                M.settings.priority_scripts &&
                  (F = M.settings.priority_scripts);
                const z = [],
                  oe = {};
                for (let ge = 0; ge < F.length; ge++)
                  z.push(F[ge]), (oe[F[ge]] = !0);
                const de = M.entities;
                for (const ge in de) {
                  if (!de[ge].components.script) continue;
                  const Re = de[ge].components.script.scripts;
                  for (let Te = 0; Te < Re.length; Te++)
                    oe[Re[Te].url] ||
                      (z.push(Re[Te].url), (oe[Re[Te].url] = !0));
                }
                return z;
              }
              start() {
                (this.frame = 0),
                  this.fire("start", { timestamp: (0, T.z)(), target: this }),
                  this._librariesLoaded || this.onLibrariesLoaded(),
                  this.systems.fire("initialize", this.root),
                  this.fire("initialize"),
                  this.systems.fire("postInitialize", this.root),
                  this.systems.fire("postPostInitialize", this.root),
                  this.fire("postinitialize"),
                  this.tick();
              }
              inputUpdate(M) {
                this.controller && this.controller.update(M),
                  this.mouse && this.mouse.update(),
                  this.keyboard && this.keyboard.update(),
                  this.gamepads && this.gamepads.update();
              }
              update(M) {
                this.frame++,
                  this.graphicsDevice.updateClientRect(),
                  V._.legacy &&
                    this.systems.fire("fixedUpdate", 0.016666666666666666),
                  this.systems.fire(
                    this._inTools ? "toolsUpdate" : "update",
                    M
                  ),
                  this.systems.fire("animationUpdate", M),
                  this.systems.fire("postUpdate", M),
                  this.fire("update", M),
                  this.inputUpdate(M);
              }
              frameStart() {
                this.graphicsDevice.frameStart();
              }
              frameEnd() {
                this.graphicsDevice.frameEnd();
              }
              render() {
                this.fire("prerender"),
                  this.root.syncHierarchy(),
                  this._batcher && this._batcher.updateAll(),
                  this.renderComposition(this.scene.layers),
                  this.fire("postrender");
              }
              renderComposition(M) {
                this.renderer.buildFrameGraph(this.frameGraph, M),
                  this.frameGraph.render(this.graphicsDevice);
              }
              _fillFrameStatsBasic(M, F, z) {
                const oe = this.stats.frame;
                (oe.dt = F),
                  (oe.ms = z),
                  M > oe._timeToCountFrames
                    ? ((oe.fps = oe._fpsAccum),
                      (oe._fpsAccum = 0),
                      (oe._timeToCountFrames = M + 1e3))
                    : oe._fpsAccum++,
                  (this.stats.drawCalls.total =
                    this.graphicsDevice._drawCallsPerFrame),
                  (this.graphicsDevice._drawCallsPerFrame = 0);
              }
              _fillFrameStats() {
                let M = this.stats.frame;
                (M.cameras = this.renderer._camerasRendered),
                  (M.materials = this.renderer._materialSwitches),
                  (M.shaders = this.graphicsDevice._shaderSwitchesPerFrame),
                  (M.shadowMapUpdates = this.renderer._shadowMapUpdates),
                  (M.shadowMapTime = this.renderer._shadowMapTime),
                  (M.depthMapTime = this.renderer._depthMapTime),
                  (M.forwardTime = this.renderer._forwardTime);
                const F = this.graphicsDevice._primsPerFrame;
                (M.triangles =
                  F[n.LAy] / 3 +
                  Math.max(F[n.fmY] - 2, 0) +
                  Math.max(F[n.x5Y] - 2, 0)),
                  (M.cullTime = this.renderer._cullTime),
                  (M.sortTime = this.renderer._sortTime),
                  (M.skinTime = this.renderer._skinTime),
                  (M.morphTime = this.renderer._morphTime),
                  (M.lightClusters = this.renderer._lightClusters),
                  (M.lightClustersTime = this.renderer._lightClustersTime),
                  (M.otherPrimitives = 0);
                for (let z = 0; z < F.length; z++)
                  z < n.LAy && (M.otherPrimitives += F[z]), (F[z] = 0);
                (this.renderer._camerasRendered = 0),
                  (this.renderer._materialSwitches = 0),
                  (this.renderer._shadowMapUpdates = 0),
                  (this.graphicsDevice._shaderSwitchesPerFrame = 0),
                  (this.renderer._cullTime = 0),
                  (this.renderer._layerCompositionUpdateTime = 0),
                  (this.renderer._lightClustersTime = 0),
                  (this.renderer._sortTime = 0),
                  (this.renderer._skinTime = 0),
                  (this.renderer._morphTime = 0),
                  (this.renderer._shadowMapTime = 0),
                  (this.renderer._depthMapTime = 0),
                  (this.renderer._forwardTime = 0),
                  (M = this.stats.drawCalls),
                  (M.forward = this.renderer._forwardDrawCalls),
                  (M.culled = this.renderer._numDrawCallsCulled),
                  (M.depth = 0),
                  (M.shadow = this.renderer._shadowDrawCalls),
                  (M.skinned = this.renderer._skinDrawCalls),
                  (M.immediate = 0),
                  (M.instanced = 0),
                  (M.removedByInstancing = 0),
                  (M.misc = M.total - (M.forward + M.shadow)),
                  (this.renderer._depthDrawCalls = 0),
                  (this.renderer._shadowDrawCalls = 0),
                  (this.renderer._forwardDrawCalls = 0),
                  (this.renderer._numDrawCallsCulled = 0),
                  (this.renderer._skinDrawCalls = 0),
                  (this.renderer._immediateRendered = 0),
                  (this.renderer._instancedDrawCalls = 0),
                  (this.stats.misc.renderTargetCreationTime =
                    this.graphicsDevice.renderTargetCreationTime),
                  (M = this.stats.particles),
                  (M.updatesPerFrame = M._updatesPerFrame),
                  (M.frameTime = M._frameTime),
                  (M._updatesPerFrame = 0),
                  (M._frameTime = 0);
              }
              setCanvasFillMode(M, F, z) {
                (this._fillMode = M), this.resizeCanvas(F, z);
              }
              setCanvasResolution(M, F, z) {
                (this._resolutionMode = M),
                  M === ae.Qd &&
                    F === void 0 &&
                    ((F = this.graphicsDevice.canvas.clientWidth),
                    (z = this.graphicsDevice.canvas.clientHeight)),
                  this.graphicsDevice.resizeCanvas(F, z);
              }
              isHidden() {
                return document[this._hiddenAttr];
              }
              onVisibilityChange() {
                this.isHidden()
                  ? this._soundManager && this._soundManager.suspend()
                  : this._soundManager && this._soundManager.resume();
              }
              resizeCanvas(M, F) {
                if (!this._allowResize || (this.xr && this.xr.session)) return;
                const z = window.innerWidth,
                  oe = window.innerHeight;
                if (this._fillMode === ae.Wx) {
                  const de =
                      this.graphicsDevice.canvas.width /
                      this.graphicsDevice.canvas.height,
                    ge = z / oe;
                  de > ge ? ((M = z), (F = M / de)) : ((F = oe), (M = F * de));
                } else this._fillMode === ae.Qb && ((M = z), (F = oe));
                return (
                  (this.graphicsDevice.canvas.style.width = M + "px"),
                  (this.graphicsDevice.canvas.style.height = F + "px"),
                  this.updateCanvasSize(),
                  { width: M, height: F }
                );
              }
              updateCanvasSize() {
                var M;
                if (
                  !(
                    !this._allowResize ||
                    ((M = this.xr) != null && M.active)
                  ) &&
                  this._resolutionMode === ae.Qd
                ) {
                  const F = this.graphicsDevice.canvas;
                  this.graphicsDevice.resizeCanvas(
                    F.clientWidth,
                    F.clientHeight
                  );
                }
              }
              onLibrariesLoaded() {
                (this._librariesLoaded = !0),
                  this.systems.rigidbody &&
                    this.systems.rigidbody.onLibraryLoaded();
              }
              applySceneSettings(M) {
                let F;
                if (this.systems.rigidbody && typeof Ammo != "undefined") {
                  const z = M.physics.gravity;
                  this.systems.rigidbody.gravity.set(z[0], z[1], z[2]);
                }
                this.scene.applySettings(M),
                  M.render.hasOwnProperty("skybox") &&
                    (M.render.skybox
                      ? ((F = this.assets.get(M.render.skybox)),
                        F
                          ? this.setSkybox(F)
                          : this.assets.once(
                              "add:" + M.render.skybox,
                              this.setSkybox,
                              this
                            ))
                      : this.setSkybox(null));
              }
              setAreaLightLuts(M, F) {
                M && F && P.set(this.graphicsDevice, M, F);
              }
              setSkybox(M) {
                if (M !== this._skyboxAsset) {
                  const F = () => {
                      this.setSkybox(null);
                    },
                    z = () => {
                      this.scene.setSkybox(
                        this._skyboxAsset ? this._skyboxAsset.resources : null
                      );
                    };
                  this._skyboxAsset &&
                    (this.assets.off("load:" + this._skyboxAsset.id, z, this),
                    this.assets.off("remove:" + this._skyboxAsset.id, F, this),
                    this._skyboxAsset.off("change", z, this)),
                    (this._skyboxAsset = M),
                    this._skyboxAsset &&
                      (this.assets.on("load:" + this._skyboxAsset.id, z, this),
                      this.assets.once(
                        "remove:" + this._skyboxAsset.id,
                        F,
                        this
                      ),
                      this._skyboxAsset.on("change", z, this),
                      this.scene.skyboxMip === 0 &&
                        !this._skyboxAsset.loadFaces &&
                        (this._skyboxAsset.loadFaces = !0),
                      this.assets.load(this._skyboxAsset)),
                    z();
                }
              }
              _firstBake() {
                var M;
                (M = this.lightmapper) == null ||
                  M.bake(null, this.scene.lightmapMode);
              }
              _firstBatch() {
                var M;
                (M = this.batcher) == null || M.generate();
              }
              _processTimestamp(M) {
                return M;
              }
              drawLine(M, F, z, oe, de) {
                this.scene.drawLine(M, F, z, oe, de);
              }
              drawLines(M, F, z = !0, oe = this.scene.defaultDrawLayer) {
                this.scene.drawLines(M, F, z, oe);
              }
              drawLineArrays(M, F, z = !0, oe = this.scene.defaultDrawLayer) {
                this.scene.drawLineArrays(M, F, z, oe);
              }
              drawWireSphere(
                M,
                F,
                z = d.I.WHITE,
                oe = 20,
                de = !0,
                ge = this.scene.defaultDrawLayer
              ) {
                this.scene.immediate.drawWireSphere(M, F, z, oe, de, ge);
              }
              drawWireAlignedBox(
                M,
                F,
                z = d.I.WHITE,
                oe = !0,
                de = this.scene.defaultDrawLayer
              ) {
                this.scene.immediate.drawWireAlignedBox(M, F, z, oe, de);
              }
              drawMeshInstance(M, F = this.scene.defaultDrawLayer) {
                this.scene.immediate.drawMesh(null, null, null, M, F);
              }
              drawMesh(M, F, z, oe = this.scene.defaultDrawLayer) {
                this.scene.immediate.drawMesh(F, z, M, null, oe);
              }
              drawQuad(M, F, z = this.scene.defaultDrawLayer) {
                this.scene.immediate.drawMesh(
                  F,
                  M,
                  this.scene.immediate.getQuadMesh(),
                  null,
                  z
                );
              }
              drawTexture(
                M,
                F,
                z,
                oe,
                de,
                ge,
                Re = this.scene.defaultDrawLayer,
                Te = !0
              ) {
                if (Te === !1 && !this.graphicsDevice.isWebGPU) return;
                const Ne = new h.y();
                Ne.setTRS(new l.A(M, F, 0), s.D.IDENTITY, new l.A(z, -oe, 0)),
                  ge ||
                    ((ge = new C.F()),
                    (ge.cull = n.OL2),
                    ge.setParameter("colorMap", de),
                    (ge.shader = Te
                      ? this.scene.immediate.getTextureShader()
                      : this.scene.immediate.getUnfilterableTextureShader()),
                    ge.update()),
                  this.drawQuad(Ne, ge, Re);
              }
              drawDepthTexture(M, F, z, oe, de = this.scene.defaultDrawLayer) {
                const ge = new C.F();
                (ge.cull = n.OL2),
                  (ge.shader = this.scene.immediate.getDepthTextureShader()),
                  ge.update(),
                  this.drawTexture(M, F, z, oe, null, ge, de);
              }
              destroy() {
                var M, F, z, oe;
                if (this._inFrameUpdate) {
                  this._destroyRequested = !0;
                  return;
                }
                const de = this.graphicsDevice.canvas.id;
                this.off("librariesloaded"),
                  typeof document != "undefined" &&
                    (document.removeEventListener(
                      "visibilitychange",
                      this._visibilityChangeHandler,
                      !1
                    ),
                    document.removeEventListener(
                      "mozvisibilitychange",
                      this._visibilityChangeHandler,
                      !1
                    ),
                    document.removeEventListener(
                      "msvisibilitychange",
                      this._visibilityChangeHandler,
                      !1
                    ),
                    document.removeEventListener(
                      "webkitvisibilitychange",
                      this._visibilityChangeHandler,
                      !1
                    )),
                  (this._visibilityChangeHandler = null),
                  this.root.destroy(),
                  (this.root = null),
                  this.mouse &&
                    (this.mouse.off(),
                    this.mouse.detach(),
                    (this.mouse = null)),
                  this.keyboard &&
                    (this.keyboard.off(),
                    this.keyboard.detach(),
                    (this.keyboard = null)),
                  this.touch &&
                    (this.touch.off(),
                    this.touch.detach(),
                    (this.touch = null)),
                  this.elementInput &&
                    (this.elementInput.detach(), (this.elementInput = null)),
                  this.gamepads &&
                    (this.gamepads.destroy(), (this.gamepads = null)),
                  this.controller && (this.controller = null),
                  this.systems.destroy(),
                  this.scene.layers && this.scene.layers.destroy();
                const ge = this.assets.list();
                for (let Te = 0; Te < ge.length; Te++)
                  ge[Te].unload(), ge[Te].off();
                this.assets.off(),
                  this.bundles.destroy(),
                  (this.bundles = null),
                  this.i18n.destroy(),
                  (this.i18n = null);
                const Re = this.loader.getHandler("script");
                Re == null || Re.clearCache(),
                  this.loader.destroy(),
                  (this.loader = null),
                  this.scene.destroy(),
                  (this.scene = null),
                  (this.systems = null),
                  (this.context = null),
                  this.scripts.destroy(),
                  (this.scripts = null),
                  this.scenes.destroy(),
                  (this.scenes = null),
                  (M = this.lightmapper) == null || M.destroy(),
                  (this.lightmapper = null),
                  this._batcher &&
                    (this._batcher.destroy(), (this._batcher = null)),
                  (this._entityIndex = {}),
                  (this.defaultLayerDepth.onPreRenderOpaque = null),
                  (this.defaultLayerDepth.onPostRenderOpaque = null),
                  (this.defaultLayerDepth.onDisable = null),
                  (this.defaultLayerDepth.onEnable = null),
                  (this.defaultLayerDepth = null),
                  (this.defaultLayerWorld = null),
                  (F = this.xr) == null || F.end(),
                  (z = this.xr) == null || z.destroy(),
                  this.renderer.destroy(),
                  (this.renderer = null),
                  this.graphicsDevice.destroy(),
                  (this.graphicsDevice = null),
                  (this.tick = null),
                  this.off(),
                  (oe = this._soundManager) == null || oe.destroy(),
                  (this._soundManager = null),
                  (V._.app = null),
                  (se._applications[de] = null),
                  (0, L.i)() === this && (0, L.b)(null);
              }
              getEntityFromIndex(M) {
                return this._entityIndex[M];
              }
              _registerSceneImmediate(M) {
                this.on("postrender", M.immediate.onPostRender, M.immediate);
              }
            }
            se._applications = {};
            const ce = {},
              ie = function (M) {
                const F = M;
                let z;
                return function (oe, de) {
                  var ge;
                  if (!F.graphicsDevice) return;
                  (0, L.b)(F),
                    z && (window.cancelAnimationFrame(z), (z = null)),
                    (j = F);
                  const Re = F._processTimestamp(oe) || (0, T.z)(),
                    Te = Re - (F._time || Re);
                  let Ne = Te / 1e3;
                  if (
                    ((Ne = f.m.clamp(Ne, 0, F.maxDeltaTime)),
                    (Ne *= F.timeScale),
                    (F._time = Re),
                    (ge = F.xr) != null && ge.session
                      ? (z = F.xr.session.requestAnimationFrame(F.tick))
                      : (z = x.J.browser
                          ? window.requestAnimationFrame(F.tick)
                          : null),
                    F.graphicsDevice.contextLost)
                  )
                    return;
                  F._fillFrameStatsBasic(Re, Ne, Te),
                    (F._inFrameUpdate = !0),
                    F.fire("frameupdate", Te);
                  let Le = !0;
                  if (de) {
                    var ke;
                    (Le = (ke = F.xr) == null ? void 0 : ke.update(de)),
                      (F.graphicsDevice.defaultFramebuffer =
                        de.session.renderState.baseLayer.framebuffer);
                  } else F.graphicsDevice.defaultFramebuffer = null;
                  Le &&
                    (F.update(Ne),
                    F.fire("framerender"),
                    (F.autoRender || F.renderNextFrame) &&
                      (F.updateCanvasSize(),
                      F.frameStart(),
                      F.render(),
                      F.frameEnd(),
                      (F.renderNextFrame = !1)),
                    (ce.timestamp = (0, T.z)()),
                    (ce.target = F),
                    F.fire("frameend", ce)),
                    (F._inFrameUpdate = !1),
                    F._destroyRequested && F.destroy();
                };
              };
          },
          3322: (Se, W, a) => {
            "use strict";
            a.d(W, { U: () => x });
            class x {
              constructor() {
                (this.elementInput = void 0),
                  (this.keyboard = void 0),
                  (this.mouse = void 0),
                  (this.touch = void 0),
                  (this.gamepads = void 0),
                  (this.scriptPrefix = void 0),
                  (this.assetPrefix = void 0),
                  (this.scriptsOrder = void 0),
                  (this.soundManager = void 0),
                  (this.graphicsDevice = void 0),
                  (this.lightmapper = void 0),
                  (this.batchManager = void 0),
                  (this.xr = void 0),
                  (this.componentSystems = []),
                  (this.resourceHandlers = []);
              }
            }
          },
          3221: (Se, W, a) => {
            "use strict";
            a.d(W, { M: () => Re });
            var x = a(4444),
              T = a(9207),
              g = a(5491),
              c = a(6236),
              d = a(793),
              h = a(2816),
              f = a(3322),
              s = a(5751),
              l = a(1012),
              n = a(5212),
              o = a(9578),
              i = a(8740),
              e = a(1951),
              t = a(2280),
              r = a(7627),
              u = a(6869),
              y = a(428),
              p = a(7847),
              _ = a(1166),
              m = a(3678),
              E = a(3962),
              v = a(8069),
              P = a(3659),
              I = a(8345),
              A = a(6795),
              B = a(8874),
              C = a(1873),
              w = a(1485),
              k = a(5441),
              K = a(5865),
              te = a(8320),
              X = a(1345),
              $ = a(1642),
              ne = a(1257),
              Y = a(5229),
              Z = a(6706),
              ye = a(8652),
              pe = a(3913),
              O = a(8493),
              me = a(3671),
              N = a(216),
              V = a(1912),
              L = a(8001),
              J = a(325),
              ae = a(2353),
              R = a(496),
              j = a(1676),
              se = a(5404),
              ce = a(8169),
              ie = a(1297),
              b = a(8115),
              M = a(1761),
              F = a(7265),
              z = a(8769),
              oe = a(5275),
              de = a(8020),
              ge = a(1502);
            class Re extends h.k {
              constructor(Ne, Le = {}) {
                super(Ne);
                const ke = new f.U();
                (ke.graphicsDevice = this.createDevice(Ne, Le)),
                  this.addComponentSystems(ke),
                  this.addResourceHandles(ke),
                  (ke.elementInput = Le.elementInput),
                  (ke.keyboard = Le.keyboard),
                  (ke.mouse = Le.mouse),
                  (ke.touch = Le.touch),
                  (ke.gamepads = Le.gamepads),
                  (ke.scriptPrefix = Le.scriptPrefix),
                  (ke.assetPrefix = Le.assetPrefix),
                  (ke.scriptsOrder = Le.scriptsOrder),
                  (ke.soundManager = new g.P()),
                  (ke.lightmapper = c.T),
                  (ke.batchManager = d.D),
                  (ke.xr = ge.V),
                  this.init(ke);
              }
              createDevice(Ne, Le) {
                return (
                  Le.graphicsDeviceOptions || (Le.graphicsDeviceOptions = {}),
                  x.J.browser &&
                    navigator.xr &&
                    (Le.graphicsDeviceOptions.xrCompatible = !0),
                  (Le.graphicsDeviceOptions.alpha =
                    Le.graphicsDeviceOptions.alpha || !1),
                  new T.S(Ne, Le.graphicsDeviceOptions)
                );
              }
              addComponentSystems(Ne) {
                Ne.componentSystems = [
                  v.Lz,
                  t._,
                  u.m,
                  l._,
                  n.R,
                  _.w,
                  E.r,
                  K.r,
                  te.i,
                  s._.legacy ? I.I : X.q,
                  i.D,
                  C.T,
                  o.n,
                  m._,
                  P.P,
                  r.h,
                  e.n,
                  A.c,
                  B.$,
                  w.P,
                  p.T,
                  y.G,
                  k.x,
                ];
              }
              addResourceHandles(Ne) {
                Ne.resourceHandlers = [
                  $.c,
                  ne.n,
                  Y.m,
                  Z.O,
                  se.U,
                  j.r,
                  de.A,
                  z.q,
                  R.G,
                  ye.Z,
                  ie.z,
                  ce.d,
                  N.o,
                  ae.x,
                  me.s,
                  b.C,
                  J.c,
                  V.s,
                  L.G,
                  pe.o,
                  oe.d,
                  M.B,
                  F.V,
                  O.F,
                ];
              }
            }
          },
          2416: (Se, W, a) => {
            "use strict";
            a.d(W, { E: () => g });
            var x = a(5338),
              T = a(6204);
            class g extends x.b {
              constructor(d) {
                super(),
                  (this._app = d),
                  d.i18n.on("set:locale", this._onSetLocale, this),
                  (this._autoLoad = !1),
                  (this._disableLocalization = !1),
                  (this._defaultAsset = null),
                  (this._localizedAsset = null);
              }
              set defaultAsset(d) {
                const h = d instanceof T.x ? d.id : d;
                this._defaultAsset !== h &&
                  (this._defaultAsset && this._unbindDefaultAsset(),
                  (this._defaultAsset = h),
                  this._defaultAsset && this._bindDefaultAsset(),
                  this._onSetLocale(this._app.i18n.locale));
              }
              get defaultAsset() {
                return this._defaultAsset;
              }
              set localizedAsset(d) {
                const h = d instanceof T.x ? d.id : d;
                this._localizedAsset !== h &&
                  (this._localizedAsset &&
                    (this._app.assets.off(
                      "add:" + this._localizedAsset,
                      this._onLocalizedAssetAdd,
                      this
                    ),
                    this._unbindLocalizedAsset(),
                    (this._localizedAsset = null)),
                  (this._localizedAsset = h),
                  this._localizedAsset &&
                    (this._app.assets.get(this._localizedAsset)
                      ? this._bindLocalizedAsset()
                      : this._app.assets.once(
                          "add:" + this._localizedAsset,
                          this._onLocalizedAssetAdd,
                          this
                        )));
              }
              get localizedAsset() {
                return this._localizedAsset;
              }
              set autoLoad(d) {
                this._autoLoad !== d &&
                  ((this._autoLoad = d),
                  this._autoLoad &&
                    this._localizedAsset &&
                    (this._unbindLocalizedAsset(), this._bindLocalizedAsset()));
              }
              get autoLoad() {
                return this._autoLoad;
              }
              set disableLocalization(d) {
                this._disableLocalization !== d &&
                  ((this._disableLocalization = d),
                  this._onSetLocale(this._app.i18n.locale));
              }
              get disableLocalization() {
                return this._disableLocalization;
              }
              _bindDefaultAsset() {
                const d = this._app.assets.get(this._defaultAsset);
                d
                  ? this._onDefaultAssetAdd(d)
                  : this._app.assets.once(
                      "add:" + this._defaultAsset,
                      this._onDefaultAssetAdd,
                      this
                    );
              }
              _unbindDefaultAsset() {
                if (!this._defaultAsset) return;
                this._app.assets.off(
                  "add:" + this._defaultAsset,
                  this._onDefaultAssetAdd,
                  this
                );
                const d = this._app.assets.get(this._defaultAsset);
                d &&
                  (d.off("add:localized", this._onLocaleAdd, this),
                  d.off("remove:localized", this._onLocaleRemove, this),
                  d.off("remove", this._onDefaultAssetRemove, this));
              }
              _onDefaultAssetAdd(d) {
                this._defaultAsset === d.id &&
                  (d.on("add:localized", this._onLocaleAdd, this),
                  d.on("remove:localized", this._onLocaleRemove, this),
                  d.once("remove", this._onDefaultAssetRemove, this));
              }
              _onDefaultAssetRemove(d) {
                this._defaultAsset === d.id &&
                  (d.off("add:localized", this._onLocaleAdd, this),
                  d.off("remove:localized", this._onLocaleAdd, this),
                  this._app.assets.once(
                    "add:" + this._defaultAsset,
                    this._onDefaultAssetAdd,
                    this
                  ));
              }
              _bindLocalizedAsset() {
                if (!this._autoLoad) return;
                const d = this._app.assets.get(this._localizedAsset);
                d &&
                  (d.on("load", this._onLocalizedAssetLoad, this),
                  d.on("change", this._onLocalizedAssetChange, this),
                  d.on("remove", this._onLocalizedAssetRemove, this),
                  d.resource
                    ? this._onLocalizedAssetLoad(d)
                    : this._app.assets.load(d));
              }
              _unbindLocalizedAsset() {
                const d = this._app.assets.get(this._localizedAsset);
                d &&
                  (d.off("load", this._onLocalizedAssetLoad, this),
                  d.off("change", this._onLocalizedAssetChange, this),
                  d.off("remove", this._onLocalizedAssetRemove, this));
              }
              _onLocalizedAssetAdd(d) {
                this._localizedAsset === d.id && this._bindLocalizedAsset();
              }
              _onLocalizedAssetLoad(d) {
                this.fire("load", d);
              }
              _onLocalizedAssetChange(d, h, f, s) {
                this.fire("change", d, h, f, s);
              }
              _onLocalizedAssetRemove(d) {
                this._localizedAsset === d.id &&
                  (this.localizedAsset = this._defaultAsset),
                  this.fire("remove", d);
              }
              _onLocaleAdd(d, h) {
                this._app.i18n.locale === d && this._onSetLocale(d);
              }
              _onLocaleRemove(d, h) {
                this._app.i18n.locale === d && this._onSetLocale(d);
              }
              _onSetLocale(d) {
                if (!this._defaultAsset) {
                  this.localizedAsset = null;
                  return;
                }
                const h = this._app.assets.get(this._defaultAsset);
                if (!h || this._disableLocalization) {
                  this.localizedAsset = this._defaultAsset;
                  return;
                }
                const f = h.getLocalizedAssetId(d);
                if (!f) {
                  this.localizedAsset = this._defaultAsset;
                  return;
                }
                this.localizedAsset = f;
              }
              destroy() {
                (this.defaultAsset = null),
                  this._app.i18n.off("set:locale", this._onSetLocale, this),
                  this.off();
              }
            }
          },
          5755: (Se, W, a) => {
            "use strict";
            a.d(W, { M: () => x });
            class x {
              constructor(g, c, d, h, f) {
                (this.propertyName = g),
                  (this.parent = c),
                  (this._scope = f),
                  (this._registry = d),
                  (this.id = null),
                  (this.url = null),
                  (this.asset = null),
                  (this._onAssetLoad = h.load),
                  (this._onAssetAdd = h.add),
                  (this._onAssetRemove = h.remove),
                  (this._onAssetUnload = h.unload);
              }
              set id(g) {
                if (this.url) throw Error("Can't set id and url");
                this._unbind(),
                  (this._id = g),
                  (this.asset = this._registry.get(this._id)),
                  this._bind();
              }
              get id() {
                return this._id;
              }
              set url(g) {
                if (this.id) throw Error("Can't set id and url");
                this._unbind(),
                  (this._url = g),
                  (this.asset = this._registry.getByUrl(this._url)),
                  this._bind();
              }
              get url() {
                return this._url;
              }
              _bind() {
                this.id &&
                  (this._onAssetLoad &&
                    this._registry.on("load:" + this.id, this._onLoad, this),
                  this._onAssetAdd &&
                    this._registry.once("add:" + this.id, this._onAdd, this),
                  this._onAssetRemove &&
                    this._registry.on(
                      "remove:" + this.id,
                      this._onRemove,
                      this
                    ),
                  this._onAssetUnload &&
                    this._registry.on(
                      "unload:" + this.id,
                      this._onUnload,
                      this
                    )),
                  this.url &&
                    (this._onAssetLoad &&
                      this._registry.on(
                        "load:url:" + this.url,
                        this._onLoad,
                        this
                      ),
                    this._onAssetAdd &&
                      this._registry.once(
                        "add:url:" + this.url,
                        this._onAdd,
                        this
                      ),
                    this._onAssetRemove &&
                      this._registry.on(
                        "remove:url:" + this.url,
                        this._onRemove,
                        this
                      ));
              }
              _unbind() {
                this.id &&
                  (this._onAssetLoad &&
                    this._registry.off("load:" + this.id, this._onLoad, this),
                  this._onAssetAdd &&
                    this._registry.off("add:" + this.id, this._onAdd, this),
                  this._onAssetRemove &&
                    this._registry.off(
                      "remove:" + this.id,
                      this._onRemove,
                      this
                    ),
                  this._onAssetUnload &&
                    this._registry.off(
                      "unload:" + this.id,
                      this._onUnload,
                      this
                    )),
                  this.url &&
                    (this._onAssetLoad &&
                      this._registry.off(
                        "load:" + this.url,
                        this._onLoad,
                        this
                      ),
                    this._onAssetAdd &&
                      this._registry.off("add:" + this.url, this._onAdd, this),
                    this._onAssetRemove &&
                      this._registry.off(
                        "remove:" + this.url,
                        this._onRemove,
                        this
                      ));
              }
              _onLoad(g) {
                this._onAssetLoad.call(
                  this._scope,
                  this.propertyName,
                  this.parent,
                  g
                );
              }
              _onAdd(g) {
                (this.asset = g),
                  this._onAssetAdd.call(
                    this._scope,
                    this.propertyName,
                    this.parent,
                    g
                  );
              }
              _onRemove(g) {
                this._onAssetRemove.call(
                  this._scope,
                  this.propertyName,
                  this.parent,
                  g
                ),
                  (this.asset = null);
              }
              _onUnload(g) {
                this._onAssetUnload.call(
                  this._scope,
                  this.propertyName,
                  this.parent,
                  g
                );
              }
            }
          },
          6612: (Se, W, a) => {
            "use strict";
            a.d(W, { o: () => f });
            var x = a(9296),
              T = a(5338);
            class g {
              constructor(l = null) {
                (this._index = {}), (this._key = void 0), (this._key = l);
              }
              addItem(l) {
                const n = l.tags._list;
                for (const o of n) this.add(o, l);
              }
              removeItem(l) {
                const n = l.tags._list;
                for (const o of n) this.remove(o, l);
              }
              add(l, n) {
                (this._index[l] && this._index[l].list.indexOf(n) !== -1) ||
                  (this._index[l] ||
                    ((this._index[l] = { list: [] }),
                    this._key && (this._index[l].keys = {})),
                  this._index[l].list.push(n),
                  this._key && (this._index[l].keys[n[this._key]] = n));
              }
              remove(l, n) {
                if (
                  !this._index[l] ||
                  (this._key && !this._index[l].keys[n[this._key]])
                )
                  return;
                const o = this._index[l].list.indexOf(n);
                o !== -1 &&
                  (this._index[l].list.splice(o, 1),
                  this._key && delete this._index[l].keys[n[this._key]],
                  this._index[l].list.length === 0 && delete this._index[l]);
              }
              find(l) {
                const n = {},
                  o = [];
                let i, e, t, r, u;
                const y = (p, _) =>
                  this._index[p].list.length - this._index[_].list.length;
                for (let p = 0; p < l.length; p++) {
                  if (((e = l[p]), e instanceof Array)) {
                    if (e.length === 0) continue;
                    if (e.length === 1) e = e[0];
                    else {
                      u = !1;
                      for (let _ = 0; _ < e.length; _++)
                        if (!this._index[e[_]]) {
                          u = !0;
                          break;
                        }
                      if (u) continue;
                      (t = e.slice(0).sort(y)),
                        (r = t.slice(1)),
                        r.length === 1 && (r = r[0]);
                      for (let _ = 0; _ < this._index[t[0]].list.length; _++)
                        (i = this._index[t[0]].list[_]),
                          (this._key
                            ? !n[i[this._key]]
                            : o.indexOf(i) === -1) &&
                            i.tags.has(r) &&
                            (this._key && (n[i[this._key]] = !0), o.push(i));
                      continue;
                    }
                  }
                  if (e && typeof e == "string" && this._index[e])
                    for (let _ = 0; _ < this._index[e].list.length; _++)
                      (i = this._index[e].list[_]),
                        this._key
                          ? n[i[this._key]] ||
                            ((n[i[this._key]] = !0), o.push(i))
                          : o.indexOf(i) === -1 && o.push(i);
                }
                return o;
              }
            }
            var c = a(6672),
              d = a(5751),
              h = a(6204);
            class f extends T.b {
              constructor(l) {
                super(),
                  (this._assets = new Set()),
                  (this._idToAsset = new Map()),
                  (this._urlToAsset = new Map()),
                  (this._nameToAsset = new Map()),
                  (this._tags = new g("_id")),
                  (this.prefix = null),
                  (this._loader = l);
              }
              list(l = {}) {
                const n = Array.from(this._assets);
                return l.preload !== void 0
                  ? n.filter((o) => o.preload === l.preload)
                  : n;
              }
              add(l) {
                var n, o;
                this._assets.has(l) ||
                  (this._assets.add(l),
                  this._idToAsset.set(l.id, l),
                  (n = l.file) != null &&
                    n.url &&
                    this._urlToAsset.set(l.file.url, l),
                  this._nameToAsset.has(l.name) ||
                    this._nameToAsset.set(l.name, new Set()),
                  this._nameToAsset.get(l.name).add(l),
                  l.on("name", this._onNameChange, this),
                  (l.registry = this),
                  this._tags.addItem(l),
                  l.tags.on("add", this._onTagAdd, this),
                  l.tags.on("remove", this._onTagRemove, this),
                  this.fire("add", l),
                  this.fire("add:" + l.id, l),
                  (o = l.file) != null &&
                    o.url &&
                    this.fire("add:url:" + l.file.url, l),
                  l.preload && this.load(l));
              }
              remove(l) {
                var n, o;
                if (!this._assets.has(l)) return !1;
                if (
                  (this._assets.delete(l),
                  this._idToAsset.delete(l.id),
                  (n = l.file) != null &&
                    n.url &&
                    this._urlToAsset.delete(l.file.url),
                  l.off("name", this._onNameChange, this),
                  this._nameToAsset.has(l.name))
                ) {
                  const i = this._nameToAsset.get(l.name);
                  i.delete(l), i.size === 0 && this._nameToAsset.delete(l.name);
                }
                return (
                  this._tags.removeItem(l),
                  l.tags.off("add", this._onTagAdd, this),
                  l.tags.off("remove", this._onTagRemove, this),
                  l.fire("remove", l),
                  this.fire("remove", l),
                  this.fire("remove:" + l.id, l),
                  (o = l.file) != null &&
                    o.url &&
                    this.fire("remove:url:" + l.file.url, l),
                  !0
                );
              }
              get(l) {
                return this._idToAsset.get(Number(l));
              }
              getByUrl(l) {
                return this._urlToAsset.get(l);
              }
              load(l) {
                if (l.loading || l.loaded) return;
                const n = l.file,
                  o = (e) => {
                    e instanceof Array ? (l.resources = e) : (l.resource = e),
                      this._loader.patch(l, this),
                      this.fire("load", l),
                      this.fire("load:" + l.id, l),
                      n && n.url && this.fire("load:url:" + n.url, l),
                      l.fire("load", l);
                  },
                  i = (e, t, r) => {
                    if (((l.loaded = !0), (l.loading = !1), e))
                      this.fire("error", e, l),
                        this.fire("error:" + l.id, e, l),
                        l.fire("error", e, l);
                    else {
                      if (!d._.legacy && l.type === "script") {
                        const u = this._loader.getHandler("script");
                        u._cache[l.id] &&
                          u._cache[l.id].parentNode === document.head &&
                          document.head.removeChild(u._cache[l.id]),
                          (u._cache[l.id] = r);
                      }
                      o(t);
                    }
                  };
                if (n || l.type === "cubemap")
                  this.fire("load:start", l),
                    this.fire("load:" + l.id + ":start", l),
                    (l.loading = !0),
                    this._loader.load(l.getFileUrl(), l.type, i, l);
                else {
                  const e = this._loader.open(l.type, l.data);
                  (l.loaded = !0), o(e);
                }
              }
              loadFromUrl(l, n, o) {
                this.loadFromUrlAndFilename(l, null, n, o);
              }
              loadFromUrlAndFilename(l, n, o, i) {
                const e = x.E.getBasename(n || l),
                  t = { filename: n || e, url: l };
                let r = this.getByUrl(l);
                if (!r) (r = new h.x(e, o, t)), this.add(r);
                else if (r.loaded) {
                  i(r.loadFromUrlError || null, r);
                  return;
                }
                const u = (y) => {
                  y.once("load", (p) => {
                    o === "material"
                      ? this._loadTextures(p, (_, m) => {
                          i(_, p);
                        })
                      : i(null, p);
                  }),
                    y.once("error", (p) => {
                      p && (this.loadFromUrlError = p), i(p, y);
                    }),
                    this.load(y);
                };
                r.resource
                  ? i(null, r)
                  : o === "model"
                  ? this._loadModel(r, u)
                  : u(r);
              }
              _loadModel(l, n) {
                const o = l.getFileUrl(),
                  i = x.E.getExtension(o);
                if (i === ".json" || i === ".glb") {
                  const e = x.E.getDirectory(o),
                    t = x.E.getBasename(o),
                    r = x.E.join(e, t.replace(i, ".mapping.json"));
                  this._loader.load(r, "json", (u, y) => {
                    u
                      ? ((l.data = { mapping: [] }), n(l))
                      : this._loadMaterials(l, y, (p, _) => {
                          (l.data = y), n(l);
                        });
                  });
                } else n(l);
              }
              _loadMaterials(l, n, o) {
                const i = [];
                let e = 0;
                const t = (r, u) => {
                  this._loadTextures(u, (y, p) => {
                    i.push(u), i.length === e && o(null, i);
                  });
                };
                for (let r = 0; r < n.mapping.length; r++) {
                  const u = n.mapping[r].path;
                  if (u) {
                    e++;
                    const y = l.getAbsoluteUrl(u);
                    this.loadFromUrl(y, "material", t);
                  }
                }
                e === 0 && o(null, i);
              }
              _loadTextures(l, n) {
                const o = [];
                let i = 0;
                const e = l.data;
                if (e.mappingFormat !== "path") {
                  n(null, o);
                  return;
                }
                const t = (u, y) => {
                    u && console.error(u),
                      o.push(y),
                      o.length === i && n(null, o);
                  },
                  r = c.Eh;
                for (let u = 0; u < r.length; u++) {
                  const y = e[r[u]];
                  if (y && typeof y == "string") {
                    i++;
                    const p = l.getAbsoluteUrl(y);
                    this.loadFromUrl(p, "texture", t);
                  }
                }
                i === 0 && n(null, o);
              }
              _onTagAdd(l, n) {
                this._tags.add(l, n);
              }
              _onTagRemove(l, n) {
                this._tags.remove(l, n);
              }
              _onNameChange(l, n, o) {
                if (this._nameToAsset.has(o)) {
                  const i = this._nameToAsset.get(o);
                  i.delete(l), i.size === 0 && this._nameToAsset.delete(o);
                }
                this._nameToAsset.has(l.name) ||
                  this._nameToAsset.set(l.name, new Set()),
                  this._nameToAsset.get(l.name).add(l);
              }
              findByTag() {
                return this._tags.find(arguments);
              }
              filter(l) {
                return Array.from(this._assets).filter((n) => l(n));
              }
              find(l, n) {
                const o = this._nameToAsset.get(l);
                if (!o) return null;
                for (const i of o) if (!n || i.type === n) return i;
                return null;
              }
              findAll(l, n) {
                const o = this._nameToAsset.get(l);
                if (!o) return [];
                const i = Array.from(o);
                return n ? i.filter((e) => e.type === n) : i;
              }
            }
          },
          6204: (Se, W, a) => {
            "use strict";
            a.d(W, { x: () => i });
            var x = a(9296),
              T = a(6660),
              g = a(5338),
              c = a(9735),
              d = a(8462);
            class h {
              constructor(
                t = "",
                r = "",
                u = null,
                y = null,
                p = null,
                _ = null
              ) {
                (this.url = t),
                  (this.filename = r),
                  (this.hash = u),
                  (this.size = y),
                  (this.opt = p),
                  (this.contents = _);
              }
              equals(t) {
                return (
                  this.url === t.url &&
                  this.filename === t.filename &&
                  this.hash === t.hash &&
                  this.size === t.size &&
                  this.opt === t.opt &&
                  this.contents === t.contents
                );
              }
            }
            var f = a(4355),
              s = a(1467);
            let l = -1;
            const n = {
                pvr: "extCompressedTexturePVRTC",
                dxt: "extCompressedTextureS3TC",
                etc2: "extCompressedTextureETC",
                etc1: "extCompressedTextureETC1",
                basis: "canvas",
              },
              o = ["pvr", "dxt", "etc2", "etc1", "basis"];
            class i extends g.b {
              constructor(t, r, u, y, p) {
                super(),
                  (this._id = l--),
                  (this._name = t || ""),
                  (this.type = r),
                  (this.tags = new T.$(this)),
                  (this._preload = !1),
                  (this._file = null),
                  (this._data = y || {}),
                  (this.options = p || {}),
                  (this._resources = []),
                  (this._i18n = {}),
                  (this.loaded = !1),
                  (this.loading = !1),
                  (this.registry = null),
                  u && (this.file = u);
              }
              set id(t) {
                this._id = t;
              }
              get id() {
                return this._id;
              }
              set name(t) {
                if (this._name === t) return;
                const r = this._name;
                (this._name = t), this.fire("name", this, this._name, r);
              }
              get name() {
                return this._name;
              }
              set file(t) {
                if (
                  t &&
                  t.variants &&
                  ["texture", "textureatlas", "bundle"].indexOf(this.type) !==
                    -1
                ) {
                  var r;
                  const p =
                      ((r = this.registry) == null || (r = r._loader) == null
                        ? void 0
                        : r._app) || (0, f.i)(),
                    _ = p == null ? void 0 : p.graphicsDevice;
                  if (_)
                    for (let m = 0, E = o.length; m < E; m++) {
                      const v = o[m];
                      if (t.variants[v] && _[n[v]]) {
                        t = t.variants[v];
                        break;
                      }
                      if (p.enableBundles) {
                        const P = p.bundles.listBundlesForAsset(this);
                        if (
                          P &&
                          P.find((I) => {
                            var A;
                            return I == null || (A = I.file) == null
                              ? void 0
                              : A.variants[v];
                          })
                        )
                          break;
                      }
                    }
                }
                const u = this._file,
                  y = t
                    ? new h(
                        t.url,
                        t.filename,
                        t.hash,
                        t.size,
                        t.opt,
                        t.contents
                      )
                    : null;
                (!!y != !!u || (y && !y.equals(u))) &&
                  ((this._file = y),
                  this.fire("change", this, "file", y, u),
                  this.reload());
              }
              get file() {
                return this._file;
              }
              set data(t) {
                const r = this._data;
                (this._data = t),
                  t !== r &&
                    (this.fire("change", this, "data", t, r),
                    this.loaded &&
                      this.registry._loader.patch(this, this.registry));
              }
              get data() {
                return this._data;
              }
              set resource(t) {
                const r = this._resources[0];
                (this._resources[0] = t),
                  this.fire("change", this, "resource", t, r);
              }
              get resource() {
                return this._resources[0];
              }
              set resources(t) {
                const r = this._resources;
                (this._resources = t),
                  this.fire("change", this, "resources", t, r);
              }
              get resources() {
                return this._resources;
              }
              set preload(t) {
                (t = !!t),
                  this._preload !== t &&
                    ((this._preload = t),
                    this._preload &&
                      !this.loaded &&
                      !this.loading &&
                      this.registry &&
                      this.registry.load(this));
              }
              get preload() {
                return this._preload;
              }
              set loadFaces(t) {
                (t = !!t),
                  (!this.hasOwnProperty("_loadFaces") ||
                    t !== this._loadFaces) &&
                    ((this._loadFaces = t),
                    this.loaded &&
                      this.registry._loader.patch(this, this.registry));
              }
              get loadFaces() {
                return this._loadFaces;
              }
              getFileUrl() {
                const t = this.file;
                if (!t || !t.url) return null;
                let r = t.url;
                if (
                  (this.registry &&
                    this.registry.prefix &&
                    !d.P1.test(r) &&
                    (r = this.registry.prefix + r),
                  this.type !== "script" && t.hash)
                ) {
                  const u = r.indexOf("?") !== -1 ? "&" : "?";
                  r += u + "t=" + t.hash;
                }
                return r;
              }
              getAbsoluteUrl(t) {
                if (t.startsWith("blob:") || t.startsWith("data:")) return t;
                const r = x.E.getDirectory(this.file.url);
                return x.E.join(r, t);
              }
              getLocalizedAssetId(t) {
                return (t = (0, c.Vj)(t, this._i18n)), this._i18n[t] || null;
              }
              addLocalizedAssetId(t, r) {
                (this._i18n[t] = r), this.fire("add:localized", t, r);
              }
              removeLocalizedAssetId(t) {
                const r = this._i18n[t];
                r &&
                  (delete this._i18n[t], this.fire("remove:localized", t, r));
              }
              ready(t, r) {
                (r = r || this),
                  this.loaded
                    ? t.call(r, this)
                    : this.once("load", function (u) {
                        t.call(r, u);
                      });
              }
              reload() {
                this.loaded && ((this.loaded = !1), this.registry.load(this));
              }
              unload() {
                if (!this.loaded && this._resources.length === 0) return;
                this.fire("unload", this),
                  this.registry.fire("unload:" + this.id, this);
                const t = this._resources;
                (this.resources = []),
                  (this.loaded = !1),
                  this.file &&
                    this.registry._loader.clearCache(
                      this.getFileUrl(),
                      this.type
                    );
                for (let r = 0; r < t.length; ++r) {
                  const u = t[r];
                  u && u.destroy && u.destroy();
                }
              }
              static fetchArrayBuffer(t, r, u, y = 0) {
                var p;
                u != null && (p = u.file) != null && p.contents
                  ? setTimeout(() => {
                      r(null, u.file.contents);
                    })
                  : s.d.get(
                      t,
                      {
                        cache: !0,
                        responseType: "arraybuffer",
                        retry: y > 0,
                        maxRetries: y,
                      },
                      r
                    );
              }
            }
          },
          8462: (Se, W, a) => {
            "use strict";
            a.d(W, {
              CZ: () => c,
              Ex: () => o,
              GY: () => n,
              I0: () => i,
              IS: () => t,
              MH: () => r,
              P1: () => x,
              SV: () => h,
              V7: () => g,
              Ve: () => l,
              Zf: () => d,
              bB: () => s,
              g9: () => f,
              mu: () => u,
              pU: () => e,
              ql: () => T,
            });
            const x = new RegExp(
                "^\\s*(?:(?:[a-z]+[a-z0-9\\-\\+\\.]*:)?//|data:|blob:)",
                "i"
              ),
              T = "animation",
              g = "audio",
              c = "image",
              d = "json",
              h = "model",
              f = "material",
              s = "text",
              l = "texture",
              n = "textureatlas",
              o = "cubemap",
              i = "shader",
              e = "css",
              t = "html",
              r = "script",
              u = "container";
          },
          4091: (Se, W, a) => {
            "use strict";
            a.d(W, { X: () => x });
            class x {
              constructor(g) {
                (this._assets = g),
                  (this._bundleAssets = {}),
                  (this._assetsInBundles = {}),
                  (this._urlsInBundles = {}),
                  (this._fileRequests = {}),
                  this._assets.on("add", this._onAssetAdded, this),
                  this._assets.on("remove", this._onAssetRemoved, this);
              }
              _onAssetAdded(g) {
                if (g.type === "bundle") {
                  (this._bundleAssets[g.id] = g),
                    this._registerBundleEventListeners(g.id);
                  for (let c = 0, d = g.data.assets.length; c < d; c++)
                    this._indexAssetInBundle(g.data.assets[c], g);
                } else
                  this._assetsInBundles[g.id] && this._indexAssetFileUrls(g);
              }
              _registerBundleEventListeners(g) {
                this._assets.on("load:" + g, this._onBundleLoaded, this),
                  this._assets.on("error:" + g, this._onBundleError, this);
              }
              _unregisterBundleEventListeners(g) {
                this._assets.off("load:" + g, this._onBundleLoaded, this),
                  this._assets.off("error:" + g, this._onBundleError, this);
              }
              _indexAssetInBundle(g, c) {
                if (!this._assetsInBundles[g]) this._assetsInBundles[g] = [c];
                else {
                  const h = this._assetsInBundles[g];
                  h.indexOf(c) === -1 && h.push(c);
                }
                const d = this._assets.get(g);
                d && this._indexAssetFileUrls(d);
              }
              _indexAssetFileUrls(g) {
                const c = this._getAssetFileUrls(g);
                if (c)
                  for (let d = 0, h = c.length; d < h; d++) {
                    const f = c[d];
                    this._urlsInBundles[f] = this._assetsInBundles[g.id];
                  }
              }
              _getAssetFileUrls(g) {
                let c = g.getFileUrl();
                if (!c) return null;
                c = this._normalizeUrl(c);
                const d = [c];
                if (g.type === "font") {
                  const h = g.data.info.maps.length;
                  for (let f = 1; f < h; f++)
                    d.push(c.replace(".png", f + ".png"));
                }
                return d;
              }
              _normalizeUrl(g) {
                return g && g.split("?")[0];
              }
              _onAssetRemoved(g) {
                if (g.type === "bundle") {
                  delete this._bundleAssets[g.id],
                    this._unregisterBundleEventListeners(g.id);
                  for (const c in this._assetsInBundles) {
                    const d = this._assetsInBundles[c],
                      h = d.indexOf(g);
                    if (h !== -1 && (d.splice(h, 1), !d.length)) {
                      delete this._assetsInBundles[c];
                      for (const f in this._urlsInBundles)
                        this._urlsInBundles[f] === d &&
                          delete this._urlsInBundles[f];
                    }
                  }
                  this._onBundleError(`Bundle ${g.id} was removed`, g);
                } else if (this._assetsInBundles[g.id]) {
                  delete this._assetsInBundles[g.id];
                  const c = this._getAssetFileUrls(g);
                  for (let d = 0, h = c.length; d < h; d++)
                    delete this._urlsInBundles[c[d]];
                }
              }
              _onBundleLoaded(g) {
                if (!g.resource) {
                  this._onBundleError(`Bundle ${g.id} failed to load`, g);
                  return;
                }
                requestAnimationFrame(() => {
                  if (this._fileRequests)
                    for (const c in this._fileRequests) {
                      const d = this._urlsInBundles[c];
                      if (!d || d.indexOf(g) === -1) continue;
                      const h = decodeURIComponent(c);
                      let f = null;
                      g.resource.hasBlobUrl(h) ||
                        (f = `Bundle ${g.id} does not contain URL ${c}`);
                      const s = this._fileRequests[c];
                      for (let l = 0, n = s.length; l < n; l++)
                        f ? s[l](f) : s[l](null, g.resource.getBlobUrl(h));
                      delete this._fileRequests[c];
                    }
                });
              }
              _onBundleError(g, c) {
                for (const d in this._fileRequests)
                  if (!this._findLoadedOrLoadingBundleForUrl(d)) {
                    const f = this._fileRequests[d];
                    for (let s = 0, l = f.length; s < l; s++) f[s](g);
                    delete this._fileRequests[d];
                  }
              }
              _findLoadedOrLoadingBundleForUrl(g) {
                const c = this._urlsInBundles[g];
                if (!c) return null;
                const d = c.length;
                for (let h = 0; h < d; h++)
                  if (c[h].loaded && c[h].resource) return c[h];
                for (let h = 0; h < d; h++) if (c[h].loading) return c[h];
                return null;
              }
              listBundlesForAsset(g) {
                return this._assetsInBundles[g.id] || null;
              }
              list() {
                const g = [];
                for (const c in this._bundleAssets)
                  g.push(this._bundleAssets[c]);
                return g;
              }
              hasUrl(g) {
                return !!this._urlsInBundles[g];
              }
              canLoadUrl(g) {
                return !!this._findLoadedOrLoadingBundleForUrl(g);
              }
              loadUrl(g, c) {
                const d = this._findLoadedOrLoadingBundleForUrl(g);
                if (!d) {
                  c(`URL ${g} not found in any bundles`);
                  return;
                }
                if (d.loaded) {
                  const h = decodeURIComponent(g);
                  if (!d.resource.hasBlobUrl(h)) {
                    c(`Bundle ${d.id} does not contain URL ${g}`);
                    return;
                  }
                  c(null, d.resource.getBlobUrl(h));
                } else
                  this._fileRequests.hasOwnProperty(g)
                    ? this._fileRequests[g].push(c)
                    : (this._fileRequests[g] = [c]);
              }
              destroy() {
                this._assets.off("add", this._onAssetAdded, this),
                  this._assets.off("remove", this._onAssetRemoved, this);
                for (const g in this._bundleAssets)
                  this._unregisterBundleEventListeners(g);
                (this._assets = null),
                  (this._bundleAssets = null),
                  (this._assetsInBundles = null),
                  (this._urlsInBundles = null),
                  (this._fileRequests = null);
              }
            }
          },
          8804: (Se, W, a) => {
            "use strict";
            a.d(W, { b: () => x });
            class x {
              constructor(g) {
                this._blobUrls = {};
                for (let c = 0, d = g.length; c < d; c++)
                  g[c].url && (this._blobUrls[g[c].name] = g[c].url);
              }
              hasBlobUrl(g) {
                return !!this._blobUrls[g];
              }
              getBlobUrl(g) {
                return this._blobUrls[g];
              }
              destroy() {
                for (const g in this._blobUrls)
                  URL.revokeObjectURL(this._blobUrls[g]);
                this._blobUrls = null;
              }
            }
          },
          8182: (Se, W, a) => {
            "use strict";
            a.d(W, { _: () => d });
            var x = a(4585),
              T = a(8949),
              g = a(7230),
              c = a(8250);
            class d {
              constructor(f, s, l, n = 1, o = c.xU, i = !0) {
                (this._name = f),
                  (this._controller = s),
                  (this._component = l),
                  (this._weight = n),
                  (this._blendType = o),
                  (this._normalizedWeight = i),
                  (this._mask = null),
                  (this._blendTime = 0),
                  (this._blendTimeElapsed = 0),
                  (this._startingWeight = 0),
                  (this._targetWeight = 0);
              }
              get name() {
                return this._name;
              }
              set playing(f) {
                this._controller.playing = f;
              }
              get playing() {
                return this._controller.playing;
              }
              get playable() {
                return this._controller.playable;
              }
              get activeState() {
                return this._controller.activeStateName;
              }
              get previousState() {
                return this._controller.previousStateName;
              }
              get activeStateProgress() {
                return this._controller.activeStateProgress;
              }
              get activeStateDuration() {
                return this._controller.activeStateDuration;
              }
              set activeStateCurrentTime(f) {
                const s = this._controller,
                  l = s.playing;
                (s.playing = !0),
                  (s.activeStateCurrentTime = f),
                  l || s.update(0),
                  (s.playing = l);
              }
              get activeStateCurrentTime() {
                return this._controller.activeStateCurrentTime;
              }
              get transitioning() {
                return this._controller.transitioning;
              }
              get transitionProgress() {
                return this.transitioning
                  ? this._controller.transitionProgress
                  : null;
              }
              get states() {
                return this._controller.states;
              }
              set weight(f) {
                (this._weight = f), this._component.dirtifyTargets();
              }
              get weight() {
                return this._weight;
              }
              set blendType(f) {
                f !== this._blendType &&
                  ((this._blendType = f),
                  this._controller.normalizeWeights &&
                    this._component.rebind());
              }
              get blendType() {
                return this._blendType;
              }
              set mask(f) {
                this._controller.assignMask(f) && this._component.rebind(),
                  (this._mask = f);
              }
              get mask() {
                return this._mask;
              }
              play(f) {
                this._controller.play(f);
              }
              pause() {
                this._controller.pause();
              }
              reset() {
                this._controller.reset();
              }
              rebind() {
                this._controller.rebind();
              }
              update(f) {
                this._blendTime &&
                  (this._blendTimeElapsed < this._blendTime
                    ? ((this.weight = x.m.lerp(
                        this._startingWeight,
                        this._targetWeight,
                        this._blendTimeElapsed / this._blendTime
                      )),
                      (this._blendTimeElapsed += f))
                    : ((this.weight = this._targetWeight),
                      (this._blendTime = 0),
                      (this._blendTimeElapsed = 0),
                      (this._startingWeight = 0),
                      (this._targetWeight = 0))),
                  this._controller.update(f);
              }
              blendToWeight(f, s) {
                (this._startingWeight = this.weight),
                  (this._targetWeight = f),
                  (this._blendTime = Math.max(0, s)),
                  (this._blendTimeElapsed = 0);
              }
              assignMask(f) {
                this._controller.assignMask(f) && this._component.rebind(),
                  (this._mask = f);
              }
              assignAnimation(f, s, l, n) {
                s instanceof T.k &&
                  (this._controller.assignAnimation(f, s, l, n),
                  this._controller._transitions.length === 0 &&
                    this._controller._transitions.push(
                      new g.T({ from: "START", to: f })
                    ),
                  this._component.activate &&
                    this._component.playable &&
                    (this._component.playing = !0));
              }
              removeNodeAnimations(f) {
                this._controller.removeNodeAnimations(f) &&
                  (this._component.playing = !1);
              }
              getAnimationAsset(f) {
                return this._component.animationAssets[`${this.name}:${f}`];
              }
              transition(f, s = 0, l = null) {
                this._controller.updateStateFromTransition(
                  new g.T({
                    from: this._controller.activeStateName,
                    to: f,
                    time: s,
                    transitionOffset: l,
                  })
                );
              }
            }
          },
          7078: (Se, W, a) => {
            "use strict";
            a.d(W, { l: () => A });
            var x = a(9078),
              T = a(6204),
              g = a(7570),
              c = a(9509),
              d = a(8620),
              h = a(8250),
              f = a(5440),
              s = a(7122),
              l = a(7301),
              n = a(1367),
              o = a(6847),
              i = a(2978),
              e = a(6556),
              t = a(6630);
            const r = new i.S(),
              u = new e.A(),
              y = new t.T(),
              p = new n.I(),
              _ = new o.D();
            class m extends s.o {
              constructor(C, w, k, K, te) {
                super(w),
                  (this.animComponent = C),
                  (this._mask = K),
                  (this.layerName = k),
                  (this.layerIndex = te);
              }
              static _packFloat(C) {
                return C[0];
              }
              static _packBoolean(C) {
                return !!C[0];
              }
              static _packVec2(C) {
                return (r.x = C[0]), (r.y = C[1]), r;
              }
              static _packVec3(C) {
                return (u.x = C[0]), (u.y = C[1]), (u.z = C[2]), u;
              }
              static _packVec4(C) {
                return (
                  (y.x = C[0]), (y.y = C[1]), (y.z = C[2]), (y.w = C[3]), y
                );
              }
              static _packColor(C) {
                return (
                  (p.r = C[0]), (p.g = C[1]), (p.b = C[2]), (p.a = C[3]), p
                );
              }
              static _packQuat(C) {
                return (
                  (_.x = C[0]), (_.y = C[1]), (_.z = C[2]), (_.w = C[3]), _
                );
              }
              resolve(C) {
                const w = l.S.encode(C.entityPath, C.component, C.propertyPath);
                let k = this.targetCache[w];
                if (k) return k;
                let K, te, X;
                switch (C.component) {
                  case "entity":
                    (K = this._getEntityFromHierarchy(C.entityPath)),
                      (X = l.S.encode(K.path, "entity", C.propertyPath)),
                      (te = K);
                    break;
                  case "graph":
                    if (((te = this.findNode(C)), !te)) return null;
                    X = l.S.encode(te.path, "graph", C.propertyPath);
                    break;
                  default:
                    if (
                      ((K = this._getEntityFromHierarchy(C.entityPath)),
                      (te = K.findComponent(C.component)),
                      !te)
                    )
                      return null;
                    X = l.S.encode(K.path, C.component, C.propertyPath);
                    break;
                }
                return (
                  (k = this._createAnimTargetForProperty(
                    te,
                    C.propertyPath,
                    X
                  )),
                  (this.targetCache[w] = k),
                  k
                );
              }
              update(C) {
                const w = this.activeNodes;
                if (w) for (let k = 0; k < w.length; k++) w[k]._dirtifyLocal();
              }
              _getEntityFromHierarchy(C) {
                if (!this.animComponent.entity.name === C[0]) return null;
                const w = this.animComponent.entity;
                return C.length === 1 ? w : w._parent.findByPath(C);
              }
              _resolvePath(C, w, k) {
                const K = w.length - (k ? 0 : 1);
                for (let te = 0; te < K; te++) C = C[w[te]];
                return C;
              }
              _setter(C, w, k) {
                const K = this._resolvePath(C, w),
                  te = w[w.length - 1],
                  X =
                    "set" + te.substring(0, 1).toUpperCase() + te.substring(1);
                if (K[X]) {
                  let Y =
                    K[
                      "get" + te.substring(0, 1).toUpperCase() + te.substring(1)
                    ].bind(K)();
                  Y = [Y.x, Y.y, Y.z, Y.w];
                  const Z = K[X].bind(K);
                  return {
                    set: (ye) => {
                      Z(k(ye));
                    },
                    get: () => Y,
                  };
                }
                const $ = K[te];
                if (typeof $ == "object" && $.hasOwnProperty("copy"))
                  return function (ne) {
                    $.copy(k(ne));
                  };
                if (
                  [i.S, e.A, t.T, n.I, o.D].indexOf(K.constructor) !== -1 &&
                  w.length > 1
                ) {
                  const ne =
                      w.length > 2 ? this._resolvePath(C, w.slice(0, -1)) : C,
                    Y = w[w.length - 2];
                  return function (Z) {
                    (K[te] = k(Z)), (ne[Y] = K);
                  };
                }
                return function (ne) {
                  K[te] = k(ne);
                };
              }
              _createAnimTargetForProperty(C, w, k) {
                if (this.handlers && w[0].startsWith("weight."))
                  return this.handlers.weight(C, w[0].replace("weight.", ""));
                if (this.handlers && w[0] === "material" && w.length === 2) {
                  const ne = w[1];
                  if (ne.endsWith("Map"))
                    return this.handlers.materialTexture(C, ne);
                }
                const K = this._resolvePath(C, w, !0);
                if (typeof K == "undefined") return null;
                let te, X, $;
                if (typeof K == "number")
                  (te = this._setter(C, w, m._packFloat)),
                    (X = "vector"),
                    ($ = 1);
                else if (typeof K == "boolean")
                  (te = this._setter(C, w, m._packBoolean)),
                    (X = "vector"),
                    ($ = 1);
                else if (typeof K == "object")
                  switch (K.constructor) {
                    case i.S:
                      (te = this._setter(C, w, m._packVec2)),
                        (X = "vector"),
                        ($ = 2);
                      break;
                    case e.A:
                      (te = this._setter(C, w, m._packVec3)),
                        (X = "vector"),
                        ($ = 3);
                      break;
                    case t.T:
                      (te = this._setter(C, w, m._packVec4)),
                        (X = "vector"),
                        ($ = 4);
                      break;
                    case n.I:
                      (te = this._setter(C, w, m._packColor)),
                        (X = "vector"),
                        ($ = 4);
                      break;
                    case o.D:
                      (te = this._setter(C, w, m._packQuat)),
                        (X = "quaternion"),
                        ($ = 4);
                      break;
                    default:
                      return null;
                  }
                return w.indexOf("material") !== -1
                  ? new f.e(
                      function (ne) {
                        te(ne), C.material.update();
                      },
                      X,
                      $,
                      k
                    )
                  : new f.e(te, X, $, k);
              }
              rebind() {
                (this.targetCache = {}),
                  this.animComponent.rootBone
                    ? (this.graph = this.animComponent.rootBone)
                    : (this.graph = this.animComponent.entity);
                const C = {};
                (function k(K) {
                  C[K.name] = K;
                  for (let te = 0; te < K.children.length; ++te)
                    k(K.children[te]);
                })(this.graph),
                  (this.nodes = C);
              }
            }
            var E = a(8182),
              v = a(6608),
              P = a(258),
              I = a(8949);
            class A extends d.w {
              constructor(C, w) {
                super(C, w),
                  (this.findParameter = (k) => this._parameters[k]),
                  (this.consumeTrigger = (k) => {
                    this._consumedTriggers.add(k);
                  }),
                  (this._stateGraphAsset = null),
                  (this._animationAssets = {}),
                  (this._speed = 1),
                  (this._activate = !0),
                  (this._playing = !1),
                  (this._rootBone = null),
                  (this._stateGraph = null),
                  (this._layers = []),
                  (this._layerIndices = {}),
                  (this._parameters = {}),
                  (this._targets = {}),
                  (this._consumedTriggers = new Set()),
                  (this._normalizeWeights = !1);
              }
              set stateGraphAsset(C) {
                if (C === null) {
                  this.removeStateGraph();
                  return;
                }
                this._stateGraphAsset &&
                  this.system.app.assets
                    .get(this._stateGraphAsset)
                    .off("change", this._onStateGraphAssetChangeEvent, this);
                let w, k;
                C instanceof T.x
                  ? ((w = C.id),
                    (k = this.system.app.assets.get(w)),
                    k ||
                      (this.system.app.assets.add(C),
                      (k = this.system.app.assets.get(w))))
                  : ((w = C), (k = this.system.app.assets.get(w))),
                  !(!k || this._stateGraphAsset === w) &&
                    (k.resource
                      ? ((this._stateGraph = k.resource),
                        this.loadStateGraph(this._stateGraph),
                        k.on(
                          "change",
                          this._onStateGraphAssetChangeEvent,
                          this
                        ))
                      : (k.once("load", (K) => {
                          (this._stateGraph = K.resource),
                            this.loadStateGraph(this._stateGraph);
                        }),
                        k.on(
                          "change",
                          this._onStateGraphAssetChangeEvent,
                          this
                        ),
                        this.system.app.assets.load(k)),
                    (this._stateGraphAsset = w));
              }
              get stateGraphAsset() {
                return this._stateGraphAsset;
              }
              set normalizeWeights(C) {
                (this._normalizeWeights = C), this.unbind();
              }
              get normalizeWeights() {
                return this._normalizeWeights;
              }
              set animationAssets(C) {
                (this._animationAssets = C), this.loadAnimationAssets();
              }
              get animationAssets() {
                return this._animationAssets;
              }
              set speed(C) {
                this._speed = C;
              }
              get speed() {
                return this._speed;
              }
              set activate(C) {
                this._activate = C;
              }
              get activate() {
                return this._activate;
              }
              set playing(C) {
                this._playing = C;
              }
              get playing() {
                return this._playing;
              }
              set rootBone(C) {
                if (typeof C == "string") {
                  const w = this.entity.root.findByGuid(C);
                  this._rootBone = w;
                } else
                  C instanceof P.J
                    ? (this._rootBone = C)
                    : (this._rootBone = null);
                this.rebind();
              }
              get rootBone() {
                return this._rootBone;
              }
              set stateGraph(C) {
                this._stateGraph = C;
              }
              get stateGraph() {
                return this._stateGraph;
              }
              get layers() {
                return this._layers;
              }
              set layerIndices(C) {
                this._layerIndices = C;
              }
              get layerIndices() {
                return this._layerIndices;
              }
              set parameters(C) {
                this._parameters = C;
              }
              get parameters() {
                return this._parameters;
              }
              set targets(C) {
                this._targets = C;
              }
              get targets() {
                return this._targets;
              }
              get playable() {
                for (let C = 0; C < this._layers.length; C++)
                  if (!this._layers[C].playable) return !1;
                return !0;
              }
              get baseLayer() {
                return this._layers.length > 0 ? this._layers[0] : null;
              }
              _onStateGraphAssetChangeEvent(C) {
                const w = this.animationAssets,
                  k = this.layers.map((K) => K.mask);
                this.removeStateGraph(),
                  (this._stateGraph = new v.Z(C._data)),
                  this.loadStateGraph(this._stateGraph),
                  (this.animationAssets = w),
                  this.loadAnimationAssets(),
                  this.layers.forEach((K, te) => {
                    K.mask = k[te];
                  }),
                  this.rebind();
              }
              dirtifyTargets() {
                const C = Object.values(this._targets);
                for (let w = 0; w < C.length; w++) C[w].dirty = !0;
              }
              _addLayer({
                name: C,
                states: w,
                transitions: k,
                weight: K,
                mask: te,
                blendType: X,
              }) {
                let $;
                this.rootBone ? ($ = this.rootBone) : ($ = this.entity);
                const ne = this._layers.length,
                  Y = new m(this, $, C, te, ne),
                  Z = new g.g(Y),
                  ye = new c.o(
                    Z,
                    w,
                    k,
                    this._activate,
                    this,
                    this.findParameter,
                    this.consumeTrigger
                  );
                return (
                  this._layers.push(new E._(C, ye, this, K, X)),
                  (this._layerIndices[C] = ne),
                  this._layers[ne]
                );
              }
              addLayer(C, w, k, K) {
                const te = this.findAnimationLayer(C);
                if (te) return te;
                const X = [{ name: "START", speed: 1 }],
                  $ = [];
                return this._addLayer({
                  name: C,
                  states: X,
                  transitions: $,
                  weight: w,
                  mask: k,
                  blendType: K,
                });
              }
              _assignParameters(C) {
                this._parameters = {};
                const w = Object.keys(C.parameters);
                for (let k = 0; k < w.length; k++) {
                  const K = w[k];
                  this._parameters[K] = {
                    type: C.parameters[K].type,
                    value: C.parameters[K].value,
                  };
                }
              }
              loadStateGraph(C) {
                (this._stateGraph = C),
                  this._assignParameters(C),
                  (this._layers = []);
                let w = !1;
                for (let k = 0; k < C.layers.length; k++) {
                  const K = C.layers[k];
                  this._addLayer.bind(this)((0, x.g)({}, K)),
                    K.states.some((te) => te.blendTree) && (w = !0);
                }
                w || this.setupAnimationAssets();
              }
              setupAnimationAssets() {
                for (let C = 0; C < this._layers.length; C++) {
                  const w = this._layers[C],
                    k = w.name;
                  for (let K = 0; K < w.states.length; K++) {
                    const te = w.states[K];
                    if (h.Fw.indexOf(te) === -1) {
                      const X = k + ":" + te;
                      this._animationAssets[X] ||
                        (this._animationAssets[X] = { asset: null });
                    }
                  }
                }
                this.loadAnimationAssets();
              }
              loadAnimationAssets() {
                for (let C = 0; C < this._layers.length; C++) {
                  const w = this._layers[C];
                  for (let k = 0; k < w.states.length; k++) {
                    const K = w.states[k];
                    if (h.Fw.indexOf(K) !== -1) continue;
                    const te = this._animationAssets[w.name + ":" + K];
                    if (!te || !te.asset) {
                      this.findAnimationLayer(w.name).assignAnimation(
                        K,
                        I.k.EMPTY
                      );
                      continue;
                    }
                    const X = te.asset,
                      $ = this.system.app.assets.get(X);
                    $ &&
                      ($.resource
                        ? this.onAnimationAssetLoaded(w.name, K, $)
                        : ($.once(
                            "load",
                            function (ne, Y) {
                              return function (Z) {
                                this.onAnimationAssetLoaded(ne, Y, Z);
                              }.bind(this);
                            }.bind(this)(w.name, K)
                          ),
                          this.system.app.assets.load($)));
                  }
                }
              }
              onAnimationAssetLoaded(C, w, k) {
                this.findAnimationLayer(C).assignAnimation(w, k.resource);
              }
              removeStateGraph() {
                (this._stateGraph = null),
                  (this._stateGraphAsset = null),
                  (this._animationAssets = {}),
                  (this._layers = []),
                  (this._layerIndices = {}),
                  (this._parameters = {}),
                  (this._playing = !1),
                  this.unbind(),
                  (this._targets = {});
              }
              reset() {
                this._assignParameters(this._stateGraph);
                for (let C = 0; C < this._layers.length; C++) {
                  const w = this._layers[C].playing;
                  this._layers[C].reset(), (this._layers[C].playing = w);
                }
              }
              unbind() {
                this._normalizeWeights ||
                  Object.keys(this._targets).forEach((C) => {
                    this._targets[C].unbind();
                  });
              }
              rebind() {
                this._targets = {};
                for (let C = 0; C < this._layers.length; C++)
                  this._layers[C].rebind();
              }
              findAnimationLayer(C) {
                const w = this._layerIndices[C];
                return this._layers[w] || null;
              }
              addAnimationState(C, w, k = 1, K = !0, te = "Base") {
                this._stateGraph ||
                  this.loadStateGraph(
                    new v.Z({
                      layers: [
                        {
                          name: te,
                          states: [
                            { name: "START", speed: 1 },
                            { name: C, speed: k, loop: K, defaultState: !0 },
                          ],
                          transitions: [{ from: "START", to: C }],
                        },
                      ],
                      parameters: {},
                    })
                  );
                const X = this.findAnimationLayer(te);
                if (X) X.assignAnimation(C, w, k, K);
                else {
                  var $;
                  ($ = this.addLayer(te)) == null ||
                    $.assignAnimation(C, w, k, K);
                }
              }
              assignAnimation(C, w, k, K = 1, te = !0) {
                if (!this._stateGraph && C.indexOf(".") === -1) {
                  this.loadStateGraph(
                    new v.Z({
                      layers: [
                        {
                          name: "Base",
                          states: [
                            { name: "START", speed: 1 },
                            { name: C, speed: K, loop: te, defaultState: !0 },
                          ],
                          transitions: [{ from: "START", to: C }],
                        },
                      ],
                      parameters: {},
                    })
                  ),
                    this.baseLayer.assignAnimation(C, w);
                  return;
                }
                const X = k ? this.findAnimationLayer(k) : this.baseLayer;
                X && X.assignAnimation(C, w, K, te);
              }
              removeNodeAnimations(C, w) {
                const k = w ? this.findAnimationLayer(w) : this.baseLayer;
                k && k.removeNodeAnimations(C);
              }
              getParameterValue(C, w) {
                const k = this._parameters[C];
                if (k && k.type === w) return k.value;
              }
              setParameterValue(C, w, k) {
                const K = this._parameters[C];
                if (K && K.type === w) {
                  K.value = k;
                  return;
                }
              }
              getFloat(C) {
                return this.getParameterValue(C, h.yg);
              }
              setFloat(C, w) {
                this.setParameterValue(C, h.yg, w);
              }
              getInteger(C) {
                return this.getParameterValue(C, h.qR);
              }
              setInteger(C, w) {
                typeof w == "number" &&
                  w % 1 === 0 &&
                  this.setParameterValue(C, h.qR, w);
              }
              getBoolean(C) {
                return this.getParameterValue(C, h.p2);
              }
              setBoolean(C, w) {
                this.setParameterValue(C, h.p2, !!w);
              }
              getTrigger(C) {
                return this.getParameterValue(C, h.S5);
              }
              setTrigger(C, w = !1) {
                this.setParameterValue(C, h.S5, !0),
                  w && this._consumedTriggers.add(C);
              }
              resetTrigger(C) {
                this.setParameterValue(C, h.S5, !1);
              }
              onBeforeRemove() {
                Number.isFinite(this._stateGraphAsset) &&
                  this.system.app.assets
                    .get(this._stateGraphAsset)
                    .off("change", this._onStateGraphAssetChangeEvent, this);
              }
              update(C) {
                for (let w = 0; w < this.layers.length; w++)
                  this.layers[w].update(C * this.speed);
                this._consumedTriggers.forEach((w) => {
                  this.parameters[w].value = !1;
                }),
                  this._consumedTriggers.clear();
              }
              resolveDuplicatedEntityReferenceProperties(C, w) {
                C.rootBone && w[C.rootBone.getGuid()]
                  ? (this.rootBone = w[C.rootBone.getGuid()])
                  : this.rebind();
              }
            }
          },
          5212: (Se, W, a) => {
            "use strict";
            a.d(W, { R: () => f });
            var x = a(8949),
              T = a(8620),
              g = a(6813),
              c = a(7078);
            class d {
              constructor() {
                this.enabled = !0;
              }
            }
            const h = ["enabled"];
            class f extends g.Q {
              constructor(l) {
                super(l),
                  (this.id = "anim"),
                  (this.ComponentType = c.l),
                  (this.DataType = d),
                  (this.schema = h),
                  this.on("beforeremove", this.onBeforeRemove, this),
                  this.app.systems.on(
                    "animationUpdate",
                    this.onAnimationUpdate,
                    this
                  );
              }
              initializeComponentData(l, n, o) {
                super.initializeComponentData(l, n, h);
                const i = ["animationAssets", "stateGraph", "layers", "masks"];
                Object.keys(n).forEach((e) => {
                  i.includes(e) || (l[e] = n[e]);
                }),
                  n.stateGraph &&
                    ((l.stateGraph = n.stateGraph),
                    l.loadStateGraph(l.stateGraph)),
                  n.layers
                    ? n.layers.forEach((e, t) => {
                        e._controller.states.forEach((r) => {
                          e._controller._states[r]._animationList.forEach(
                            (u) => {
                              if (!u.animTrack || u.animTrack === x.k.EMPTY) {
                                const y = this.app.assets.get(
                                  e._component._animationAssets[
                                    e.name + ":" + u.name
                                  ].asset
                                );
                                y &&
                                  !y.loaded &&
                                  y.once("load", () => {
                                    l.layers[t].assignAnimation(
                                      u.name,
                                      y.resource
                                    );
                                  });
                              } else
                                l.layers[t].assignAnimation(
                                  u.name,
                                  u.animTrack
                                );
                            }
                          );
                        });
                      })
                    : n.animationAssets &&
                      (l.animationAssets = Object.assign(
                        l.animationAssets,
                        n.animationAssets
                      )),
                  n.masks &&
                    Object.keys(n.masks).forEach((e) => {
                      if (l.layers[e]) {
                        const t = n.masks[e].mask,
                          r = {};
                        Object.keys(t).forEach((u) => {
                          r[decodeURI(u)] = t[u];
                        }),
                          (l.layers[e].mask = r);
                      }
                    });
              }
              onAnimationUpdate(l) {
                const n = this.store;
                for (const o in n)
                  if (n.hasOwnProperty(o)) {
                    const i = n[o].entity.anim;
                    i.data.enabled &&
                      i.entity.enabled &&
                      i.playing &&
                      i.update(l);
                  }
              }
              cloneComponent(l, n) {
                let o;
                (!l.anim.rootBone || l.anim.rootBone === l) &&
                  ((o = {}),
                  l.anim.layers.forEach((e, t) => {
                    if (e.mask) {
                      const r = {};
                      Object.keys(e.mask).forEach((u) => {
                        const y = u.split("/");
                        y.shift();
                        const p = [n.name, ...y].join("/");
                        r[p] = e.mask[u];
                      }),
                        (o[t] = { mask: r });
                    }
                  }));
                const i = {
                  stateGraphAsset: l.anim.stateGraphAsset,
                  animationAssets: l.anim.animationAssets,
                  speed: l.anim.speed,
                  activate: l.anim.activate,
                  playing: l.anim.playing,
                  rootBone: l.anim.rootBone,
                  stateGraph: l.anim.stateGraph,
                  layers: l.anim.layers,
                  layerIndices: l.anim.layerIndices,
                  parameters: l.anim.parameters,
                  normalizeWeights: l.anim.normalizeWeights,
                  masks: o,
                };
                return this.addComponent(n, i);
              }
              onBeforeRemove(l, n) {
                n.onBeforeRemove();
              }
              destroy() {
                super.destroy(),
                  this.app.systems.off(
                    "animationUpdate",
                    this.onAnimationUpdate,
                    this
                  );
              }
            }
            T.w._buildAccessors(c.l.prototype, h);
          },
          5107: (Se, W, a) => {
            "use strict";
            a.d(W, { c: () => s });
            var x = a(7968),
              T = a(7570),
              g = a(8949),
              c = a(7122),
              d = a(242),
              h = a(6204),
              f = a(8620);
            class s extends f.w {
              constructor(n, o) {
                super(n, o),
                  (this._animations = {}),
                  (this._assets = []),
                  (this._loop = !0),
                  (this.animEvaluator = null),
                  (this.model = null),
                  (this.skeleton = null),
                  (this.fromSkel = null),
                  (this.toSkel = null),
                  (this.animationsIndex = {}),
                  (this.prevAnim = null),
                  (this.currAnim = null),
                  (this.blend = 0),
                  (this.blending = !1),
                  (this.blendSpeed = 0),
                  (this.activate = !0),
                  (this.speed = 1);
              }
              set animations(n) {
                (this._animations = n), this.onSetAnimations();
              }
              get animations() {
                return this._animations;
              }
              set assets(n) {
                const o = this._assets;
                if (o && o.length) {
                  for (let e = 0; e < o.length; e++)
                    if (o[e]) {
                      const t = this.system.app.assets.get(o[e]);
                      if (t) {
                        t.off("change", this.onAssetChanged, this),
                          t.off("remove", this.onAssetRemoved, this);
                        const r = this.animationsIndex[t.id];
                        this.currAnim === r && this._stopCurrentAnimation(),
                          delete this.animations[r],
                          delete this.animationsIndex[t.id];
                      }
                    }
                }
                this._assets = n;
                const i = n.map((e) => (e instanceof h.x ? e.id : e));
                this.loadAnimationAssets(i);
              }
              get assets() {
                return this._assets;
              }
              set currentTime(n) {
                if (
                  (this.skeleton &&
                    ((this.skeleton.currentTime = n),
                    this.skeleton.addTime(0),
                    this.skeleton.updateGraph()),
                  this.animEvaluator)
                ) {
                  const o = this.animEvaluator.clips;
                  for (let i = 0; i < o.length; ++i) o[i].time = n;
                }
              }
              get currentTime() {
                if (this.skeleton) return this.skeleton._time;
                if (this.animEvaluator) {
                  const n = this.animEvaluator.clips;
                  if (n.length > 0) return n[n.length - 1].time;
                }
                return 0;
              }
              get duration() {
                return this.currAnim
                  ? this.animations[this.currAnim].duration
                  : 0;
              }
              set loop(n) {
                if (
                  ((this._loop = n),
                  this.skeleton && (this.skeleton.looping = n),
                  this.animEvaluator)
                )
                  for (let o = 0; o < this.animEvaluator.clips.length; ++o)
                    this.animEvaluator.clips[o].loop = n;
              }
              get loop() {
                return this._loop;
              }
              play(n, o = 0) {
                if (
                  !(!this.enabled || !this.entity.enabled) &&
                  this.animations[n]
                ) {
                  if (
                    ((this.prevAnim = this.currAnim),
                    (this.currAnim = n),
                    this.model)
                  ) {
                    !this.skeleton &&
                      !this.animEvaluator &&
                      this._createAnimationController();
                    const i = this.animations[this.prevAnim],
                      e = this.animations[this.currAnim];
                    if (
                      ((this.blending = o > 0 && !!this.prevAnim),
                      this.blending &&
                        ((this.blend = 0), (this.blendSpeed = 1 / o)),
                      this.skeleton &&
                        (this.blending
                          ? ((this.fromSkel.animation = i),
                            this.fromSkel.addTime(this.skeleton._time),
                            (this.toSkel.animation = e))
                          : (this.skeleton.animation = e)),
                      this.animEvaluator)
                    ) {
                      const t = this.animEvaluator;
                      if (this.blending)
                        for (; t.clips.length > 1; ) t.removeClip(0);
                      else this.animEvaluator.removeClips();
                      const r = new x.L(
                        this.animations[this.currAnim],
                        0,
                        1,
                        !0,
                        this.loop
                      );
                      (r.name = this.currAnim),
                        (r.blendWeight = this.blending ? 0 : 1),
                        r.reset(),
                        this.animEvaluator.addClip(r);
                    }
                  }
                  this.playing = !0;
                }
              }
              getAnimation(n) {
                return this.animations[n];
              }
              setModel(n) {
                n !== this.model &&
                  (this._resetAnimationController(),
                  (this.model = n),
                  this.animations &&
                    this.currAnim &&
                    this.animations[this.currAnim] &&
                    this.play(this.currAnim));
              }
              onSetAnimations() {
                const n = this.entity.model;
                if (n) {
                  const o = n.model;
                  o && o !== this.model && this.setModel(o);
                }
                if (
                  !this.currAnim &&
                  this.activate &&
                  this.enabled &&
                  this.entity.enabled
                ) {
                  const o = Object.keys(this._animations);
                  o.length > 0 && this.play(o[0]);
                }
              }
              _resetAnimationController() {
                (this.skeleton = null),
                  (this.fromSkel = null),
                  (this.toSkel = null),
                  (this.animEvaluator = null);
              }
              _createAnimationController() {
                const n = this.model,
                  o = this.animations;
                let i = !1,
                  e = !1;
                for (const r in o)
                  o.hasOwnProperty(r) &&
                    (o[r].constructor === g.k ? (e = !0) : (i = !0));
                const t = n.getGraph();
                i
                  ? ((this.fromSkel = new d.O(t)),
                    (this.toSkel = new d.O(t)),
                    (this.skeleton = new d.O(t)),
                    (this.skeleton.looping = this.loop),
                    this.skeleton.setGraph(t))
                  : e && (this.animEvaluator = new T.g(new c.o(this.entity)));
              }
              loadAnimationAssets(n) {
                if (!n || !n.length) return;
                const o = this.system.app.assets,
                  i = (t) => {
                    if (t.resources.length > 1)
                      for (let r = 0; r < t.resources.length; r++)
                        (this.animations[t.resources[r].name] = t.resources[r]),
                          (this.animationsIndex[t.id] = t.resources[r].name);
                    else
                      (this.animations[t.name] = t.resource),
                        (this.animationsIndex[t.id] = t.name);
                    this.animations = this.animations;
                  },
                  e = (t) => {
                    t.off("change", this.onAssetChanged, this),
                      t.on("change", this.onAssetChanged, this),
                      t.off("remove", this.onAssetRemoved, this),
                      t.on("remove", this.onAssetRemoved, this),
                      t.resource
                        ? i(t)
                        : (t.once("load", i, this),
                          this.enabled && this.entity.enabled && o.load(t));
                  };
                for (let t = 0, r = n.length; t < r; t++) {
                  const u = o.get(n[t]);
                  u ? e(u) : o.on("add:" + n[t], e);
                }
              }
              onAssetChanged(n, o, i, e) {
                if (o === "resource" || o === "resources")
                  if (
                    (o === "resources" && i && i.length === 0 && (i = null), i)
                  ) {
                    let t = !1;
                    if (i.length > 1) {
                      if (e && e.length > 1)
                        for (let r = 0; r < e.length; r++)
                          delete this.animations[e[r].name];
                      else delete this.animations[n.name];
                      t = !1;
                      for (let r = 0; r < i.length; r++)
                        (this.animations[i[r].name] = i[r]),
                          !t &&
                            this.currAnim === i[r].name &&
                            this.playing &&
                            this.enabled &&
                            this.entity.enabled &&
                            ((t = !0), this.play(i[r].name));
                      t ||
                        (this._stopCurrentAnimation(), this.onSetAnimations());
                    } else {
                      if (e && e.length > 1)
                        for (let r = 0; r < e.length; r++)
                          delete this.animations[e[r].name];
                      (this.animations[n.name] = i[0] || i),
                        (t = !1),
                        this.currAnim === n.name &&
                          this.playing &&
                          this.enabled &&
                          this.entity.enabled &&
                          ((t = !0), this.play(n.name)),
                        t ||
                          (this._stopCurrentAnimation(),
                          this.onSetAnimations());
                    }
                    this.animationsIndex[n.id] = n.name;
                  } else {
                    if (e.length > 1)
                      for (let t = 0; t < e.length; t++)
                        delete this.animations[e[t].name],
                          this.currAnim === e[t].name &&
                            this._stopCurrentAnimation();
                    else
                      delete this.animations[n.name],
                        this.currAnim === n.name &&
                          this._stopCurrentAnimation();
                    delete this.animationsIndex[n.id];
                  }
              }
              onAssetRemoved(n) {
                if (
                  (n.off("remove", this.onAssetRemoved, this), this.animations)
                ) {
                  if (n.resources.length > 1)
                    for (let o = 0; o < n.resources.length; o++)
                      delete this.animations[n.resources[o].name],
                        this.currAnim === n.resources[o].name &&
                          this._stopCurrentAnimation();
                  else
                    delete this.animations[n.name],
                      this.currAnim === n.name && this._stopCurrentAnimation();
                  delete this.animationsIndex[n.id];
                }
              }
              _stopCurrentAnimation() {
                if (
                  ((this.currAnim = null),
                  (this.playing = !1),
                  this.skeleton &&
                    ((this.skeleton.currentTime = 0),
                    (this.skeleton.animation = null)),
                  this.animEvaluator)
                ) {
                  for (let n = 0; n < this.animEvaluator.clips.length; ++n)
                    this.animEvaluator.clips[n].stop();
                  this.animEvaluator.update(0),
                    this.animEvaluator.removeClips();
                }
              }
              onEnable() {
                super.onEnable();
                const n = this.assets,
                  o = this.system.app.assets;
                if (n)
                  for (let i = 0, e = n.length; i < e; i++) {
                    let t = n[i];
                    t instanceof h.x || (t = o.get(t)),
                      t && !t.resource && o.load(t);
                  }
                if (this.activate && !this.currAnim) {
                  const i = Object.keys(this.animations);
                  i.length > 0 && this.play(i[0]);
                }
              }
              onBeforeRemove() {
                for (let n = 0; n < this.assets.length; n++) {
                  let o = this.assets[n];
                  typeof o == "number" && (o = this.system.app.assets.get(o)),
                    o &&
                      (o.off("change", this.onAssetChanged, this),
                      o.off("remove", this.onAssetRemoved, this));
                }
                (this.skeleton = null),
                  (this.fromSkel = null),
                  (this.toSkel = null),
                  (this.animEvaluator = null);
              }
              update(n) {
                if (
                  (this.blending &&
                    ((this.blend += n * this.blendSpeed),
                    this.blend >= 1 && (this.blend = 1)),
                  this.playing)
                ) {
                  const i = this.skeleton;
                  if (i !== null && this.model !== null) {
                    if (this.blending)
                      i.blend(this.fromSkel, this.toSkel, this.blend);
                    else {
                      const e = n * this.speed;
                      i.addTime(e),
                        this.speed > 0 &&
                        i._time === i.animation.duration &&
                        !this.loop
                          ? (this.playing = !1)
                          : this.speed < 0 &&
                            i._time === 0 &&
                            !this.loop &&
                            (this.playing = !1);
                    }
                    this.blending &&
                      this.blend === 1 &&
                      (i.animation = this.toSkel.animation),
                      i.updateGraph();
                  }
                }
                const o = this.animEvaluator;
                if (o) {
                  for (let i = 0; i < o.clips.length; ++i) {
                    const e = o.clips[i];
                    (e.speed = this.speed),
                      this.playing ? e.resume() : e.pause();
                  }
                  this.blending &&
                    o.clips.length > 1 &&
                    (o.clips[1].blendWeight = this.blend),
                    o.update(n);
                }
                this.blending && this.blend === 1 && (this.blending = !1);
              }
            }
          },
          1012: (Se, W, a) => {
            "use strict";
            a.d(W, { _: () => h });
            var x = a(8620),
              T = a(6813),
              g = a(5107);
            class c {
              constructor() {
                this.enabled = !0;
              }
            }
            const d = ["enabled"];
            class h extends T.Q {
              constructor(s) {
                super(s),
                  (this.id = "animation"),
                  (this.ComponentType = g.c),
                  (this.DataType = c),
                  (this.schema = d),
                  this.on("beforeremove", this.onBeforeRemove, this),
                  this.app.systems.on("update", this.onUpdate, this);
              }
              initializeComponentData(s, l, n) {
                n = ["activate", "enabled", "loop", "speed", "assets"];
                for (const o of n) l.hasOwnProperty(o) && (s[o] = l[o]);
                super.initializeComponentData(s, l, d);
              }
              cloneComponent(s, l) {
                this.addComponent(l, {}),
                  (l.animation.assets = s.animation.assets.slice()),
                  (l.animation.speed = s.animation.speed),
                  (l.animation.loop = s.animation.loop),
                  (l.animation.activate = s.animation.activate),
                  (l.animation.enabled = s.animation.enabled);
                const n = {},
                  o = s.animation.animations;
                for (const t in o) o.hasOwnProperty(t) && (n[t] = o[t]);
                l.animation.animations = n;
                const i = {},
                  e = s.animation.animationsIndex;
                for (const t in e) e.hasOwnProperty(t) && (i[t] = e[t]);
                return (l.animation.animationsIndex = i), l.animation;
              }
              onBeforeRemove(s, l) {
                l.onBeforeRemove();
              }
              onUpdate(s) {
                const l = this.store;
                for (const n in l)
                  if (l.hasOwnProperty(n)) {
                    const o = l[n];
                    o.data.enabled &&
                      o.entity.enabled &&
                      o.entity.animation.update(s);
                  }
              }
              destroy() {
                super.destroy(),
                  this.app.systems.off("update", this.onUpdate, this);
              }
            }
            x.w._buildAccessors(g.c.prototype, d);
          },
          7075: (Se, W, a) => {
            "use strict";
            a.d(W, { r: () => T });
            var x = a(8620);
            class T extends x.w {
              constructor(c, d) {
                super(c, d);
              }
              setCurrentListener() {
                if (
                  this.enabled &&
                  this.entity.audiolistener &&
                  this.entity.enabled
                ) {
                  this.system.current = this.entity;
                  const c = this.system.current.getPosition();
                  this.system.manager.listener.setPosition(c);
                }
              }
              onEnable() {
                this.setCurrentListener();
              }
              onDisable() {
                this.system.current === this.entity &&
                  (this.system.current = null);
              }
            }
          },
          9578: (Se, W, a) => {
            "use strict";
            a.d(W, { n: () => h });
            var x = a(8620),
              T = a(6813),
              g = a(7075);
            class c {
              constructor() {
                this.enabled = !0;
              }
            }
            const d = ["enabled"];
            class h extends T.Q {
              constructor(s) {
                super(s),
                  (this.id = "audiolistener"),
                  (this.ComponentType = g.r),
                  (this.DataType = c),
                  (this.schema = d),
                  (this.manager = s.soundManager),
                  (this.current = null),
                  this.app.systems.on("update", this.onUpdate, this);
              }
              initializeComponentData(s, l, n) {
                (n = ["enabled"]), super.initializeComponentData(s, l, n);
              }
              onUpdate(s) {
                if (this.current) {
                  const l = this.current.getPosition();
                  this.manager.listener.setPosition(l);
                  const n = this.current.getWorldTransform();
                  this.manager.listener.setOrientation(n);
                }
              }
              destroy() {
                super.destroy(),
                  this.app.systems.off("update", this.onUpdate, this);
              }
            }
            x.w._buildAccessors(g.r.prototype, d);
          },
          356: (Se, W, a) => {
            "use strict";
            a.d(W, { Q: () => c });
            var x = a(6204),
              T = a(9725),
              g = a(8620);
            class c extends g.w {
              constructor(h, f) {
                super(h, f),
                  this.on("set_assets", this.onSetAssets, this),
                  this.on("set_loop", this.onSetLoop, this),
                  this.on("set_volume", this.onSetVolume, this),
                  this.on("set_pitch", this.onSetPitch, this),
                  this.on("set_minDistance", this.onSetMinDistance, this),
                  this.on("set_maxDistance", this.onSetMaxDistance, this),
                  this.on("set_rollOffFactor", this.onSetRollOffFactor, this),
                  this.on("set_distanceModel", this.onSetDistanceModel, this),
                  this.on("set_3d", this.onSet3d, this);
              }
              play(h) {
                if (!this.enabled || !this.entity.enabled) return;
                this.channel && this.stop();
                let f;
                const s = this.data;
                if (s.sources[h])
                  if (!s["3d"])
                    (f = this.system.manager.playSound(s.sources[h], s)),
                      (s.currentSource = h),
                      (s.channel = f);
                  else {
                    const l = this.entity.getPosition();
                    (f = this.system.manager.playSound3d(s.sources[h], l, s)),
                      (s.currentSource = h),
                      (s.channel = f);
                  }
              }
              pause() {
                this.channel && this.channel.pause();
              }
              unpause() {
                this.channel && this.channel.paused && this.channel.unpause();
              }
              stop() {
                this.channel && (this.channel.stop(), (this.channel = null));
              }
              onSetAssets(h, f, s) {
                const l = [],
                  n = s.length;
                if (f && f.length) {
                  for (let o = 0; o < f.length; o++)
                    if (f[o]) {
                      const i = this.system.app.assets.get(f[o]);
                      i &&
                        (i.off("change", this.onAssetChanged, this),
                        i.off("remove", this.onAssetRemoved, this),
                        this.currentSource === i.name && this.stop());
                    }
                }
                if (n)
                  for (let o = 0; o < n; o++)
                    f.indexOf(s[o]) < 0 &&
                      (s[o] instanceof x.x ? l.push(s[o].id) : l.push(s[o]));
                !this.system._inTools &&
                  l.length &&
                  this.loadAudioSourceAssets(l);
              }
              onAssetChanged(h, f, s, l) {
                f === "resource" &&
                  this.data.sources &&
                  ((this.data.sources[h.name] = s),
                  this.data.currentSource === h.name &&
                    this.channel &&
                    (this.channel.paused
                      ? (this.play(h.name), this.pause())
                      : this.play(h.name)));
              }
              onAssetRemoved(h) {
                h.off("remove", this.onAssetRemoved, this),
                  this.data.sources[h.name] &&
                    (delete this.data.sources[h.name],
                    this.data.currentSource === h.name &&
                      (this.stop(), (this.data.currentSource = null)));
              }
              onSetLoop(h, f, s) {
                f !== s && this.channel && this.channel.setLoop(s);
              }
              onSetVolume(h, f, s) {
                f !== s && this.channel && this.channel.setVolume(s);
              }
              onSetPitch(h, f, s) {
                f !== s && this.channel && this.channel.setPitch(s);
              }
              onSetMaxDistance(h, f, s) {
                f !== s &&
                  this.channel instanceof T.b &&
                  this.channel.setMaxDistance(s);
              }
              onSetMinDistance(h, f, s) {
                f !== s &&
                  this.channel instanceof T.b &&
                  this.channel.setMinDistance(s);
              }
              onSetRollOffFactor(h, f, s) {
                f !== s &&
                  this.channel instanceof T.b &&
                  this.channel.setRollOffFactor(s);
              }
              onSetDistanceModel(h, f, s) {
                f !== s &&
                  this.channel instanceof T.b &&
                  this.channel.setDistanceModel(s);
              }
              onSet3d(h, f, s) {
                if (f !== s && this.system.initialized && this.currentSource) {
                  let l = !1,
                    n = !1;
                  this.channel &&
                    ((l = this.channel.paused), (n = this.channel.suspended)),
                    this.play(this.currentSource),
                    this.channel &&
                      ((this.channel.paused = l), (this.channel.suspended = n));
                }
              }
              onEnable() {
                const h = this.data.assets;
                if (h) {
                  const f = this.system.app.assets;
                  for (let s = 0, l = h.length; s < l; s++) {
                    let n = h[s];
                    n instanceof x.x || (n = f.get(n)),
                      n && !n.resource && f.load(n);
                  }
                }
                this.system.initialized &&
                  (this.data.activate && !this.channel
                    ? this.play(this.currentSource)
                    : this.unpause());
              }
              onDisable() {
                this.pause();
              }
              loadAudioSourceAssets(h) {
                const f = h.map((e) => this.system.app.assets.get(e)),
                  s = {};
                let l = null,
                  n = f.length;
                const o = (e) => {
                    n--;
                  },
                  i = () => {
                    (this.data.sources = s),
                      (this.data.currentSource = l),
                      this.enabled && this.activate && l && this.onEnable();
                  };
                f.forEach((e, t) => {
                  e
                    ? ((l = l || e.name),
                      e.off("change", this.onAssetChanged, this),
                      e.on("change", this.onAssetChanged, this),
                      e.off("remove", this.onAssetRemoved, this),
                      e.on("remove", this.onAssetRemoved, this),
                      e.off("error", o, this),
                      e.on("error", o, this),
                      e.ready((r) => {
                        (s[r.name] = r.resource), n--, n === 0 && i();
                      }),
                      !e.resource &&
                        this.enabled &&
                        this.entity.enabled &&
                        this.system.app.assets.load(e))
                    : (n--,
                      n === 0 && i(),
                      this.system.app.assets.on("add:" + h[t], (r) => {
                        r.ready((u) => {
                          this.data.sources[u.name] = u.resource;
                        }),
                          r.resource || this.system.app.assets.load(r);
                      }));
                });
              }
            }
          },
          8740: (Se, W, a) => {
            "use strict";
            a.d(W, { D: () => l });
            var x = a(9725),
              T = a(258),
              g = a(8620),
              c = a(6813),
              d = a(356),
              h = a(1304);
            class f {
              constructor() {
                (this.enabled = !0),
                  (this.assets = []),
                  (this.activate = !0),
                  (this.volume = 1),
                  (this.pitch = 1),
                  (this.loop = !1),
                  (this["3d"] = !0),
                  (this.minDistance = 1),
                  (this.maxDistance = 1e4),
                  (this.rollOffFactor = 1),
                  (this.distanceModel = h.mU),
                  (this.paused = !0),
                  (this.sources = {}),
                  (this.currentSource = null),
                  (this.channel = null);
              }
            }
            const s = [
              "enabled",
              "assets",
              "volume",
              "pitch",
              "loop",
              "activate",
              "3d",
              "minDistance",
              "maxDistance",
              "rollOffFactor",
              "distanceModel",
              "sources",
              "currentSource",
              "channel",
            ];
            class l extends c.Q {
              constructor(o) {
                super(o),
                  (this.id = "audiosource"),
                  (this.ComponentType = d.Q),
                  (this.DataType = f),
                  (this.schema = s),
                  (this.manager = o.soundManager),
                  (this.initialized = !1),
                  this.app.systems.on("initialize", this.onInitialize, this),
                  this.app.systems.on("update", this.onUpdate, this),
                  this.on("remove", this.onRemove, this);
              }
              initializeComponentData(o, i, e) {
                (e = [
                  "activate",
                  "volume",
                  "pitch",
                  "loop",
                  "3d",
                  "minDistance",
                  "maxDistance",
                  "rollOffFactor",
                  "distanceModel",
                  "enabled",
                  "assets",
                ]),
                  super.initializeComponentData(o, i, e),
                  (o.paused = !(o.enabled && o.activate));
              }
              onInitialize(o) {
                o.audiosource &&
                  o.enabled &&
                  o.audiosource.enabled &&
                  o.audiosource.activate &&
                  o.audiosource.play(o.audiosource.currentSource);
                const i = o._children;
                for (let e = 0, t = i.length; e < t; e++)
                  i[e] instanceof T.J && this.onInitialize(i[e]);
                this.initialized = !0;
              }
              onUpdate(o) {
                const i = this.store;
                for (const e in i)
                  if (i.hasOwnProperty(e)) {
                    const t = i[e],
                      r = t.entity,
                      u = t.data;
                    if (u.enabled && r.enabled && u.channel instanceof x.b) {
                      const y = r.getPosition();
                      u.channel.setPosition(y);
                    }
                  }
              }
              onRemove(o, i) {
                i.channel && (i.channel.stop(), (i.channel = null));
              }
              setVolume(o) {
                this.manager.setVolume(o);
              }
              destroy() {
                super.destroy(),
                  this.app.systems.off("initialize", this.onInitialize, this),
                  this.app.systems.off("update", this.onUpdate, this);
              }
            }
            g.w._buildAccessors(d.Q.prototype, s);
          },
          889: (Se, W, a) => {
            "use strict";
            a.d(W, { r: () => i });
            var x = a(3821),
              T = a(4585),
              g = a(1367),
              c = a(5004),
              d = a(8620),
              h = a(5545),
              f = a(3404);
            const s = {
                DEFAULT: "DEFAULT",
                HOVER: "HOVER",
                PRESSED: "PRESSED",
                INACTIVE: "INACTIVE",
              },
              l = {};
            (l[s.DEFAULT] = "_defaultTint"),
              (l[s.HOVER] = "hoverTint"),
              (l[s.PRESSED] = "pressedTint"),
              (l[s.INACTIVE] = "inactiveTint");
            const n = {};
            (n[s.DEFAULT] = "_defaultSpriteAsset"),
              (n[s.HOVER] = "hoverSpriteAsset"),
              (n[s.PRESSED] = "pressedSpriteAsset"),
              (n[s.INACTIVE] = "inactiveSpriteAsset");
            const o = {};
            (o[s.DEFAULT] = "_defaultSpriteFrame"),
              (o[s.HOVER] = "hoverSpriteFrame"),
              (o[s.PRESSED] = "pressedSpriteFrame"),
              (o[s.INACTIVE] = "inactiveSpriteFrame");
            class i extends d.w {
              constructor(r, u) {
                super(r, u),
                  (this._visualState = s.DEFAULT),
                  (this._isHovering = !1),
                  (this._hoveringCounter = 0),
                  (this._isPressed = !1),
                  (this._defaultTint = new g.I(1, 1, 1, 1)),
                  (this._defaultSpriteAsset = null),
                  (this._defaultSpriteFrame = 0),
                  (this._imageReference = new c.e(this, "imageEntity", {
                    "element#gain": this._onImageElementGain,
                    "element#lose": this._onImageElementLose,
                    "element#set:color": this._onSetColor,
                    "element#set:opacity": this._onSetOpacity,
                    "element#set:spriteAsset": this._onSetSpriteAsset,
                    "element#set:spriteFrame": this._onSetSpriteFrame,
                  })),
                  this._toggleLifecycleListeners("on", r);
              }
              _toggleLifecycleListeners(r, u) {
                this[r]("set_active", this._onSetActive, this),
                  this[r](
                    "set_transitionMode",
                    this._onSetTransitionMode,
                    this
                  ),
                  this[r]("set_hoverTint", this._onSetTransitionValue, this),
                  this[r]("set_pressedTint", this._onSetTransitionValue, this),
                  this[r]("set_inactiveTint", this._onSetTransitionValue, this),
                  this[r](
                    "set_hoverSpriteAsset",
                    this._onSetTransitionValue,
                    this
                  ),
                  this[r](
                    "set_hoverSpriteFrame",
                    this._onSetTransitionValue,
                    this
                  ),
                  this[r](
                    "set_pressedSpriteAsset",
                    this._onSetTransitionValue,
                    this
                  ),
                  this[r](
                    "set_pressedSpriteFrame",
                    this._onSetTransitionValue,
                    this
                  ),
                  this[r](
                    "set_inactiveSpriteAsset",
                    this._onSetTransitionValue,
                    this
                  ),
                  this[r](
                    "set_inactiveSpriteFrame",
                    this._onSetTransitionValue,
                    this
                  ),
                  u.app.systems.element[r](
                    "add",
                    this._onElementComponentAdd,
                    this
                  ),
                  u.app.systems.element[r](
                    "beforeremove",
                    this._onElementComponentRemove,
                    this
                  );
              }
              _onSetActive(r, u, y) {
                u !== y && this._updateVisualState();
              }
              _onSetTransitionMode(r, u, y) {
                u !== y &&
                  (this._cancelTween(),
                  this._resetToDefaultVisualState(u),
                  this._forceReapplyVisualState());
              }
              _onSetTransitionValue(r, u, y) {
                u !== y && this._forceReapplyVisualState();
              }
              _onElementComponentRemove(r) {
                this.entity === r && this._toggleHitElementListeners("off");
              }
              _onElementComponentAdd(r) {
                this.entity === r && this._toggleHitElementListeners("on");
              }
              _onImageElementLose() {
                this._cancelTween(),
                  this._resetToDefaultVisualState(this.transitionMode);
              }
              _onImageElementGain() {
                this._storeDefaultVisualState(),
                  this._forceReapplyVisualState();
              }
              _toggleHitElementListeners(r) {
                if (this.entity.element) {
                  const u = r === "on";
                  if (u && this._hasHitElementListeners) return;
                  this.entity.element[r](
                    "mouseenter",
                    this._onMouseEnter,
                    this
                  ),
                    this.entity.element[r](
                      "mouseleave",
                      this._onMouseLeave,
                      this
                    ),
                    this.entity.element[r](
                      "mousedown",
                      this._onMouseDown,
                      this
                    ),
                    this.entity.element[r]("mouseup", this._onMouseUp, this),
                    this.entity.element[r](
                      "touchstart",
                      this._onTouchStart,
                      this
                    ),
                    this.entity.element[r]("touchend", this._onTouchEnd, this),
                    this.entity.element[r](
                      "touchleave",
                      this._onTouchLeave,
                      this
                    ),
                    this.entity.element[r](
                      "touchcancel",
                      this._onTouchCancel,
                      this
                    ),
                    this.entity.element[r](
                      "selectstart",
                      this._onSelectStart,
                      this
                    ),
                    this.entity.element[r](
                      "selectend",
                      this._onSelectEnd,
                      this
                    ),
                    this.entity.element[r](
                      "selectenter",
                      this._onSelectEnter,
                      this
                    ),
                    this.entity.element[r](
                      "selectleave",
                      this._onSelectLeave,
                      this
                    ),
                    this.entity.element[r]("click", this._onClick, this),
                    (this._hasHitElementListeners = u);
                }
              }
              _storeDefaultVisualState() {
                if (this._imageReference.hasComponent("element")) {
                  const r = this._imageReference.entity.element;
                  r.type !== f.Kv &&
                    (this._storeDefaultColor(r.color),
                    this._storeDefaultOpacity(r.opacity),
                    this._storeDefaultSpriteAsset(r.spriteAsset),
                    this._storeDefaultSpriteFrame(r.spriteFrame));
                }
              }
              _storeDefaultColor(r) {
                (this._defaultTint.r = r.r),
                  (this._defaultTint.g = r.g),
                  (this._defaultTint.b = r.b);
              }
              _storeDefaultOpacity(r) {
                this._defaultTint.a = r;
              }
              _storeDefaultSpriteAsset(r) {
                this._defaultSpriteAsset = r;
              }
              _storeDefaultSpriteFrame(r) {
                this._defaultSpriteFrame = r;
              }
              _onSetColor(r) {
                this._isApplyingTint ||
                  (this._storeDefaultColor(r), this._forceReapplyVisualState());
              }
              _onSetOpacity(r) {
                this._isApplyingTint ||
                  (this._storeDefaultOpacity(r),
                  this._forceReapplyVisualState());
              }
              _onSetSpriteAsset(r) {
                this._isApplyingSprite ||
                  (this._storeDefaultSpriteAsset(r),
                  this._forceReapplyVisualState());
              }
              _onSetSpriteFrame(r) {
                this._isApplyingSprite ||
                  (this._storeDefaultSpriteFrame(r),
                  this._forceReapplyVisualState());
              }
              _onMouseEnter(r) {
                (this._isHovering = !0),
                  this._updateVisualState(),
                  this._fireIfActive("mouseenter", r);
              }
              _onMouseLeave(r) {
                (this._isHovering = !1),
                  (this._isPressed = !1),
                  this._updateVisualState(),
                  this._fireIfActive("mouseleave", r);
              }
              _onMouseDown(r) {
                (this._isPressed = !0),
                  this._updateVisualState(),
                  this._fireIfActive("mousedown", r);
              }
              _onMouseUp(r) {
                (this._isPressed = !1),
                  this._updateVisualState(),
                  this._fireIfActive("mouseup", r);
              }
              _onTouchStart(r) {
                (this._isPressed = !0),
                  this._updateVisualState(),
                  this._fireIfActive("touchstart", r);
              }
              _onTouchEnd(r) {
                r.event.preventDefault(),
                  (this._isPressed = !1),
                  this._updateVisualState(),
                  this._fireIfActive("touchend", r);
              }
              _onTouchLeave(r) {
                (this._isPressed = !1),
                  this._updateVisualState(),
                  this._fireIfActive("touchleave", r);
              }
              _onTouchCancel(r) {
                (this._isPressed = !1),
                  this._updateVisualState(),
                  this._fireIfActive("touchcancel", r);
              }
              _onSelectStart(r) {
                (this._isPressed = !0),
                  this._updateVisualState(),
                  this._fireIfActive("selectstart", r);
              }
              _onSelectEnd(r) {
                (this._isPressed = !1),
                  this._updateVisualState(),
                  this._fireIfActive("selectend", r);
              }
              _onSelectEnter(r) {
                this._hoveringCounter++,
                  this._hoveringCounter === 1 &&
                    ((this._isHovering = !0), this._updateVisualState()),
                  this._fireIfActive("selectenter", r);
              }
              _onSelectLeave(r) {
                this._hoveringCounter--,
                  this._hoveringCounter === 0 &&
                    ((this._isHovering = !1),
                    (this._isPressed = !1),
                    this._updateVisualState()),
                  this._fireIfActive("selectleave", r);
              }
              _onClick(r) {
                this._fireIfActive("click", r);
              }
              _fireIfActive(r, u) {
                this.data.active && this.fire(r, u);
              }
              _updateVisualState(r) {
                const u = this._visualState,
                  y = this._determineVisualState();
                if ((u !== y || r) && this.enabled)
                  switch (
                    ((this._visualState = y),
                    u === s.HOVER && this._fireIfActive("hoverend"),
                    u === s.PRESSED && this._fireIfActive("pressedend"),
                    y === s.HOVER && this._fireIfActive("hoverstart"),
                    y === s.PRESSED && this._fireIfActive("pressedstart"),
                    this.transitionMode)
                  ) {
                    case h.C: {
                      const p = l[this._visualState],
                        _ = this[p];
                      this._applyTint(_);
                      break;
                    }
                    case h.v: {
                      const p = n[this._visualState],
                        _ = o[this._visualState],
                        m = this[p],
                        E = this[_];
                      this._applySprite(m, E);
                      break;
                    }
                  }
              }
              _forceReapplyVisualState() {
                this._updateVisualState(!0);
              }
              _resetToDefaultVisualState(r) {
                if (this._imageReference.hasComponent("element"))
                  switch (r) {
                    case h.C:
                      this._cancelTween(),
                        this._applyTintImmediately(this._defaultTint);
                      break;
                    case h.v:
                      this._applySprite(
                        this._defaultSpriteAsset,
                        this._defaultSpriteFrame
                      );
                      break;
                  }
              }
              _determineVisualState() {
                if (this.active) {
                  if (this._isPressed) return s.PRESSED;
                  if (this._isHovering) return s.HOVER;
                } else return s.INACTIVE;
                return s.DEFAULT;
              }
              _applySprite(r, u) {
                (u = u || 0),
                  this._imageReference.hasComponent("element") &&
                    ((this._isApplyingSprite = !0),
                    this._imageReference.entity.element.spriteAsset !== r &&
                      (this._imageReference.entity.element.spriteAsset = r),
                    this._imageReference.entity.element.spriteFrame !== u &&
                      (this._imageReference.entity.element.spriteFrame = u),
                    (this._isApplyingSprite = !1));
              }
              _applyTint(r) {
                this._cancelTween(),
                  this.fadeDuration === 0
                    ? this._applyTintImmediately(r)
                    : this._applyTintWithTween(r);
              }
              _applyTintImmediately(r) {
                if (
                  !r ||
                  !this._imageReference.hasComponent("element") ||
                  this._imageReference.entity.element.type === f.Kv
                )
                  return;
                const u = e(r);
                (this._isApplyingTint = !0),
                  u.equals(this._imageReference.entity.element.color) ||
                    (this._imageReference.entity.element.color = u),
                  this._imageReference.entity.element.opacity !== r.a &&
                    (this._imageReference.entity.element.opacity = r.a),
                  (this._isApplyingTint = !1);
              }
              _applyTintWithTween(r) {
                if (
                  !r ||
                  !this._imageReference.hasComponent("element") ||
                  this._imageReference.entity.element.type === f.Kv
                )
                  return;
                const u = e(r),
                  y = this._imageReference.entity.element.color,
                  p = this._imageReference.entity.element.opacity;
                (u.equals(y) && r.a === p) ||
                  (this._tweenInfo = {
                    startTime: (0, x.z)(),
                    from: new g.I(y.r, y.g, y.b, p),
                    to: r.clone(),
                    lerpColor: new g.I(),
                  });
              }
              _updateTintTween() {
                const r = (0, x.z)() - this._tweenInfo.startTime;
                let u = this.fadeDuration === 0 ? 1 : r / this.fadeDuration;
                if (((u = T.m.clamp(u, 0, 1)), Math.abs(u - 1) > 1e-5)) {
                  const y = this._tweenInfo.lerpColor;
                  y.lerp(this._tweenInfo.from, this._tweenInfo.to, u),
                    this._applyTintImmediately(new g.I(y.r, y.g, y.b, y.a));
                } else
                  this._applyTintImmediately(this._tweenInfo.to),
                    this._cancelTween();
              }
              _cancelTween() {
                delete this._tweenInfo;
              }
              onUpdate() {
                this._tweenInfo && this._updateTintTween();
              }
              onEnable() {
                (this._isHovering = !1),
                  (this._hoveringCounter = 0),
                  (this._isPressed = !1),
                  this._imageReference.onParentComponentEnable(),
                  this._toggleHitElementListeners("on"),
                  this._forceReapplyVisualState();
              }
              onDisable() {
                this._toggleHitElementListeners("off"),
                  this._resetToDefaultVisualState(this.transitionMode);
              }
              onRemove() {
                this._toggleLifecycleListeners("off", this.system),
                  this.onDisable();
              }
            }
            function e(t) {
              return new g.I(t.r, t.g, t.b);
            }
          },
          5545: (Se, W, a) => {
            "use strict";
            a.d(W, { C: () => x, v: () => T });
            const x = 0,
              T = 1;
          },
          1951: (Se, W, a) => {
            "use strict";
            a.d(W, { n: () => l });
            var x = a(8620),
              T = a(6813),
              g = a(889),
              c = a(1367),
              d = a(6630),
              h = a(5545);
            class f {
              constructor() {
                (this.enabled = !0),
                  (this.active = !0),
                  (this.imageEntity = null),
                  (this.hitPadding = new d.T()),
                  (this.transitionMode = h.C),
                  (this.hoverTint = new c.I(0.75, 0.75, 0.75)),
                  (this.pressedTint = new c.I(0.5, 0.5, 0.5)),
                  (this.inactiveTint = new c.I(0.25, 0.25, 0.25)),
                  (this.fadeDuration = 0),
                  (this.hoverSpriteAsset = null),
                  (this.hoverSpriteFrame = 0),
                  (this.pressedSpriteAsset = null),
                  (this.pressedSpriteFrame = 0),
                  (this.inactiveSpriteAsset = null),
                  (this.inactiveSpriteFrame = 0);
              }
            }
            const s = [
              "enabled",
              "active",
              { name: "imageEntity", type: "entity" },
              { name: "hitPadding", type: "vec4" },
              "transitionMode",
              { name: "hoverTint", type: "rgba" },
              { name: "pressedTint", type: "rgba" },
              { name: "inactiveTint", type: "rgba" },
              "fadeDuration",
              "hoverSpriteAsset",
              "hoverSpriteFrame",
              "pressedSpriteAsset",
              "pressedSpriteFrame",
              "inactiveSpriteAsset",
              "inactiveSpriteFrame",
            ];
            class l extends T.Q {
              constructor(o) {
                super(o),
                  (this.id = "button"),
                  (this.ComponentType = g.r),
                  (this.DataType = f),
                  (this.schema = s),
                  this.on("beforeremove", this._onRemoveComponent, this),
                  this.app.systems.on("update", this.onUpdate, this);
              }
              initializeComponentData(o, i, e) {
                super.initializeComponentData(o, i, s);
              }
              onUpdate(o) {
                const i = this.store;
                for (const e in i) {
                  const t = i[e].entity,
                    r = t.button;
                  r.enabled && t.enabled && r.onUpdate();
                }
              }
              _onRemoveComponent(o, i) {
                i.onRemove();
              }
              destroy() {
                super.destroy(),
                  this.app.systems.off("update", this.onUpdate, this);
              }
            }
            x.w._buildAccessors(g.r.prototype, s);
          },
          4378: (Se, W, a) => {
            "use strict";
            a.d(W, { M: () => h });
            var x = a(3114),
              T = a(6165),
              g = a(1585),
              c = a(8620),
              d = a(3121);
            class h extends c.w {
              constructor(s, l) {
                super(s, l),
                  (this.onPostprocessing = null),
                  (this.onPreRender = null),
                  (this.onPostRender = null),
                  (this._renderSceneDepthMap = 0),
                  (this._renderSceneColorMap = 0),
                  (this._sceneDepthMapRequested = !1),
                  (this._sceneColorMapRequested = !1),
                  (this._priority = 0),
                  (this._disablePostEffectsLayer = x.Q7),
                  (this._camera = new T.V()),
                  (this._camera.node = l),
                  (this._postEffects = new d.G(s.app, this));
              }
              setShaderPass(s) {
                const l = g.T.get(this.system.app.graphicsDevice),
                  n = s ? l.allocate(s, { isForward: !0 }) : null;
                return (this._camera.shaderPassInfo = n), n.index;
              }
              getShaderPass() {
                var s;
                return (s = this._camera.shaderPassInfo) == null
                  ? void 0
                  : s.name;
              }
              set aperture(s) {
                this._camera.aperture = s;
              }
              get aperture() {
                return this._camera.aperture;
              }
              set aspectRatio(s) {
                this._camera.aspectRatio = s;
              }
              get aspectRatio() {
                return this._camera.aspectRatio;
              }
              set aspectRatioMode(s) {
                this._camera.aspectRatioMode = s;
              }
              get aspectRatioMode() {
                return this._camera.aspectRatioMode;
              }
              set calculateProjection(s) {
                this._camera.calculateProjection = s;
              }
              get calculateProjection() {
                return this._camera.calculateProjection;
              }
              set calculateTransform(s) {
                this._camera.calculateTransform = s;
              }
              get calculateTransform() {
                return this._camera.calculateTransform;
              }
              get camera() {
                return this._camera;
              }
              set clearColor(s) {
                this._camera.clearColor = s;
              }
              get clearColor() {
                return this._camera.clearColor;
              }
              set clearColorBuffer(s) {
                (this._camera.clearColorBuffer = s),
                  this.dirtyLayerCompositionCameras();
              }
              get clearColorBuffer() {
                return this._camera.clearColorBuffer;
              }
              set clearDepthBuffer(s) {
                (this._camera.clearDepthBuffer = s),
                  this.dirtyLayerCompositionCameras();
              }
              get clearDepthBuffer() {
                return this._camera.clearDepthBuffer;
              }
              set clearStencilBuffer(s) {
                (this._camera.clearStencilBuffer = s),
                  this.dirtyLayerCompositionCameras();
              }
              get clearStencilBuffer() {
                return this._camera.clearStencilBuffer;
              }
              set cullFaces(s) {
                this._camera.cullFaces = s;
              }
              get cullFaces() {
                return this._camera.cullFaces;
              }
              set disablePostEffectsLayer(s) {
                (this._disablePostEffectsLayer = s),
                  this.dirtyLayerCompositionCameras();
              }
              get disablePostEffectsLayer() {
                return this._disablePostEffectsLayer;
              }
              set farClip(s) {
                this._camera.farClip = s;
              }
              get farClip() {
                return this._camera.farClip;
              }
              set flipFaces(s) {
                this._camera.flipFaces = s;
              }
              get flipFaces() {
                return this._camera.flipFaces;
              }
              set fov(s) {
                this._camera.fov = s;
              }
              get fov() {
                return this._camera.fov;
              }
              get frustum() {
                return this._camera.frustum;
              }
              set frustumCulling(s) {
                this._camera.frustumCulling = s;
              }
              get frustumCulling() {
                return this._camera.frustumCulling;
              }
              set horizontalFov(s) {
                this._camera.horizontalFov = s;
              }
              get horizontalFov() {
                return this._camera.horizontalFov;
              }
              set layers(s) {
                const l = this._camera.layers;
                for (let n = 0; n < l.length; n++) {
                  const o = this.system.app.scene.layers.getLayerById(l[n]);
                  o && o.removeCamera(this);
                }
                if (
                  ((this._camera.layers = s),
                  !(!this.enabled || !this.entity.enabled))
                )
                  for (let n = 0; n < s.length; n++) {
                    const o = this.system.app.scene.layers.getLayerById(s[n]);
                    o && o.addCamera(this);
                  }
              }
              get layers() {
                return this._camera.layers;
              }
              get layersSet() {
                return this._camera.layersSet;
              }
              set nearClip(s) {
                this._camera.nearClip = s;
              }
              get nearClip() {
                return this._camera.nearClip;
              }
              set orthoHeight(s) {
                this._camera.orthoHeight = s;
              }
              get orthoHeight() {
                return this._camera.orthoHeight;
              }
              get postEffects() {
                return this._postEffects;
              }
              get postEffectsEnabled() {
                return this._postEffects.enabled;
              }
              set priority(s) {
                (this._priority = s), this.dirtyLayerCompositionCameras();
              }
              get priority() {
                return this._priority;
              }
              set projection(s) {
                this._camera.projection = s;
              }
              get projection() {
                return this._camera.projection;
              }
              get projectionMatrix() {
                return this._camera.projectionMatrix;
              }
              set rect(s) {
                (this._camera.rect = s),
                  this.fire("set:rect", this._camera.rect);
              }
              get rect() {
                return this._camera.rect;
              }
              set renderSceneColorMap(s) {
                s && !this._sceneColorMapRequested
                  ? (this.requestSceneColorMap(!0),
                    (this._sceneColorMapRequested = !0))
                  : this._sceneColorMapRequested &&
                    (this.requestSceneColorMap(!1),
                    (this._sceneColorMapRequested = !1));
              }
              get renderSceneColorMap() {
                return this._renderSceneColorMap > 0;
              }
              set renderSceneDepthMap(s) {
                s && !this._sceneDepthMapRequested
                  ? (this.requestSceneDepthMap(!0),
                    (this._sceneDepthMapRequested = !0))
                  : this._sceneDepthMapRequested &&
                    (this.requestSceneDepthMap(!1),
                    (this._sceneDepthMapRequested = !1));
              }
              get renderSceneDepthMap() {
                return this._renderSceneDepthMap > 0;
              }
              set renderTarget(s) {
                (this._camera.renderTarget = s),
                  this.dirtyLayerCompositionCameras();
              }
              get renderTarget() {
                return this._camera.renderTarget;
              }
              set scissorRect(s) {
                this._camera.scissorRect = s;
              }
              get scissorRect() {
                return this._camera.scissorRect;
              }
              set sensitivity(s) {
                this._camera.sensitivity = s;
              }
              get sensitivity() {
                return this._camera.sensitivity;
              }
              set shutter(s) {
                this._camera.shutter = s;
              }
              get shutter() {
                return this._camera.shutter;
              }
              get viewMatrix() {
                return this._camera.viewMatrix;
              }
              _enableDepthLayer(s) {
                if (this.layers.find((n) => n === x.Pp)) {
                  const n = this.system.app.scene.layers.getLayerById(x.Pp);
                  s
                    ? n == null || n.incrementCounter()
                    : n == null || n.decrementCounter();
                } else if (s) return !1;
                return !0;
              }
              requestSceneColorMap(s) {
                (this._renderSceneColorMap += s ? 1 : -1),
                  this._enableDepthLayer(s);
              }
              requestSceneDepthMap(s) {
                (this._renderSceneDepthMap += s ? 1 : -1),
                  this._enableDepthLayer(s);
              }
              dirtyLayerCompositionCameras() {
                const s = this.system.app.scene.layers;
                s._dirtyCameras = !0;
              }
              screenToWorld(s, l, n, o) {
                const i = this.system.app.graphicsDevice,
                  e = i.clientRect.width,
                  t = i.clientRect.height;
                return this._camera.screenToWorld(s, l, n, e, t, o);
              }
              worldToScreen(s, l) {
                const n = this.system.app.graphicsDevice,
                  o = n.clientRect.width,
                  i = n.clientRect.height;
                return this._camera.worldToScreen(s, o, i, l);
              }
              onAppPrerender() {
                (this._camera._viewMatDirty = !0),
                  (this._camera._viewProjMatDirty = !0);
              }
              addCameraToLayers() {
                const s = this.layers;
                for (let l = 0; l < s.length; l++) {
                  const n = this.system.app.scene.layers.getLayerById(s[l]);
                  n && n.addCamera(this);
                }
              }
              removeCameraFromLayers() {
                const s = this.layers;
                for (let l = 0; l < s.length; l++) {
                  const n = this.system.app.scene.layers.getLayerById(s[l]);
                  n && n.removeCamera(this);
                }
              }
              onLayersChanged(s, l) {
                this.addCameraToLayers(),
                  s.off("add", this.onLayerAdded, this),
                  s.off("remove", this.onLayerRemoved, this),
                  l.on("add", this.onLayerAdded, this),
                  l.on("remove", this.onLayerRemoved, this);
              }
              onLayerAdded(s) {
                this.layers.indexOf(s.id) < 0 || s.addCamera(this);
              }
              onLayerRemoved(s) {
                this.layers.indexOf(s.id) < 0 || s.removeCamera(this);
              }
              onEnable() {
                const s = this.system,
                  l = s.app.scene,
                  n = l.layers;
                s.addCamera(this),
                  l.on("set:layers", this.onLayersChanged, this),
                  n &&
                    (n.on("add", this.onLayerAdded, this),
                    n.on("remove", this.onLayerRemoved, this)),
                  this.enabled &&
                    this.entity.enabled &&
                    this.addCameraToLayers(),
                  this.postEffects.enable();
              }
              onDisable() {
                const s = this.system,
                  l = s.app.scene,
                  n = l.layers;
                this.postEffects.disable(),
                  this.removeCameraFromLayers(),
                  l.off("set:layers", this.onLayersChanged, this),
                  n &&
                    (n.off("add", this.onLayerAdded, this),
                    n.off("remove", this.onLayerRemoved, this)),
                  s.removeCamera(this);
              }
              onRemove() {
                this.onDisable(), this.off();
              }
              calculateAspectRatio(s) {
                const l = this.system.app.graphicsDevice,
                  n = s ? s.width : l.width,
                  o = s ? s.height : l.height;
                return (n * this.rect.z) / (o * this.rect.w);
              }
              frameUpdate(s) {
                this.aspectRatioMode === x.HJ &&
                  (this.aspectRatio = this.calculateAspectRatio(s));
              }
              startXr(s, l, n) {
                this.system.app.xr.start(this, s, l, n);
              }
              endXr(s) {
                if (!this._camera.xr) {
                  s && s(new Error("Camera is not in XR"));
                  return;
                }
                this._camera.xr.end(s);
              }
              copy(s) {
                (this.aperture = s.aperture),
                  (this.aspectRatio = s.aspectRatio),
                  (this.aspectRatioMode = s.aspectRatioMode),
                  (this.calculateProjection = s.calculateProjection),
                  (this.calculateTransform = s.calculateTransform),
                  (this.clearColor = s.clearColor),
                  (this.clearColorBuffer = s.clearColorBuffer),
                  (this.clearDepthBuffer = s.clearDepthBuffer),
                  (this.clearStencilBuffer = s.clearStencilBuffer),
                  (this.cullFaces = s.cullFaces),
                  (this.disablePostEffectsLayer = s.disablePostEffectsLayer),
                  (this.farClip = s.farClip),
                  (this.flipFaces = s.flipFaces),
                  (this.fov = s.fov),
                  (this.frustumCulling = s.frustumCulling),
                  (this.horizontalFov = s.horizontalFov),
                  (this.layers = s.layers),
                  (this.nearClip = s.nearClip),
                  (this.orthoHeight = s.orthoHeight),
                  (this.priority = s.priority),
                  (this.projection = s.projection),
                  (this.rect = s.rect),
                  (this.renderTarget = s.renderTarget),
                  (this.scissorRect = s.scissorRect),
                  (this.sensitivity = s.sensitivity),
                  (this.shutter = s.shutter);
              }
            }
          },
          3121: (Se, W, a) => {
            "use strict";
            a.d(W, { G: () => h });
            var x = a(7921),
              T = a(3412),
              g = a(8869),
              c = a(3114);
            class d {
              constructor(s, l) {
                (this.effect = s),
                  (this.inputTarget = l),
                  (this.outputTarget = null),
                  (this.name = s.constructor.name);
              }
            }
            class h {
              constructor(s, l) {
                (this.app = s),
                  (this.camera = l),
                  (this.destinationRenderTarget = null),
                  (this.effects = []),
                  (this.enabled = !1),
                  (this.depthTarget = null),
                  l.on("set:rect", this.onCameraRectChanged, this);
              }
              _allocateColorBuffer(s, l) {
                var n, o, i, e;
                const t = this.camera.rect,
                  r = Math.floor(
                    t.z *
                      ((n =
                        (o = this.camera.renderTarget) == null
                          ? void 0
                          : o.width) != null
                        ? n
                        : this.app.graphicsDevice.width)
                  ),
                  u = Math.floor(
                    t.w *
                      ((i =
                        (e = this.camera.renderTarget) == null
                          ? void 0
                          : e.height) != null
                        ? i
                        : this.app.graphicsDevice.height)
                  );
                return new g.x(this.app.graphicsDevice, {
                  name: l,
                  format: s,
                  width: r,
                  height: u,
                  mipmaps: !1,
                  minFilter: x.yib,
                  magFilter: x.yib,
                  addressU: x.uFb,
                  addressV: x.uFb,
                });
              }
              _createOffscreenTarget(s, l) {
                const n = this.app.graphicsDevice,
                  o = (l && n.getHdrFormat(!1, !0, !1, !1)) || x.jKI,
                  i =
                    this.camera.entity.name +
                    "-posteffect-" +
                    this.effects.length,
                  e = this._allocateColorBuffer(o, i);
                return new T.A({
                  colorBuffer: e,
                  depth: s,
                  stencil: s && this.app.graphicsDevice.supportsStencil,
                  samples: s ? n.samples : 1,
                });
              }
              _resizeOffscreenTarget(s) {
                const l = s.colorBuffer.format,
                  n = s.colorBuffer.name;
                s.destroyFrameBuffers(),
                  s.destroyTextureBuffers(),
                  (s._colorBuffer = this._allocateColorBuffer(l, n)),
                  (s._colorBuffers = [s._colorBuffer]);
              }
              _destroyOffscreenTarget(s) {
                s.destroyTextureBuffers(), s.destroy();
              }
              addEffect(s) {
                const l = this.effects,
                  n = l.length === 0,
                  o = this._createOffscreenTarget(n, s.hdr),
                  i = new d(s, o);
                l.push(i),
                  (this._sourceTarget = i.inputTarget),
                  l.length > 1 &&
                    (l[l.length - 2].outputTarget = i.inputTarget),
                  (this._newPostEffect = s),
                  s.needsDepthBuffer && this._requestDepthMap(),
                  this.enable(),
                  (this._newPostEffect = void 0);
              }
              removeEffect(s) {
                let l = -1;
                for (let n = 0, o = this.effects.length; n < o; n++)
                  if (this.effects[n].effect === s) {
                    l = n;
                    break;
                  }
                l >= 0 &&
                  (l > 0
                    ? (this.effects[l - 1].outputTarget =
                        l + 1 < this.effects.length
                          ? this.effects[l + 1].inputTarget
                          : null)
                    : this.effects.length > 1 &&
                      (this.effects[1].inputTarget._depth ||
                        (this._destroyOffscreenTarget(
                          this.effects[1].inputTarget
                        ),
                        (this.effects[1].inputTarget =
                          this._createOffscreenTarget(!0, this.effects[1].hdr)),
                        (this._sourceTarget = this.effects[1].inputTarget)),
                      (this.camera.renderTarget = this.effects[1].inputTarget)),
                  this._destroyOffscreenTarget(this.effects[l].inputTarget),
                  this.effects.splice(l, 1)),
                  this.enabled && s.needsDepthBuffer && this._releaseDepthMap(),
                  this.effects.length === 0 && this.disable();
              }
              _requestDepthMaps() {
                for (let s = 0, l = this.effects.length; s < l; s++) {
                  const n = this.effects[s].effect;
                  this._newPostEffect !== n &&
                    n.needsDepthBuffer &&
                    this._requestDepthMap();
                }
              }
              _releaseDepthMaps() {
                for (let s = 0, l = this.effects.length; s < l; s++)
                  this.effects[s].effect.needsDepthBuffer &&
                    this._releaseDepthMap();
              }
              _requestDepthMap() {
                const s = this.app.scene.layers.getLayerById(c.Pp);
                s &&
                  (s.incrementCounter(), this.camera.requestSceneDepthMap(!0));
              }
              _releaseDepthMap() {
                const s = this.app.scene.layers.getLayerById(c.Pp);
                s &&
                  (s.decrementCounter(), this.camera.requestSceneDepthMap(!1));
              }
              destroy() {
                for (let s = 0, l = this.effects.length; s < l; s++)
                  this.effects[s].inputTarget.destroy();
                (this.effects.length = 0), this.disable();
              }
              enable() {
                !this.enabled &&
                  this.effects.length &&
                  ((this.enabled = !0),
                  this._requestDepthMaps(),
                  this.app.graphicsDevice.on(
                    "resizecanvas",
                    this._onCanvasResized,
                    this
                  ),
                  (this.destinationRenderTarget = this.camera.renderTarget),
                  (this.camera.renderTarget = this.effects[0].inputTarget),
                  (this.camera.onPostprocessing = () => {
                    if (this.enabled) {
                      let s = null;
                      const l = this.effects.length;
                      if (l)
                        for (let n = 0; n < l; n++) {
                          const o = this.effects[n];
                          let i = o.outputTarget;
                          n === l - 1 &&
                            ((s = this.camera.rect),
                            this.destinationRenderTarget &&
                              (i = this.destinationRenderTarget)),
                            o.effect.render(o.inputTarget, i, s);
                        }
                    }
                  }));
              }
              disable() {
                this.enabled &&
                  ((this.enabled = !1),
                  this.app.graphicsDevice.off(
                    "resizecanvas",
                    this._onCanvasResized,
                    this
                  ),
                  this._releaseDepthMaps(),
                  this._destroyOffscreenTarget(this._sourceTarget),
                  (this.camera.renderTarget = null),
                  (this.camera.onPostprocessing = null));
              }
              _onCanvasResized(s, l) {
                const n = this.camera.rect,
                  o = this.app.graphicsDevice;
                (this.camera.camera.aspectRatio =
                  (o.width * n.z) / (o.height * n.w)),
                  this.resizeRenderTargets();
              }
              resizeRenderTargets() {
                const s = this.camera.rect,
                  l = Math.floor(s.z * this.app.graphicsDevice.width),
                  n = Math.floor(s.w * this.app.graphicsDevice.height),
                  o = this.effects;
                for (let i = 0, e = o.length; i < e; i++) {
                  const t = o[i];
                  (t.inputTarget.width !== l || t.inputTarget.height !== n) &&
                    this._resizeOffscreenTarget(t.inputTarget);
                }
              }
              onCameraRectChanged(s, l, n) {
                this.enabled && this.resizeRenderTargets();
              }
            }
          },
          5865: (Se, W, a) => {
            "use strict";
            a.d(W, { r: () => l });
            var x = a(324),
              T = a(1367),
              g = a(6630),
              c = a(8620),
              d = a(6813),
              h = a(4378);
            class f {
              constructor() {
                this.enabled = !0;
              }
            }
            const s = ["enabled"];
            class l extends d.Q {
              constructor(o) {
                super(o),
                  (this.cameras = []),
                  (this.id = "camera"),
                  (this.ComponentType = h.M),
                  (this.DataType = f),
                  (this.schema = s),
                  this.on("beforeremove", this.onBeforeRemove, this),
                  this.app.on("prerender", this.onAppPrerender, this),
                  this.app.systems.on("update", this.onUpdate, this);
              }
              initializeComponentData(o, i, e) {
                e = [
                  "aspectRatio",
                  "aspectRatioMode",
                  "calculateProjection",
                  "calculateTransform",
                  "clearColor",
                  "clearColorBuffer",
                  "clearDepthBuffer",
                  "clearStencilBuffer",
                  "renderSceneColorMap",
                  "renderSceneDepthMap",
                  "cullFaces",
                  "farClip",
                  "flipFaces",
                  "fov",
                  "frustumCulling",
                  "horizontalFov",
                  "layers",
                  "renderTarget",
                  "nearClip",
                  "orthoHeight",
                  "projection",
                  "priority",
                  "rect",
                  "scissorRect",
                  "aperture",
                  "shutter",
                  "sensitivity",
                ];
                for (let t = 0; t < e.length; t++) {
                  const r = e[t];
                  if (i.hasOwnProperty(r)) {
                    const u = i[r];
                    switch (r) {
                      case "rect":
                      case "scissorRect":
                        Array.isArray(u)
                          ? (o[r] = new g.T(u[0], u[1], u[2], u[3]))
                          : (o[r] = u);
                        break;
                      case "clearColor":
                        Array.isArray(u)
                          ? (o[r] = new T.I(u[0], u[1], u[2], u[3]))
                          : (o[r] = u);
                        break;
                      default:
                        o[r] = u;
                        break;
                    }
                  }
                }
                super.initializeComponentData(o, i, ["enabled"]);
              }
              cloneComponent(o, i) {
                const e = o.camera;
                return this.addComponent(i, {
                  aspectRatio: e.aspectRatio,
                  aspectRatioMode: e.aspectRatioMode,
                  calculateProjection: e.calculateProjection,
                  calculateTransform: e.calculateTransform,
                  clearColor: e.clearColor,
                  clearColorBuffer: e.clearColorBuffer,
                  clearDepthBuffer: e.clearDepthBuffer,
                  clearStencilBuffer: e.clearStencilBuffer,
                  renderSceneDepthMap: e.renderSceneDepthMap,
                  renderSceneColorMap: e.renderSceneColorMap,
                  cullFaces: e.cullFaces,
                  enabled: e.enabled,
                  farClip: e.farClip,
                  flipFaces: e.flipFaces,
                  fov: e.fov,
                  frustumCulling: e.frustumCulling,
                  horizontalFov: e.horizontalFov,
                  layers: e.layers,
                  renderTarget: e.renderTarget,
                  nearClip: e.nearClip,
                  orthoHeight: e.orthoHeight,
                  projection: e.projection,
                  priority: e.priority,
                  rect: e.rect,
                  scissorRect: e.scissorRect,
                  aperture: e.aperture,
                  sensitivity: e.sensitivity,
                  shutter: e.shutter,
                });
              }
              onBeforeRemove(o, i) {
                this.removeCamera(i);
              }
              onUpdate(o) {}
              onAppPrerender() {
                for (let o = 0, i = this.cameras.length; o < i; o++)
                  this.cameras[o].onAppPrerender();
              }
              addCamera(o) {
                this.cameras.push(o), (0, x._)(this.cameras);
              }
              removeCamera(o) {
                const i = this.cameras.indexOf(o);
                i >= 0 && (this.cameras.splice(i, 1), (0, x._)(this.cameras));
              }
              destroy() {
                super.destroy(),
                  this.app.systems.off("update", this.onUpdate, this);
              }
            }
            c.w._buildAccessors(h.M.prototype, s);
          },
          4185: (Se, W, a) => {
            "use strict";
            a.d(W, { k: () => f });
            var x = a(6847),
              T = a(6556),
              g = a(6204),
              c = a(8620);
            const d = new T.A(),
              h = new x.D();
            class f extends c.w {
              constructor(l, n) {
                super(l, n),
                  (this._compoundParent = null),
                  (this._hasOffset = !1),
                  this.entity.on("insert", this._onInsert, this),
                  this.on("set_type", this.onSetType, this),
                  this.on("set_halfExtents", this.onSetHalfExtents, this),
                  this.on("set_linearOffset", this.onSetOffset, this),
                  this.on("set_angularOffset", this.onSetOffset, this),
                  this.on("set_radius", this.onSetRadius, this),
                  this.on("set_height", this.onSetHeight, this),
                  this.on("set_axis", this.onSetAxis, this),
                  this.on("set_asset", this.onSetAsset, this),
                  this.on("set_renderAsset", this.onSetRenderAsset, this),
                  this.on("set_model", this.onSetModel, this),
                  this.on("set_render", this.onSetRender, this);
              }
              onSetType(l, n, o) {
                n !== o && this.system.changeType(this, n, o);
              }
              onSetHalfExtents(l, n, o) {
                const i = this.data.type;
                this.data.initialized &&
                  i === "box" &&
                  this.system.recreatePhysicalShapes(this);
              }
              onSetOffset(l, n, o) {
                (this._hasOffset =
                  !this.data.linearOffset.equals(T.A.ZERO) ||
                  !this.data.angularOffset.equals(x.D.IDENTITY)),
                  this.data.initialized &&
                    this.system.recreatePhysicalShapes(this);
              }
              onSetRadius(l, n, o) {
                const i = this.data.type;
                this.data.initialized &&
                  (i === "sphere" ||
                    i === "capsule" ||
                    i === "cylinder" ||
                    i === "cone") &&
                  this.system.recreatePhysicalShapes(this);
              }
              onSetHeight(l, n, o) {
                const i = this.data.type;
                this.data.initialized &&
                  (i === "capsule" || i === "cylinder" || i === "cone") &&
                  this.system.recreatePhysicalShapes(this);
              }
              onSetAxis(l, n, o) {
                const i = this.data.type;
                this.data.initialized &&
                  (i === "capsule" || i === "cylinder" || i === "cone") &&
                  this.system.recreatePhysicalShapes(this);
              }
              onSetAsset(l, n, o) {
                const i = this.system.app.assets;
                if (n) {
                  const e = i.get(n);
                  e && e.off("remove", this.onAssetRemoved, this);
                }
                if (o) {
                  o instanceof g.x && (this.data.asset = o.id);
                  const e = i.get(this.data.asset);
                  e &&
                    (e.off("remove", this.onAssetRemoved, this),
                    e.on("remove", this.onAssetRemoved, this));
                }
                this.data.initialized &&
                  this.data.type === "mesh" &&
                  (o || (this.data.model = null),
                  this.system.recreatePhysicalShapes(this));
              }
              onSetRenderAsset(l, n, o) {
                const i = this.system.app.assets;
                if (n) {
                  const e = i.get(n);
                  e && e.off("remove", this.onRenderAssetRemoved, this);
                }
                if (o) {
                  o instanceof g.x && (this.data.renderAsset = o.id);
                  const e = i.get(this.data.renderAsset);
                  e &&
                    (e.off("remove", this.onRenderAssetRemoved, this),
                    e.on("remove", this.onRenderAssetRemoved, this));
                }
                this.data.initialized &&
                  this.data.type === "mesh" &&
                  (o || (this.data.render = null),
                  this.system.recreatePhysicalShapes(this));
              }
              onSetModel(l, n, o) {
                this.data.initialized &&
                  this.data.type === "mesh" &&
                  this.system.implementations.mesh.doRecreatePhysicalShape(
                    this
                  );
              }
              onSetRender(l, n, o) {
                this.onSetModel(l, n, o);
              }
              onAssetRemoved(l) {
                l.off("remove", this.onAssetRemoved, this),
                  this.data.asset === l.id && (this.asset = null);
              }
              onRenderAssetRemoved(l) {
                l.off("remove", this.onRenderAssetRemoved, this),
                  this.data.renderAsset === l.id && (this.renderAsset = null);
              }
              _getCompoundChildShapeIndex(l) {
                const n = this.data.shape,
                  o = n.getNumChildShapes();
                for (let i = 0; i < o; i++)
                  if (n.getChildShape(i).ptr === l.ptr) return i;
                return null;
              }
              _onInsert(l) {
                if (typeof Ammo != "undefined") {
                  if (this._compoundParent)
                    this.system.recreatePhysicalShapes(this);
                  else if (!this.entity.rigidbody) {
                    let n = this.entity.parent;
                    for (; n; ) {
                      if (n.collision && n.collision.type === "compound") {
                        n.collision.shape.getNumChildShapes() === 0
                          ? this.system.recreatePhysicalShapes(n.collision)
                          : this.system.recreatePhysicalShapes(this);
                        break;
                      }
                      n = n.parent;
                    }
                  }
                }
              }
              _updateCompound() {
                const l = this.entity;
                if (l._dirtyWorld) {
                  let n = l._dirtyLocal,
                    o = l;
                  for (
                    ;
                    o &&
                    !n &&
                    !(o.collision && o.collision === this._compoundParent);

                  )
                    o._dirtyLocal && (n = !0), (o = o.parent);
                  if (n) {
                    l.forEach(
                      this.system.implementations.compound
                        ._updateEachDescendantTransform,
                      l
                    );
                    const i = this._compoundParent.entity.rigidbody;
                    i && i.activate();
                  }
                }
              }
              getShapePosition() {
                const l = this.entity.getPosition();
                if (this._hasOffset) {
                  const n = this.entity.getRotation(),
                    o = this.data.linearOffset;
                  return h.copy(n).transformVector(o, d), d.add(l);
                }
                return l;
              }
              getShapeRotation() {
                const l = this.entity.getRotation();
                return this._hasOffset
                  ? h.copy(l).mul(this.data.angularOffset)
                  : l;
              }
              onEnable() {
                if (
                  this.data.type === "mesh" &&
                  (this.data.asset || this.data.renderAsset) &&
                  this.data.initialized
                ) {
                  const l = this.system.app.assets.get(
                    this.data.asset || this.data.renderAsset
                  );
                  if (l && (!l.resource || !this.data.shape)) {
                    this.system.recreatePhysicalShapes(this);
                    return;
                  }
                }
                if (this.entity.rigidbody)
                  this.entity.rigidbody.enabled &&
                    this.entity.rigidbody.enableSimulation();
                else if (this._compoundParent && this !== this._compoundParent)
                  if (this._compoundParent.shape.getNumChildShapes() === 0)
                    this.system.recreatePhysicalShapes(this._compoundParent);
                  else {
                    const l = this.system._getNodeTransform(
                      this.entity,
                      this._compoundParent.entity
                    );
                    this._compoundParent.shape.addChildShape(
                      l,
                      this.data.shape
                    ),
                      Ammo.destroy(l),
                      this._compoundParent.entity.rigidbody &&
                        this._compoundParent.entity.rigidbody.activate();
                  }
                else this.entity.trigger && this.entity.trigger.enable();
              }
              onDisable() {
                this.entity.rigidbody
                  ? this.entity.rigidbody.disableSimulation()
                  : this._compoundParent && this !== this._compoundParent
                  ? this._compoundParent.entity._destroying ||
                    (this.system._removeCompoundChild(
                      this._compoundParent,
                      this.data.shape
                    ),
                    this._compoundParent.entity.rigidbody &&
                      this._compoundParent.entity.rigidbody.activate())
                  : this.entity.trigger && this.entity.trigger.disable();
              }
              onBeforeRemove() {
                this.asset && (this.asset = null),
                  this.renderAsset && (this.renderAsset = null),
                  this.entity.off("insert", this._onInsert, this),
                  this.off();
              }
            }
          },
          2280: (Se, W, a) => {
            "use strict";
            a.d(W, { _: () => K });
            var x = a(9758),
              T = a(6847),
              g = a(6556),
              c = a(7921),
              d = a(7915),
              h = a(9915),
              f = a(8620),
              s = a(6813),
              l = a(4185);
            class n {
              constructor() {
                (this.enabled = !0),
                  (this.type = "box"),
                  (this.halfExtents = new g.A(0.5, 0.5, 0.5)),
                  (this.linearOffset = new g.A()),
                  (this.angularOffset = new T.D()),
                  (this.radius = 0.5),
                  (this.axis = 1),
                  (this.height = 2),
                  (this.asset = null),
                  (this.renderAsset = null),
                  (this.shape = null),
                  (this.model = null),
                  (this.render = null),
                  (this.initialized = !1);
              }
            }
            var o = a(2628);
            let i, e, t;
            class r {
              constructor(X, $, ne) {
                (this.entity = $.entity),
                  (this.component = $),
                  (this.app = X),
                  typeof Ammo != "undefined" &&
                    !i &&
                    ((i = new Ammo.btVector3()),
                    (e = new Ammo.btQuaternion()),
                    (t = new Ammo.btTransform())),
                  this.initialize(ne);
              }
              initialize(X) {
                const $ = this.entity,
                  ne = X.shape;
                if (ne && typeof Ammo != "undefined") {
                  $.trigger && $.trigger.destroy();
                  const Y = 1,
                    Z = this.component;
                  if (Z) {
                    const pe = Z.getShapePosition(),
                      O = Z.getShapeRotation();
                    i.setValue(pe.x, pe.y, pe.z),
                      e.setValue(O.x, O.y, O.z, O.w);
                  } else {
                    const pe = $.getPosition(),
                      O = $.getRotation();
                    i.setValue(pe.x, pe.y, pe.z),
                      e.setValue(O.x, O.y, O.z, O.w);
                  }
                  t.setOrigin(i), t.setRotation(e);
                  const ye = this.app.systems.rigidbody.createBody(Y, ne, t);
                  ye.setRestitution(0),
                    ye.setFriction(0),
                    ye.setDamping(0, 0),
                    i.setValue(0, 0, 0),
                    ye.setLinearFactor(i),
                    ye.setAngularFactor(i),
                    ye.setCollisionFlags(ye.getCollisionFlags() | o.ge),
                    (ye.entity = $),
                    (this.body = ye),
                    this.component.enabled && $.enabled && this.enable();
                }
              }
              destroy() {
                const X = this.body;
                X &&
                  (this.disable(), this.app.systems.rigidbody.destroyBody(X));
              }
              _getEntityTransform(X) {
                const $ = this.component;
                if ($) {
                  const ne = $.getShapePosition(),
                    Y = $.getShapeRotation();
                  i.setValue(ne.x, ne.y, ne.z), e.setValue(Y.x, Y.y, Y.z, Y.w);
                } else {
                  const ne = this.entity.getPosition(),
                    Y = this.entity.getRotation();
                  i.setValue(ne.x, ne.y, ne.z), e.setValue(Y.x, Y.y, Y.z, Y.w);
                }
                X.setOrigin(i), X.setRotation(e);
              }
              updateTransform() {
                this._getEntityTransform(t);
                const X = this.body;
                X.setWorldTransform(t), X.activate();
              }
              enable() {
                const X = this.body;
                if (!X) return;
                const $ = this.app.systems;
                $.rigidbody.addBody(X, o.Im, o.wn ^ o.Im),
                  $.rigidbody._triggers.push(this),
                  X.forceActivationState(o.sc),
                  this.updateTransform();
              }
              disable() {
                const X = this.body;
                if (!X) return;
                const $ = this.app.systems,
                  ne = $.rigidbody._triggers.indexOf(this);
                ne > -1 && $.rigidbody._triggers.splice(ne, 1),
                  $.rigidbody.removeBody(X),
                  X.forceActivationState(o.AE);
              }
            }
            const u = new x.y(),
              y = new g.A(),
              p = new g.A(),
              _ = new T.D(),
              m = new d.A(),
              E = [
                "enabled",
                "type",
                "halfExtents",
                "linearOffset",
                "angularOffset",
                "radius",
                "axis",
                "height",
                "asset",
                "renderAsset",
                "shape",
                "model",
                "render",
              ];
            class v {
              constructor(X) {
                this.system = X;
              }
              beforeInitialize(X, $) {
                ($.shape = null),
                  ($.model = new h.H()),
                  ($.model.graph = new d.A());
              }
              afterInitialize(X, $) {
                this.recreatePhysicalShapes(X), (X.data.initialized = !0);
              }
              reset(X, $) {
                this.beforeInitialize(X, $), this.afterInitialize(X, $);
              }
              recreatePhysicalShapes(X) {
                const $ = X.entity,
                  ne = X.data;
                if (typeof Ammo != "undefined") {
                  $.trigger && ($.trigger.destroy(), delete $.trigger),
                    ne.shape &&
                      (X._compoundParent &&
                        (this.system._removeCompoundChild(
                          X._compoundParent,
                          ne.shape
                        ),
                        X._compoundParent.entity.rigidbody &&
                          X._compoundParent.entity.rigidbody.activate()),
                      this.destroyShape(ne)),
                    (ne.shape = this.createPhysicalShape(X.entity, ne));
                  const Y = !X._compoundParent;
                  if (
                    ne.type === "compound" &&
                    (!X._compoundParent || X === X._compoundParent)
                  )
                    (X._compoundParent = X),
                      $.forEach(this._addEachDescendant, X);
                  else if (
                    ne.type !== "compound" &&
                    (X._compoundParent &&
                      X === X._compoundParent &&
                      $.forEach(
                        this.system.implementations.compound
                          ._updateEachDescendant,
                        X
                      ),
                    !X.rigidbody)
                  ) {
                    X._compoundParent = null;
                    let Z = $.parent;
                    for (; Z; ) {
                      if (Z.collision && Z.collision.type === "compound") {
                        X._compoundParent = Z.collision;
                        break;
                      }
                      Z = Z.parent;
                    }
                  }
                  X._compoundParent &&
                    X !== X._compoundParent &&
                    (Y && X._compoundParent.shape.getNumChildShapes() === 0
                      ? this.system.recreatePhysicalShapes(X._compoundParent)
                      : (this.system.updateCompoundChildTransform($),
                        X._compoundParent.entity.rigidbody &&
                          X._compoundParent.entity.rigidbody.activate())),
                    $.rigidbody
                      ? ($.rigidbody.disableSimulation(),
                        $.rigidbody.createBody(),
                        $.enabled &&
                          $.rigidbody.enabled &&
                          $.rigidbody.enableSimulation())
                      : X._compoundParent ||
                        ($.trigger
                          ? $.trigger.initialize(ne)
                          : ($.trigger = new r(this.system.app, X, ne)));
                }
              }
              createPhysicalShape(X, $) {}
              updateTransform(X, $, ne, Y) {
                X.entity.trigger && X.entity.trigger.updateTransform();
              }
              destroyShape(X) {
                X.shape && (Ammo.destroy(X.shape), (X.shape = null));
              }
              beforeRemove(X, $) {
                $.data.shape &&
                  ($._compoundParent &&
                    !$._compoundParent.entity._destroying &&
                    (this.system._removeCompoundChild(
                      $._compoundParent,
                      $.data.shape
                    ),
                    $._compoundParent.entity.rigidbody &&
                      $._compoundParent.entity.rigidbody.activate()),
                  ($._compoundParent = null),
                  this.destroyShape($.data));
              }
              remove(X, $) {
                X.rigidbody &&
                  X.rigidbody.body &&
                  X.rigidbody.disableSimulation(),
                  X.trigger && (X.trigger.destroy(), delete X.trigger);
              }
              clone(X, $) {
                const ne = this.system.store[X.getGuid()],
                  Y = {
                    enabled: ne.data.enabled,
                    type: ne.data.type,
                    halfExtents: [
                      ne.data.halfExtents.x,
                      ne.data.halfExtents.y,
                      ne.data.halfExtents.z,
                    ],
                    linearOffset: [
                      ne.data.linearOffset.x,
                      ne.data.linearOffset.y,
                      ne.data.linearOffset.z,
                    ],
                    angularOffset: [
                      ne.data.angularOffset.x,
                      ne.data.angularOffset.y,
                      ne.data.angularOffset.z,
                      ne.data.angularOffset.w,
                    ],
                    radius: ne.data.radius,
                    axis: ne.data.axis,
                    height: ne.data.height,
                    asset: ne.data.asset,
                    renderAsset: ne.data.renderAsset,
                    model: ne.data.model,
                    render: ne.data.render,
                  };
                return this.system.addComponent($, Y);
              }
            }
            class P extends v {
              createPhysicalShape(X, $) {
                if (typeof Ammo != "undefined") {
                  const ne = $.halfExtents,
                    Y = new Ammo.btVector3(
                      ne ? ne.x : 0.5,
                      ne ? ne.y : 0.5,
                      ne ? ne.z : 0.5
                    ),
                    Z = new Ammo.btBoxShape(Y);
                  return Ammo.destroy(Y), Z;
                }
              }
            }
            class I extends v {
              createPhysicalShape(X, $) {
                if (typeof Ammo != "undefined")
                  return new Ammo.btSphereShape($.radius);
              }
            }
            class A extends v {
              createPhysicalShape(X, $) {
                var ne, Y, Z;
                const ye = (ne = $.axis) != null ? ne : 1,
                  pe = (Y = $.radius) != null ? Y : 0.5,
                  O = Math.max(((Z = $.height) != null ? Z : 2) - 2 * pe, 0);
                let me = null;
                if (typeof Ammo != "undefined")
                  switch (ye) {
                    case 0:
                      me = new Ammo.btCapsuleShapeX(pe, O);
                      break;
                    case 1:
                      me = new Ammo.btCapsuleShape(pe, O);
                      break;
                    case 2:
                      me = new Ammo.btCapsuleShapeZ(pe, O);
                      break;
                  }
                return me;
              }
            }
            class B extends v {
              createPhysicalShape(X, $) {
                var ne, Y, Z;
                const ye = (ne = $.axis) != null ? ne : 1,
                  pe = (Y = $.radius) != null ? Y : 0.5,
                  O = (Z = $.height) != null ? Z : 1;
                let me = null,
                  N = null;
                if (typeof Ammo != "undefined")
                  switch (ye) {
                    case 0:
                      (me = new Ammo.btVector3(O * 0.5, pe, pe)),
                        (N = new Ammo.btCylinderShapeX(me));
                      break;
                    case 1:
                      (me = new Ammo.btVector3(pe, O * 0.5, pe)),
                        (N = new Ammo.btCylinderShape(me));
                      break;
                    case 2:
                      (me = new Ammo.btVector3(pe, pe, O * 0.5)),
                        (N = new Ammo.btCylinderShapeZ(me));
                      break;
                  }
                return me && Ammo.destroy(me), N;
              }
            }
            class C extends v {
              createPhysicalShape(X, $) {
                var ne, Y, Z;
                const ye = (ne = $.axis) != null ? ne : 1,
                  pe = (Y = $.radius) != null ? Y : 0.5,
                  O = (Z = $.height) != null ? Z : 1;
                let me = null;
                if (typeof Ammo != "undefined")
                  switch (ye) {
                    case 0:
                      me = new Ammo.btConeShapeX(pe, O);
                      break;
                    case 1:
                      me = new Ammo.btConeShape(pe, O);
                      break;
                    case 2:
                      me = new Ammo.btConeShapeZ(pe, O);
                      break;
                  }
                return me;
              }
            }
            class w extends v {
              beforeInitialize(X, $) {}
              createAmmoMesh(X, $, ne) {
                let Y;
                if (this.system._triMeshCache[X.id])
                  Y = this.system._triMeshCache[X.id];
                else {
                  const me = X.vertexBuffer,
                    N = me.getFormat();
                  let V, L;
                  for (let F = 0; F < N.elements.length; F++) {
                    const z = N.elements[F];
                    if (z.name === c.Q5v) {
                      (L = new Float32Array(me.lock(), z.offset)),
                        (V = z.stride / 4);
                      break;
                    }
                  }
                  const J = [];
                  X.getIndices(J);
                  const ae = X.primitive[0].count / 3,
                    R = new Ammo.btVector3(),
                    j = new Ammo.btVector3(),
                    se = new Ammo.btVector3();
                  let ce, ie, b;
                  const M = X.primitive[0].base;
                  (Y = new Ammo.btTriangleMesh()),
                    (this.system._triMeshCache[X.id] = Y);
                  for (let F = 0; F < ae; F++)
                    (ce = J[M + F * 3] * V),
                      (ie = J[M + F * 3 + 1] * V),
                      (b = J[M + F * 3 + 2] * V),
                      R.setValue(L[ce], L[ce + 1], L[ce + 2]),
                      j.setValue(L[ie], L[ie + 1], L[ie + 2]),
                      se.setValue(L[b], L[b + 1], L[b + 2]),
                      Y.addTriangle(R, j, se, !0);
                  Ammo.destroy(R), Ammo.destroy(j), Ammo.destroy(se);
                }
                const Z = !0,
                  ye = new Ammo.btBvhTriangleMeshShape(Y, Z),
                  pe = this.system._getNodeScaling($);
                ye.setLocalScaling(pe), Ammo.destroy(pe);
                const O = this.system._getNodeTransform($);
                ne.addChildShape(O, ye), Ammo.destroy(O);
              }
              createPhysicalShape(X, $) {
                if (typeof Ammo != "undefined" && ($.model || $.render)) {
                  const ne = new Ammo.btCompoundShape();
                  if ($.model) {
                    const pe = $.model.meshInstances;
                    for (let O = 0; O < pe.length; O++)
                      this.createAmmoMesh(pe[O].mesh, pe[O].node, ne);
                  } else if ($.render) {
                    const pe = $.render.meshes;
                    for (let O = 0; O < pe.length; O++)
                      this.createAmmoMesh(pe[O], m, ne);
                  }
                  const Z = X.getWorldTransform().getScale(),
                    ye = new Ammo.btVector3(Z.x, Z.y, Z.z);
                  return ne.setLocalScaling(ye), Ammo.destroy(ye), ne;
                }
              }
              recreatePhysicalShapes(X) {
                const $ = X.data;
                if (
                  ($.renderAsset || $.asset) &&
                  X.enabled &&
                  X.entity.enabled
                ) {
                  this.loadAsset(
                    X,
                    $.renderAsset || $.asset,
                    $.renderAsset ? "render" : "model"
                  );
                  return;
                }
                this.doRecreatePhysicalShape(X);
              }
              loadAsset(X, $, ne) {
                const Y = X.data,
                  Z = this.system.app.assets,
                  ye = Z.get($);
                ye
                  ? (ye.ready((pe) => {
                      (Y[ne] = pe.resource), this.doRecreatePhysicalShape(X);
                    }),
                    Z.load(ye))
                  : Z.once("add:" + $, (pe) => {
                      pe.ready((O) => {
                        (Y[ne] = O.resource), this.doRecreatePhysicalShape(X);
                      }),
                        Z.load(pe);
                    });
              }
              doRecreatePhysicalShape(X) {
                const $ = X.entity,
                  ne = X.data;
                ne.model || ne.render
                  ? (this.destroyShape(ne),
                    (ne.shape = this.createPhysicalShape($, ne)),
                    $.rigidbody
                      ? ($.rigidbody.disableSimulation(),
                        $.rigidbody.createBody(),
                        $.enabled &&
                          $.rigidbody.enabled &&
                          $.rigidbody.enableSimulation())
                      : $.trigger
                      ? $.trigger.initialize(ne)
                      : ($.trigger = new r(this.system.app, X, ne)))
                  : (this.beforeRemove($, X), this.remove($, ne));
              }
              updateTransform(X, $, ne, Y) {
                if (X.shape) {
                  const ye = X.entity.getWorldTransform().getScale(),
                    pe = X.shape.getLocalScaling();
                  (ye.x !== pe.x() || ye.y !== pe.y() || ye.z !== pe.z()) &&
                    this.doRecreatePhysicalShape(X);
                }
                super.updateTransform(X, $, ne, Y);
              }
              destroyShape(X) {
                if (!X.shape) return;
                const $ = X.shape.getNumChildShapes();
                for (let ne = 0; ne < $; ne++) {
                  const Y = X.shape.getChildShape(ne);
                  Ammo.destroy(Y);
                }
                Ammo.destroy(X.shape), (X.shape = null);
              }
            }
            class k extends v {
              createPhysicalShape(X, $) {
                if (typeof Ammo != "undefined")
                  return new Ammo.btCompoundShape();
              }
              _addEachDescendant(X) {
                !X.collision ||
                  X.rigidbody ||
                  ((X.collision._compoundParent = this),
                  X !== this.entity &&
                    X.collision.system.recreatePhysicalShapes(X.collision));
              }
              _updateEachDescendant(X) {
                X.collision &&
                  X.collision._compoundParent === this &&
                  ((X.collision._compoundParent = null),
                  X !== this.entity &&
                    !X.rigidbody &&
                    X.collision.system.recreatePhysicalShapes(X.collision));
              }
              _updateEachDescendantTransform(X) {
                !X.collision ||
                  X.collision._compoundParent !==
                    this.collision._compoundParent ||
                  this.collision.system.updateCompoundChildTransform(X);
              }
            }
            class K extends s.Q {
              constructor(X) {
                super(X),
                  (this.id = "collision"),
                  (this.ComponentType = l.k),
                  (this.DataType = n),
                  (this.schema = E),
                  (this.implementations = {}),
                  (this._triMeshCache = {}),
                  this.on("beforeremove", this.onBeforeRemove, this),
                  this.on("remove", this.onRemove, this);
              }
              initializeComponentData(X, $, ne) {
                ne = [
                  "type",
                  "halfExtents",
                  "radius",
                  "axis",
                  "height",
                  "shape",
                  "model",
                  "asset",
                  "render",
                  "renderAsset",
                  "enabled",
                  "linearOffset",
                  "angularOffset",
                ];
                const Y = {};
                for (let pe = 0, O = ne.length; pe < O; pe++) {
                  const me = ne[pe];
                  Y[me] = $[me];
                }
                let Z;
                if (
                  ($.hasOwnProperty("asset")
                    ? ((Z = ne.indexOf("model")),
                      Z !== -1 && ne.splice(Z, 1),
                      (Z = ne.indexOf("render")),
                      Z !== -1 && ne.splice(Z, 1))
                    : $.hasOwnProperty("model") &&
                      ((Z = ne.indexOf("asset")), Z !== -1 && ne.splice(Z, 1)),
                  Y.type || (Y.type = X.data.type),
                  (X.data.type = Y.type),
                  Array.isArray(Y.halfExtents) &&
                    (Y.halfExtents = new g.A(Y.halfExtents)),
                  Array.isArray(Y.linearOffset) &&
                    (Y.linearOffset = new g.A(Y.linearOffset)),
                  Array.isArray(Y.angularOffset))
                ) {
                  const pe = Y.angularOffset;
                  pe.length === 3
                    ? (Y.angularOffset = new T.D().setFromEulerAngles(
                        pe[0],
                        pe[1],
                        pe[2]
                      ))
                    : (Y.angularOffset = new T.D(Y.angularOffset));
                }
                const ye = this._createImplementation(Y.type);
                ye.beforeInitialize(X, Y),
                  super.initializeComponentData(X, Y, ne),
                  ye.afterInitialize(X, Y);
              }
              _createImplementation(X) {
                if (this.implementations[X] === void 0) {
                  let $;
                  switch (X) {
                    case "box":
                      $ = new P(this);
                      break;
                    case "sphere":
                      $ = new I(this);
                      break;
                    case "capsule":
                      $ = new A(this);
                      break;
                    case "cylinder":
                      $ = new B(this);
                      break;
                    case "cone":
                      $ = new C(this);
                      break;
                    case "mesh":
                      $ = new w(this);
                      break;
                    case "compound":
                      $ = new k(this);
                      break;
                  }
                  this.implementations[X] = $;
                }
                return this.implementations[X];
              }
              _getImplementation(X) {
                return this.implementations[X.collision.data.type];
              }
              cloneComponent(X, $) {
                return this._getImplementation(X).clone(X, $);
              }
              onBeforeRemove(X, $) {
                this.implementations[$.data.type].beforeRemove(X, $),
                  $.onBeforeRemove();
              }
              onRemove(X, $) {
                this.implementations[$.type].remove(X, $);
              }
              updateCompoundChildTransform(X) {
                if (
                  (this._removeCompoundChild(
                    X.collision._compoundParent,
                    X.collision.data.shape
                  ),
                  X.enabled && X.collision.enabled)
                ) {
                  const $ = this._getNodeTransform(
                    X,
                    X.collision._compoundParent.entity
                  );
                  X.collision._compoundParent.shape.addChildShape(
                    $,
                    X.collision.data.shape
                  ),
                    Ammo.destroy($);
                }
              }
              _removeCompoundChild(X, $) {
                if (X.shape.removeChildShape) X.shape.removeChildShape($);
                else {
                  const ne = X._getCompoundChildShapeIndex($);
                  ne !== null && X.shape.removeChildShapeByIndex(ne);
                }
              }
              onTransformChanged(X, $, ne, Y) {
                this.implementations[X.data.type].updateTransform(X, $, ne, Y);
              }
              changeType(X, $, ne) {
                this.implementations[$].beforeRemove(X.entity, X),
                  this.implementations[$].remove(X.entity, X.data),
                  this._createImplementation(ne).reset(X, X.data);
              }
              recreatePhysicalShapes(X) {
                this.implementations[X.data.type].recreatePhysicalShapes(X);
              }
              _calculateNodeRelativeTransform(X, $) {
                if (X === $) {
                  const ne = X.getWorldTransform().getScale();
                  u.setScale(ne.x, ne.y, ne.z);
                } else
                  this._calculateNodeRelativeTransform(X.parent, $),
                    u.mul(X.getLocalTransform());
              }
              _getNodeScaling(X) {
                const ne = X.getWorldTransform().getScale();
                return new Ammo.btVector3(ne.x, ne.y, ne.z);
              }
              _getNodeTransform(X, $) {
                let ne, Y;
                $
                  ? (this._calculateNodeRelativeTransform(X, $),
                    (ne = y),
                    (Y = _),
                    u.getTranslation(ne),
                    Y.setFromMat4(u))
                  : ((ne = X.getPosition()), (Y = X.getRotation()));
                const Z = new Ammo.btQuaternion(),
                  ye = new Ammo.btTransform();
                ye.setIdentity();
                const pe = ye.getOrigin(),
                  O = X.collision;
                if (O && O._hasOffset) {
                  const me = O.data.linearOffset,
                    N = O.data.angularOffset,
                    V = p;
                  _.copy(Y).transformVector(me, V),
                    V.add(ne),
                    _.copy(Y).mul(N),
                    pe.setValue(V.x, V.y, V.z),
                    Z.setValue(_.x, _.y, _.z, _.w);
                } else
                  pe.setValue(ne.x, ne.y, ne.z), Z.setValue(Y.x, Y.y, Y.z, Y.w);
                return ye.setRotation(Z), Ammo.destroy(Z), Ammo.destroy(pe), ye;
              }
              destroy() {
                for (const X in this._triMeshCache)
                  Ammo.destroy(this._triMeshCache[X]);
                (this._triMeshCache = null), super.destroy();
              }
            }
            f.w._buildAccessors(l.k.prototype, E);
          },
          8620: (Se, W, a) => {
            "use strict";
            a.d(W, { w: () => T });
            var x = a(5338);
            class T extends x.b {
              constructor(c, d) {
                super(),
                  (this.system = void 0),
                  (this.entity = void 0),
                  (this.system = c),
                  (this.entity = d),
                  this.system.schema &&
                    !this._accessorsBuilt &&
                    this.buildAccessors(this.system.schema),
                  this.on("set", function (h, f, s) {
                    this.fire("set_" + h, h, f, s);
                  }),
                  this.on("set_enabled", this.onSetEnabled, this);
              }
              static _buildAccessors(c, d) {
                d.forEach(function (h) {
                  const f = typeof h == "object" ? h.name : h;
                  Object.defineProperty(c, f, {
                    get: function () {
                      return this.data[f];
                    },
                    set: function (s) {
                      const l = this.data,
                        n = l[f];
                      (l[f] = s), this.fire("set", f, n, s);
                    },
                    configurable: !0,
                  });
                }),
                  (c._accessorsBuilt = !0);
              }
              buildAccessors(c) {
                T._buildAccessors(this, c);
              }
              onSetEnabled(c, d, h) {
                d !== h &&
                  this.entity.enabled &&
                  (h ? this.onEnable() : this.onDisable());
              }
              onEnable() {}
              onDisable() {}
              onPostStateChange() {}
              get data() {
                const c = this.system.store[this.entity.getGuid()];
                return c ? c.data : null;
              }
            }
          },
          7964: (Se, W, a) => {
            "use strict";
            a.d(W, { o: () => v });
            var x = a(9758),
              T = a(2978),
              g = a(6556),
              c = a(6630),
              d = a(7921),
              h = a(3114),
              f = a(3240),
              s = a(30),
              l = a(258),
              n = a(8620),
              o = a(3404),
              i = a(9968),
              e = a(9409);
            const t = new g.A(),
              r = new x.y(),
              u = new g.A(),
              y = new g.A(),
              p = new x.y(),
              _ = new x.y(),
              m = new x.y(),
              E = new x.y();
            class v extends n.w {
              constructor(A, B) {
                super(A, B),
                  (this._beingInitialized = !1),
                  (this._anchor = new c.T()),
                  (this._localAnchor = new c.T()),
                  (this._pivot = new T.S()),
                  (this._width = this._calculatedWidth = 32),
                  (this._height = this._calculatedHeight = 32),
                  (this._margin = new c.T(0, 0, -32, -32)),
                  (this._modelTransform = new x.y()),
                  (this._screenToWorld = new x.y()),
                  (this._anchorTransform = new x.y()),
                  (this._anchorDirty = !0),
                  (this._parentWorldTransform = new x.y()),
                  (this._screenTransform = new x.y()),
                  (this._screenCorners = [
                    new g.A(),
                    new g.A(),
                    new g.A(),
                    new g.A(),
                  ]),
                  (this._canvasCorners = [
                    new T.S(),
                    new T.S(),
                    new T.S(),
                    new T.S(),
                  ]),
                  (this._worldCorners = [
                    new g.A(),
                    new g.A(),
                    new g.A(),
                    new g.A(),
                  ]),
                  (this._cornersDirty = !0),
                  (this._canvasCornersDirty = !0),
                  (this._worldCornersDirty = !0),
                  this.entity.on("insert", this._onInsert, this),
                  this._patch(),
                  (this.screen = null),
                  (this._type = o.Kv),
                  (this._image = null),
                  (this._text = null),
                  (this._group = null),
                  (this._drawOrder = 0),
                  (this._fitMode = o.gc),
                  (this._useInput = !1),
                  (this._layers = [h.Q7]),
                  (this._addedModels = []),
                  (this._batchGroupId = -1),
                  (this._offsetReadAt = 0),
                  (this._maskOffset = 0.5),
                  (this._maskedBy = null);
              }
              get _absLeft() {
                return this._localAnchor.x + this._margin.x;
              }
              get _absRight() {
                return this._localAnchor.z - this._margin.z;
              }
              get _absTop() {
                return this._localAnchor.w - this._margin.w;
              }
              get _absBottom() {
                return this._localAnchor.y + this._margin.y;
              }
              get _hasSplitAnchorsX() {
                return Math.abs(this._anchor.x - this._anchor.z) > 0.001;
              }
              get _hasSplitAnchorsY() {
                return Math.abs(this._anchor.y - this._anchor.w) > 0.001;
              }
              get aabb() {
                return this._image
                  ? this._image.aabb
                  : this._text
                  ? this._text.aabb
                  : null;
              }
              set anchor(A) {
                A instanceof c.T
                  ? this._anchor.copy(A)
                  : this._anchor.set(...A),
                  !this.entity._parent && !this.screen
                    ? this._calculateLocalAnchors()
                    : this._calculateSize(
                        this._hasSplitAnchorsX,
                        this._hasSplitAnchorsY
                      ),
                  (this._anchorDirty = !0),
                  this.entity._dirtyLocal || this.entity._dirtifyLocal(),
                  this.fire("set:anchor", this._anchor);
              }
              get anchor() {
                return this._anchor;
              }
              set batchGroupId(A) {
                if (this._batchGroupId !== A) {
                  if (this.entity.enabled && this._batchGroupId >= 0) {
                    var B;
                    (B = this.system.app.batcher) == null ||
                      B.remove(f.y.ELEMENT, this.batchGroupId, this.entity);
                  }
                  if (this.entity.enabled && A >= 0) {
                    var C;
                    (C = this.system.app.batcher) == null ||
                      C.insert(f.y.ELEMENT, A, this.entity);
                  }
                  A < 0 &&
                    this._batchGroupId >= 0 &&
                    this.enabled &&
                    this.entity.enabled &&
                    (this._image && this._image._renderable.model
                      ? this.addModelToLayers(this._image._renderable.model)
                      : this._text &&
                        this._text._model &&
                        this.addModelToLayers(this._text._model)),
                    (this._batchGroupId = A);
                }
              }
              get batchGroupId() {
                return this._batchGroupId;
              }
              set bottom(A) {
                this._margin.y = A;
                const B = this.entity.getLocalPosition(),
                  C = this._absTop,
                  w = this._localAnchor.y + A;
                this._setHeight(C - w),
                  (B.y = A + this._calculatedHeight * this._pivot.y),
                  this.entity.setLocalPosition(B);
              }
              get bottom() {
                return this._margin.y;
              }
              set calculatedWidth(A) {
                this._setCalculatedWidth(A, !0);
              }
              get calculatedWidth() {
                return this._calculatedWidth;
              }
              set calculatedHeight(A) {
                this._setCalculatedHeight(A, !0);
              }
              get calculatedHeight() {
                return this._calculatedHeight;
              }
              get canvasCorners() {
                if (
                  !this._canvasCornersDirty ||
                  !this.screen ||
                  !this.screen.screen.screenSpace
                )
                  return this._canvasCorners;
                const A = this.system.app.graphicsDevice,
                  B = this.screenCorners,
                  C = A.canvas.clientWidth / A.width,
                  w = A.canvas.clientHeight / A.height;
                for (let k = 0; k < 4; k++)
                  this._canvasCorners[k].set(
                    B[k].x * C,
                    (A.height - B[k].y) * w
                  );
                return (this._canvasCornersDirty = !1), this._canvasCorners;
              }
              set drawOrder(A) {
                let B = 0;
                this.screen && (B = this.screen.screen.priority),
                  A > 16777215 && (A = 16777215),
                  (this._drawOrder = (B << 24) + A),
                  this.fire("set:draworder", this._drawOrder);
              }
              get drawOrder() {
                return this._drawOrder;
              }
              set height(A) {
                (this._height = A),
                  this._hasSplitAnchorsY || this._setCalculatedHeight(A, !0),
                  this.fire("set:height", this._height);
              }
              get height() {
                return this._height;
              }
              set layers(A) {
                if (this._addedModels.length)
                  for (let B = 0; B < this._layers.length; B++) {
                    const C = this.system.app.scene.layers.getLayerById(
                      this._layers[B]
                    );
                    if (C)
                      for (let w = 0; w < this._addedModels.length; w++)
                        C.removeMeshInstances(
                          this._addedModels[w].meshInstances
                        );
                  }
                if (
                  ((this._layers = A),
                  !(
                    !this.enabled ||
                    !this.entity.enabled ||
                    !this._addedModels.length
                  ))
                )
                  for (let B = 0; B < this._layers.length; B++) {
                    const C = this.system.app.scene.layers.getLayerById(
                      this._layers[B]
                    );
                    if (C)
                      for (let w = 0; w < this._addedModels.length; w++)
                        C.addMeshInstances(this._addedModels[w].meshInstances);
                  }
              }
              get layers() {
                return this._layers;
              }
              set left(A) {
                this._margin.x = A;
                const B = this.entity.getLocalPosition(),
                  C = this._absRight,
                  w = this._localAnchor.x + A;
                this._setWidth(C - w),
                  (B.x = A + this._calculatedWidth * this._pivot.x),
                  this.entity.setLocalPosition(B);
              }
              get left() {
                return this._margin.x;
              }
              set margin(A) {
                this._margin.copy(A),
                  this._calculateSize(!0, !0),
                  this.fire("set:margin", this._margin);
              }
              get margin() {
                return this._margin;
              }
              get maskedBy() {
                return this._maskedBy;
              }
              set pivot(A) {
                const { pivot: B, margin: C } = this,
                  w = B.x,
                  k = B.y;
                A instanceof T.S ? B.copy(A) : B.set(...A);
                const K = C.x + C.z,
                  te = B.x - w;
                (C.x += K * te), (C.z -= K * te);
                const X = C.y + C.w,
                  $ = B.y - k;
                (C.y += X * $),
                  (C.w -= X * $),
                  (this._anchorDirty = !0),
                  (this._cornersDirty = !0),
                  (this._worldCornersDirty = !0),
                  this._calculateSize(!1, !1),
                  this._flagChildrenAsDirty(),
                  this.fire("set:pivot", B);
              }
              get pivot() {
                return this._pivot;
              }
              set right(A) {
                this._margin.z = A;
                const B = this.entity.getLocalPosition(),
                  C = this._absLeft,
                  w = this._localAnchor.z - A;
                this._setWidth(w - C),
                  (B.x =
                    this._localAnchor.z -
                    this._localAnchor.x -
                    A -
                    this._calculatedWidth * (1 - this._pivot.x)),
                  this.entity.setLocalPosition(B);
              }
              get right() {
                return this._margin.z;
              }
              get screenCorners() {
                if (!this._cornersDirty || !this.screen)
                  return this._screenCorners;
                const A =
                  this.entity.parent &&
                  this.entity.parent.element &&
                  this.entity.parent.element.screenCorners[0];
                this._screenCorners[0].set(this._absLeft, this._absBottom, 0),
                  this._screenCorners[1].set(
                    this._absRight,
                    this._absBottom,
                    0
                  ),
                  this._screenCorners[2].set(this._absRight, this._absTop, 0),
                  this._screenCorners[3].set(this._absLeft, this._absTop, 0);
                const B = this.screen.screen.screenSpace;
                for (let C = 0; C < 4; C++)
                  this._screenTransform.transformPoint(
                    this._screenCorners[C],
                    this._screenCorners[C]
                  ),
                    B &&
                      this._screenCorners[C].mulScalar(
                        this.screen.screen.scale
                      ),
                    A && this._screenCorners[C].add(A);
                return (
                  (this._cornersDirty = !1),
                  (this._canvasCornersDirty = !0),
                  (this._worldCornersDirty = !0),
                  this._screenCorners
                );
              }
              get textWidth() {
                return this._text ? this._text.width : 0;
              }
              get textHeight() {
                return this._text ? this._text.height : 0;
              }
              set top(A) {
                this._margin.w = A;
                const B = this.entity.getLocalPosition(),
                  C = this._absBottom,
                  w = this._localAnchor.w - A;
                this._setHeight(w - C),
                  (B.y =
                    this._localAnchor.w -
                    this._localAnchor.y -
                    A -
                    this._calculatedHeight * (1 - this._pivot.y)),
                  this.entity.setLocalPosition(B);
              }
              get top() {
                return this._margin.w;
              }
              set type(A) {
                A !== this._type &&
                  ((this._type = A),
                  this._image && (this._image.destroy(), (this._image = null)),
                  this._text && (this._text.destroy(), (this._text = null)),
                  A === o.rf
                    ? (this._image = new i.K(this))
                    : A === o.l2 && (this._text = new e.G(this)));
              }
              get type() {
                return this._type;
              }
              set useInput(A) {
                this._useInput !== A &&
                  ((this._useInput = A),
                  this.system.app.elementInput
                    ? A
                      ? this.enabled &&
                        this.entity.enabled &&
                        this.system.app.elementInput.addElement(this)
                      : this.system.app.elementInput.removeElement(this)
                    : this._useInput,
                  this.fire("set:useInput", A));
              }
              get useInput() {
                return this._useInput;
              }
              set fitMode(A) {
                (this._fitMode = A),
                  this._calculateSize(!0, !0),
                  this._image && this._image.refreshMesh();
              }
              get fitMode() {
                return this._fitMode;
              }
              set width(A) {
                (this._width = A),
                  this._hasSplitAnchorsX || this._setCalculatedWidth(A, !0),
                  this.fire("set:width", this._width);
              }
              get width() {
                return this._width;
              }
              get worldCorners() {
                if (!this._worldCornersDirty) return this._worldCorners;
                if (this.screen) {
                  const A = this.screenCorners;
                  if (!this.screen.screen.screenSpace) {
                    p.copy(this.screen.screen._screenMatrix),
                      (p.data[13] = -p.data[13]),
                      p.mul2(this.screen.getWorldTransform(), p);
                    for (let B = 0; B < 4; B++)
                      p.transformPoint(A[B], this._worldCorners[B]);
                  }
                } else {
                  const A = this.entity.getLocalPosition();
                  p.setTranslate(-A.x, -A.y, -A.z),
                    _.setTRS(
                      g.A.ZERO,
                      this.entity.getLocalRotation(),
                      this.entity.getLocalScale()
                    ),
                    m.setTranslate(A.x, A.y, A.z);
                  const B = this.entity.parent
                    ? this.entity.parent
                    : this.entity;
                  E.copy(B.getWorldTransform()),
                    E.mul(m).mul(_).mul(p),
                    u.set(
                      A.x - this.pivot.x * this.calculatedWidth,
                      A.y - this.pivot.y * this.calculatedHeight,
                      A.z
                    ),
                    E.transformPoint(u, this._worldCorners[0]),
                    u.set(
                      A.x + (1 - this.pivot.x) * this.calculatedWidth,
                      A.y - this.pivot.y * this.calculatedHeight,
                      A.z
                    ),
                    E.transformPoint(u, this._worldCorners[1]),
                    u.set(
                      A.x + (1 - this.pivot.x) * this.calculatedWidth,
                      A.y + (1 - this.pivot.y) * this.calculatedHeight,
                      A.z
                    ),
                    E.transformPoint(u, this._worldCorners[2]),
                    u.set(
                      A.x - this.pivot.x * this.calculatedWidth,
                      A.y + (1 - this.pivot.y) * this.calculatedHeight,
                      A.z
                    ),
                    E.transformPoint(u, this._worldCorners[3]);
                }
                return (this._worldCornersDirty = !1), this._worldCorners;
              }
              _patch() {
                (this.entity._sync = this._sync),
                  (this.entity.setPosition = this._setPosition),
                  (this.entity.setLocalPosition = this._setLocalPosition);
              }
              _unpatch() {
                (this.entity._sync = l.J.prototype._sync),
                  (this.entity.setPosition = l.J.prototype.setPosition),
                  (this.entity.setLocalPosition =
                    l.J.prototype.setLocalPosition);
              }
              _setPosition(A, B, C) {
                if (!this.element.screen) {
                  l.J.prototype.setPosition.call(this, A, B, C);
                  return;
                }
                A instanceof g.A ? t.copy(A) : t.set(A, B, C),
                  this.getWorldTransform(),
                  r.copy(this.element._screenToWorld).invert(),
                  r.transformPoint(t, this.localPosition),
                  this._dirtyLocal || this._dirtifyLocal();
              }
              _setLocalPosition(A, B, C) {
                A instanceof g.A
                  ? this.localPosition.copy(A)
                  : this.localPosition.set(A, B, C);
                const w = this.element,
                  k = this.localPosition,
                  K = w._pivot;
                (w._margin.x = k.x - w._calculatedWidth * K.x),
                  (w._margin.z =
                    w._localAnchor.z -
                    w._localAnchor.x -
                    w._calculatedWidth -
                    w._margin.x),
                  (w._margin.y = k.y - w._calculatedHeight * K.y),
                  (w._margin.w =
                    w._localAnchor.w -
                    w._localAnchor.y -
                    w._calculatedHeight -
                    w._margin.y),
                  this._dirtyLocal || this._dirtifyLocal();
              }
              _sync() {
                const A = this.element,
                  B = A.screen;
                if (B) {
                  if (A._anchorDirty) {
                    let C = 0,
                      w = 0,
                      k = 0,
                      K = 1;
                    if (this._parent && this._parent.element)
                      (C = this._parent.element.calculatedWidth),
                        (w = this._parent.element.calculatedHeight),
                        (k = this._parent.element.pivot.x),
                        (K = this._parent.element.pivot.y);
                    else {
                      const te = B.screen.resolution;
                      (C = te.x / B.screen.scale), (w = te.y / B.screen.scale);
                    }
                    A._anchorTransform.setTranslate(
                      C * (A.anchor.x - k),
                      -(w * (K - A.anchor.y)),
                      0
                    ),
                      (A._anchorDirty = !1),
                      A._calculateLocalAnchors();
                  }
                  A._sizeDirty && A._calculateSize(!1, !1);
                }
                if (this._dirtyLocal) {
                  this.localTransform.setTRS(
                    this.localPosition,
                    this.localRotation,
                    this.localScale
                  );
                  const C = this.localPosition,
                    w = A._pivot;
                  (A._margin.x = C.x - A._calculatedWidth * w.x),
                    (A._margin.z =
                      A._localAnchor.z -
                      A._localAnchor.x -
                      A._calculatedWidth -
                      A._margin.x),
                    (A._margin.y = C.y - A._calculatedHeight * w.y),
                    (A._margin.w =
                      A._localAnchor.w -
                      A._localAnchor.y -
                      A._calculatedHeight -
                      A._margin.y),
                    (this._dirtyLocal = !1);
                }
                if (!B)
                  return (
                    this._dirtyWorld &&
                      ((A._cornersDirty = !0),
                      (A._canvasCornersDirty = !0),
                      (A._worldCornersDirty = !0)),
                    l.J.prototype._sync.call(this)
                  );
                if (this._dirtyWorld) {
                  if (this._parent === null)
                    this.worldTransform.copy(this.localTransform);
                  else if (
                    (this._parent.element
                      ? A._screenToWorld.mul2(
                          this._parent.element._modelTransform,
                          A._anchorTransform
                        )
                      : A._screenToWorld.copy(A._anchorTransform),
                    A._modelTransform.mul2(
                      A._screenToWorld,
                      this.localTransform
                    ),
                    B)
                  ) {
                    A._screenToWorld.mul2(
                      B.screen._screenMatrix,
                      A._screenToWorld
                    ),
                      B.screen.screenSpace ||
                        A._screenToWorld.mul2(
                          B.worldTransform,
                          A._screenToWorld
                        ),
                      this.worldTransform.mul2(
                        A._screenToWorld,
                        this.localTransform
                      );
                    const C = A._parentWorldTransform;
                    C.setIdentity();
                    const w = this._parent;
                    w &&
                      w.element &&
                      w !== B &&
                      (p.setTRS(
                        g.A.ZERO,
                        w.getLocalRotation(),
                        w.getLocalScale()
                      ),
                      C.mul2(w.element._parentWorldTransform, p));
                    const k = u;
                    k.set(0, 0, this.localPosition.z);
                    const K = y;
                    K.set(
                      A._absLeft + A._pivot.x * A.calculatedWidth,
                      A._absBottom + A._pivot.y * A.calculatedHeight,
                      0
                    ),
                      p.setTranslate(-K.x, -K.y, -K.z),
                      _.setTRS(
                        k,
                        this.getLocalRotation(),
                        this.getLocalScale()
                      ),
                      m.setTranslate(K.x, K.y, K.z),
                      A._screenTransform
                        .mul2(A._parentWorldTransform, m)
                        .mul(_)
                        .mul(p),
                      (A._cornersDirty = !0),
                      (A._canvasCornersDirty = !0),
                      (A._worldCornersDirty = !0);
                  } else this.worldTransform.copy(A._modelTransform);
                  this._dirtyWorld = !1;
                }
              }
              _onInsert(A) {
                const B = this._parseUpToScreen();
                this.entity._dirtifyWorld(),
                  this._updateScreen(B.screen),
                  this._dirtifyMask();
              }
              _dirtifyMask() {
                let A = this.entity;
                for (; A; ) {
                  const B = A.parent;
                  if ((B === null || B.screen) && A.element) {
                    (!this.system._prerender ||
                      !this.system._prerender.length) &&
                      ((this.system._prerender = []),
                      this.system.app.once(
                        "prerender",
                        this._onPrerender,
                        this
                      ));
                    const C = this.system._prerender.indexOf(this.entity);
                    C >= 0 && this.system._prerender.splice(C, 1),
                      this.system._prerender.indexOf(A) < 0 &&
                        this.system._prerender.push(A);
                  }
                  A = B;
                }
              }
              _onPrerender() {
                for (let A = 0; A < this.system._prerender.length; A++) {
                  const B = this.system._prerender[A];
                  B.element && B.element.syncMask(1);
                }
                this.system._prerender.length = 0;
              }
              _bindScreen(A) {
                A._bindElement(this);
              }
              _unbindScreen(A) {
                A._unbindElement(this);
              }
              _updateScreen(A) {
                this.screen &&
                  this.screen !== A &&
                  this._unbindScreen(this.screen.screen);
                const B = this.screen;
                (this.screen = A),
                  this.screen && this._bindScreen(this.screen.screen),
                  this._calculateSize(
                    this._hasSplitAnchorsX,
                    this._hasSplitAnchorsY
                  ),
                  this.fire("set:screen", this.screen, B),
                  (this._anchorDirty = !0);
                const C = this.entity.children;
                for (let w = 0, k = C.length; w < k; w++)
                  C[w].element && C[w].element._updateScreen(A);
                this.screen && this.screen.screen.syncDrawOrder();
              }
              syncMask(A) {
                const B = this._parseUpToScreen();
                this._updateMask(B.mask, A);
              }
              _setMaskedBy(A) {
                const B = this._image || this._text;
                if (A) {
                  const C = A.element._image._maskRef;
                  B == null || B._setStencil(new s.p({ ref: C, func: d._v4 })),
                    (this._maskedBy = A);
                } else
                  B == null || B._setStencil(null), (this._maskedBy = null);
              }
              _updateMask(A, B) {
                if (A) {
                  if ((this._setMaskedBy(A), this.mask)) {
                    const K = A.element._image._maskRef,
                      te = new s.p({ ref: K, func: d._v4, zpass: d.ROU });
                    this._image._setStencil(te),
                      (this._image._maskRef = B),
                      B++,
                      (A = this.entity);
                  }
                  const k = this.entity.children;
                  for (let K = 0, te = k.length; K < te; K++) {
                    var C;
                    (C = k[K].element) == null || C._updateMask(A, B);
                  }
                  this.mask && B--;
                } else {
                  if ((this._setMaskedBy(null), this.mask)) {
                    const K = new s.p({ ref: B, func: d.g8z, zpass: d.P3e });
                    this._image._setStencil(K),
                      (this._image._maskRef = B),
                      B++,
                      (A = this.entity);
                  }
                  const k = this.entity.children;
                  for (let K = 0, te = k.length; K < te; K++) {
                    var w;
                    (w = k[K].element) == null || w._updateMask(A, B);
                  }
                  this.mask && B--;
                }
              }
              _parseUpToScreen() {
                const A = { screen: null, mask: null };
                let B = this.entity._parent;
                for (; B && !B.screen; )
                  B.element && B.element.mask && (A.mask || (A.mask = B)),
                    (B = B.parent);
                return B && B.screen && (A.screen = B), A;
              }
              _onScreenResize(A) {
                (this._anchorDirty = !0),
                  (this._cornersDirty = !0),
                  (this._worldCornersDirty = !0),
                  this._calculateSize(
                    this._hasSplitAnchorsX,
                    this._hasSplitAnchorsY
                  ),
                  this.fire("screen:set:resolution", A);
              }
              _onScreenSpaceChange() {
                this.fire(
                  "screen:set:screenspace",
                  this.screen.screen.screenSpace
                );
              }
              _onScreenRemove() {
                this.screen &&
                  (this.screen._destroying
                    ? (this.screen = null)
                    : this._updateScreen(null));
              }
              _calculateLocalAnchors() {
                let A = 1e3,
                  B = 1e3;
                const C = this.entity._parent;
                if (C && C.element)
                  (A = C.element.calculatedWidth),
                    (B = C.element.calculatedHeight);
                else if (this.screen) {
                  const w = this.screen.screen.resolution,
                    k = this.screen.screen.scale;
                  (A = w.x / k), (B = w.y / k);
                }
                this._localAnchor.set(
                  this._anchor.x * A,
                  this._anchor.y * B,
                  this._anchor.z * A,
                  this._anchor.w * B
                );
              }
              getOffsetPosition(A, B) {
                const C = this.entity.getLocalPosition().clone();
                return (
                  (C.x += A),
                  (C.y += B),
                  this._screenToWorld.transformPoint(C, C),
                  C
                );
              }
              onLayersChanged(A, B) {
                this.addModelToLayers(
                  this._image
                    ? this._image._renderable.model
                    : this._text._model
                ),
                  A.off("add", this.onLayerAdded, this),
                  A.off("remove", this.onLayerRemoved, this),
                  B.on("add", this.onLayerAdded, this),
                  B.on("remove", this.onLayerRemoved, this);
              }
              onLayerAdded(A) {
                this.layers.indexOf(A.id) < 0 ||
                  (this._image
                    ? A.addMeshInstances(
                        this._image._renderable.model.meshInstances
                      )
                    : this._text &&
                      A.addMeshInstances(this._text._model.meshInstances));
              }
              onLayerRemoved(A) {
                this.layers.indexOf(A.id) < 0 ||
                  (this._image
                    ? A.removeMeshInstances(
                        this._image._renderable.model.meshInstances
                      )
                    : this._text &&
                      A.removeMeshInstances(this._text._model.meshInstances));
              }
              onEnable() {
                if (
                  (this._image && this._image.onEnable(),
                  this._text && this._text.onEnable(),
                  this._group && this._group.onEnable(),
                  this.useInput &&
                    this.system.app.elementInput &&
                    this.system.app.elementInput.addElement(this),
                  this.system.app.scene.on(
                    "set:layers",
                    this.onLayersChanged,
                    this
                  ),
                  this.system.app.scene.layers &&
                    (this.system.app.scene.layers.on(
                      "add",
                      this.onLayerAdded,
                      this
                    ),
                    this.system.app.scene.layers.on(
                      "remove",
                      this.onLayerRemoved,
                      this
                    )),
                  this._batchGroupId >= 0)
                ) {
                  var A;
                  (A = this.system.app.batcher) == null ||
                    A.insert(f.y.ELEMENT, this.batchGroupId, this.entity);
                }
                this.fire("enableelement");
              }
              onDisable() {
                if (
                  (this.system.app.scene.off(
                    "set:layers",
                    this.onLayersChanged,
                    this
                  ),
                  this.system.app.scene.layers &&
                    (this.system.app.scene.layers.off(
                      "add",
                      this.onLayerAdded,
                      this
                    ),
                    this.system.app.scene.layers.off(
                      "remove",
                      this.onLayerRemoved,
                      this
                    )),
                  this._image && this._image.onDisable(),
                  this._text && this._text.onDisable(),
                  this._group && this._group.onDisable(),
                  this.system.app.elementInput &&
                    this.useInput &&
                    this.system.app.elementInput.removeElement(this),
                  this._batchGroupId >= 0)
                ) {
                  var A;
                  (A = this.system.app.batcher) == null ||
                    A.remove(f.y.ELEMENT, this.batchGroupId, this.entity);
                }
                this.fire("disableelement");
              }
              onRemove() {
                this.entity.off("insert", this._onInsert, this),
                  this._unpatch(),
                  this._image && this._image.destroy(),
                  this._text && this._text.destroy(),
                  this.system.app.elementInput &&
                    this.useInput &&
                    this.system.app.elementInput.removeElement(this),
                  this.screen &&
                    this.screen.screen &&
                    (this._unbindScreen(this.screen.screen),
                    this.screen.screen.syncDrawOrder()),
                  this.off();
              }
              _calculateSize(A, B) {
                if (!this.entity._parent && !this.screen) return;
                this._calculateLocalAnchors();
                const C = this._absRight - this._absLeft,
                  w = this._absTop - this._absBottom;
                A ? this._setWidth(C) : this._setCalculatedWidth(C, !1),
                  B ? this._setHeight(w) : this._setCalculatedHeight(w, !1);
                const k = this.entity.getLocalPosition();
                (k.x = this._margin.x + this._calculatedWidth * this._pivot.x),
                  (k.y =
                    this._margin.y + this._calculatedHeight * this._pivot.y),
                  this.entity.setLocalPosition(k),
                  (this._sizeDirty = !1);
              }
              _setWidth(A) {
                (this._width = A),
                  this._setCalculatedWidth(A, !1),
                  this.fire("set:width", this._width);
              }
              _setHeight(A) {
                (this._height = A),
                  this._setCalculatedHeight(A, !1),
                  this.fire("set:height", this._height);
              }
              _setCalculatedWidth(A, B) {
                if (!(Math.abs(A - this._calculatedWidth) <= 1e-4)) {
                  if (
                    ((this._calculatedWidth = A),
                    this.entity._dirtifyLocal(),
                    B)
                  ) {
                    const C = this.entity.getLocalPosition(),
                      w = this._pivot;
                    (this._margin.x = C.x - this._calculatedWidth * w.x),
                      (this._margin.z =
                        this._localAnchor.z -
                        this._localAnchor.x -
                        this._calculatedWidth -
                        this._margin.x);
                  }
                  this._flagChildrenAsDirty(),
                    this.fire("set:calculatedWidth", this._calculatedWidth),
                    this.fire(
                      "resize",
                      this._calculatedWidth,
                      this._calculatedHeight
                    );
                }
              }
              _setCalculatedHeight(A, B) {
                if (!(Math.abs(A - this._calculatedHeight) <= 1e-4)) {
                  if (
                    ((this._calculatedHeight = A),
                    this.entity._dirtifyLocal(),
                    B)
                  ) {
                    const C = this.entity.getLocalPosition(),
                      w = this._pivot;
                    (this._margin.y = C.y - this._calculatedHeight * w.y),
                      (this._margin.w =
                        this._localAnchor.w -
                        this._localAnchor.y -
                        this._calculatedHeight -
                        this._margin.y);
                  }
                  this._flagChildrenAsDirty(),
                    this.fire("set:calculatedHeight", this._calculatedHeight),
                    this.fire(
                      "resize",
                      this._calculatedWidth,
                      this._calculatedHeight
                    );
                }
              }
              _flagChildrenAsDirty() {
                const A = this.entity._children;
                for (let B = 0, C = A.length; B < C; B++)
                  A[B].element &&
                    ((A[B].element._anchorDirty = !0),
                    (A[B].element._sizeDirty = !0));
              }
              addModelToLayers(A) {
                this._addedModels.push(A);
                for (let B = 0; B < this.layers.length; B++) {
                  const C = this.system.app.scene.layers.getLayerById(
                    this.layers[B]
                  );
                  C && C.addMeshInstances(A.meshInstances);
                }
              }
              removeModelFromLayers(A) {
                const B = this._addedModels.indexOf(A);
                B >= 0 && this._addedModels.splice(B, 1);
                for (let C = 0; C < this.layers.length; C++) {
                  const w = this.system.app.scene.layers.getLayerById(
                    this.layers[C]
                  );
                  w && w.removeMeshInstances(A.meshInstances);
                }
              }
              getMaskOffset() {
                const A = this.system.app.frame;
                this._offsetReadAt !== A &&
                  ((this._maskOffset = 0.5), (this._offsetReadAt = A));
                const B = this._maskOffset;
                return (this._maskOffset -= 0.001), B;
              }
              isVisibleForCamera(A) {
                let B, C, w, k;
                if (this.maskedBy) {
                  const Y = this.maskedBy.element.screenCorners;
                  (B = Math.min(
                    Math.min(Y[0].x, Y[1].x),
                    Math.min(Y[2].x, Y[3].x)
                  )),
                    (C = Math.max(
                      Math.max(Y[0].x, Y[1].x),
                      Math.max(Y[2].x, Y[3].x)
                    )),
                    (k = Math.min(
                      Math.min(Y[0].y, Y[1].y),
                      Math.min(Y[2].y, Y[3].y)
                    )),
                    (w = Math.max(
                      Math.max(Y[0].y, Y[1].y),
                      Math.max(Y[2].y, Y[3].y)
                    ));
                } else {
                  const Y = this.system.app.graphicsDevice.width,
                    Z = this.system.app.graphicsDevice.height,
                    ye = A._rect.z * Y,
                    pe = A._rect.w * Z;
                  (B = A._rect.x * Y),
                    (C = B + ye),
                    (w = (1 - A._rect.y) * Z),
                    (k = w - pe);
                }
                const K = this.screenCorners,
                  te = Math.min(
                    Math.min(K[0].x, K[1].x),
                    Math.min(K[2].x, K[3].x)
                  ),
                  X = Math.max(
                    Math.max(K[0].x, K[1].x),
                    Math.max(K[2].x, K[3].x)
                  ),
                  $ = Math.min(
                    Math.min(K[0].y, K[1].y),
                    Math.min(K[2].y, K[3].y)
                  ),
                  ne = Math.max(
                    Math.max(K[0].y, K[1].y),
                    Math.max(K[2].y, K[3].y)
                  );
                return !(X < B || te > C || $ > w || ne < k);
              }
              _isScreenSpace() {
                return this.screen && this.screen.screen
                  ? this.screen.screen.screenSpace
                  : !1;
              }
              _isScreenCulled() {
                return this.screen && this.screen.screen
                  ? this.screen.screen.cull
                  : !1;
              }
              _dirtyBatch() {
                if (this.batchGroupId !== -1) {
                  var A;
                  (A = this.system.app.batcher) == null ||
                    A.markGroupDirty(this.batchGroupId);
                }
              }
            }
            function P(I) {
              Object.defineProperty(v.prototype, I, {
                get: function () {
                  return this._text
                    ? this._text[I]
                    : this._image
                    ? this._image[I]
                    : null;
                },
                set: function (A) {
                  this._text
                    ? (this._text[I] !== A && this._dirtyBatch(),
                      (this._text[I] = A))
                    : this._image &&
                      (this._image[I] !== A && this._dirtyBatch(),
                      (this._image[I] = A));
                },
              });
            }
            P("fontSize"),
              P("minFontSize"),
              P("maxFontSize"),
              P("maxLines"),
              P("autoFitWidth"),
              P("autoFitHeight"),
              P("color"),
              P("font"),
              P("fontAsset"),
              P("spacing"),
              P("lineHeight"),
              P("wrapLines"),
              P("lines"),
              P("alignment"),
              P("autoWidth"),
              P("autoHeight"),
              P("rtlReorder"),
              P("unicodeConverter"),
              P("text"),
              P("key"),
              P("texture"),
              P("textureAsset"),
              P("material"),
              P("materialAsset"),
              P("sprite"),
              P("spriteAsset"),
              P("spriteFrame"),
              P("pixelsPerUnit"),
              P("opacity"),
              P("rect"),
              P("mask"),
              P("outlineColor"),
              P("outlineThickness"),
              P("shadowColor"),
              P("shadowOffset"),
              P("enableMarkup"),
              P("rangeStart"),
              P("rangeEnd");
          },
          3404: (Se, W, a) => {
            "use strict";
            a.d(W, {
              Kv: () => x,
              cm: () => h,
              fM: () => d,
              gc: () => c,
              l2: () => g,
              rf: () => T,
            });
            const x = "group",
              T = "image",
              g = "text",
              c = "stretch",
              d = "contain",
              h = "cover";
          },
          4647: (Se, W, a) => {
            "use strict";
            a.d(W, { d: () => y });
            var x = a(4444),
              T = a(5338),
              g = a(6847),
              c = a(2978),
              d = a(6556),
              h = a(7964),
              f = a(3028),
              s = a(6251);
            const l = new c.S(),
              n = new d.A(),
              o = new f.z(),
              i = new s.J(),
              e = new d.A(),
              t = new d.A(),
              r = new g.D(),
              u = { x: "y", y: "x" };
            class y extends T.b {
              constructor(_, m) {
                if ((super(), !_ || !(_ instanceof h.o)))
                  throw new Error(
                    "Element was null or not an ElementComponent"
                  );
                if (m && m !== "x" && m !== "y")
                  throw new Error("Unrecognized axis: " + m);
                (this._element = _),
                  (this._app = _.system.app),
                  (this._axis = m || null),
                  (this._enabled = !0),
                  (this._dragScale = new d.A()),
                  (this._dragStartMousePosition = new d.A()),
                  (this._dragStartHandlePosition = new d.A()),
                  (this._deltaMousePosition = new d.A()),
                  (this._deltaHandlePosition = new d.A()),
                  (this._isDragging = !1),
                  this._toggleLifecycleListeners("on");
              }
              _toggleLifecycleListeners(_) {
                this._element[_](
                  "mousedown",
                  this._onMouseDownOrTouchStart,
                  this
                ),
                  this._element[_](
                    "touchstart",
                    this._onMouseDownOrTouchStart,
                    this
                  ),
                  this._element[_](
                    "selectstart",
                    this._onMouseDownOrTouchStart,
                    this
                  );
              }
              _toggleDragListeners(_) {
                const m = _ === "on";
                (this._hasDragListeners && m) ||
                  (this._app.mouse &&
                    (this._element[_]("mousemove", this._onMove, this),
                    this._element[_](
                      "mouseup",
                      this._onMouseUpOrTouchEnd,
                      this
                    )),
                  x.J.touch &&
                    (this._element[_]("touchmove", this._onMove, this),
                    this._element[_](
                      "touchend",
                      this._onMouseUpOrTouchEnd,
                      this
                    ),
                    this._element[_](
                      "touchcancel",
                      this._onMouseUpOrTouchEnd,
                      this
                    )),
                  this._element[_]("selectmove", this._onMove, this),
                  this._element[_](
                    "selectend",
                    this._onMouseUpOrTouchEnd,
                    this
                  ),
                  (this._hasDragListeners = m));
              }
              _onMouseDownOrTouchStart(_) {
                if (this._element && !this._isDragging && this.enabled) {
                  (this._dragCamera = _.camera), this._calculateDragScale();
                  const m = this._screenToLocal(_);
                  m &&
                    (this._toggleDragListeners("on"),
                    (this._isDragging = !0),
                    this._dragStartMousePosition.copy(m),
                    this._dragStartHandlePosition.copy(
                      this._element.entity.getLocalPosition()
                    ),
                    this.fire("drag:start"));
                }
              }
              _onMouseUpOrTouchEnd() {
                this._isDragging &&
                  ((this._isDragging = !1),
                  this._toggleDragListeners("off"),
                  this.fire("drag:end"));
              }
              _screenToLocal(_) {
                return (
                  _.inputSource
                    ? o.set(
                        _.inputSource.getOrigin(),
                        _.inputSource.getDirection()
                      )
                    : (this._determineInputPosition(_),
                      this._chooseRayOriginAndDirection()),
                  e.copy(this._element.entity.forward).mulScalar(-1),
                  i.setFromPointNormal(this._element.entity.getPosition(), e),
                  i.intersectsRay(o, t)
                    ? (r
                        .copy(this._element.entity.getRotation())
                        .invert()
                        .transformVector(t, t),
                      t.mul(this._dragScale),
                      t)
                    : null
                );
              }
              _determineInputPosition(_) {
                const m = this._app.graphicsDevice.maxPixelRatio;
                typeof _.x != "undefined" && typeof _.y != "undefined"
                  ? ((l.x = _.x * m), (l.y = _.y * m))
                  : _.changedTouches
                  ? ((l.x = _.changedTouches[0].x * m),
                    (l.y = _.changedTouches[0].y * m))
                  : console.warn(
                      "Could not determine position from input event"
                    );
              }
              _chooseRayOriginAndDirection() {
                this._element.screen && this._element.screen.screen.screenSpace
                  ? (o.origin.set(l.x, -l.y, 0), o.direction.copy(d.A.FORWARD))
                  : (n.copy(this._dragCamera.screenToWorld(l.x, l.y, 1)),
                    o.origin.copy(this._dragCamera.entity.getPosition()),
                    o.direction.copy(n).sub(o.origin).normalize());
              }
              _calculateDragScale() {
                let _ = this._element.entity.parent;
                const m = this._element.screen && this._element.screen.screen,
                  E = m && m.screenSpace,
                  v = E ? m.scale : 1,
                  P = this._dragScale;
                for (
                  P.set(v, v, v);
                  _ &&
                  (P.mul(_.getLocalScale()), (_ = _.parent), !(E && _.screen));

                );
                (P.x = 1 / P.x), (P.y = 1 / P.y), (P.z = 0);
              }
              _onMove(_) {
                const {
                  _element: m,
                  _deltaMousePosition: E,
                  _deltaHandlePosition: v,
                  _axis: P,
                } = this;
                if (
                  m &&
                  this._isDragging &&
                  this.enabled &&
                  m.enabled &&
                  m.entity.enabled
                ) {
                  const I = this._screenToLocal(_);
                  if (I) {
                    if (
                      (E.sub2(I, this._dragStartMousePosition),
                      v.add2(this._dragStartHandlePosition, E),
                      P)
                    ) {
                      const A = m.entity.getLocalPosition(),
                        B = u[P];
                      v[B] = A[B];
                    }
                    m.entity.setLocalPosition(v), this.fire("drag:move", v);
                  }
                }
              }
              destroy() {
                this._toggleLifecycleListeners("off"),
                  this._toggleDragListeners("off");
              }
              set enabled(_) {
                this._enabled = _;
              }
              get enabled() {
                return this._enabled;
              }
              get isDragging() {
                return this._isDragging;
              }
            }
          },
          9968: (Se, W, a) => {
            "use strict";
            a.d(W, { K: () => m });
            var x = a(4585),
              T = a(1367),
              g = a(2978),
              c = a(6556),
              d = a(6630),
              h = a(7921),
              f = a(6615),
              s = a(8385),
              l = a(7338),
              n = a(3114),
              o = a(7915),
              i = a(7678),
              e = a(8792),
              t = a(9915),
              r = a(30),
              u = a(3404),
              y = a(6204);
            const p = new l.c();
            class _ {
              constructor(v, P, I) {
                (this._entity = v),
                  (this._element = v.element),
                  (this.model = new t.H()),
                  (this.node = new o.A()),
                  (this.model.graph = this.node),
                  (this.mesh = P),
                  (this.meshInstance = new e.l(this.mesh, I, this.node)),
                  (this.meshInstance.name = "ImageElement: " + v.name),
                  (this.meshInstance.castShadow = !1),
                  (this.meshInstance.receiveShadow = !1),
                  (this._meshDirty = !1),
                  this.model.meshInstances.push(this.meshInstance),
                  this._entity.addChild(this.model.graph),
                  (this.model._entity = this._entity),
                  (this.unmaskMeshInstance = null);
              }
              destroy() {
                this.setMaterial(null),
                  this._element.removeModelFromLayers(this.model),
                  this.model.destroy(),
                  (this.model = null),
                  (this.node = null),
                  (this.mesh = null),
                  (this.meshInstance = null),
                  (this._entity = null),
                  (this._element = null);
              }
              setMesh(v) {
                this.meshInstance &&
                  ((this.mesh = v),
                  (this.meshInstance.mesh = v),
                  (this.meshInstance.visible = !!v),
                  this.unmaskMeshInstance && (this.unmaskMeshInstance.mesh = v),
                  this.forceUpdateAabb());
              }
              setMask(v) {
                if (this.meshInstance) {
                  if (v) {
                    (this.unmaskMeshInstance = new e.l(
                      this.mesh,
                      this.meshInstance.material,
                      this.node
                    )),
                      (this.unmaskMeshInstance.name =
                        "Unmask: " + this._entity.name),
                      (this.unmaskMeshInstance.castShadow = !1),
                      (this.unmaskMeshInstance.receiveShadow = !1),
                      (this.unmaskMeshInstance.pick = !1),
                      this.model.meshInstances.push(this.unmaskMeshInstance);
                    for (const P in this.meshInstance.parameters)
                      this.unmaskMeshInstance.setParameter(
                        P,
                        this.meshInstance.parameters[P].data
                      );
                  } else {
                    const P = this.model.meshInstances.indexOf(
                      this.unmaskMeshInstance
                    );
                    P >= 0 && this.model.meshInstances.splice(P, 1),
                      (this.unmaskMeshInstance = null);
                  }
                  this._entity.enabled &&
                    this._element.enabled &&
                    (this._element.removeModelFromLayers(this.model),
                    this._element.addModelToLayers(this.model));
                }
              }
              setMaterial(v) {
                this.meshInstance &&
                  ((this.meshInstance.material = v),
                  this.unmaskMeshInstance &&
                    (this.unmaskMeshInstance.material = v));
              }
              setParameter(v, P) {
                this.meshInstance &&
                  (this.meshInstance.setParameter(v, P),
                  this.unmaskMeshInstance &&
                    this.unmaskMeshInstance.setParameter(v, P));
              }
              deleteParameter(v) {
                this.meshInstance &&
                  (this.meshInstance.deleteParameter(v),
                  this.unmaskMeshInstance &&
                    this.unmaskMeshInstance.deleteParameter(v));
              }
              setUnmaskDrawOrder() {
                if (!this.meshInstance) return;
                const v = function P(I) {
                  let A;
                  const B = I.children,
                    C = B.length;
                  if (C) {
                    for (let k = 0; k < C; k++) B[k].element && (A = B[k]);
                    if (!A) return null;
                    const w = P(A);
                    return w || A;
                  }
                  return null;
                };
                if (this.unmaskMeshInstance) {
                  const P = v(this._entity);
                  P && P.element
                    ? (this.unmaskMeshInstance.drawOrder =
                        P.element.drawOrder + P.element.getMaskOffset())
                    : (this.unmaskMeshInstance.drawOrder =
                        this.meshInstance.drawOrder +
                        this._element.getMaskOffset());
                }
              }
              setDrawOrder(v) {
                this.meshInstance && (this.meshInstance.drawOrder = v);
              }
              setCull(v) {
                if (!this.meshInstance) return;
                const P = this._element;
                let I = null;
                v &&
                  P._isScreenSpace() &&
                  (I = function (A) {
                    return P.isVisibleForCamera(A);
                  }),
                  (this.meshInstance.cull = v),
                  (this.meshInstance.isVisibleFunc = I),
                  this.unmaskMeshInstance &&
                    ((this.unmaskMeshInstance.cull = v),
                    (this.unmaskMeshInstance.isVisibleFunc = I));
              }
              setScreenSpace(v) {
                this.meshInstance &&
                  ((this.meshInstance.screenSpace = v),
                  this.unmaskMeshInstance &&
                    (this.unmaskMeshInstance.screenSpace = v));
              }
              setLayer(v) {
                this.meshInstance &&
                  ((this.meshInstance.layer = v),
                  this.unmaskMeshInstance &&
                    (this.unmaskMeshInstance.layer = v));
              }
              forceUpdateAabb(v) {
                this.meshInstance &&
                  ((this.meshInstance._aabbVer = -1),
                  this.unmaskMeshInstance &&
                    (this.unmaskMeshInstance._aabbVer = -1));
              }
              setAabbFunc(v) {
                this.meshInstance &&
                  ((this.meshInstance._updateAabbFunc = v),
                  this.unmaskMeshInstance &&
                    (this.unmaskMeshInstance._updateAabbFunc = v));
              }
            }
            class m {
              constructor(v) {
                (this._element = v),
                  (this._entity = v.entity),
                  (this._system = v.system),
                  (this._textureAsset = null),
                  (this._texture = null),
                  (this._materialAsset = null),
                  (this._material = null),
                  (this._spriteAsset = null),
                  (this._sprite = null),
                  (this._spriteFrame = 0),
                  (this._pixelsPerUnit = null),
                  (this._targetAspectRatio = -1),
                  (this._rect = new d.T(0, 0, 1, 1)),
                  (this._mask = !1),
                  (this._maskRef = 0),
                  (this._outerScale = new g.S()),
                  (this._outerScaleUniform = new Float32Array(2)),
                  (this._innerOffset = new d.T()),
                  (this._innerOffsetUniform = new Float32Array(4)),
                  (this._atlasRect = new d.T()),
                  (this._atlasRectUniform = new Float32Array(4)),
                  (this._defaultMesh = this._createMesh()),
                  (this._renderable = new _(
                    this._entity,
                    this._defaultMesh,
                    this._material
                  )),
                  (this._color = new T.I(1, 1, 1, 1)),
                  (this._colorUniform = new Float32Array([1, 1, 1])),
                  this._renderable.setParameter(
                    "material_emissive",
                    this._colorUniform
                  ),
                  this._renderable.setParameter("material_opacity", 1),
                  (this._updateAabbFunc = this._updateAabb.bind(this)),
                  this._onScreenChange(this._element.screen),
                  this._element.on(
                    "resize",
                    this._onParentResizeOrPivotChange,
                    this
                  ),
                  this._element.on(
                    "set:pivot",
                    this._onParentResizeOrPivotChange,
                    this
                  ),
                  this._element.on(
                    "screen:set:screenspace",
                    this._onScreenSpaceChange,
                    this
                  ),
                  this._element.on("set:screen", this._onScreenChange, this),
                  this._element.on(
                    "set:draworder",
                    this._onDrawOrderChange,
                    this
                  ),
                  this._element.on(
                    "screen:set:resolution",
                    this._onResolutionChange,
                    this
                  );
              }
              destroy() {
                (this.textureAsset = null),
                  (this.spriteAsset = null),
                  (this.materialAsset = null),
                  this._renderable.setMesh(this._defaultMesh),
                  this._renderable.destroy(),
                  (this._defaultMesh = null),
                  this._element.off(
                    "resize",
                    this._onParentResizeOrPivotChange,
                    this
                  ),
                  this._element.off(
                    "set:pivot",
                    this._onParentResizeOrPivotChange,
                    this
                  ),
                  this._element.off(
                    "screen:set:screenspace",
                    this._onScreenSpaceChange,
                    this
                  ),
                  this._element.off("set:screen", this._onScreenChange, this),
                  this._element.off(
                    "set:draworder",
                    this._onDrawOrderChange,
                    this
                  ),
                  this._element.off(
                    "screen:set:resolution",
                    this._onResolutionChange,
                    this
                  );
              }
              _onResolutionChange(v) {}
              _onParentResizeOrPivotChange() {
                this._renderable.mesh &&
                  this._updateMesh(this._renderable.mesh);
              }
              _onScreenSpaceChange(v) {
                this._updateMaterial(v);
              }
              _onScreenChange(v, P) {
                v
                  ? this._updateMaterial(v.screen.screenSpace)
                  : this._updateMaterial(!1);
              }
              _onDrawOrderChange(v) {
                this._renderable.setDrawOrder(v),
                  this.mask &&
                    this._element.screen &&
                    this._element.screen.screen.once(
                      "syncdraworder",
                      function () {
                        this._renderable.setUnmaskDrawOrder();
                      },
                      this
                    );
              }
              _hasUserMaterial() {
                return (
                  !!this._materialAsset ||
                  (!!this._material &&
                    this._system.defaultImageMaterials.indexOf(
                      this._material
                    ) === -1)
                );
              }
              _use9Slicing() {
                return (
                  this.sprite &&
                  (this.sprite.renderMode === n.ei ||
                    this.sprite.renderMode === n.DD)
                );
              }
              _updateMaterial(v) {
                const P = !!this._mask,
                  I = !!(this.sprite && this.sprite.renderMode === n.ei),
                  A = !!(this.sprite && this.sprite.renderMode === n.DD);
                this._hasUserMaterial() ||
                  (this._material = this._system.getImageElementMaterial(
                    v,
                    P,
                    I,
                    A
                  )),
                  this._renderable &&
                    (this._renderable.setCull(
                      !this._element._isScreenSpace() ||
                        this._element._isScreenCulled()
                    ),
                    this._renderable.setMaterial(this._material),
                    this._renderable.setScreenSpace(v),
                    this._renderable.setLayer(v ? n._3 : n.G));
              }
              _createMesh() {
                const v = this._element,
                  P = v.calculatedWidth,
                  I = v.calculatedHeight,
                  A = this._rect,
                  B = this._system.app.graphicsDevice,
                  C = new Float32Array([
                    P,
                    0,
                    0,
                    0,
                    0,
                    1,
                    A.x + A.z,
                    1 - A.y,
                    P,
                    I,
                    0,
                    0,
                    0,
                    1,
                    A.x + A.z,
                    1 - (A.y + A.w),
                    0,
                    0,
                    0,
                    0,
                    0,
                    1,
                    A.x,
                    1 - A.y,
                    0,
                    I,
                    0,
                    0,
                    0,
                    1,
                    A.x,
                    1 - (A.y + A.w),
                  ]),
                  w = p.get(
                    B,
                    () =>
                      new s.g(B, [
                        { semantic: h.Q5v, components: 3, type: h.r8O },
                        { semantic: h.SA$, components: 3, type: h.r8O },
                        { semantic: h.$fY, components: 2, type: h.r8O },
                      ])
                  ),
                  k = new f.o(B, w, 4, h.dxy, C.buffer),
                  K = new i.K(B);
                return (
                  (K.vertexBuffer = k),
                  (K.primitive[0].type = h.fmY),
                  (K.primitive[0].base = 0),
                  (K.primitive[0].count = 4),
                  (K.primitive[0].indexed = !1),
                  K.aabb.setMinMax(c.A.ZERO, new c.A(P, I, 0)),
                  this._updateMesh(K),
                  K
                );
              }
              _updateMesh(v) {
                const P = this._element;
                let I = P.calculatedWidth,
                  A = P.calculatedHeight;
                if (P.fitMode !== u.gc && this._targetAspectRatio > 0) {
                  const C = P.calculatedWidth / P.calculatedHeight;
                  (P.fitMode === u.fM && C > this._targetAspectRatio) ||
                  (P.fitMode === u.cm && C < this._targetAspectRatio)
                    ? (I = P.calculatedHeight * this._targetAspectRatio)
                    : (A = P.calculatedWidth / this._targetAspectRatio);
                }
                const B = P._isScreenSpace();
                if (
                  (this._updateMaterial(B),
                  this._renderable && this._renderable.forceUpdateAabb(),
                  this.sprite &&
                    (this.sprite.renderMode === n.ei ||
                      this.sprite.renderMode === n.DD))
                ) {
                  const C =
                      this._sprite.atlas.frames[
                        this._sprite.frameKeys[this._spriteFrame]
                      ],
                    w = 2 / C.rect.z,
                    k = 2 / C.rect.w;
                  this._innerOffset.set(
                    C.border.x * w,
                    C.border.y * k,
                    C.border.z * w,
                    C.border.w * k
                  );
                  const K = this.sprite.atlas.texture;
                  this._atlasRect.set(
                    C.rect.x / K.width,
                    C.rect.y / K.height,
                    C.rect.z / K.width,
                    C.rect.w / K.height
                  );
                  const te =
                      this._pixelsPerUnit !== null
                        ? this._pixelsPerUnit
                        : this.sprite.pixelsPerUnit,
                    X = C.rect.z / te,
                    $ = C.rect.w / te;
                  this._outerScale.set(
                    Math.max(I, this._innerOffset.x * X),
                    Math.max(A, this._innerOffset.y * $)
                  );
                  let ne = X,
                    Y = $;
                  (this._outerScale.x /= X),
                    (this._outerScale.y /= $),
                    (ne *= x.m.clamp(I / (this._innerOffset.x * X), 1e-4, 1)),
                    (Y *= x.m.clamp(A / (this._innerOffset.y * $), 1e-4, 1)),
                    this._renderable &&
                      ((this._innerOffsetUniform[0] = this._innerOffset.x),
                      (this._innerOffsetUniform[1] = this._innerOffset.y),
                      (this._innerOffsetUniform[2] = this._innerOffset.z),
                      (this._innerOffsetUniform[3] = this._innerOffset.w),
                      this._renderable.setParameter(
                        "innerOffset",
                        this._innerOffsetUniform
                      ),
                      (this._atlasRectUniform[0] = this._atlasRect.x),
                      (this._atlasRectUniform[1] = this._atlasRect.y),
                      (this._atlasRectUniform[2] = this._atlasRect.z),
                      (this._atlasRectUniform[3] = this._atlasRect.w),
                      this._renderable.setParameter(
                        "atlasRect",
                        this._atlasRectUniform
                      ),
                      (this._outerScaleUniform[0] = this._outerScale.x),
                      (this._outerScaleUniform[1] = this._outerScale.y),
                      this._renderable.setParameter(
                        "outerScale",
                        this._outerScaleUniform
                      ),
                      this._renderable.setAabbFunc(this._updateAabbFunc),
                      this._renderable.node.setLocalScale(ne, Y, 1),
                      this._renderable.node.setLocalPosition(
                        (0.5 - P.pivot.x) * I,
                        (0.5 - P.pivot.y) * A,
                        0
                      ));
                } else {
                  const C = v.vertexBuffer,
                    w = new Float32Array(C.lock()),
                    k = P.pivot.x,
                    K = P.pivot.y;
                  (w[0] = I - k * I),
                    (w[1] = 0 - K * A),
                    (w[8] = I - k * I),
                    (w[9] = A - K * A),
                    (w[16] = 0 - k * I),
                    (w[17] = 0 - K * A),
                    (w[24] = 0 - k * I),
                    (w[25] = A - K * A);
                  let te = 1,
                    X = 1,
                    $ = this._rect;
                  if (
                    this._sprite &&
                    this._sprite.frameKeys[this._spriteFrame] &&
                    this._sprite.atlas
                  ) {
                    const Z =
                      this._sprite.atlas.frames[
                        this._sprite.frameKeys[this._spriteFrame]
                      ];
                    Z &&
                      (($ = Z.rect),
                      (te = this._sprite.atlas.texture.width),
                      (X = this._sprite.atlas.texture.height));
                  }
                  (w[6] = ($.x + $.z) / te),
                    (w[7] = 1 - $.y / X),
                    (w[14] = ($.x + $.z) / te),
                    (w[15] = 1 - ($.y + $.w) / X),
                    (w[22] = $.x / te),
                    (w[23] = 1 - $.y / X),
                    (w[30] = $.x / te),
                    (w[31] = 1 - ($.y + $.w) / X),
                    C.unlock();
                  const ne = new c.A(0 - k * I, 0 - K * A, 0),
                    Y = new c.A(I - k * I, A - K * A, 0);
                  v.aabb.setMinMax(ne, Y),
                    this._renderable &&
                      (this._renderable.node.setLocalScale(1, 1, 1),
                      this._renderable.node.setLocalPosition(0, 0, 0),
                      this._renderable.setAabbFunc(null));
                }
                this._meshDirty = !1;
              }
              _updateSprite() {
                let v = !1,
                  P = null;
                if (
                  ((this._targetAspectRatio = -1),
                  this._sprite && this._sprite.atlas)
                ) {
                  (P = this._sprite.meshes[this.spriteFrame]),
                    (v =
                      this._sprite.renderMode === n.ei ||
                      this._sprite.renderMode === n.DD);
                  const I =
                    this._sprite.atlas.frames[
                      this._sprite.frameKeys[this._spriteFrame]
                    ];
                  (I == null ? void 0 : I.rect.w) > 0 &&
                    (this._targetAspectRatio = I.rect.z / I.rect.w);
                }
                (this.mesh = v ? P : this._defaultMesh), this.refreshMesh();
              }
              refreshMesh() {
                this.mesh &&
                  (this._element._beingInitialized
                    ? (this._meshDirty = !0)
                    : this._updateMesh(this.mesh));
              }
              _updateAabb(v) {
                return (
                  v.center.set(0, 0, 0),
                  v.halfExtents.set(
                    this._outerScale.x * 0.5,
                    this._outerScale.y * 0.5,
                    0.001
                  ),
                  v.setFromTransformedAabb(
                    v,
                    this._renderable.node.getWorldTransform()
                  ),
                  v
                );
              }
              _toggleMask() {
                this._element._dirtifyMask();
                const v = this._element._isScreenSpace();
                this._updateMaterial(v), this._renderable.setMask(!!this._mask);
              }
              _onMaterialLoad(v) {
                this.material = v.resource;
              }
              _onMaterialAdded(v) {
                this._system.app.assets.off(
                  "add:" + v.id,
                  this._onMaterialAdded,
                  this
                ),
                  this._materialAsset === v.id && this._bindMaterialAsset(v);
              }
              _bindMaterialAsset(v) {
                this._entity.enabled &&
                  (v.on("load", this._onMaterialLoad, this),
                  v.on("change", this._onMaterialChange, this),
                  v.on("remove", this._onMaterialRemove, this),
                  v.resource
                    ? this._onMaterialLoad(v)
                    : this._system.app.assets.load(v));
              }
              _unbindMaterialAsset(v) {
                v.off("load", this._onMaterialLoad, this),
                  v.off("change", this._onMaterialChange, this),
                  v.off("remove", this._onMaterialRemove, this);
              }
              _onMaterialChange() {}
              _onMaterialRemove() {}
              _onTextureAdded(v) {
                this._system.app.assets.off(
                  "add:" + v.id,
                  this._onTextureAdded,
                  this
                ),
                  this._textureAsset === v.id && this._bindTextureAsset(v);
              }
              _bindTextureAsset(v) {
                this._entity.enabled &&
                  (v.on("load", this._onTextureLoad, this),
                  v.on("change", this._onTextureChange, this),
                  v.on("remove", this._onTextureRemove, this),
                  v.resource
                    ? this._onTextureLoad(v)
                    : this._system.app.assets.load(v));
              }
              _unbindTextureAsset(v) {
                v.off("load", this._onTextureLoad, this),
                  v.off("change", this._onTextureChange, this),
                  v.off("remove", this._onTextureRemove, this);
              }
              _onTextureLoad(v) {
                this.texture = v.resource;
              }
              _onTextureChange(v) {}
              _onTextureRemove(v) {}
              _onSpriteAssetAdded(v) {
                this._system.app.assets.off(
                  "add:" + v.id,
                  this._onSpriteAssetAdded,
                  this
                ),
                  this._spriteAsset === v.id && this._bindSpriteAsset(v);
              }
              _bindSpriteAsset(v) {
                this._entity.enabled &&
                  (v.on("load", this._onSpriteAssetLoad, this),
                  v.on("change", this._onSpriteAssetChange, this),
                  v.on("remove", this._onSpriteAssetRemove, this),
                  v.resource
                    ? this._onSpriteAssetLoad(v)
                    : this._system.app.assets.load(v));
              }
              _unbindSpriteAsset(v) {
                v.off("load", this._onSpriteAssetLoad, this),
                  v.off("change", this._onSpriteAssetChange, this),
                  v.off("remove", this._onSpriteAssetRemove, this),
                  v.data.textureAtlasAsset &&
                    this._system.app.assets.off(
                      "load:" + v.data.textureAtlasAsset,
                      this._onTextureAtlasLoad,
                      this
                    );
              }
              _onSpriteAssetLoad(v) {
                if (!v || !v.resource) this.sprite = null;
                else if (v.resource.atlas) this.sprite = v.resource;
                else {
                  const P = v.data.textureAtlasAsset;
                  if (P) {
                    const I = this._system.app.assets;
                    I.off("load:" + P, this._onTextureAtlasLoad, this),
                      I.once("load:" + P, this._onTextureAtlasLoad, this);
                  }
                }
              }
              _onSpriteAssetChange(v) {
                this._onSpriteAssetLoad(v);
              }
              _onSpriteAssetRemove(v) {}
              _bindSprite(v) {
                v.on("set:meshes", this._onSpriteMeshesChange, this),
                  v.on("set:pixelsPerUnit", this._onSpritePpuChange, this),
                  v.on("set:atlas", this._onAtlasTextureChange, this),
                  v.atlas &&
                    v.atlas.on("set:texture", this._onAtlasTextureChange, this);
              }
              _unbindSprite(v) {
                v.off("set:meshes", this._onSpriteMeshesChange, this),
                  v.off("set:pixelsPerUnit", this._onSpritePpuChange, this),
                  v.off("set:atlas", this._onAtlasTextureChange, this),
                  v.atlas &&
                    v.atlas.off(
                      "set:texture",
                      this._onAtlasTextureChange,
                      this
                    );
              }
              _onSpriteMeshesChange() {
                this._sprite &&
                  (this._spriteFrame = x.m.clamp(
                    this._spriteFrame,
                    0,
                    this._sprite.frameKeys.length - 1
                  )),
                  this._updateSprite();
              }
              _onSpritePpuChange() {
                this.sprite.renderMode !== n._r &&
                  this._pixelsPerUnit === null &&
                  this._updateSprite();
              }
              _onAtlasTextureChange() {
                this.sprite && this.sprite.atlas && this.sprite.atlas.texture
                  ? (this._renderable.setParameter(
                      "texture_emissiveMap",
                      this._sprite.atlas.texture
                    ),
                    this._renderable.setParameter(
                      "texture_opacityMap",
                      this._sprite.atlas.texture
                    ))
                  : (this._renderable.deleteParameter("texture_emissiveMap"),
                    this._renderable.deleteParameter("texture_opacityMap"));
              }
              _onTextureAtlasLoad(v) {
                const P = this._spriteAsset;
                P instanceof y.x
                  ? this._onSpriteAssetLoad(P)
                  : this._onSpriteAssetLoad(this._system.app.assets.get(P));
              }
              onEnable() {
                if (this._materialAsset) {
                  const v = this._system.app.assets.get(this._materialAsset);
                  v &&
                    v.resource !== this._material &&
                    this._bindMaterialAsset(v);
                }
                if (this._textureAsset) {
                  const v = this._system.app.assets.get(this._textureAsset);
                  v &&
                    v.resource !== this._texture &&
                    this._bindTextureAsset(v);
                }
                if (this._spriteAsset) {
                  const v = this._system.app.assets.get(this._spriteAsset);
                  v && v.resource !== this._sprite && this._bindSpriteAsset(v);
                }
                this._element.addModelToLayers(this._renderable.model);
              }
              onDisable() {
                this._element.removeModelFromLayers(this._renderable.model);
              }
              _setStencil(v) {
                (this._renderable.meshInstance.stencilFront = v),
                  (this._renderable.meshInstance.stencilBack = v);
                let P = 0;
                if (
                  (this._element.maskedBy &&
                    (P = this._element.maskedBy.element._image._maskRef),
                  this._renderable.unmaskMeshInstance)
                ) {
                  const I = new r.p({ ref: P + 1, func: h._v4, zpass: h.A8C });
                  (this._renderable.unmaskMeshInstance.stencilFront = I),
                    (this._renderable.unmaskMeshInstance.stencilBack = I);
                }
              }
              set color(v) {
                const P = v.r,
                  I = v.g,
                  A = v.b;
                (this._color.r !== P ||
                  this._color.g !== I ||
                  this._color.b !== A) &&
                  ((this._color.r = P),
                  (this._color.g = I),
                  (this._color.b = A),
                  (this._colorUniform[0] = P),
                  (this._colorUniform[1] = I),
                  (this._colorUniform[2] = A),
                  this._renderable.setParameter(
                    "material_emissive",
                    this._colorUniform
                  )),
                  this._element && this._element.fire("set:color", this._color);
              }
              get color() {
                return this._color;
              }
              set opacity(v) {
                v !== this._color.a &&
                  ((this._color.a = v),
                  this._renderable.setParameter("material_opacity", v)),
                  this._element && this._element.fire("set:opacity", v);
              }
              get opacity() {
                return this._color.a;
              }
              set rect(v) {
                let P, I, A, B;
                v instanceof d.T
                  ? ((P = v.x), (I = v.y), (A = v.z), (B = v.w))
                  : ((P = v[0]), (I = v[1]), (A = v[2]), (B = v[3])),
                  !(
                    P === this._rect.x &&
                    I === this._rect.y &&
                    A === this._rect.z &&
                    B === this._rect.w
                  ) &&
                    (this._rect.set(P, I, A, B),
                    this._renderable.mesh &&
                      (this._element._beingInitialized
                        ? (this._meshDirty = !0)
                        : this._updateMesh(this._renderable.mesh)));
              }
              get rect() {
                return this._rect;
              }
              _removeMaterialAssetEvents() {
                if (this._materialAsset) {
                  const v = this._system.app.assets;
                  v.off(
                    "add:" + this._materialAsset,
                    this._onMaterialAdded,
                    this
                  );
                  const P = v.get(this._materialAsset);
                  P &&
                    (P.off("load", this._onMaterialLoad, this),
                    P.off("change", this._onMaterialChange, this),
                    P.off("remove", this._onMaterialRemove, this));
                }
              }
              set material(v) {
                if (this._material !== v) {
                  if (!v) {
                    const P = this._element._isScreenSpace();
                    this.mask
                      ? (v = P
                          ? this._system.defaultScreenSpaceImageMaskMaterial
                          : this._system.defaultImageMaskMaterial)
                      : (v = P
                          ? this._system.defaultScreenSpaceImageMaterial
                          : this._system.defaultImageMaterial);
                  }
                  if (((this._material = v), this._materialAsset)) {
                    const P = this._system.app.assets.get(this._materialAsset);
                    (!P || P.resource !== v) &&
                      (this._removeMaterialAssetEvents(),
                      (this._materialAsset = null));
                  }
                  v &&
                    (this._renderable.setMaterial(v),
                    this._hasUserMaterial()
                      ? (this._renderable.deleteParameter("material_opacity"),
                        this._renderable.deleteParameter("material_emissive"))
                      : ((this._colorUniform[0] = this._color.r),
                        (this._colorUniform[1] = this._color.g),
                        (this._colorUniform[2] = this._color.b),
                        this._renderable.setParameter(
                          "material_emissive",
                          this._colorUniform
                        ),
                        this._renderable.setParameter(
                          "material_opacity",
                          this._color.a
                        )));
                }
              }
              get material() {
                return this._material;
              }
              set materialAsset(v) {
                const P = this._system.app.assets;
                let I = v;
                if ((v instanceof y.x && (I = v.id), this._materialAsset !== I))
                  if (
                    (this._removeMaterialAssetEvents(),
                    (this._materialAsset = I),
                    this._materialAsset)
                  ) {
                    const A = P.get(this._materialAsset);
                    A
                      ? this._bindMaterialAsset(A)
                      : ((this._materialAsset = null),
                        (this.material = null),
                        (this._materialAsset = I),
                        P.on(
                          "add:" + this._materialAsset,
                          this._onMaterialAdded,
                          this
                        ));
                  } else
                    (this._materialAsset = null),
                      (this.material = null),
                      (this._materialAsset = I);
              }
              get materialAsset() {
                return this._materialAsset;
              }
              set texture(v) {
                if (this._texture !== v) {
                  if (this._textureAsset) {
                    const P = this._system.app.assets.get(this._textureAsset);
                    P && P.resource !== v && (this.textureAsset = null);
                  }
                  if (((this._texture = v), v)) {
                    this._spriteAsset && (this.spriteAsset = null),
                      this._renderable.setParameter(
                        "texture_emissiveMap",
                        this._texture
                      ),
                      this._renderable.setParameter(
                        "texture_opacityMap",
                        this._texture
                      ),
                      (this._colorUniform[0] = this._color.r),
                      (this._colorUniform[1] = this._color.g),
                      (this._colorUniform[2] = this._color.b),
                      this._renderable.setParameter(
                        "material_emissive",
                        this._colorUniform
                      ),
                      this._renderable.setParameter(
                        "material_opacity",
                        this._color.a
                      );
                    const P = this._texture.width / this._texture.height;
                    P !== this._targetAspectRatio &&
                      ((this._targetAspectRatio = P),
                      this._element.fitMode !== u.gc && this.refreshMesh());
                  } else
                    this._renderable.deleteParameter("texture_emissiveMap"),
                      this._renderable.deleteParameter("texture_opacityMap"),
                      (this._targetAspectRatio = -1),
                      this._element.fitMode !== u.gc && this.refreshMesh();
                }
              }
              get texture() {
                return this._texture;
              }
              set textureAsset(v) {
                const P = this._system.app.assets;
                let I = v;
                if (
                  (v instanceof y.x && (I = v.id), this._textureAsset !== I)
                ) {
                  if (this._textureAsset) {
                    P.off(
                      "add:" + this._textureAsset,
                      this._onTextureAdded,
                      this
                    );
                    const A = P.get(this._textureAsset);
                    A &&
                      (A.off("load", this._onTextureLoad, this),
                      A.off("change", this._onTextureChange, this),
                      A.off("remove", this._onTextureRemove, this));
                  }
                  if (((this._textureAsset = I), this._textureAsset)) {
                    const A = P.get(this._textureAsset);
                    A
                      ? this._bindTextureAsset(A)
                      : ((this.texture = null),
                        P.on(
                          "add:" + this._textureAsset,
                          this._onTextureAdded,
                          this
                        ));
                  } else this.texture = null;
                }
              }
              get textureAsset() {
                return this._textureAsset;
              }
              set spriteAsset(v) {
                const P = this._system.app.assets;
                let I = v;
                if ((v instanceof y.x && (I = v.id), this._spriteAsset !== I)) {
                  if (this._spriteAsset) {
                    P.off(
                      "add:" + this._spriteAsset,
                      this._onSpriteAssetAdded,
                      this
                    );
                    const A = P.get(this._spriteAsset);
                    A && this._unbindSpriteAsset(A);
                  }
                  if (((this._spriteAsset = I), this._spriteAsset)) {
                    const A = P.get(this._spriteAsset);
                    A
                      ? this._bindSpriteAsset(A)
                      : ((this.sprite = null),
                        P.on(
                          "add:" + this._spriteAsset,
                          this._onSpriteAssetAdded,
                          this
                        ));
                  } else this.sprite = null;
                }
                this._element && this._element.fire("set:spriteAsset", I);
              }
              get spriteAsset() {
                return this._spriteAsset;
              }
              set sprite(v) {
                if (this._sprite !== v) {
                  if (
                    (this._sprite && this._unbindSprite(this._sprite),
                    this._spriteAsset)
                  ) {
                    const P = this._system.app.assets.get(this._spriteAsset);
                    P && P.resource !== v && (this.spriteAsset = null);
                  }
                  (this._sprite = v),
                    this._sprite &&
                      (this._bindSprite(this._sprite),
                      this._textureAsset && (this.textureAsset = null)),
                    this._sprite &&
                    this._sprite.atlas &&
                    this._sprite.atlas.texture
                      ? (this._renderable.setParameter(
                          "texture_emissiveMap",
                          this._sprite.atlas.texture
                        ),
                        this._renderable.setParameter(
                          "texture_opacityMap",
                          this._sprite.atlas.texture
                        ))
                      : (this._renderable.deleteParameter(
                          "texture_emissiveMap"
                        ),
                        this._renderable.deleteParameter("texture_opacityMap")),
                    this._sprite &&
                      (this._spriteFrame = x.m.clamp(
                        this._spriteFrame,
                        0,
                        this._sprite.frameKeys.length - 1
                      )),
                    this._updateSprite();
                }
              }
              get sprite() {
                return this._sprite;
              }
              set spriteFrame(v) {
                const P = this._spriteFrame;
                this._sprite
                  ? (this._spriteFrame = x.m.clamp(
                      v,
                      0,
                      this._sprite.frameKeys.length - 1
                    ))
                  : (this._spriteFrame = v),
                  this._spriteFrame !== P && this._updateSprite(),
                  this._element && this._element.fire("set:spriteFrame", v);
              }
              get spriteFrame() {
                return this._spriteFrame;
              }
              set mesh(v) {
                this._renderable.setMesh(v),
                  this._defaultMesh === v
                    ? this._renderable.setAabbFunc(null)
                    : this._renderable.setAabbFunc(this._updateAabbFunc);
              }
              get mesh() {
                return this._renderable.mesh;
              }
              set mask(v) {
                this._mask !== v && ((this._mask = v), this._toggleMask());
              }
              get mask() {
                return this._mask;
              }
              set pixelsPerUnit(v) {
                this._pixelsPerUnit !== v &&
                  ((this._pixelsPerUnit = v),
                  this._sprite &&
                    (this._sprite.renderMode === n.ei ||
                      this._sprite.renderMode === n.DD) &&
                    this._updateSprite());
              }
              get pixelsPerUnit() {
                return this._pixelsPerUnit;
              }
              get aabb() {
                return this._renderable.meshInstance
                  ? this._renderable.meshInstance.aabb
                  : null;
              }
            }
          },
          7627: (Se, W, a) => {
            "use strict";
            a.d(W, { h: () => t });
            var x = a(1367),
              T = a(2978),
              g = a(6630),
              c = a(7921),
              d = a(8869),
              h = a(3114),
              f = a(8944),
              s = a(8620),
              l = a(6813),
              n = a(3404),
              o = a(7964);
            class i {
              constructor() {
                this.enabled = !0;
              }
            }
            const e = ["enabled"];
            class t extends l.Q {
              constructor(u) {
                super(u),
                  (this.id = "element"),
                  (this.ComponentType = o.o),
                  (this.DataType = i),
                  (this.schema = e),
                  (this._unicodeConverter = null),
                  (this._rtlReorder = null),
                  (this._defaultTexture = new d.x(u.graphicsDevice, {
                    width: 1,
                    height: 1,
                    format: c.jKI,
                    name: "element-system",
                  }));
                const y = this._defaultTexture.lock(),
                  p = new Uint8Array(4);
                (p[0] = 255),
                  (p[1] = 255),
                  (p[2] = 255),
                  (p[3] = 255),
                  y.set(p),
                  this._defaultTexture.unlock(),
                  (this.defaultImageMaterial = null),
                  (this.defaultImage9SlicedMaterial = null),
                  (this.defaultImage9TiledMaterial = null),
                  (this.defaultImageMaskMaterial = null),
                  (this.defaultImage9SlicedMaskMaterial = null),
                  (this.defaultImage9TiledMaskMaterial = null),
                  (this.defaultScreenSpaceImageMaterial = null),
                  (this.defaultScreenSpaceImage9SlicedMaterial = null),
                  (this.defaultScreenSpaceImage9TiledMaterial = null),
                  (this.defaultScreenSpaceImageMask9SlicedMaterial = null),
                  (this.defaultScreenSpaceImageMask9TiledMaterial = null),
                  (this.defaultScreenSpaceImageMaskMaterial = null),
                  (this._defaultTextMaterials = {}),
                  (this.defaultImageMaterials = []),
                  this.on("beforeremove", this.onRemoveComponent, this);
              }
              destroy() {
                super.destroy(), this._defaultTexture.destroy();
              }
              initializeComponentData(u, y, p) {
                (u._beingInitialized = !0),
                  y.anchor !== void 0 &&
                    (y.anchor instanceof g.T
                      ? u.anchor.copy(y.anchor)
                      : u.anchor.set(
                          y.anchor[0],
                          y.anchor[1],
                          y.anchor[2],
                          y.anchor[3]
                        )),
                  y.pivot !== void 0 &&
                    (y.pivot instanceof T.S
                      ? u.pivot.copy(y.pivot)
                      : u.pivot.set(y.pivot[0], y.pivot[1]));
                const _ = Math.abs(u.anchor.x - u.anchor.z) > 0.001,
                  m = Math.abs(u.anchor.y - u.anchor.w) > 0.001;
                let E = !1,
                  v;
                y.margin !== void 0 &&
                  (y.margin instanceof g.T
                    ? u.margin.copy(y.margin)
                    : u._margin.set(
                        y.margin[0],
                        y.margin[1],
                        y.margin[2],
                        y.margin[3]
                      ),
                  (E = !0)),
                  y.left !== void 0 && ((u._margin.x = y.left), (E = !0)),
                  y.bottom !== void 0 && ((u._margin.y = y.bottom), (E = !0)),
                  y.right !== void 0 && ((u._margin.z = y.right), (E = !0)),
                  y.top !== void 0 && ((u._margin.w = y.top), (E = !0)),
                  E && (u.margin = u._margin);
                let P = !1;
                y.width !== void 0 && !_ ? (u.width = y.width) : _ && (P = !0),
                  y.height !== void 0 && !m
                    ? (u.height = y.height)
                    : m && (P = !0),
                  P && (u.anchor = u.anchor),
                  y.enabled !== void 0 && (u.enabled = y.enabled),
                  y.useInput !== void 0 && (u.useInput = y.useInput),
                  y.fitMode !== void 0 && (u.fitMode = y.fitMode),
                  (u.batchGroupId =
                    y.batchGroupId === void 0 || y.batchGroupId === null
                      ? -1
                      : y.batchGroupId),
                  y.layers &&
                    Array.isArray(y.layers) &&
                    (u.layers = y.layers.slice(0)),
                  y.type !== void 0 && (u.type = y.type),
                  u.type === n.rf
                    ? (y.rect !== void 0 && (u.rect = y.rect),
                      y.color !== void 0 &&
                        ((v = y.color),
                        v instanceof x.I ||
                          (v = new x.I(y.color[0], y.color[1], y.color[2])),
                        (u.color = v)),
                      y.opacity !== void 0 && (u.opacity = y.opacity),
                      y.textureAsset !== void 0 &&
                        (u.textureAsset = y.textureAsset),
                      y.texture && (u.texture = y.texture),
                      y.spriteAsset !== void 0 &&
                        (u.spriteAsset = y.spriteAsset),
                      y.sprite && (u.sprite = y.sprite),
                      y.spriteFrame !== void 0 &&
                        (u.spriteFrame = y.spriteFrame),
                      y.pixelsPerUnit !== void 0 &&
                        y.pixelsPerUnit !== null &&
                        (u.pixelsPerUnit = y.pixelsPerUnit),
                      y.materialAsset !== void 0 &&
                        (u.materialAsset = y.materialAsset),
                      y.material && (u.material = y.material),
                      y.mask !== void 0 && (u.mask = y.mask))
                    : u.type === n.l2 &&
                      (y.autoWidth !== void 0 && (u.autoWidth = y.autoWidth),
                      y.autoHeight !== void 0 && (u.autoHeight = y.autoHeight),
                      y.rtlReorder !== void 0 && (u.rtlReorder = y.rtlReorder),
                      y.unicodeConverter !== void 0 &&
                        (u.unicodeConverter = y.unicodeConverter),
                      y.text !== null && y.text !== void 0
                        ? (u.text = y.text)
                        : y.key !== null && y.key !== void 0 && (u.key = y.key),
                      y.color !== void 0 &&
                        ((v = y.color),
                        v instanceof x.I || (v = new x.I(v[0], v[1], v[2])),
                        (u.color = v)),
                      y.opacity !== void 0 && (u.opacity = y.opacity),
                      y.spacing !== void 0 && (u.spacing = y.spacing),
                      y.fontSize !== void 0 &&
                        ((u.fontSize = y.fontSize),
                        y.lineHeight || (u.lineHeight = y.fontSize)),
                      y.lineHeight !== void 0 && (u.lineHeight = y.lineHeight),
                      y.maxLines !== void 0 && (u.maxLines = y.maxLines),
                      y.wrapLines !== void 0 && (u.wrapLines = y.wrapLines),
                      y.minFontSize !== void 0 &&
                        (u.minFontSize = y.minFontSize),
                      y.maxFontSize !== void 0 &&
                        (u.maxFontSize = y.maxFontSize),
                      y.autoFitWidth && (u.autoFitWidth = y.autoFitWidth),
                      y.autoFitHeight && (u.autoFitHeight = y.autoFitHeight),
                      y.fontAsset !== void 0 && (u.fontAsset = y.fontAsset),
                      y.font !== void 0 && (u.font = y.font),
                      y.alignment !== void 0 && (u.alignment = y.alignment),
                      y.outlineColor !== void 0 &&
                        (u.outlineColor = y.outlineColor),
                      y.outlineThickness !== void 0 &&
                        (u.outlineThickness = y.outlineThickness),
                      y.shadowColor !== void 0 &&
                        (u.shadowColor = y.shadowColor),
                      y.shadowOffset !== void 0 &&
                        (u.shadowOffset = y.shadowOffset),
                      y.enableMarkup !== void 0 &&
                        (u.enableMarkup = y.enableMarkup));
                const I = u._parseUpToScreen();
                I.screen && u._updateScreen(I.screen),
                  super.initializeComponentData(u, y, p),
                  (u._beingInitialized = !1),
                  u.type === n.rf &&
                    u._image._meshDirty &&
                    u._image._updateMesh(u._image.mesh);
              }
              onRemoveComponent(u, y) {
                y.onRemove();
              }
              cloneComponent(u, y) {
                const p = u.element,
                  _ = {
                    enabled: p.enabled,
                    width: p.width,
                    height: p.height,
                    anchor: p.anchor.clone(),
                    pivot: p.pivot.clone(),
                    margin: p.margin.clone(),
                    alignment:
                      (p.alignment && p.alignment.clone()) || p.alignment,
                    autoWidth: p.autoWidth,
                    autoHeight: p.autoHeight,
                    type: p.type,
                    rect: (p.rect && p.rect.clone()) || p.rect,
                    rtlReorder: p.rtlReorder,
                    unicodeConverter: p.unicodeConverter,
                    materialAsset: p.materialAsset,
                    material: p.material,
                    color: (p.color && p.color.clone()) || p.color,
                    opacity: p.opacity,
                    textureAsset: p.textureAsset,
                    texture: p.texture,
                    spriteAsset: p.spriteAsset,
                    sprite: p.sprite,
                    spriteFrame: p.spriteFrame,
                    pixelsPerUnit: p.pixelsPerUnit,
                    spacing: p.spacing,
                    lineHeight: p.lineHeight,
                    wrapLines: p.wrapLines,
                    layers: p.layers,
                    fontSize: p.fontSize,
                    minFontSize: p.minFontSize,
                    maxFontSize: p.maxFontSize,
                    autoFitWidth: p.autoFitWidth,
                    autoFitHeight: p.autoFitHeight,
                    maxLines: p.maxLines,
                    fontAsset: p.fontAsset,
                    font: p.font,
                    useInput: p.useInput,
                    fitMode: p.fitMode,
                    batchGroupId: p.batchGroupId,
                    mask: p.mask,
                    outlineColor:
                      (p.outlineColor && p.outlineColor.clone()) ||
                      p.outlineColor,
                    outlineThickness: p.outlineThickness,
                    shadowColor:
                      (p.shadowColor && p.shadowColor.clone()) || p.shadowColor,
                    shadowOffset:
                      (p.shadowOffset && p.shadowOffset.clone()) ||
                      p.shadowOffset,
                    enableMarkup: p.enableMarkup,
                  };
                return (
                  p.key !== void 0 && p.key !== null
                    ? (_.key = p.key)
                    : (_.text = p.text),
                  this.addComponent(y, _)
                );
              }
              getTextElementMaterial(u, y, p) {
                const _ = (u && 1) | (y && 2) | (p && 4);
                let m = this._defaultTextMaterials[_];
                if (m) return m;
                let E = "TextMaterial";
                return (
                  (m = new f.K()),
                  y
                    ? ((m.msdfMap = this._defaultTexture),
                      (m.msdfTextAttribute = p),
                      m.emissive.set(1, 1, 1))
                    : ((E = "Bitmap" + E),
                      m.emissive.set(0.5, 0.5, 0.5),
                      (m.emissiveMap = this._defaultTexture),
                      (m.emissiveTint = !0),
                      (m.opacityMap = this._defaultTexture),
                      (m.opacityMapChannel = "a")),
                  u && ((E = "ScreenSpace" + E), (m.depthTest = !1)),
                  (m.name = "default" + E),
                  (m.useLighting = !1),
                  (m.useGammaTonemap = !1),
                  (m.useFog = !1),
                  (m.useSkybox = !1),
                  m.diffuse.set(0, 0, 0),
                  (m.opacity = 0.5),
                  (m.blendType = h.yp),
                  (m.depthWrite = !1),
                  (m.emissiveVertexColor = !0),
                  m.update(),
                  (this._defaultTextMaterials[_] = m),
                  m
                );
              }
              _createBaseImageMaterial() {
                const u = new f.K();
                return (
                  u.diffuse.set(0, 0, 0),
                  u.emissive.set(0.5, 0.5, 0.5),
                  (u.emissiveMap = this._defaultTexture),
                  (u.emissiveTint = !0),
                  (u.opacityMap = this._defaultTexture),
                  (u.opacityMapChannel = "a"),
                  (u.opacityTint = !0),
                  (u.opacity = 0),
                  (u.useLighting = !1),
                  (u.useGammaTonemap = !1),
                  (u.useFog = !1),
                  (u.useSkybox = !1),
                  (u.blendType = h.yp),
                  (u.depthWrite = !1),
                  u
                );
              }
              getImageElementMaterial(u, y, p, _) {
                return u
                  ? y
                    ? p
                      ? (this.defaultScreenSpaceImageMask9SlicedMaterial ||
                          ((this.defaultScreenSpaceImageMask9SlicedMaterial =
                            this._createBaseImageMaterial()),
                          (this.defaultScreenSpaceImageMask9SlicedMaterial.name =
                            "defaultScreenSpaceImageMask9SlicedMaterial"),
                          (this.defaultScreenSpaceImageMask9SlicedMaterial.nineSlicedMode =
                            h.ei),
                          (this.defaultScreenSpaceImageMask9SlicedMaterial.depthTest =
                            !1),
                          (this.defaultScreenSpaceImageMask9SlicedMaterial.alphaTest = 1),
                          (this.defaultScreenSpaceImageMask9SlicedMaterial.redWrite =
                            !1),
                          (this.defaultScreenSpaceImageMask9SlicedMaterial.greenWrite =
                            !1),
                          (this.defaultScreenSpaceImageMask9SlicedMaterial.blueWrite =
                            !1),
                          (this.defaultScreenSpaceImageMask9SlicedMaterial.alphaWrite =
                            !1),
                          this.defaultScreenSpaceImageMask9SlicedMaterial.update(),
                          this.defaultImageMaterials.push(
                            this.defaultScreenSpaceImageMask9SlicedMaterial
                          )),
                        this.defaultScreenSpaceImageMask9SlicedMaterial)
                      : _
                      ? (this.defaultScreenSpaceImageMask9TiledMaterial ||
                          ((this.defaultScreenSpaceImageMask9TiledMaterial =
                            this.defaultScreenSpaceImage9TiledMaterial.clone()),
                          (this.defaultScreenSpaceImageMask9TiledMaterial.name =
                            "defaultScreenSpaceImageMask9TiledMaterial"),
                          (this.defaultScreenSpaceImageMask9TiledMaterial.nineSlicedMode =
                            h.DD),
                          (this.defaultScreenSpaceImageMask9TiledMaterial.depthTest =
                            !1),
                          (this.defaultScreenSpaceImageMask9TiledMaterial.alphaTest = 1),
                          (this.defaultScreenSpaceImageMask9TiledMaterial.redWrite =
                            !1),
                          (this.defaultScreenSpaceImageMask9TiledMaterial.greenWrite =
                            !1),
                          (this.defaultScreenSpaceImageMask9TiledMaterial.blueWrite =
                            !1),
                          (this.defaultScreenSpaceImageMask9TiledMaterial.alphaWrite =
                            !1),
                          this.defaultScreenSpaceImageMask9TiledMaterial.update(),
                          this.defaultImageMaterials.push(
                            this.defaultScreenSpaceImageMask9TiledMaterial
                          )),
                        this.defaultScreenSpaceImageMask9TiledMaterial)
                      : (this.defaultScreenSpaceImageMaskMaterial ||
                          ((this.defaultScreenSpaceImageMaskMaterial =
                            this._createBaseImageMaterial()),
                          (this.defaultScreenSpaceImageMaskMaterial.name =
                            "defaultScreenSpaceImageMaskMaterial"),
                          (this.defaultScreenSpaceImageMaskMaterial.depthTest =
                            !1),
                          (this.defaultScreenSpaceImageMaskMaterial.alphaTest = 1),
                          (this.defaultScreenSpaceImageMaskMaterial.redWrite =
                            !1),
                          (this.defaultScreenSpaceImageMaskMaterial.greenWrite =
                            !1),
                          (this.defaultScreenSpaceImageMaskMaterial.blueWrite =
                            !1),
                          (this.defaultScreenSpaceImageMaskMaterial.alphaWrite =
                            !1),
                          this.defaultScreenSpaceImageMaskMaterial.update(),
                          this.defaultImageMaterials.push(
                            this.defaultScreenSpaceImageMaskMaterial
                          )),
                        this.defaultScreenSpaceImageMaskMaterial)
                    : p
                    ? (this.defaultScreenSpaceImage9SlicedMaterial ||
                        ((this.defaultScreenSpaceImage9SlicedMaterial =
                          this._createBaseImageMaterial()),
                        (this.defaultScreenSpaceImage9SlicedMaterial.name =
                          "defaultScreenSpaceImage9SlicedMaterial"),
                        (this.defaultScreenSpaceImage9SlicedMaterial.nineSlicedMode =
                          h.ei),
                        (this.defaultScreenSpaceImage9SlicedMaterial.depthTest =
                          !1),
                        this.defaultScreenSpaceImage9SlicedMaterial.update(),
                        this.defaultImageMaterials.push(
                          this.defaultScreenSpaceImage9SlicedMaterial
                        )),
                      this.defaultScreenSpaceImage9SlicedMaterial)
                    : _
                    ? (this.defaultScreenSpaceImage9TiledMaterial ||
                        ((this.defaultScreenSpaceImage9TiledMaterial =
                          this._createBaseImageMaterial()),
                        (this.defaultScreenSpaceImage9TiledMaterial.name =
                          "defaultScreenSpaceImage9TiledMaterial"),
                        (this.defaultScreenSpaceImage9TiledMaterial.nineSlicedMode =
                          h.DD),
                        (this.defaultScreenSpaceImage9TiledMaterial.depthTest =
                          !1),
                        this.defaultScreenSpaceImage9TiledMaterial.update(),
                        this.defaultImageMaterials.push(
                          this.defaultScreenSpaceImage9TiledMaterial
                        )),
                      this.defaultScreenSpaceImage9TiledMaterial)
                    : (this.defaultScreenSpaceImageMaterial ||
                        ((this.defaultScreenSpaceImageMaterial =
                          this._createBaseImageMaterial()),
                        (this.defaultScreenSpaceImageMaterial.name =
                          "defaultScreenSpaceImageMaterial"),
                        (this.defaultScreenSpaceImageMaterial.depthTest = !1),
                        this.defaultScreenSpaceImageMaterial.update(),
                        this.defaultImageMaterials.push(
                          this.defaultScreenSpaceImageMaterial
                        )),
                      this.defaultScreenSpaceImageMaterial)
                  : y
                  ? p
                    ? (this.defaultImage9SlicedMaskMaterial ||
                        ((this.defaultImage9SlicedMaskMaterial =
                          this._createBaseImageMaterial()),
                        (this.defaultImage9SlicedMaskMaterial.name =
                          "defaultImage9SlicedMaskMaterial"),
                        (this.defaultImage9SlicedMaskMaterial.nineSlicedMode =
                          h.ei),
                        (this.defaultImage9SlicedMaskMaterial.alphaTest = 1),
                        (this.defaultImage9SlicedMaskMaterial.redWrite = !1),
                        (this.defaultImage9SlicedMaskMaterial.greenWrite = !1),
                        (this.defaultImage9SlicedMaskMaterial.blueWrite = !1),
                        (this.defaultImage9SlicedMaskMaterial.alphaWrite = !1),
                        this.defaultImage9SlicedMaskMaterial.update(),
                        this.defaultImageMaterials.push(
                          this.defaultImage9SlicedMaskMaterial
                        )),
                      this.defaultImage9SlicedMaskMaterial)
                    : _
                    ? (this.defaultImage9TiledMaskMaterial ||
                        ((this.defaultImage9TiledMaskMaterial =
                          this._createBaseImageMaterial()),
                        (this.defaultImage9TiledMaskMaterial.name =
                          "defaultImage9TiledMaskMaterial"),
                        (this.defaultImage9TiledMaskMaterial.nineSlicedMode =
                          h.DD),
                        (this.defaultImage9TiledMaskMaterial.alphaTest = 1),
                        (this.defaultImage9TiledMaskMaterial.redWrite = !1),
                        (this.defaultImage9TiledMaskMaterial.greenWrite = !1),
                        (this.defaultImage9TiledMaskMaterial.blueWrite = !1),
                        (this.defaultImage9TiledMaskMaterial.alphaWrite = !1),
                        this.defaultImage9TiledMaskMaterial.update(),
                        this.defaultImageMaterials.push(
                          this.defaultImage9TiledMaskMaterial
                        )),
                      this.defaultImage9TiledMaskMaterial)
                    : (this.defaultImageMaskMaterial ||
                        ((this.defaultImageMaskMaterial =
                          this._createBaseImageMaterial()),
                        (this.defaultImageMaskMaterial.name =
                          "defaultImageMaskMaterial"),
                        (this.defaultImageMaskMaterial.alphaTest = 1),
                        (this.defaultImageMaskMaterial.redWrite = !1),
                        (this.defaultImageMaskMaterial.greenWrite = !1),
                        (this.defaultImageMaskMaterial.blueWrite = !1),
                        (this.defaultImageMaskMaterial.alphaWrite = !1),
                        this.defaultImageMaskMaterial.update(),
                        this.defaultImageMaterials.push(
                          this.defaultImageMaskMaterial
                        )),
                      this.defaultImageMaskMaterial)
                  : p
                  ? (this.defaultImage9SlicedMaterial ||
                      ((this.defaultImage9SlicedMaterial =
                        this._createBaseImageMaterial()),
                      (this.defaultImage9SlicedMaterial.name =
                        "defaultImage9SlicedMaterial"),
                      (this.defaultImage9SlicedMaterial.nineSlicedMode = h.ei),
                      this.defaultImage9SlicedMaterial.update(),
                      this.defaultImageMaterials.push(
                        this.defaultImage9SlicedMaterial
                      )),
                    this.defaultImage9SlicedMaterial)
                  : _
                  ? (this.defaultImage9TiledMaterial ||
                      ((this.defaultImage9TiledMaterial =
                        this._createBaseImageMaterial()),
                      (this.defaultImage9TiledMaterial.name =
                        "defaultImage9TiledMaterial"),
                      (this.defaultImage9TiledMaterial.nineSlicedMode = h.DD),
                      this.defaultImage9TiledMaterial.update(),
                      this.defaultImageMaterials.push(
                        this.defaultImage9TiledMaterial
                      )),
                    this.defaultImage9TiledMaterial)
                  : (this.defaultImageMaterial ||
                      ((this.defaultImageMaterial =
                        this._createBaseImageMaterial()),
                      (this.defaultImageMaterial.name = "defaultImageMaterial"),
                      this.defaultImageMaterial.update(),
                      this.defaultImageMaterials.push(
                        this.defaultImageMaterial
                      )),
                    this.defaultImageMaterial);
              }
              registerUnicodeConverter(u) {
                this._unicodeConverter = u;
              }
              registerRtlReorder(u) {
                this._rtlReorder = u;
              }
              getUnicodeConverter() {
                return this._unicodeConverter;
              }
              getRtlReorder() {
                return this._rtlReorder;
              }
            }
            s.w._buildAccessors(o.o.prototype, e);
          },
          9409: (Se, W, a) => {
            "use strict";
            a.d(W, { G: () => J });
            var x = a(9351),
              T = a(4585),
              g = a(1367),
              c = a(2978),
              d = a(3148),
              h = a(7921),
              f = a(6938),
              s = a(7915),
              l = a(8792),
              n = a(9915),
              o = a(7678),
              i = a(2416),
              e = a(5611);
            const t = 0,
              r = 1,
              u = 2,
              y = 3,
              p = 4,
              _ = 5,
              m = 6,
              E = 7,
              v = 8,
              P = ` 	
\r\v\f`,
              I = /[A-Z|a-z|0-9|_|-|/]/;
            class A {
              constructor(R) {
                (this._symbols = R),
                  (this._index = 0),
                  (this._last = 0),
                  (this._cur =
                    this._symbols.length > 0 ? this._symbols[0] : null),
                  (this._buf = []),
                  (this._mode = "text"),
                  (this._error = null);
              }
              read() {
                let R = this._read();
                for (; R === v; ) R = this._read();
                return R !== t && R !== r && (this._last = this._index), R;
              }
              buf() {
                return this._buf;
              }
              last() {
                return this._last;
              }
              error() {
                return this._error;
              }
              debugPrint() {
                const R = [
                  "EOF",
                  "ERROR",
                  "TEXT",
                  "OPEN_BRACKET",
                  "CLOSE_BRACKET",
                  "EQUALS",
                  "STRING",
                  "IDENTIFIER",
                  "WHITESPACE",
                ];
                let j = this.read(),
                  se = "";
                for (
                  ;
                  (se +=
                    (se.length > 0
                      ? `
`
                      : "") +
                    R[j] +
                    " '" +
                    this.buf().join("") +
                    "'"),
                    !(j === t || j === r);

                )
                  j = this.read();
                return se;
              }
              _read() {
                return (
                  (this._buf = []),
                  this._eof()
                    ? t
                    : this._mode === "text"
                    ? this._text()
                    : this._tag()
                );
              }
              _text() {
                for (;;)
                  switch (this._cur) {
                    case null:
                      return this._buf.length > 0 ? u : t;
                    case "[":
                      return (
                        (this._mode = "tag"),
                        this._buf.length > 0 ? u : this._tag()
                      );
                    case "\\":
                      switch ((this._next(), this._cur)) {
                        case "[":
                          this._store();
                          break;
                        default:
                          this._output("\\");
                          break;
                      }
                      break;
                    default:
                      this._store();
                      break;
                  }
              }
              _tag() {
                switch (this._cur) {
                  case null:
                    return (
                      (this._error = "unexpected end of input reading tag"), r
                    );
                  case "[":
                    return this._store(), y;
                  case "]":
                    return this._store(), (this._mode = "text"), p;
                  case "=":
                    return this._store(), _;
                  case " ":
                  case "	":
                  case `
`:
                  case "\r":
                  case "\v":
                  case "\f":
                    return this._whitespace();
                  case '"':
                    return this._string();
                  default:
                    return this._isIdentifierSymbol(this._cur)
                      ? this._identifier()
                      : ((this._error = "unrecognized character"), r);
                }
              }
              _whitespace() {
                for (this._store(); P.indexOf(this._cur) !== -1; )
                  this._store();
                return v;
              }
              _string() {
                for (this._next(); ; )
                  switch (this._cur) {
                    case null:
                      return (
                        (this._error =
                          "unexpected end of input reading string"),
                        r
                      );
                    case '"':
                      return this._next(), m;
                    default:
                      this._store();
                      break;
                  }
              }
              _identifier() {
                for (
                  this._store();
                  this._cur !== null && this._isIdentifierSymbol(this._cur);

                )
                  this._store();
                return E;
              }
              _isIdentifierSymbol(R) {
                return R.length === 1 && R.match(I) !== null;
              }
              _eof() {
                return this._cur === null;
              }
              _next() {
                return (
                  this._eof() ||
                    (this._index++,
                    (this._cur =
                      this._index < this._symbols.length
                        ? this._symbols[this._index]
                        : null)),
                  this._cur
                );
              }
              _store() {
                return this._buf.push(this._cur), this._next();
              }
              _output(R) {
                this._buf.push(R);
              }
            }
            class B {
              constructor(R) {
                (this._scanner = new A(R)), (this._error = null);
              }
              parse(R, j) {
                for (;;)
                  switch (this._scanner.read()) {
                    case t:
                      return !0;
                    case r:
                      return !1;
                    case u:
                      Array.prototype.push.apply(R, this._scanner.buf());
                      break;
                    case y:
                      if (!this._parseTag(R, j)) return !1;
                      break;
                    default:
                      return !1;
                  }
              }
              error() {
                return (
                  "Error evaluating markup at #" +
                  this._scanner.last().toString() +
                  " (" +
                  (this._scanner.error() || this._error) +
                  ")"
                );
              }
              _parseTag(R, j) {
                let se = this._scanner.read();
                if (se !== E) return (this._error = "expected identifier"), !1;
                const ce = this._scanner.buf().join("");
                if (ce[0] === "/") {
                  for (let b = j.length - 1; b >= 0; --b)
                    if (ce === "/" + j[b].name && j[b].end === null)
                      return (
                        (j[b].end = R.length),
                        (se = this._scanner.read()),
                        se !== p
                          ? ((this._error = "expected close bracket"), !1)
                          : !0
                      );
                  return (this._error = "failed to find matching tag"), !1;
                }
                const ie = {
                  name: ce,
                  value: null,
                  attributes: {},
                  start: R.length,
                  end: null,
                };
                if (((se = this._scanner.read()), se === _)) {
                  if (((se = this._scanner.read()), se !== m))
                    return (this._error = "expected string"), !1;
                  (ie.value = this._scanner.buf().join("")),
                    (se = this._scanner.read());
                }
                for (;;) {
                  switch (se) {
                    case p:
                      return j.push(ie), !0;
                    case E: {
                      const b = this._scanner.buf().join("");
                      if (((se = this._scanner.read()), se !== _))
                        return (this._error = "expected equals"), !1;
                      if (((se = this._scanner.read()), se !== m))
                        return (this._error = "expected string"), !1;
                      const M = this._scanner.buf().join("");
                      ie.attributes[b] = M;
                      break;
                    }
                    default:
                      return (
                        (this._error = "expected close bracket or identifier"),
                        !1
                      );
                  }
                  se = this._scanner.read();
                }
              }
            }
            function C(ae, R) {
              for (const j in R) {
                if (!R.hasOwnProperty(j)) continue;
                const se = R[j];
                se instanceof Object
                  ? (ae.hasOwnProperty(j) || (ae[j] = {}), C(ae[j], R[j]))
                  : (ae[j] = se);
              }
            }
            function w(ae) {
              if (ae.length === 0) return null;
              const R = {};
              for (let j = 0; j < ae.length; ++j) {
                const se = ae[j],
                  ce = {};
                (ce[se.name] = { value: se.value, attributes: se.attributes }),
                  C(R, ce);
              }
              return R;
            }
            function k(ae, R) {
              if (ae.length === 0) return null;
              const j = {};
              for (let oe = 0; oe < ae.length; ++oe) {
                const de = ae[oe];
                j.hasOwnProperty(de.start)
                  ? j[de.start].open === null
                    ? (j[de.start].open = [de])
                    : j[de.start].open.push(de)
                  : (j[de.start] = { open: [de], close: null }),
                  j.hasOwnProperty(de.end)
                    ? j[de.end].close === null
                      ? (j[de.end].close = [de])
                      : j[de.end].close.push(de)
                    : (j[de.end] = { open: null, close: [de] });
              }
              let se = [];
              function ce(oe) {
                se = se.filter(function (de) {
                  return (
                    oe.find(function (ge) {
                      return ge === de;
                    }) === void 0
                  );
                });
              }
              function ie(oe) {
                for (let de = 0; de < oe.length; ++de) se.push(oe[de]);
              }
              const b = Object.keys(j).sort(function (oe, de) {
                  return oe - de;
                }),
                M = [];
              for (let oe = 0; oe < b.length; ++oe) {
                const de = j[b[oe]];
                de.close !== null && ce(de.close),
                  de.open !== null && ie(de.open),
                  M.push({ start: b[oe], tags: w(se) });
              }
              const F = [];
              let z = null;
              for (let oe = 0; oe < M.length; ++oe) {
                const de = M[oe];
                for (; F.length < de.start; ) F.push(z ? z.tags : null);
                z = de;
              }
              for (; F.length < R; ) F.push(null);
              return F;
            }
            function K(ae) {
              const R = new B(ae),
                j = [],
                se = [];
              if (!R.parse(j, se))
                return console.warn(R.error()), { symbols: ae, tags: null };
              const ce = se.find(function (b) {
                return b.end === null;
              });
              if (ce)
                return (
                  console.warn(`Markup error: found unclosed tag='${ce.name}'`),
                  { symbols: ae, tags: null }
                );
              const ie = k(se, j.length);
              return { symbols: j, tags: ie };
            }
            class te {
              static evaluate(R) {
                return K(R);
              }
            }
            class X {
              constructor() {
                (this.count = 0),
                  (this.quad = 0),
                  (this.lines = {}),
                  (this.positions = []),
                  (this.normals = []),
                  (this.uvs = []),
                  (this.colors = []),
                  (this.indices = []),
                  (this.outlines = []),
                  (this.shadows = []),
                  (this.meshInstance = null);
              }
            }
            function $(ae, R) {
              const j = new o.K(ae);
              return (
                j.setPositions(R.positions),
                j.setNormals(R.normals),
                j.setColors32(R.colors),
                j.setUvs(0, R.uvs),
                j.setIndices(R.indices),
                j.setVertexStream(h.syi, R.outlines, 3, void 0, h.r8O, !1),
                j.setVertexStream(h.ScY, R.shadows, 3, void 0, h.r8O, !1),
                j.update(),
                j
              );
            }
            const ne = /^[\r\n]$/,
              Y = /^[ \t]$/,
              Z = /^[ \t\-]|[\u200b]$/,
              ye = /^[a-z0-9]$/i,
              pe =
                /^[\u1100-\u11ff]|[\u3000-\u9fff]|[\ua960-\ua97f]|[\uac00-\ud7ff]$/,
              O =
                /^[]$/,
              me = [
                "\u200B",
                "\u061C",
                "\u200E",
                "\u200F",
                "\u202A",
                "\u202B",
                "\u202C",
                "\u202D",
                "\u202E",
                "\u2066",
                "\u2067",
                "\u2068",
                "\u2069",
              ],
              N = { width: 0, height: 0, xadvance: 0, xoffset: 0, yoffset: 0 },
              V = new g.I(),
              L = new c.S();
            class J {
              constructor(R) {
                (this._element = R),
                  (this._system = R.system),
                  (this._entity = R.entity),
                  (this._text = ""),
                  (this._symbols = []),
                  (this._colorPalette = []),
                  (this._outlinePalette = []),
                  (this._shadowPalette = []),
                  (this._symbolColors = null),
                  (this._symbolOutlineParams = null),
                  (this._symbolShadowParams = null),
                  (this._i18nKey = null),
                  (this._fontAsset = new i.E(this._system.app)),
                  (this._fontAsset.disableLocalization = !0),
                  this._fontAsset.on("load", this._onFontLoad, this),
                  this._fontAsset.on("change", this._onFontChange, this),
                  this._fontAsset.on("remove", this._onFontRemove, this),
                  (this._font = null),
                  (this._color = new g.I(1, 1, 1, 1)),
                  (this._colorUniform = new Float32Array(3)),
                  (this._spacing = 1),
                  (this._fontSize = 32),
                  (this._fontMinY = 0),
                  (this._fontMaxY = 0),
                  (this._originalFontSize = 32),
                  (this._maxFontSize = 32),
                  (this._minFontSize = 8),
                  (this._autoFitWidth = !1),
                  (this._autoFitHeight = !1),
                  (this._maxLines = -1),
                  (this._lineHeight = 32),
                  (this._scaledLineHeight = 32),
                  (this._wrapLines = !1),
                  (this._drawOrder = 0),
                  (this._alignment = new c.S(0.5, 0.5)),
                  (this._autoWidth = !0),
                  (this._autoHeight = !0),
                  (this.width = 0),
                  (this.height = 0),
                  (this._node = new s.A()),
                  (this._model = new n.H()),
                  (this._model.graph = this._node),
                  this._entity.addChild(this._node),
                  (this._meshInfo = []),
                  (this._material = null),
                  (this._aabbDirty = !0),
                  (this._aabb = new d.k()),
                  (this._noResize = !1),
                  (this._currentMaterialType = null),
                  (this._maskedMaterialSrc = null),
                  (this._rtlReorder = !1),
                  (this._unicodeConverter = !1),
                  (this._rtl = !1),
                  (this._outlineColor = new g.I(0, 0, 0, 1)),
                  (this._outlineColorUniform = new Float32Array(4)),
                  (this._outlineThicknessScale = 0.2),
                  (this._outlineThickness = 0),
                  (this._shadowColor = new g.I(0, 0, 0, 1)),
                  (this._shadowColorUniform = new Float32Array(4)),
                  (this._shadowOffsetScale = 0.005),
                  (this._shadowOffset = new c.S(0, 0)),
                  (this._shadowOffsetUniform = new Float32Array(2)),
                  (this._enableMarkup = !1),
                  this._onScreenChange(this._element.screen),
                  R.on("resize", this._onParentResize, this),
                  R.on("set:screen", this._onScreenChange, this),
                  R.on(
                    "screen:set:screenspace",
                    this._onScreenSpaceChange,
                    this
                  ),
                  R.on("set:draworder", this._onDrawOrderChange, this),
                  R.on("set:pivot", this._onPivotChange, this),
                  this._system.app.i18n.on(
                    "set:locale",
                    this._onLocaleSet,
                    this
                  ),
                  this._system.app.i18n.on(
                    "data:add",
                    this._onLocalizationData,
                    this
                  ),
                  this._system.app.i18n.on(
                    "data:remove",
                    this._onLocalizationData,
                    this
                  ),
                  (this._rangeStart = 0),
                  (this._rangeEnd = 0);
              }
              destroy() {
                this._setMaterial(null),
                  this._model &&
                    (this._element.removeModelFromLayers(this._model),
                    this._model.destroy(),
                    (this._model = null)),
                  this._fontAsset.destroy(),
                  (this.font = null),
                  this._element.off("resize", this._onParentResize, this),
                  this._element.off("set:screen", this._onScreenChange, this),
                  this._element.off(
                    "screen:set:screenspace",
                    this._onScreenSpaceChange,
                    this
                  ),
                  this._element.off(
                    "set:draworder",
                    this._onDrawOrderChange,
                    this
                  ),
                  this._element.off("set:pivot", this._onPivotChange, this),
                  this._system.app.i18n.off(
                    "set:locale",
                    this._onLocaleSet,
                    this
                  ),
                  this._system.app.i18n.off(
                    "data:add",
                    this._onLocalizationData,
                    this
                  ),
                  this._system.app.i18n.off(
                    "data:remove",
                    this._onLocalizationData,
                    this
                  );
              }
              _onParentResize(R, j) {
                this._noResize || (this._font && this._updateText());
              }
              _onScreenChange(R) {
                R
                  ? this._updateMaterial(R.screen.screenSpace)
                  : this._updateMaterial(!1);
              }
              _onScreenSpaceChange(R) {
                this._updateMaterial(R);
              }
              _onDrawOrderChange(R) {
                if (((this._drawOrder = R), this._model))
                  for (
                    let j = 0, se = this._model.meshInstances.length;
                    j < se;
                    j++
                  )
                    this._model.meshInstances[j].drawOrder = R;
              }
              _onPivotChange(R) {
                this._font && this._updateText();
              }
              _onLocaleSet(R) {
                if (this._i18nKey) {
                  if (this.fontAsset) {
                    const j = this._system.app.assets.get(this.fontAsset);
                    (!j || !j.resource || j.resource !== this._font) &&
                      (this.font = null);
                  }
                  this._resetLocalizedText();
                }
              }
              _onLocalizationData(R, j) {
                this._i18nKey && j[this._i18nKey] && this._resetLocalizedText();
              }
              _resetLocalizedText() {
                this._setText(this._system.app.i18n.getText(this._i18nKey));
              }
              _setText(R) {
                if (this.unicodeConverter) {
                  const j = this._system.getUnicodeConverter();
                  j
                    ? (R = j(R))
                    : console.warn(
                        "Element created with unicodeConverter option but no unicodeConverter function registered"
                      );
                }
                this._text !== R &&
                  (this._font && this._updateText(R), (this._text = R));
              }
              _updateText(R) {
                let j;
                if (
                  (R === void 0 && (R = this._text),
                  (this._symbols = x.Z.getSymbols(
                    R.normalize ? R.normalize("NFC") : R
                  )),
                  this._symbols.length === 0 && (this._symbols = [" "]),
                  this._enableMarkup)
                ) {
                  const de = te.evaluate(this._symbols);
                  (this._symbols = de.symbols), (j = de.tags || []);
                }
                if (this._rtlReorder) {
                  const de = this._system.app.systems.element.getRtlReorder();
                  if (de) {
                    const ge = de(this._symbols);
                    (this._rtl = ge.rtl),
                      (this._symbols = ge.mapping.map(function (Re) {
                        return this._symbols[Re];
                      }, this)),
                      j &&
                        (j = ge.mapping.map(function (Re) {
                          return j[Re];
                        }));
                  } else
                    console.warn(
                      "Element created with rtlReorder option but no rtlReorder function registered"
                    );
                } else this._rtl = !1;
                const se = (de, ge) =>
                    `${de.toString(!0).toLowerCase()}:${ge.toFixed(2)}`,
                  ce = (de, ge) =>
                    `${de.toString(!0).toLowerCase()}:${ge.x.toFixed(
                      2
                    )}:${ge.y.toFixed(2)}`;
                if (j) {
                  const de = {},
                    ge = {},
                    Re = {};
                  (this._colorPalette = [
                    Math.round(this._color.r * 255),
                    Math.round(this._color.g * 255),
                    Math.round(this._color.b * 255),
                  ]),
                    (this._outlinePalette = [
                      Math.round(this._outlineColor.r * 255),
                      Math.round(this._outlineColor.g * 255),
                      Math.round(this._outlineColor.b * 255),
                      Math.round(this._outlineColor.a * 255),
                      Math.round(this._outlineThickness * 255),
                    ]),
                    (this._shadowPalette = [
                      Math.round(this._shadowColor.r * 255),
                      Math.round(this._shadowColor.g * 255),
                      Math.round(this._shadowColor.b * 255),
                      Math.round(this._shadowColor.a * 255),
                      Math.round(this._shadowOffset.x * 127),
                      Math.round(this._shadowOffset.y * 127),
                    ]),
                    (this._symbolColors = []),
                    (this._symbolOutlineParams = []),
                    (this._symbolShadowParams = []),
                    (de[this._color.toString(!1).toLowerCase()] = 0),
                    (ge[se(this._outlineColor, this._outlineThickness)] = 0),
                    (Re[ce(this._shadowColor, this._shadowOffset)] = 0);
                  for (let Te = 0, Ne = this._symbols.length; Te < Ne; ++Te) {
                    const Le = j[Te];
                    let ke = 0;
                    if (Le && Le.color && Le.color.value) {
                      const U = Le.color.value;
                      if (U.length === 7 && U[0] === "#") {
                        const H = U.substring(1).toLowerCase();
                        de.hasOwnProperty(H)
                          ? (ke = de[H])
                          : /^([0-9a-f]{2}){3}$/.test(H) &&
                            ((ke = this._colorPalette.length / 3),
                            (de[H] = ke),
                            this._colorPalette.push(
                              parseInt(H.substring(0, 2), 16)
                            ),
                            this._colorPalette.push(
                              parseInt(H.substring(2, 4), 16)
                            ),
                            this._colorPalette.push(
                              parseInt(H.substring(4, 6), 16)
                            ));
                      }
                    }
                    this._symbolColors.push(ke);
                    let ht = 0;
                    if (
                      Le &&
                      Le.outline &&
                      (Le.outline.attributes.color ||
                        Le.outline.attributes.thickness)
                    ) {
                      let U = Le.outline.attributes.color
                          ? V.fromString(Le.outline.attributes.color)
                          : this._outlineColor,
                        H = Number(Le.outline.attributes.thickness);
                      (Number.isNaN(U.r) ||
                        Number.isNaN(U.g) ||
                        Number.isNaN(U.b) ||
                        Number.isNaN(U.a)) &&
                        (U = this._outlineColor),
                        Number.isNaN(H) && (H = this._outlineThickness);
                      const Ee = se(U, H);
                      ge.hasOwnProperty(Ee)
                        ? (ht = ge[Ee])
                        : ((ht = this._outlinePalette.length / 5),
                          (ge[Ee] = ht),
                          this._outlinePalette.push(
                            Math.round(U.r * 255),
                            Math.round(U.g * 255),
                            Math.round(U.b * 255),
                            Math.round(U.a * 255),
                            Math.round(H * 255)
                          ));
                    }
                    this._symbolOutlineParams.push(ht);
                    let _e = 0;
                    if (
                      Le &&
                      Le.shadow &&
                      (Le.shadow.attributes.color ||
                        Le.shadow.attributes.offset ||
                        Le.shadow.attributes.offsetX ||
                        Le.shadow.attributes.offsetY)
                    ) {
                      let U = Le.shadow.attributes.color
                        ? V.fromString(Le.shadow.attributes.color)
                        : this._shadowColor;
                      const H = Number(Le.shadow.attributes.offset),
                        Ee = Number(Le.shadow.attributes.offsetX),
                        G = Number(Le.shadow.attributes.offsetY);
                      (Number.isNaN(U.r) ||
                        Number.isNaN(U.g) ||
                        Number.isNaN(U.b) ||
                        Number.isNaN(U.a)) &&
                        (U = this._shadowColor);
                      const Q = L.set(
                          Number.isNaN(Ee)
                            ? Number.isNaN(H)
                              ? this._shadowOffset.x
                              : H
                            : Ee,
                          Number.isNaN(G)
                            ? Number.isNaN(H)
                              ? this._shadowOffset.y
                              : H
                            : G
                        ),
                        q = ce(U, Q);
                      Re.hasOwnProperty(q)
                        ? (_e = Re[q])
                        : ((_e = this._shadowPalette.length / 6),
                          (Re[q] = _e),
                          this._shadowPalette.push(
                            Math.round(U.r * 255),
                            Math.round(U.g * 255),
                            Math.round(U.b * 255),
                            Math.round(U.a * 255),
                            Math.round(Q.x * 127),
                            Math.round(Q.y * 127)
                          ));
                    }
                    this._symbolShadowParams.push(_e);
                  }
                } else
                  (this._colorPalette = []),
                    (this._symbolColors = null),
                    (this._symbolOutlineParams = null),
                    (this._symbolShadowParams = null);
                this._updateMaterialEmissive(),
                  this._updateMaterialOutline(),
                  this._updateMaterialShadow();
                const ie = this._calculateCharsPerTexture();
                let b = !1;
                const M = this._element,
                  F = M._isScreenSpace(),
                  z = M._isScreenCulled(),
                  oe = function (ge) {
                    return M.isVisibleForCamera(ge);
                  };
                for (let de = 0, ge = this._meshInfo.length; de < ge; de++) {
                  const Re = ie[de] || 0,
                    Te = this._meshInfo[de];
                  if (Te.count !== Re) {
                    if (
                      (b || (M.removeModelFromLayers(this._model), (b = !0)),
                      (Te.count = Re),
                      (Te.positions.length = Te.normals.length = Re * 3 * 4),
                      (Te.indices.length = Re * 3 * 2),
                      (Te.uvs.length = Re * 2 * 4),
                      (Te.colors.length = Re * 4 * 4),
                      (Te.outlines.length = Re * 4 * 3),
                      (Te.shadows.length = Re * 4 * 3),
                      Te.meshInstance &&
                        this._removeMeshInstance(Te.meshInstance),
                      Re === 0)
                    ) {
                      Te.meshInstance = null;
                      continue;
                    }
                    for (let ke = 0; ke < Re; ke++)
                      (Te.indices[ke * 3 * 2 + 0] = ke * 4),
                        (Te.indices[ke * 3 * 2 + 1] = ke * 4 + 1),
                        (Te.indices[ke * 3 * 2 + 2] = ke * 4 + 3),
                        (Te.indices[ke * 3 * 2 + 3] = ke * 4 + 2),
                        (Te.indices[ke * 3 * 2 + 4] = ke * 4 + 3),
                        (Te.indices[ke * 3 * 2 + 5] = ke * 4 + 1),
                        (Te.normals[ke * 4 * 3 + 0] = 0),
                        (Te.normals[ke * 4 * 3 + 1] = 0),
                        (Te.normals[ke * 4 * 3 + 2] = -1),
                        (Te.normals[ke * 4 * 3 + 3] = 0),
                        (Te.normals[ke * 4 * 3 + 4] = 0),
                        (Te.normals[ke * 4 * 3 + 5] = -1),
                        (Te.normals[ke * 4 * 3 + 6] = 0),
                        (Te.normals[ke * 4 * 3 + 7] = 0),
                        (Te.normals[ke * 4 * 3 + 8] = -1),
                        (Te.normals[ke * 4 * 3 + 9] = 0),
                        (Te.normals[ke * 4 * 3 + 10] = 0),
                        (Te.normals[ke * 4 * 3 + 11] = -1);
                    const Ne = $(this._system.app.graphicsDevice, Te),
                      Le = new l.l(Ne, this._material, this._node);
                    if (
                      ((Le.name = "Text Element: " + this._entity.name),
                      (Le.castShadow = !1),
                      (Le.receiveShadow = !1),
                      (Le.cull = !F),
                      (Le.screenSpace = F),
                      (Le.drawOrder = this._drawOrder),
                      z && ((Le.cull = !0), (Le.isVisibleFunc = oe)),
                      this._setTextureParams(Le, this._font.textures[de]),
                      Le.setParameter("material_emissive", this._colorUniform),
                      Le.setParameter("material_opacity", this._color.a),
                      Le.setParameter(
                        "font_sdfIntensity",
                        this._font.intensity
                      ),
                      Le.setParameter(
                        "font_pxrange",
                        this._getPxRange(this._font)
                      ),
                      Le.setParameter(
                        "font_textureWidth",
                        this._font.data.info.maps[de].width
                      ),
                      Le.setParameter(
                        "outline_color",
                        this._outlineColorUniform
                      ),
                      Le.setParameter(
                        "outline_thickness",
                        this._outlineThicknessScale * this._outlineThickness
                      ),
                      Le.setParameter("shadow_color", this._shadowColorUniform),
                      this._symbolShadowParams)
                    )
                      (this._shadowOffsetUniform[0] = 0),
                        (this._shadowOffsetUniform[1] = 0);
                    else {
                      const ke =
                        -this._font.data.info.maps[de].width /
                        this._font.data.info.maps[de].height;
                      (this._shadowOffsetUniform[0] =
                        this._shadowOffsetScale * this._shadowOffset.x),
                        (this._shadowOffsetUniform[1] =
                          ke * this._shadowOffsetScale * this._shadowOffset.y);
                    }
                    Le.setParameter("shadow_offset", this._shadowOffsetUniform),
                      (Te.meshInstance = Le),
                      this._model.meshInstances.push(Le);
                  }
                }
                this._element.maskedBy &&
                  this._element._setMaskedBy(this._element.maskedBy),
                  b &&
                    this._element.enabled &&
                    this._entity.enabled &&
                    this._element.addModelToLayers(this._model),
                  this._updateMeshes(),
                  (this._rangeStart = 0),
                  (this._rangeEnd = this._symbols.length),
                  this._updateRenderRange();
              }
              _removeMeshInstance(R) {
                R.destroy();
                const j = this._model.meshInstances.indexOf(R);
                j !== -1 && this._model.meshInstances.splice(j, 1);
              }
              _setMaterial(R) {
                if (((this._material = R), this._model))
                  for (
                    let j = 0, se = this._model.meshInstances.length;
                    j < se;
                    j++
                  ) {
                    const ce = this._model.meshInstances[j];
                    ce.material = R;
                  }
              }
              _updateMaterial(R) {
                const j = this._element,
                  se = j._isScreenCulled(),
                  ce = function (M) {
                    return j.isVisibleForCamera(M);
                  },
                  ie = this._font && this._font.type === e.E;
                if (
                  ((this._material = this._system.getTextElementMaterial(
                    R,
                    ie,
                    this._enableMarkup
                  )),
                  this._model)
                )
                  for (
                    let b = 0, M = this._model.meshInstances.length;
                    b < M;
                    b++
                  ) {
                    const F = this._model.meshInstances[b];
                    (F.cull = !R),
                      (F.material = this._material),
                      (F.screenSpace = R),
                      se
                        ? ((F.cull = !0), (F.isVisibleFunc = ce))
                        : (F.isVisibleFunc = null);
                  }
              }
              _updateMaterialEmissive() {
                this._symbolColors
                  ? ((this._colorUniform[0] = 1),
                    (this._colorUniform[1] = 1),
                    (this._colorUniform[2] = 1))
                  : ((this._colorUniform[0] = this._color.r),
                    (this._colorUniform[1] = this._color.g),
                    (this._colorUniform[2] = this._color.b));
              }
              _updateMaterialOutline() {
                this._symbolOutlineParams
                  ? ((this._outlineColorUniform[0] = 0),
                    (this._outlineColorUniform[1] = 0),
                    (this._outlineColorUniform[2] = 0),
                    (this._outlineColorUniform[3] = 1))
                  : ((this._outlineColorUniform[0] = this._outlineColor.r),
                    (this._outlineColorUniform[1] = this._outlineColor.g),
                    (this._outlineColorUniform[2] = this._outlineColor.b),
                    (this._outlineColorUniform[3] = this._outlineColor.a));
              }
              _updateMaterialShadow() {
                this._symbolOutlineParams
                  ? ((this._shadowColorUniform[0] = 0),
                    (this._shadowColorUniform[1] = 0),
                    (this._shadowColorUniform[2] = 0),
                    (this._shadowColorUniform[3] = 0))
                  : ((this._shadowColorUniform[0] = this._shadowColor.r),
                    (this._shadowColorUniform[1] = this._shadowColor.g),
                    (this._shadowColorUniform[2] = this._shadowColor.b),
                    (this._shadowColorUniform[3] = this._shadowColor.a));
              }
              _isWordBoundary(R) {
                return Z.test(R);
              }
              _isValidNextChar(R) {
                return R !== null && !O.test(R);
              }
              _isNextCJKBoundary(R, j) {
                return pe.test(R) && (Z.test(j) || ye.test(j));
              }
              _isNextCJKWholeWord(R) {
                return pe.test(R);
              }
              _updateMeshes() {
                const R = this._font.data,
                  j = this,
                  se = Math.min(this._minFontSize, this._maxFontSize),
                  ce = this._maxFontSize,
                  ie = this._shouldAutoFit();
                ie && (this._fontSize = this._maxFontSize);
                const b = 32,
                  M = this._symbols.length;
                let F = 0,
                  z = 0,
                  oe = 0,
                  de = 0,
                  ge = 1,
                  Re = 0,
                  Te = 0,
                  Ne = 0,
                  Le = 0,
                  ke = 0,
                  ht = 0;
                const _e =
                  Math.abs(this._element.anchor.x - this._element.anchor.z) >=
                  1e-4;
                let U = this._element.calculatedWidth;
                ((this.autoWidth && !_e) || !this._wrapLines) &&
                  (U = Number.POSITIVE_INFINITY);
                let H = 0,
                  Ee = 0,
                  G,
                  Q,
                  q,
                  xe;
                function be(qe, Tt, Mt) {
                  j._lineWidths.push(Math.abs(Mt));
                  const Dt = Ne > Tt ? Tt + 1 : Ne,
                    ut = Ne > Tt ? Ne + 1 : Tt,
                    At = qe.slice(Dt, ut);
                  if (ht) {
                    let xt = At.length;
                    for (; xt-- && ht > 0; )
                      ne.test(At[xt]) && (At.splice(xt, 1), ht--);
                  }
                  j._lineContents.push(At.join("")),
                    (F = 0),
                    (z -= j._scaledLineHeight),
                    ge++,
                    (Le = 0),
                    (ke = 0),
                    (ht = 0),
                    (Re = 0),
                    (Ne = Tt);
                }
                let Pe = !0;
                for (; Pe; ) {
                  (Pe = !1),
                    ie
                      ? (this._scaledLineHeight =
                          (this._lineHeight * this._fontSize) /
                          (this._maxFontSize || 1e-4))
                      : (this._scaledLineHeight = this._lineHeight),
                    (this.width = 0),
                    (this.height = 0),
                    (this._lineWidths = []),
                    (this._lineContents = []),
                    (F = 0),
                    (z = 0),
                    (oe = 0),
                    (de = 0),
                    (ge = 1),
                    (Re = 0),
                    (Te = 0),
                    (Ne = 0),
                    (Le = 0),
                    (ke = 0),
                    (ht = 0);
                  const qe = this._fontSize / b;
                  (H = this._fontMinY * qe), (Ee = this._fontMaxY * qe);
                  for (let Ae = 0; Ae < this._meshInfo.length; Ae++)
                    (this._meshInfo[Ae].quad = 0),
                      (this._meshInfo[Ae].lines = {});
                  let Tt = 255,
                    Mt = 255,
                    Dt = 255,
                    ut = 255 + 255 * 256,
                    At = 255 + 255 * 256,
                    xt = 0,
                    jt = 255 + 255 * 256,
                    Gt = 255 + 255 * 256,
                    yt = 127 + 127 * 256;
                  for (let Ae = 0; Ae < M; Ae++) {
                    if (
                      ((G = this._symbols[Ae]),
                      (xe = Ae + 1 >= M ? null : this._symbols[Ae + 1]),
                      ne.test(G))
                    ) {
                      ht++,
                        (!this._wrapLines ||
                          this._maxLines < 0 ||
                          ge < this._maxLines) &&
                          (be(this._symbols, Ae, de),
                          (Te = Ae + 1),
                          (Ne = Ae + 1));
                      continue;
                    }
                    let Ye = 0,
                      it = 0,
                      st = 0,
                      He = 1,
                      at,
                      Pt;
                    if (((Q = R.chars[G]), !Q))
                      if (me.indexOf(G) !== -1) Q = N;
                      else if (R.chars[" "]) Q = R.chars[" "];
                      else
                        for (const Qe in R.chars) {
                          Q = R.chars[Qe];
                          break;
                        }
                    if (Q) {
                      let Qe = 0;
                      if (ke > 0) {
                        const mt = this._font.data.kerning;
                        if (mt) {
                          const je =
                            mt[x.Z.getCodePoint(this._symbols[Ae - 1]) || 0];
                          je &&
                            (Qe =
                              je[x.Z.getCodePoint(this._symbols[Ae]) || 0] ||
                              0);
                        }
                      }
                      (at = Q.scale || 1),
                        (Pt = (Q.width + Q.height) / 2),
                        (He = (qe * Pt) / at),
                        (st = (Q.xadvance + Qe) * qe),
                        (Ye = (Q.xoffset - Qe) * qe),
                        (it = Q.yoffset * qe);
                    } else
                      console.error(
                        `Couldn't substitute missing character: '${G}'`
                      );
                    const he = Y.test(G),
                      fe = (Q && Q.map) || 0,
                      Ie =
                        -this._font.data.info.maps[fe].width /
                        this._font.data.info.maps[fe].height,
                      ue = this._meshInfo[fe],
                      De = F + this._spacing * st;
                    if (
                      De > U &&
                      ke > 0 &&
                      !he &&
                      (this._maxLines < 0 || ge < this._maxLines)
                    )
                      if (Le === 0) (Te = Ae), be(this._symbols, Ae, de);
                      else {
                        const Qe = Math.max(Ae - Te, 0);
                        if (this._meshInfo.length <= 1)
                          (ue.lines[ge - 1] -= Qe), (ue.quad -= Qe);
                        else {
                          const mt = Te,
                            je = Ae;
                          for (let lt = mt; lt < je; lt++) {
                            const Et = this._symbols[lt],
                              ct = R.chars[Et],
                              pt = this._meshInfo[(ct && ct.map) || 0];
                            (pt.lines[ge - 1] -= 1), (pt.quad -= 1);
                          }
                        }
                        (Ae -= Qe + 1), be(this._symbols, Te, Re);
                        continue;
                      }
                    (q = ue.quad), (ue.lines[ge - 1] = q);
                    let et = F - Ye,
                      Ze = et + He;
                    const Ve = z - it,
                      tt = Ve + He;
                    if (this._rtl) {
                      const Qe = He - Ye - this._spacing * st - Ye;
                      (et -= Qe), (Ze -= Qe);
                    }
                    (ue.positions[q * 4 * 3 + 0] = et),
                      (ue.positions[q * 4 * 3 + 1] = Ve),
                      (ue.positions[q * 4 * 3 + 2] = oe),
                      (ue.positions[q * 4 * 3 + 3] = Ze),
                      (ue.positions[q * 4 * 3 + 4] = Ve),
                      (ue.positions[q * 4 * 3 + 5] = oe),
                      (ue.positions[q * 4 * 3 + 6] = Ze),
                      (ue.positions[q * 4 * 3 + 7] = tt),
                      (ue.positions[q * 4 * 3 + 8] = oe),
                      (ue.positions[q * 4 * 3 + 9] = et),
                      (ue.positions[q * 4 * 3 + 10] = tt),
                      (ue.positions[q * 4 * 3 + 11] = oe),
                      (this.width = Math.max(this.width, De));
                    let Be;
                    if (
                      this._shouldAutoFitWidth() &&
                      this.width > this._element.calculatedWidth &&
                      ((Be = Math.floor(
                        (this._element.fontSize *
                          this._element.calculatedWidth) /
                          (this.width || 1e-4)
                      )),
                      (Be = T.m.clamp(Be, se, ce)),
                      Be !== this._element.fontSize)
                    ) {
                      (this._fontSize = Be), (Pe = !0);
                      break;
                    }
                    if (
                      ((this.height = Math.max(this.height, Ee - (z + H))),
                      this._shouldAutoFitHeight() &&
                        this.height > this._element.calculatedHeight &&
                        ((Be = T.m.clamp(this._fontSize - 1, se, ce)),
                        Be !== this._element.fontSize))
                    ) {
                      (this._fontSize = Be), (Pe = !0);
                      break;
                    }
                    (F += this._spacing * st),
                      he || (de = F),
                      (this._isWordBoundary(G) ||
                        (this._isValidNextChar(xe) &&
                          (this._isNextCJKBoundary(G, xe) ||
                            this._isNextCJKWholeWord(xe)))) &&
                        (Le++, (Re = de), (Te = Ae + 1)),
                      ke++;
                    const ot = this._getUv(G);
                    if (
                      ((ue.uvs[q * 4 * 2 + 0] = ot[0]),
                      (ue.uvs[q * 4 * 2 + 1] = 1 - ot[1]),
                      (ue.uvs[q * 4 * 2 + 2] = ot[2]),
                      (ue.uvs[q * 4 * 2 + 3] = 1 - ot[1]),
                      (ue.uvs[q * 4 * 2 + 4] = ot[2]),
                      (ue.uvs[q * 4 * 2 + 5] = 1 - ot[3]),
                      (ue.uvs[q * 4 * 2 + 6] = ot[0]),
                      (ue.uvs[q * 4 * 2 + 7] = 1 - ot[3]),
                      this._symbolColors)
                    ) {
                      const Qe = this._symbolColors[Ae] * 3;
                      (Tt = this._colorPalette[Qe]),
                        (Mt = this._colorPalette[Qe + 1]),
                        (Dt = this._colorPalette[Qe + 2]);
                    }
                    if (
                      ((ue.colors[q * 4 * 4 + 0] = Tt),
                      (ue.colors[q * 4 * 4 + 1] = Mt),
                      (ue.colors[q * 4 * 4 + 2] = Dt),
                      (ue.colors[q * 4 * 4 + 3] = 255),
                      (ue.colors[q * 4 * 4 + 4] = Tt),
                      (ue.colors[q * 4 * 4 + 5] = Mt),
                      (ue.colors[q * 4 * 4 + 6] = Dt),
                      (ue.colors[q * 4 * 4 + 7] = 255),
                      (ue.colors[q * 4 * 4 + 8] = Tt),
                      (ue.colors[q * 4 * 4 + 9] = Mt),
                      (ue.colors[q * 4 * 4 + 10] = Dt),
                      (ue.colors[q * 4 * 4 + 11] = 255),
                      (ue.colors[q * 4 * 4 + 12] = Tt),
                      (ue.colors[q * 4 * 4 + 13] = Mt),
                      (ue.colors[q * 4 * 4 + 14] = Dt),
                      (ue.colors[q * 4 * 4 + 15] = 255),
                      this._symbolOutlineParams)
                    ) {
                      const Qe = this._symbolOutlineParams[Ae] * 5;
                      (ut =
                        this._outlinePalette[Qe] +
                        this._outlinePalette[Qe + 1] * 256),
                        (At =
                          this._outlinePalette[Qe + 2] +
                          this._outlinePalette[Qe + 3] * 256),
                        (xt = this._outlinePalette[Qe + 4]);
                    }
                    if (
                      ((ue.outlines[q * 4 * 3 + 0] = ut),
                      (ue.outlines[q * 4 * 3 + 1] = At),
                      (ue.outlines[q * 4 * 3 + 2] = xt),
                      (ue.outlines[q * 4 * 3 + 3] = ut),
                      (ue.outlines[q * 4 * 3 + 4] = At),
                      (ue.outlines[q * 4 * 3 + 5] = xt),
                      (ue.outlines[q * 4 * 3 + 6] = ut),
                      (ue.outlines[q * 4 * 3 + 7] = At),
                      (ue.outlines[q * 4 * 3 + 8] = xt),
                      (ue.outlines[q * 4 * 3 + 9] = ut),
                      (ue.outlines[q * 4 * 3 + 10] = At),
                      (ue.outlines[q * 4 * 3 + 11] = xt),
                      this._symbolShadowParams)
                    ) {
                      const Qe = this._symbolShadowParams[Ae] * 6;
                      (jt =
                        this._shadowPalette[Qe] +
                        this._shadowPalette[Qe + 1] * 256),
                        (Gt =
                          this._shadowPalette[Qe + 2] +
                          this._shadowPalette[Qe + 3] * 256),
                        (yt =
                          this._shadowPalette[Qe + 4] +
                          127 +
                          Math.round(Ie * this._shadowPalette[Qe + 5] + 127) *
                            256);
                    }
                    (ue.shadows[q * 4 * 3 + 0] = jt),
                      (ue.shadows[q * 4 * 3 + 1] = Gt),
                      (ue.shadows[q * 4 * 3 + 2] = yt),
                      (ue.shadows[q * 4 * 3 + 3] = jt),
                      (ue.shadows[q * 4 * 3 + 4] = Gt),
                      (ue.shadows[q * 4 * 3 + 5] = yt),
                      (ue.shadows[q * 4 * 3 + 6] = jt),
                      (ue.shadows[q * 4 * 3 + 7] = Gt),
                      (ue.shadows[q * 4 * 3 + 8] = yt),
                      (ue.shadows[q * 4 * 3 + 9] = jt),
                      (ue.shadows[q * 4 * 3 + 10] = Gt),
                      (ue.shadows[q * 4 * 3 + 11] = yt),
                      ue.quad++;
                  }
                  Pe || (Ne < M && be(this._symbols, M, F));
                }
                (this._noResize = !0),
                  (this.autoWidth = this._autoWidth),
                  (this.autoHeight = this._autoHeight),
                  (this._noResize = !1);
                const we = this._element.pivot.x,
                  Oe = this._element.pivot.y,
                  $e = this._alignment.x,
                  gt = this._alignment.y;
                for (let qe = 0; qe < this._meshInfo.length; qe++) {
                  if (this._meshInfo[qe].count === 0) continue;
                  let Tt = 0;
                  for (const At in this._meshInfo[qe].lines) {
                    const xt = this._meshInfo[qe].lines[At],
                      jt = this._lineWidths[parseInt(At, 10)],
                      Gt =
                        -we * this._element.calculatedWidth +
                        $e *
                          (this._element.calculatedWidth - jt) *
                          (this._rtl ? -1 : 1),
                      yt =
                        (1 - Oe) * this._element.calculatedHeight -
                        Ee -
                        (1 - gt) *
                          (this._element.calculatedHeight - this.height);
                    for (let Ae = Tt; Ae <= xt; Ae++)
                      (this._meshInfo[qe].positions[Ae * 4 * 3] += Gt),
                        (this._meshInfo[qe].positions[Ae * 4 * 3 + 3] += Gt),
                        (this._meshInfo[qe].positions[Ae * 4 * 3 + 6] += Gt),
                        (this._meshInfo[qe].positions[Ae * 4 * 3 + 9] += Gt),
                        (this._meshInfo[qe].positions[Ae * 4 * 3 + 1] += yt),
                        (this._meshInfo[qe].positions[Ae * 4 * 3 + 4] += yt),
                        (this._meshInfo[qe].positions[Ae * 4 * 3 + 7] += yt),
                        (this._meshInfo[qe].positions[Ae * 4 * 3 + 10] += yt);
                    if (this._rtl)
                      for (let Ae = Tt; Ae <= xt; Ae++) {
                        const Xe = Ae * 4 * 3;
                        for (let st = 0; st < 4; ++st)
                          this._meshInfo[qe].positions[Xe + st * 3] =
                            this._element.calculatedWidth -
                            this._meshInfo[qe].positions[Xe + st * 3] +
                            Gt * 2;
                        const Ye = this._meshInfo[qe].positions[Xe + 3],
                          it = this._meshInfo[qe].positions[Xe + 6];
                        (this._meshInfo[qe].positions[Xe + 3] =
                          this._meshInfo[qe].positions[Xe + 0]),
                          (this._meshInfo[qe].positions[Xe + 6] =
                            this._meshInfo[qe].positions[Xe + 9]),
                          (this._meshInfo[qe].positions[Xe + 0] = Ye),
                          (this._meshInfo[qe].positions[Xe + 9] = it);
                      }
                    Tt = xt + 1;
                  }
                  const Mt = this._meshInfo[qe].count * 4,
                    Dt = this._meshInfo[qe].quad * 4,
                    ut = new f.O(
                      this._meshInfo[qe].meshInstance.mesh.vertexBuffer
                    );
                  for (let At = 0; At < Mt; At++)
                    At >= Dt
                      ? (ut.element[h.Q5v].set(0, 0, 0),
                        ut.element[h.$fY].set(0, 0),
                        ut.element[h.wD$].set(0, 0, 0, 0),
                        ut.element[h.syi].set(0, 0, 0, 0),
                        ut.element[h.ScY].set(0, 0, 0, 0))
                      : (ut.element[h.Q5v].set(
                          this._meshInfo[qe].positions[At * 3 + 0],
                          this._meshInfo[qe].positions[At * 3 + 1],
                          this._meshInfo[qe].positions[At * 3 + 2]
                        ),
                        ut.element[h.$fY].set(
                          this._meshInfo[qe].uvs[At * 2 + 0],
                          this._meshInfo[qe].uvs[At * 2 + 1]
                        ),
                        ut.element[h.wD$].set(
                          this._meshInfo[qe].colors[At * 4 + 0],
                          this._meshInfo[qe].colors[At * 4 + 1],
                          this._meshInfo[qe].colors[At * 4 + 2],
                          this._meshInfo[qe].colors[At * 4 + 3]
                        ),
                        ut.element[h.syi].set(
                          this._meshInfo[qe].outlines[At * 3 + 0],
                          this._meshInfo[qe].outlines[At * 3 + 1],
                          this._meshInfo[qe].outlines[At * 3 + 2]
                        ),
                        ut.element[h.ScY].set(
                          this._meshInfo[qe].shadows[At * 3 + 0],
                          this._meshInfo[qe].shadows[At * 3 + 1],
                          this._meshInfo[qe].shadows[At * 3 + 2]
                        )),
                      ut.next();
                  ut.end(),
                    this._meshInfo[qe].meshInstance.mesh.aabb.compute(
                      this._meshInfo[qe].positions
                    ),
                    (this._meshInfo[qe].meshInstance._aabbVer = -1);
                }
                this._aabbDirty = !0;
              }
              _onFontRender() {
                this.font = this._font;
              }
              _onFontLoad(R) {
                this.font !== R.resource && (this.font = R.resource);
              }
              _onFontChange(R, j, se, ce) {
                if (j === "data") {
                  this._font.data = se;
                  const ie = this._font.data.info.maps.length;
                  for (let b = 0; b < ie; b++) {
                    if (!this._meshInfo[b]) continue;
                    const M = this._meshInfo[b].meshInstance;
                    M &&
                      (M.setParameter(
                        "font_sdfIntensity",
                        this._font.intensity
                      ),
                      M.setParameter(
                        "font_pxrange",
                        this._getPxRange(this._font)
                      ),
                      M.setParameter(
                        "font_textureWidth",
                        this._font.data.info.maps[b].width
                      ));
                  }
                }
              }
              _onFontRemove(R) {}
              _setTextureParams(R, j) {
                this._font &&
                  (this._font.type === e.E
                    ? (R.deleteParameter("texture_emissiveMap"),
                      R.deleteParameter("texture_opacityMap"),
                      R.setParameter("texture_msdfMap", j))
                    : this._font.type === e.M &&
                      (R.deleteParameter("texture_msdfMap"),
                      R.setParameter("texture_emissiveMap", j),
                      R.setParameter("texture_opacityMap", j)));
              }
              _getPxRange(R) {
                const j = Object.keys(this._font.data.chars);
                for (let se = 0; se < j.length; se++) {
                  const ce = this._font.data.chars[j[se]];
                  if (ce.range) return (ce.scale || 1) * ce.range;
                }
                return 2;
              }
              _getUv(R) {
                const j = this._font.data;
                if (!j.chars[R]) {
                  const Re = " ";
                  return j.chars[Re] ? this._getUv(Re) : [0, 0, 0, 0];
                }
                const se = j.chars[R].map,
                  ce = j.info.maps[se].width,
                  ie = j.info.maps[se].height,
                  b = j.chars[R].x,
                  M = j.chars[R].y,
                  F = b,
                  z = M,
                  oe = b + j.chars[R].width,
                  de = M - j.chars[R].height,
                  ge = 1 - j.chars[R].height / ie;
                return [F / ce, ge - z / ie, oe / ce, ge - de / ie];
              }
              onEnable() {
                (this._fontAsset.autoLoad = !0),
                  this._model && this._element.addModelToLayers(this._model);
              }
              onDisable() {
                (this._fontAsset.autoLoad = !1),
                  this._model &&
                    this._element.removeModelFromLayers(this._model);
              }
              _setStencil(R) {
                if (this._model) {
                  const j = this._model.meshInstances;
                  for (let se = 0; se < j.length; se++)
                    (j[se].stencilFront = R), (j[se].stencilBack = R);
                }
              }
              _shouldAutoFitWidth() {
                return this._autoFitWidth && !this._autoWidth;
              }
              _shouldAutoFitHeight() {
                return this._autoFitHeight && !this._autoHeight;
              }
              _shouldAutoFit() {
                return (
                  (this._autoFitWidth && !this._autoWidth) ||
                  (this._autoFitHeight && !this._autoHeight)
                );
              }
              _calculateCharsPerTexture(R) {
                const j = {};
                R === void 0 && (R = this._symbols.length);
                for (let se = 0, ce = R; se < ce; se++) {
                  const ie = this._symbols[se];
                  let b = this._font.data.chars[ie];
                  b ||
                    ((b = this._font.data.chars[" "]),
                    b ||
                      (b =
                        this._font.data.chars[
                          Object.keys(this._font.data.chars)[0]
                        ]));
                  const M = b.map;
                  j[M] ? j[M]++ : (j[M] = 1);
                }
                return j;
              }
              _updateRenderRange() {
                const R =
                    this._rangeStart === 0
                      ? 0
                      : this._calculateCharsPerTexture(this._rangeStart),
                  j =
                    this._rangeEnd === 0
                      ? 0
                      : this._calculateCharsPerTexture(this._rangeEnd);
                for (let se = 0, ce = this._meshInfo.length; se < ce; se++) {
                  const ie = R[se] || 0,
                    b = j[se] || 0,
                    M = this._meshInfo[se].meshInstance;
                  if (M) {
                    const F = M.mesh;
                    F &&
                      ((F.primitive[0].base = ie * 3 * 2),
                      (F.primitive[0].count = (b - ie) * 3 * 2));
                  }
                }
              }
              set text(R) {
                this._i18nKey = null;
                const j = (R != null && R.toString()) || "";
                this._setText(j);
              }
              get text() {
                return this._text;
              }
              set key(R) {
                const j = R !== null ? R.toString() : null;
                this._i18nKey !== j &&
                  ((this._i18nKey = j),
                  j
                    ? ((this._fontAsset.disableLocalization = !1),
                      this._resetLocalizedText())
                    : (this._fontAsset.disableLocalization = !0));
              }
              get key() {
                return this._i18nKey;
              }
              set color(R) {
                const j = R.r,
                  se = R.g,
                  ce = R.b;
                if (
                  !(
                    this._color.r === j &&
                    this._color.g === se &&
                    this._color.b === ce
                  ) &&
                  ((this._color.r = j),
                  (this._color.g = se),
                  (this._color.b = ce),
                  !!this._model)
                ) {
                  if (this._symbolColors) this._font && this._updateText();
                  else {
                    (this._colorUniform[0] = this._color.r),
                      (this._colorUniform[1] = this._color.g),
                      (this._colorUniform[2] = this._color.b);
                    for (
                      let ie = 0, b = this._model.meshInstances.length;
                      ie < b;
                      ie++
                    )
                      this._model.meshInstances[ie].setParameter(
                        "material_emissive",
                        this._colorUniform
                      );
                  }
                  this._element && this._element.fire("set:color", this._color);
                }
              }
              get color() {
                return this._color;
              }
              set opacity(R) {
                if (this._color.a !== R && ((this._color.a = R), this._model))
                  for (
                    let j = 0, se = this._model.meshInstances.length;
                    j < se;
                    j++
                  )
                    this._model.meshInstances[j].setParameter(
                      "material_opacity",
                      R
                    );
                this._element && this._element.fire("set:opacity", R);
              }
              get opacity() {
                return this._color.a;
              }
              set lineHeight(R) {
                const j = this._lineHeight;
                (this._lineHeight = R),
                  (this._scaledLineHeight = R),
                  j !== R && this._font && this._updateText();
              }
              get lineHeight() {
                return this._lineHeight;
              }
              set wrapLines(R) {
                const j = this._wrapLines;
                (this._wrapLines = R),
                  j !== R && this._font && this._updateText();
              }
              get wrapLines() {
                return this._wrapLines;
              }
              get lines() {
                return this._lineContents;
              }
              set spacing(R) {
                const j = this._spacing;
                (this._spacing = R),
                  j !== R && this._font && this._updateText();
              }
              get spacing() {
                return this._spacing;
              }
              set fontSize(R) {
                const j = this._fontSize;
                (this._fontSize = R),
                  (this._originalFontSize = R),
                  j !== R && this._font && this._updateText();
              }
              get fontSize() {
                return this._fontSize;
              }
              set fontAsset(R) {
                this._fontAsset.defaultAsset = R;
              }
              get fontAsset() {
                return this._fontAsset.localizedAsset;
              }
              set font(R) {
                let j;
                if (
                  (this._font &&
                    ((j = this._font.type),
                    this._font.off &&
                      this._font.off("render", this._onFontRender, this)),
                  (this._font = R),
                  (this._fontMinY = 0),
                  (this._fontMaxY = 0),
                  !R)
                )
                  return;
                const se = this._font.data;
                for (const ie in se.chars) {
                  const b = se.chars[ie];
                  b.bounds &&
                    ((this._fontMinY = Math.min(this._fontMinY, b.bounds[1])),
                    (this._fontMaxY = Math.max(this._fontMaxY, b.bounds[3])));
                }
                if (
                  (this._font.on &&
                    this._font.on("render", this._onFontRender, this),
                  this._fontAsset.localizedAsset &&
                    this._system.app.assets.get(this._fontAsset.localizedAsset)
                      .resource !== this._font &&
                    (this._fontAsset.defaultAsset = null),
                  R.type !== j)
                ) {
                  const ie = this._element._isScreenSpace();
                  this._updateMaterial(ie);
                }
                for (let ie = 0, b = this._font.textures.length; ie < b; ie++)
                  if (!this._meshInfo[ie]) this._meshInfo[ie] = new X();
                  else {
                    const M = this._meshInfo[ie].meshInstance;
                    M &&
                      (M.setParameter(
                        "font_sdfIntensity",
                        this._font.intensity
                      ),
                      M.setParameter(
                        "font_pxrange",
                        this._getPxRange(this._font)
                      ),
                      M.setParameter(
                        "font_textureWidth",
                        this._font.data.info.maps[ie].width
                      ),
                      this._setTextureParams(M, this._font.textures[ie]));
                  }
                let ce = !1;
                for (
                  let ie = this._font.textures.length;
                  ie < this._meshInfo.length;
                  ie++
                )
                  this._meshInfo[ie].meshInstance &&
                    (ce ||
                      (this._element.removeModelFromLayers(this._model),
                      (ce = !0)),
                    this._removeMeshInstance(this._meshInfo[ie].meshInstance));
                this._meshInfo.length > this._font.textures.length &&
                  (this._meshInfo.length = this._font.textures.length),
                  this._updateText();
              }
              get font() {
                return this._font;
              }
              set alignment(R) {
                R instanceof c.S
                  ? this._alignment.set(R.x, R.y)
                  : this._alignment.set(R[0], R[1]),
                  this._font && this._updateText();
              }
              get alignment() {
                return this._alignment;
              }
              set autoWidth(R) {
                const j = this._autoWidth;
                if (
                  ((this._autoWidth = R),
                  R &&
                    Math.abs(this._element.anchor.x - this._element.anchor.z) <
                      1e-4 &&
                    (this._element.width = this.width),
                  j !== R)
                ) {
                  const se = this._shouldAutoFit()
                    ? this._maxFontSize
                    : this._originalFontSize;
                  se !== this._fontSize &&
                    ((this._fontSize = se), this._font && this._updateText());
                }
              }
              get autoWidth() {
                return this._autoWidth;
              }
              set autoHeight(R) {
                const j = this._autoHeight;
                if (
                  ((this._autoHeight = R),
                  R &&
                    Math.abs(this._element.anchor.y - this._element.anchor.w) <
                      1e-4 &&
                    (this._element.height = this.height),
                  j !== R)
                ) {
                  const se = this._shouldAutoFit()
                    ? this._maxFontSize
                    : this._originalFontSize;
                  se !== this._fontSize &&
                    ((this._fontSize = se), this._font && this._updateText());
                }
              }
              get autoHeight() {
                return this._autoHeight;
              }
              set rtlReorder(R) {
                this._rtlReorder !== R &&
                  ((this._rtlReorder = R), this._font && this._updateText());
              }
              get rtlReorder() {
                return this._rtlReorder;
              }
              set unicodeConverter(R) {
                this._unicodeConverter !== R &&
                  ((this._unicodeConverter = R), this._setText(this._text));
              }
              get unicodeConverter() {
                return this._unicodeConverter;
              }
              get aabb() {
                if (this._aabbDirty) {
                  let R = !1;
                  for (let j = 0; j < this._meshInfo.length; j++)
                    this._meshInfo[j].meshInstance &&
                      (R
                        ? this._aabb.add(this._meshInfo[j].meshInstance.aabb)
                        : (this._aabb.copy(this._meshInfo[j].meshInstance.aabb),
                          (R = !0)));
                  this._aabbDirty = !1;
                }
                return this._aabb;
              }
              set outlineColor(R) {
                const j = R instanceof g.I ? R.r : R[0],
                  se = R instanceof g.I ? R.g : R[1],
                  ce = R instanceof g.I ? R.b : R[2],
                  ie = R instanceof g.I ? R.a : R[3];
                if (
                  !(
                    this._outlineColor.r === j &&
                    this._outlineColor.g === se &&
                    this._outlineColor.b === ce &&
                    this._outlineColor.a === ie
                  ) &&
                  ((this._outlineColor.r = j),
                  (this._outlineColor.g = se),
                  (this._outlineColor.b = ce),
                  (this._outlineColor.a = ie),
                  !!this._model)
                ) {
                  if (this._symbolOutlineParams)
                    this._font && this._updateText();
                  else {
                    (this._outlineColorUniform[0] = this._outlineColor.r),
                      (this._outlineColorUniform[1] = this._outlineColor.g),
                      (this._outlineColorUniform[2] = this._outlineColor.b),
                      (this._outlineColorUniform[3] = this._outlineColor.a);
                    for (
                      let b = 0, M = this._model.meshInstances.length;
                      b < M;
                      b++
                    )
                      this._model.meshInstances[b].setParameter(
                        "outline_color",
                        this._outlineColorUniform
                      );
                  }
                  this._element &&
                    this._element.fire("set:outline", this._color);
                }
              }
              get outlineColor() {
                return this._outlineColor;
              }
              set outlineThickness(R) {
                const j = this._outlineThickness;
                if (((this._outlineThickness = R), j !== R && this._font)) {
                  if (!this._model) return;
                  if (this._symbolOutlineParams)
                    this._font && this._updateText();
                  else
                    for (
                      let se = 0, ce = this._model.meshInstances.length;
                      se < ce;
                      se++
                    )
                      this._model.meshInstances[se].setParameter(
                        "outline_thickness",
                        this._outlineThicknessScale * this._outlineThickness
                      );
                }
              }
              get outlineThickness() {
                return this._outlineThickness;
              }
              set shadowColor(R) {
                const j = R instanceof g.I ? R.r : R[0],
                  se = R instanceof g.I ? R.g : R[1],
                  ce = R instanceof g.I ? R.b : R[2],
                  ie = R instanceof g.I ? R.a : R[3];
                if (
                  !(
                    this._shadowColor.r === j &&
                    this._shadowColor.g === se &&
                    this._shadowColor.b === ce &&
                    this._shadowColor.a === ie
                  ) &&
                  ((this._shadowColor.r = j),
                  (this._shadowColor.g = se),
                  (this._shadowColor.b = ce),
                  (this._shadowColor.a = ie),
                  !!this._model)
                )
                  if (this._symbolShadowParams)
                    this._font && this._updateText();
                  else {
                    (this._shadowColorUniform[0] = this._shadowColor.r),
                      (this._shadowColorUniform[1] = this._shadowColor.g),
                      (this._shadowColorUniform[2] = this._shadowColor.b),
                      (this._shadowColorUniform[3] = this._shadowColor.a);
                    for (
                      let b = 0, M = this._model.meshInstances.length;
                      b < M;
                      b++
                    )
                      this._model.meshInstances[b].setParameter(
                        "shadow_color",
                        this._shadowColorUniform
                      );
                  }
              }
              get shadowColor() {
                return this._shadowColor;
              }
              set shadowOffset(R) {
                const j = R instanceof c.S ? R.x : R[0],
                  se = R instanceof c.S ? R.y : R[1];
                if (
                  !(
                    this._shadowOffset.x === j && this._shadowOffset.y === se
                  ) &&
                  (this._shadowOffset.set(j, se), this._font && this._model)
                )
                  if (this._symbolShadowParams) this._updateText();
                  else
                    for (
                      let ce = 0, ie = this._model.meshInstances.length;
                      ce < ie;
                      ce++
                    ) {
                      const b =
                        -this._font.data.info.maps[ce].width /
                        this._font.data.info.maps[ce].height;
                      (this._shadowOffsetUniform[0] =
                        this._shadowOffsetScale * this._shadowOffset.x),
                        (this._shadowOffsetUniform[1] =
                          b * this._shadowOffsetScale * this._shadowOffset.y),
                        this._model.meshInstances[ce].setParameter(
                          "shadow_offset",
                          this._shadowOffsetUniform
                        );
                    }
              }
              get shadowOffset() {
                return this._shadowOffset;
              }
              set minFontSize(R) {
                this._minFontSize !== R &&
                  ((this._minFontSize = R),
                  this.font && this._shouldAutoFit() && this._updateText());
              }
              get minFontSize() {
                return this._minFontSize;
              }
              set maxFontSize(R) {
                this._maxFontSize !== R &&
                  ((this._maxFontSize = R),
                  this.font && this._shouldAutoFit() && this._updateText());
              }
              get maxFontSize() {
                return this._maxFontSize;
              }
              set autoFitWidth(R) {
                this._autoFitWidth !== R &&
                  ((this._autoFitWidth = R),
                  (this._fontSize = this._shouldAutoFit()
                    ? this._maxFontSize
                    : this._originalFontSize),
                  this.font && this._updateText());
              }
              get autoFitWidth() {
                return this._autoFitWidth;
              }
              set autoFitHeight(R) {
                this._autoFitHeight !== R &&
                  ((this._autoFitHeight = R),
                  (this._fontSize = this._shouldAutoFit()
                    ? this._maxFontSize
                    : this._originalFontSize),
                  this.font && this._updateText());
              }
              get autoFitHeight() {
                return this._autoFitHeight;
              }
              set maxLines(R) {
                this._maxLines !== R &&
                  ((R === null && this._maxLines === -1) ||
                    ((this._maxLines = R === null ? -1 : R),
                    this.font && this._wrapLines && this._updateText()));
              }
              get maxLines() {
                return this._maxLines;
              }
              set enableMarkup(R) {
                if (((R = !!R), this._enableMarkup === R)) return;
                (this._enableMarkup = R), this.font && this._updateText();
                const j = this._element._isScreenSpace();
                this._updateMaterial(j);
              }
              get enableMarkup() {
                return this._enableMarkup;
              }
              get symbols() {
                return this._symbols;
              }
              get symbolColors() {
                return this._symbolColors === null
                  ? null
                  : this._symbolColors.map(function (R) {
                      return this._colorPalette.slice(R * 3, R * 3 + 3);
                    }, this);
              }
              get symbolOutlineParams() {
                return this._symbolOutlineParams === null
                  ? null
                  : this._symbolOutlineParams.map(function (R) {
                      return this._outlinePalette.slice(R * 5, R * 5 + 5);
                    }, this);
              }
              get symbolShadowParams() {
                return this._symbolShadowParams === null
                  ? null
                  : this._symbolShadowParams.map(function (R) {
                      return this._shadowPalette.slice(R * 6, R * 6 + 6);
                    }, this);
              }
              get rtl() {
                return this._rtl;
              }
              set rangeStart(R) {
                (R = Math.max(0, Math.min(R, this._symbols.length))),
                  R !== this._rangeStart &&
                    ((this._rangeStart = R), this._updateRenderRange());
              }
              get rangeStart() {
                return this._rangeStart;
              }
              set rangeEnd(R) {
                (R = Math.max(
                  this._rangeStart,
                  Math.min(R, this._symbols.length)
                )),
                  R !== this._rangeEnd &&
                    ((this._rangeEnd = R), this._updateRenderRange());
              }
              get rangeEnd() {
                return this._rangeEnd;
              }
            }
          },
          3648: (Se, W, a) => {
            "use strict";
            a.d(W, { T: () => s });
            var x = a(4585),
              T = a(9758),
              g = a(6847),
              c = a(2978),
              d = a(8620),
              h = a(7580);
            const f = [
              "angularDampingX",
              "angularDampingY",
              "angularDampingZ",
              "angularEquilibriumX",
              "angularEquilibriumY",
              "angularEquilibriumZ",
              "angularLimitsX",
              "angularLimitsY",
              "angularLimitsZ",
              "angularMotionX",
              "angularMotionY",
              "angularMotionZ",
              "angularSpringX",
              "angularSpringY",
              "angularSpringZ",
              "angularStiffnessX",
              "angularStiffnessY",
              "angularStiffnessZ",
              "breakForce",
              "enableCollision",
              "enabled",
              "entityA",
              "entityB",
              "linearDampingX",
              "linearDampingY",
              "linearDampingZ",
              "linearEquilibriumX",
              "linearEquilibriumY",
              "linearEquilibriumZ",
              "linearLimitsX",
              "linearLimitsY",
              "linearLimitsZ",
              "linearMotionX",
              "linearMotionY",
              "linearMotionZ",
              "linearSpringX",
              "linearSpringY",
              "linearSpringZ",
              "linearStiffnessX",
              "linearStiffnessY",
              "linearStiffnessZ",
            ];
            class s extends d.w {
              constructor(o, i) {
                super(o, i),
                  (this._constraint = null),
                  (this._entityA = null),
                  (this._entityB = null),
                  (this._breakForce = 34e37),
                  (this._enableCollision = !0),
                  (this._linearMotionX = h.wg),
                  (this._linearLimitsX = new c.S(0, 0)),
                  (this._linearSpringX = !1),
                  (this._linearStiffnessX = 0),
                  (this._linearDampingX = 1),
                  (this._linearEquilibriumX = 0),
                  (this._linearMotionY = h.wg),
                  (this._linearLimitsY = new c.S(0, 0)),
                  (this._linearSpringY = !1),
                  (this._linearStiffnessY = 0),
                  (this._linearDampingY = 1),
                  (this._linearEquilibriumY = 0),
                  (this._linearMotionZ = h.wg),
                  (this._linearLimitsZ = new c.S(0, 0)),
                  (this._linearSpringZ = !1),
                  (this._linearStiffnessZ = 0),
                  (this._linearDampingZ = 1),
                  (this._linearEquilibriumZ = 0),
                  (this._angularMotionX = h.wg),
                  (this._angularLimitsX = new c.S(0, 0)),
                  (this._angularSpringX = !1),
                  (this._angularStiffnessX = 0),
                  (this._angularDampingX = 1),
                  (this._angularEquilibriumX = 0),
                  (this._angularMotionY = h.wg),
                  (this._angularLimitsY = new c.S(0, 0)),
                  (this._angularSpringY = !1),
                  (this._angularStiffnessY = 0),
                  (this._angularDampingY = 1),
                  (this._angularEquilibriumY = 0),
                  (this._angularMotionZ = h.wg),
                  (this._angularLimitsZ = new c.S(0, 0)),
                  (this._angularSpringZ = !1),
                  (this._angularEquilibriumZ = 0),
                  (this._angularDampingZ = 1),
                  (this._angularStiffnessZ = 0),
                  this.on("set_enabled", this._onSetEnabled, this);
              }
              set entityA(o) {
                this._destroyConstraint(),
                  (this._entityA = o),
                  this._createConstraint();
              }
              get entityA() {
                return this._entityA;
              }
              set entityB(o) {
                this._destroyConstraint(),
                  (this._entityB = o),
                  this._createConstraint();
              }
              get entityB() {
                return this._entityB;
              }
              set breakForce(o) {
                this._constraint &&
                  this._breakForce !== o &&
                  (this._constraint.setBreakingImpulseThreshold(o),
                  (this._breakForce = o));
              }
              get breakForce() {
                return this._breakForce;
              }
              set enableCollision(o) {
                this._destroyConstraint(),
                  (this._enableCollision = o),
                  this._createConstraint();
              }
              get enableCollision() {
                return this._enableCollision;
              }
              set angularLimitsX(o) {
                this._angularLimitsX.equals(o) ||
                  (this._angularLimitsX.copy(o), this._updateAngularLimits());
              }
              get angularLimitsX() {
                return this._angularLimitsX;
              }
              set angularMotionX(o) {
                this._angularMotionX !== o &&
                  ((this._angularMotionX = o), this._updateAngularLimits());
              }
              get angularMotionX() {
                return this._angularMotionX;
              }
              set angularLimitsY(o) {
                this._angularLimitsY.equals(o) ||
                  (this._angularLimitsY.copy(o), this._updateAngularLimits());
              }
              get angularLimitsY() {
                return this._angularLimitsY;
              }
              set angularMotionY(o) {
                this._angularMotionY !== o &&
                  ((this._angularMotionY = o), this._updateAngularLimits());
              }
              get angularMotionY() {
                return this._angularMotionY;
              }
              set angularLimitsZ(o) {
                this._angularLimitsZ.equals(o) ||
                  (this._angularLimitsZ.copy(o), this._updateAngularLimits());
              }
              get angularLimitsZ() {
                return this._angularLimitsZ;
              }
              set angularMotionZ(o) {
                this._angularMotionZ !== o &&
                  ((this._angularMotionZ = o), this._updateAngularLimits());
              }
              get angularMotionZ() {
                return this._angularMotionZ;
              }
              set linearLimitsX(o) {
                this._linearLimitsX.equals(o) ||
                  (this._linearLimitsX.copy(o), this._updateLinearLimits());
              }
              get linearLimitsX() {
                return this._linearLimitsX;
              }
              set linearMotionX(o) {
                this._linearMotionX !== o &&
                  ((this._linearMotionX = o), this._updateLinearLimits());
              }
              get linearMotionX() {
                return this._linearMotionX;
              }
              set linearLimitsY(o) {
                this._linearLimitsY.equals(o) ||
                  (this._linearLimitsY.copy(o), this._updateLinearLimits());
              }
              get linearLimitsY() {
                return this._linearLimitsY;
              }
              set linearMotionY(o) {
                this._linearMotionY !== o &&
                  ((this._linearMotionY = o), this._updateLinearLimits());
              }
              get linearMotionY() {
                return this._linearMotionY;
              }
              set linearLimitsZ(o) {
                this._linearLimitsZ.equals(o) ||
                  (this._linearLimitsZ.copy(o), this._updateLinearLimits());
              }
              get linearLimitsZ() {
                return this._linearLimitsZ;
              }
              set linearMotionZ(o) {
                this._linearMotionZ !== o &&
                  ((this._linearMotionZ = o), this._updateLinearLimits());
              }
              get linearMotionZ() {
                return this._linearMotionZ;
              }
              _convertTransform(o, i) {
                const e = o.getTranslation(),
                  t = new g.D();
                t.setFromMat4(o);
                const r = new Ammo.btVector3(e.x, e.y, e.z),
                  u = new Ammo.btQuaternion(t.x, t.y, t.z, t.w);
                i.setOrigin(r),
                  i.setRotation(u),
                  Ammo.destroy(r),
                  Ammo.destroy(u);
              }
              _updateAngularLimits() {
                const o = this._constraint;
                if (o) {
                  let i, e, t, r, u, y;
                  this._angularMotionX === h.q8
                    ? ((i = this._angularLimitsX.x * x.m.DEG_TO_RAD),
                      (r = this._angularLimitsX.y * x.m.DEG_TO_RAD))
                    : this._angularMotionX === h.Pk
                    ? ((i = 1), (r = 0))
                    : (i = r = 0),
                    this._angularMotionY === h.q8
                      ? ((e = this._angularLimitsY.x * x.m.DEG_TO_RAD),
                        (u = this._angularLimitsY.y * x.m.DEG_TO_RAD))
                      : this._angularMotionY === h.Pk
                      ? ((e = 1), (u = 0))
                      : (e = u = 0),
                    this._angularMotionZ === h.q8
                      ? ((t = this._angularLimitsZ.x * x.m.DEG_TO_RAD),
                        (y = this._angularLimitsZ.y * x.m.DEG_TO_RAD))
                      : this._angularMotionZ === h.Pk
                      ? ((t = 1), (y = 0))
                      : (t = y = 0);
                  const p = new Ammo.btVector3(i, e, t);
                  o.setAngularLowerLimit(p),
                    p.setValue(r, u, y),
                    o.setAngularUpperLimit(p),
                    Ammo.destroy(p);
                }
              }
              _updateLinearLimits() {
                const o = this._constraint;
                if (o) {
                  let i, e, t, r, u, y;
                  this._linearMotionX === h.q8
                    ? ((i = this._linearLimitsX.x), (r = this._linearLimitsX.y))
                    : this._linearMotionX === h.Pk
                    ? ((i = 1), (r = 0))
                    : (i = r = 0),
                    this._linearMotionY === h.q8
                      ? ((e = this._linearLimitsY.x),
                        (u = this._linearLimitsY.y))
                      : this._linearMotionY === h.Pk
                      ? ((e = 1), (u = 0))
                      : (e = u = 0),
                    this._linearMotionZ === h.q8
                      ? ((t = this._linearLimitsZ.x),
                        (y = this._linearLimitsZ.y))
                      : this._linearMotionZ === h.Pk
                      ? ((t = 1), (y = 0))
                      : (t = y = 0);
                  const p = new Ammo.btVector3(i, e, t);
                  o.setLinearLowerLimit(p),
                    p.setValue(r, u, y),
                    o.setLinearUpperLimit(p),
                    Ammo.destroy(p);
                }
              }
              _createConstraint() {
                if (this._entityA && this._entityA.rigidbody) {
                  this._destroyConstraint();
                  const o = new T.y(),
                    i = this._entityA.rigidbody.body;
                  i.activate();
                  const e = this.entity.getWorldTransform(),
                    r = this._entityA.getWorldTransform().clone().invert();
                  o.mul2(r, e);
                  const u = new Ammo.btTransform();
                  if (
                    (this._convertTransform(o, u),
                    this._entityB && this._entityB.rigidbody)
                  ) {
                    const m = this._entityB.rigidbody.body;
                    m.activate();
                    const v = this._entityB
                      .getWorldTransform()
                      .clone()
                      .invert();
                    o.mul2(v, e);
                    const P = new Ammo.btTransform();
                    this._convertTransform(o, P),
                      (this._constraint =
                        new Ammo.btGeneric6DofSpringConstraint(
                          i,
                          m,
                          u,
                          P,
                          !this._enableCollision
                        )),
                      Ammo.destroy(P);
                  } else
                    this._constraint = new Ammo.btGeneric6DofSpringConstraint(
                      i,
                      u,
                      !this._enableCollision
                    );
                  Ammo.destroy(u);
                  const y = ["X", "Y", "Z", "X", "Y", "Z"];
                  for (let m = 0; m < 6; m++) {
                    const E = m < 3 ? "_linear" : "_angular";
                    this._constraint.enableSpring(m, this[E + "Spring" + y[m]]),
                      this._constraint.setDamping(
                        m,
                        this[E + "Damping" + y[m]]
                      ),
                      this._constraint.setEquilibriumPoint(
                        m,
                        this[E + "Equilibrium" + y[m]]
                      ),
                      this._constraint.setStiffness(
                        m,
                        this[E + "Stiffness" + y[m]]
                      );
                  }
                  this._constraint.setBreakingImpulseThreshold(
                    this._breakForce
                  ),
                    this._updateLinearLimits(),
                    this._updateAngularLimits(),
                    this.system.app.systems.rigidbody.dynamicsWorld.addConstraint(
                      this._constraint,
                      !this._enableCollision
                    );
                }
              }
              _destroyConstraint() {
                this._constraint &&
                  (this.system.app.systems.rigidbody.dynamicsWorld.removeConstraint(
                    this._constraint
                  ),
                  Ammo.destroy(this._constraint),
                  (this._constraint = null));
              }
              initFromData(o) {
                for (const i of f)
                  o.hasOwnProperty(i) &&
                    (o[i] instanceof c.S
                      ? this["_" + i].copy(o[i])
                      : (this["_" + i] = o[i]));
                this._createConstraint();
              }
              onEnable() {
                this._createConstraint();
              }
              onDisable() {
                this._destroyConstraint();
              }
              _onSetEnabled(o, i, e) {}
              _onBeforeRemove() {
                this.fire("remove");
              }
            }
            const l = {
              Damping: "setDamping",
              Equilibrium: "setEquilibriumPoint",
              Spring: "enableSpring",
              Stiffness: "setStiffness",
            };
            ["linear", "angular"].forEach((n) => {
              ["Damping", "Equilibrium", "Spring", "Stiffness"].forEach((o) => {
                ["X", "Y", "Z"].forEach((i) => {
                  const e = n + o + i,
                    t = "_" + e;
                  let r = n === "linear" ? 0 : 3;
                  i === "Y" && (r += 1),
                    i === "Z" && (r += 2),
                    Object.defineProperty(s.prototype, e, {
                      get: function () {
                        return this[t];
                      },
                      set: function (u) {
                        this[t] !== u &&
                          ((this[t] = u), this._constraint[l[o]](r, u));
                      },
                    });
                });
              });
            });
          },
          7580: (Se, W, a) => {
            "use strict";
            a.d(W, { Pk: () => x, q8: () => T, wg: () => g });
            const x = "free",
              T = "limited",
              g = "locked";
          },
          6869: (Se, W, a) => {
            "use strict";
            a.d(W, { m: () => h });
            var x = a(8620),
              T = a(6813),
              g = a(3648);
            class c {
              constructor() {
                this.enabled = !0;
              }
            }
            const d = ["enabled"];
            class h extends T.Q {
              constructor(s) {
                super(s),
                  (this.id = "joint"),
                  (this.app = s),
                  (this.ComponentType = g.T),
                  (this.DataType = c),
                  (this.schema = d);
              }
              initializeComponentData(s, l, n) {
                s.initFromData(l);
              }
            }
            x.w._buildAccessors(g.T.prototype, d);
          },
          1724: (Se, W, a) => {
            "use strict";
            a.d(W, { v: () => T });
            var x = a(8620);
            class T extends x.w {
              constructor(c, d) {
                super(c, d),
                  (this._minWidth = 0),
                  (this._minHeight = 0),
                  (this._maxWidth = null),
                  (this._maxHeight = null),
                  (this._fitWidthProportion = 0),
                  (this._fitHeightProportion = 0),
                  (this._excludeFromLayout = !1);
              }
              set minWidth(c) {
                c !== this._minWidth &&
                  ((this._minWidth = c), this.fire("resize"));
              }
              get minWidth() {
                return this._minWidth;
              }
              set minHeight(c) {
                c !== this._minHeight &&
                  ((this._minHeight = c), this.fire("resize"));
              }
              get minHeight() {
                return this._minHeight;
              }
              set maxWidth(c) {
                c !== this._maxWidth &&
                  ((this._maxWidth = c), this.fire("resize"));
              }
              get maxWidth() {
                return this._maxWidth;
              }
              set maxHeight(c) {
                c !== this._maxHeight &&
                  ((this._maxHeight = c), this.fire("resize"));
              }
              get maxHeight() {
                return this._maxHeight;
              }
              set fitWidthProportion(c) {
                c !== this._fitWidthProportion &&
                  ((this._fitWidthProportion = c), this.fire("resize"));
              }
              get fitWidthProportion() {
                return this._fitWidthProportion;
              }
              set fitHeightProportion(c) {
                c !== this._fitHeightProportion &&
                  ((this._fitHeightProportion = c), this.fire("resize"));
              }
              get fitHeightProportion() {
                return this._fitHeightProportion;
              }
              set excludeFromLayout(c) {
                c !== this._excludeFromLayout &&
                  ((this._excludeFromLayout = c), this.fire("resize"));
              }
              get excludeFromLayout() {
                return this._excludeFromLayout;
              }
            }
          },
          428: (Se, W, a) => {
            "use strict";
            a.d(W, { G: () => h });
            var x = a(8620),
              T = a(6813),
              g = a(1724);
            class c {
              constructor() {
                this.enabled = !0;
              }
            }
            const d = ["enabled"];
            class h extends T.Q {
              constructor(s) {
                super(s),
                  (this.id = "layoutchild"),
                  (this.ComponentType = g.v),
                  (this.DataType = c),
                  (this.schema = d);
              }
              initializeComponentData(s, l, n) {
                l.enabled !== void 0 && (s.enabled = l.enabled),
                  l.minWidth !== void 0 && (s.minWidth = l.minWidth),
                  l.minHeight !== void 0 && (s.minHeight = l.minHeight),
                  l.maxWidth !== void 0 && (s.maxWidth = l.maxWidth),
                  l.maxHeight !== void 0 && (s.maxHeight = l.maxHeight),
                  l.fitWidthProportion !== void 0 &&
                    (s.fitWidthProportion = l.fitWidthProportion),
                  l.fitHeightProportion !== void 0 &&
                    (s.fitHeightProportion = l.fitHeightProportion),
                  l.excludeFromLayout !== void 0 &&
                    (s.excludeFromLayout = l.excludeFromLayout),
                  super.initializeComponentData(s, l, n);
              }
              cloneComponent(s, l) {
                const n = s.layoutchild;
                return this.addComponent(l, {
                  enabled: n.enabled,
                  minWidth: n.minWidth,
                  minHeight: n.minHeight,
                  maxWidth: n.maxWidth,
                  maxHeight: n.maxHeight,
                  fitWidthProportion: n.fitWidthProportion,
                  fitHeightProportion: n.fitHeightProportion,
                  excludeFromLayout: n.excludeFromLayout,
                });
              }
            }
            x.w._buildAccessors(g.v.prototype, d);
          },
          492: (Se, W, a) => {
            "use strict";
            a.d(W, { k: () => l });
            var x = a(2978),
              T = a(6630),
              g = a(3114),
              c = a(3269),
              d = a(8620),
              h = a(381);
            function f(n) {
              return n.element;
            }
            function s(n) {
              return n.enabled && n.element && n.element.enabled;
            }
            class l extends d.w {
              constructor(o, i) {
                super(o, i),
                  (this._orientation = g.gC),
                  (this._reverseX = !1),
                  (this._reverseY = !0),
                  (this._alignment = new x.S(0, 1)),
                  (this._padding = new T.T()),
                  (this._spacing = new x.S()),
                  (this._widthFitting = c.hz),
                  (this._heightFitting = c.hz),
                  (this._wrap = !1),
                  (this._layoutCalculator = new h.S()),
                  this._listenForReflowEvents(this.entity, "on"),
                  this.entity.children.forEach((e) => {
                    this._listenForReflowEvents(e, "on");
                  }),
                  this.entity.on("childinsert", this._onChildInsert, this),
                  this.entity.on("childremove", this._onChildRemove, this),
                  o.app.systems.element.on(
                    "add",
                    this._onElementOrLayoutComponentAdd,
                    this
                  ),
                  o.app.systems.element.on(
                    "beforeremove",
                    this._onElementOrLayoutComponentRemove,
                    this
                  ),
                  o.app.systems.layoutchild.on(
                    "add",
                    this._onElementOrLayoutComponentAdd,
                    this
                  ),
                  o.app.systems.layoutchild.on(
                    "beforeremove",
                    this._onElementOrLayoutComponentRemove,
                    this
                  );
              }
              set orientation(o) {
                o !== this._orientation &&
                  ((this._orientation = o), this._scheduleReflow());
              }
              get orientation() {
                return this._orientation;
              }
              set reverseX(o) {
                o !== this._reverseX &&
                  ((this._reverseX = o), this._scheduleReflow());
              }
              get reverseX() {
                return this._reverseX;
              }
              set reverseY(o) {
                o !== this._reverseY &&
                  ((this._reverseY = o), this._scheduleReflow());
              }
              get reverseY() {
                return this._reverseY;
              }
              set alignment(o) {
                o.equals(this._alignment) ||
                  (this._alignment.copy(o), this._scheduleReflow());
              }
              get alignment() {
                return this._alignment;
              }
              set padding(o) {
                o.equals(this._padding) ||
                  (this._padding.copy(o), this._scheduleReflow());
              }
              get padding() {
                return this._padding;
              }
              set spacing(o) {
                o.equals(this._spacing) ||
                  (this._spacing.copy(o), this._scheduleReflow());
              }
              get spacing() {
                return this._spacing;
              }
              set widthFitting(o) {
                o !== this._widthFitting &&
                  ((this._widthFitting = o), this._scheduleReflow());
              }
              get widthFitting() {
                return this._widthFitting;
              }
              set heightFitting(o) {
                o !== this._heightFitting &&
                  ((this._heightFitting = o), this._scheduleReflow());
              }
              get heightFitting() {
                return this._heightFitting;
              }
              set wrap(o) {
                o !== this._wrap && ((this._wrap = o), this._scheduleReflow());
              }
              get wrap() {
                return this._wrap;
              }
              _isSelfOrChild(o) {
                return (
                  o === this.entity || this.entity.children.indexOf(o) !== -1
                );
              }
              _listenForReflowEvents(o, i) {
                o.element &&
                  (o.element[i]("enableelement", this._scheduleReflow, this),
                  o.element[i]("disableelement", this._scheduleReflow, this),
                  o.element[i]("resize", this._scheduleReflow, this),
                  o.element[i]("set:pivot", this._scheduleReflow, this)),
                  o.layoutchild &&
                    (o.layoutchild[i](
                      "set_enabled",
                      this._scheduleReflow,
                      this
                    ),
                    o.layoutchild[i]("resize", this._scheduleReflow, this));
              }
              _onElementOrLayoutComponentAdd(o) {
                this._isSelfOrChild(o) &&
                  (this._listenForReflowEvents(o, "on"),
                  this._scheduleReflow());
              }
              _onElementOrLayoutComponentRemove(o) {
                this._isSelfOrChild(o) &&
                  (this._listenForReflowEvents(o, "off"),
                  this._scheduleReflow());
              }
              _onChildInsert(o) {
                this._listenForReflowEvents(o, "on"), this._scheduleReflow();
              }
              _onChildRemove(o) {
                this._listenForReflowEvents(o, "off"), this._scheduleReflow();
              }
              _scheduleReflow() {
                this.enabled &&
                  this.entity &&
                  this.entity.enabled &&
                  !this._isPerformingReflow &&
                  this.system.scheduleReflow(this);
              }
              reflow() {
                const o = f(this.entity),
                  i = this.entity.children.filter(s).map(f);
                if (!o || i.length === 0) return;
                const e = Math.max(o.calculatedWidth, 0),
                  t = Math.max(o.calculatedHeight, 0),
                  r = {
                    orientation: this._orientation,
                    reverseX: this._reverseX,
                    reverseY: this._reverseY,
                    alignment: this._alignment,
                    padding: this._padding,
                    spacing: this._spacing,
                    widthFitting: this._widthFitting,
                    heightFitting: this._heightFitting,
                    wrap: this._wrap,
                    containerSize: new x.S(e, t),
                  };
                this._isPerformingReflow = !0;
                const u = this._layoutCalculator.calculateLayout(i, r);
                (this._isPerformingReflow = !1), this.fire("reflow", u);
              }
              onEnable() {
                this._scheduleReflow();
              }
              onRemove() {
                this.entity.off("childinsert", this._onChildInsert, this),
                  this.entity.off("childremove", this._onChildRemove, this),
                  this._listenForReflowEvents(this.entity, "off"),
                  this.entity.children.forEach((o) => {
                    this._listenForReflowEvents(o, "off");
                  }),
                  this.system.app.systems.element.off(
                    "add",
                    this._onElementOrLayoutComponentAdd,
                    this
                  ),
                  this.system.app.systems.element.off(
                    "beforeremove",
                    this._onElementOrLayoutComponentRemove,
                    this
                  ),
                  this.system.app.systems.layoutchild.off(
                    "add",
                    this._onElementOrLayoutComponentAdd,
                    this
                  ),
                  this.system.app.systems.layoutchild.off(
                    "beforeremove",
                    this._onElementOrLayoutComponentRemove,
                    this
                  );
              }
            }
          },
          3269: (Se, W, a) => {
            "use strict";
            a.d(W, { F9: () => c, az: () => T, hz: () => x, zL: () => g });
            const x = 0,
              T = 1,
              g = 2,
              c = 3;
          },
          381: (Se, W, a) => {
            "use strict";
            a.d(W, { S: () => i });
            var x = a(2978),
              T = a(6630),
              g = a(3114),
              c = a(3269);
            const d = {};
            (d[g.gC] = {
              axis: "x",
              size: "width",
              calculatedSize: "calculatedWidth",
              minSize: "minWidth",
              maxSize: "maxWidth",
              fitting: "widthFitting",
              fittingProportion: "fitWidthProportion",
            }),
              (d[g.Gh] = {
                axis: "y",
                size: "height",
                calculatedSize: "calculatedHeight",
                minSize: "minHeight",
                maxSize: "maxHeight",
                fitting: "heightFitting",
                fittingProportion: "fitHeightProportion",
              });
            const h = {};
            (h[g.gC] = g.Gh), (h[g.Gh] = g.gC);
            const f = {
                minWidth: 0,
                minHeight: 0,
                maxWidth: Number.POSITIVE_INFINITY,
                maxHeight: Number.POSITIVE_INFINITY,
                width: null,
                height: null,
                fitWidthProportion: 0,
                fitHeightProportion: 0,
              },
              s = {
                NONE: "NONE",
                APPLY_STRETCHING: "APPLY_STRETCHING",
                APPLY_SHRINKING: "APPLY_SHRINKING",
              },
              l = new x.S();
            function n(e) {
              let t;
              const r = d[e],
                u = d[h[e]];
              function y(R, j) {
                return -j[r.size] * R.pivot[r.axis];
              }
              function p(R, j) {
                return -j[u.size] * R.pivot[u.axis];
              }
              function _(R, j) {
                return j[r.size] * (1 - R.pivot[r.axis]);
              }
              function m(R, j) {
                (R = R.filter(E)),
                  (t = j),
                  (l.x = t.containerSize.x - t.padding.x - t.padding.z),
                  (l.y = t.containerSize.y - t.padding.y - t.padding.w),
                  v(R);
                const se = I(P(R)),
                  ce = B(se, A(se)),
                  ie = X(se, ce);
                return $(se, ce, ie), ne(se, ce, ie), Y(se);
              }
              function E(R) {
                const j = R.entity.layoutchild;
                return !j || !j.enabled || !j.excludeFromLayout;
              }
              function v(R) {
                for (let j = 0; j < R.length; ++j) {
                  const se = R[j],
                    ce = se.anchor;
                  (ce.x !== 0 || ce.y !== 0 || ce.z !== 0 || ce.w !== 0) &&
                    (se.anchor = T.T.ZERO);
                }
              }
              function P(R) {
                if (!t.wrap) return [R];
                const j = [[]],
                  se = Z(R);
                let ce = 0;
                const ie = t[r.fitting] === c.zL;
                for (let b = 0; b < R.length; ++b) {
                  j[j.length - 1].length > 0 && (ce += t.spacing[r.axis]);
                  const M = se[b][r.size];
                  (ce += M),
                    !ie &&
                      ce > l[r.axis] &&
                      j[j.length - 1].length !== 0 &&
                      ((ce = M), j.push([])),
                    j[j.length - 1].push(R[b]),
                    ie &&
                      ce > l[r.axis] &&
                      b !== R.length - 1 &&
                      ((ce = 0), j.push([]));
                }
                return j;
              }
              function I(R) {
                const j =
                    (t.orientation === g.gC && t.reverseX) ||
                    (t.orientation === g.Gh && t.reverseY),
                  se =
                    (t.orientation === g.gC && t.reverseY) ||
                    (t.orientation === g.Gh && t.reverseX);
                if (j)
                  for (let ce = 0; ce < R.length; ++ce) j && R[ce].reverse();
                return se && R.reverse(), R;
              }
              function A(R) {
                const j = [];
                for (let se = 0; se < R.length; ++se) {
                  const ce = R[se],
                    ie = Z(ce),
                    b = w(ie, r),
                    M = C(t[r.fitting], b, l[r.axis]);
                  M === s.APPLY_STRETCHING
                    ? k(ie, b, r)
                    : M === s.APPLY_SHRINKING && K(ie, b, r),
                    j.push(ie);
                }
                return j;
              }
              function B(R, j) {
                const se = [],
                  ce = [];
                for (let M = 0; M < R.length; ++M) {
                  const F = R[M];
                  (F.largestElement = null),
                    (F.largestSize = {
                      width: Number.NEGATIVE_INFINITY,
                      height: Number.NEGATIVE_INFINITY,
                    });
                  for (let z = 0; z < F.length; ++z) {
                    const oe = j[M][z];
                    oe[u.size] > F.largestSize[u.size] &&
                      ((F.largestElement = F[z]), (F.largestSize = oe));
                  }
                  se.push(F.largestElement), ce.push(F.largestSize);
                }
                const ie = w(ce, u),
                  b = C(t[u.fitting], ie, l[u.axis]);
                b === s.APPLY_STRETCHING
                  ? k(ce, ie, u)
                  : b === s.APPLY_SHRINKING && K(ce, ie, u);
                for (let M = 0; M < R.length; ++M) {
                  const F = R[M];
                  for (let z = 0; z < F.length; ++z) {
                    const oe = j[M][z],
                      de = oe[u.size],
                      ge = R.length === 1 ? l[u.axis] : F.largestSize[u.size],
                      Re = C(t[u.fitting], de, ge);
                    Re === s.APPLY_STRETCHING
                      ? (oe[u.size] = Math.min(ge, oe[u.maxSize]))
                      : Re === s.APPLY_SHRINKING &&
                        (oe[u.size] = Math.max(ge, oe[u.minSize]));
                  }
                }
                return j;
              }
              function C(R, j, se) {
                switch (R) {
                  case c.hz:
                    return s.NONE;
                  case c.az:
                    return j < se ? s.APPLY_STRETCHING : s.NONE;
                  case c.zL:
                    return j >= se ? s.APPLY_SHRINKING : s.NONE;
                  case c.F9:
                    return j < se ? s.APPLY_STRETCHING : s.APPLY_SHRINKING;
                  default:
                    throw new Error(`Unrecognized fitting mode: ${R}`);
                }
              }
              function w(R, j) {
                const se = O(R, j.size),
                  ce = (R.length - 1) * t.spacing[j.axis];
                return se + ce;
              }
              function k(R, j, se) {
                const ce = V(R, se.maxSize),
                  ie = me(R, se.fittingProportion),
                  b = ae(ie, ce);
                let M = l[se.axis] - j;
                for (let F = 0; F < R.length; ++F) {
                  const z = ce[F],
                    oe = te(z, M, ie, b),
                    de = R[z][se.size] + oe,
                    ge = R[z][se.maxSize],
                    Re = Math.min(de, ge);
                  R[z][se.size] = Re;
                  const Te = Math.max(de - Re, 0),
                    Ne = oe - Te;
                  M -= Ne;
                }
              }
              function K(R, j, se) {
                const ce = V(R, se.minSize, !0),
                  ie = me(R, se.fittingProportion),
                  b = N(ie),
                  M = ae(b, ce);
                let F = j - l[se.axis];
                for (let z = 0; z < R.length; ++z) {
                  const oe = ce[z],
                    de = te(oe, F, b, M),
                    ge = R[oe][se.size] - de,
                    Re = R[oe][se.minSize],
                    Te = Math.max(ge, Re);
                  R[oe][se.size] = Te;
                  const Ne = Math.max(Te - ge, 0),
                    Le = de - Ne;
                  F -= Le;
                }
              }
              function te(R, j, se, ce) {
                const ie = se[R],
                  b = ce[R];
                return Math.abs(ie) < 1e-5 && Math.abs(b) < 1e-5
                  ? j
                  : (j * ie) / b;
              }
              function X(R, j) {
                const se = {};
                (se[r.axis] = 0),
                  (se[u.axis] = 0),
                  (R[r.size] = Number.NEGATIVE_INFINITY);
                const ce = [];
                for (let ie = 0; ie < R.length; ++ie) {
                  const b = R[ie];
                  if (b.length === 0) {
                    ce.push([]);
                    continue;
                  }
                  const M = [],
                    F = j[ie];
                  for (let z = 0; z < b.length; ++z) {
                    const oe = b[z],
                      de = F[z];
                    (se[u.axis] -= p(oe, de)),
                      (se[r.axis] -= y(oe, de)),
                      (M[z] = {}),
                      (M[z][r.axis] = se[r.axis]),
                      (M[z][u.axis] = se[u.axis]),
                      (se[u.axis] += p(oe, de)),
                      (se[r.axis] += _(oe, de) + t.spacing[r.axis]);
                  }
                  (b[r.size] = se[r.axis] - t.spacing[r.axis]),
                    (b[u.size] = b.largestSize[u.size]),
                    (R[r.size] = Math.max(R[r.size], b[r.size])),
                    (se[r.axis] = 0),
                    (se[u.axis] += b[u.size] + t.spacing[u.axis]),
                    ce.push(M);
                }
                return (R[u.size] = se[u.axis] - t.spacing[u.axis]), ce;
              }
              function $(R, j, se) {
                const ce = t.alignment[r.axis],
                  ie = t.alignment[u.axis],
                  b = t.padding[r.axis],
                  M = t.padding[u.axis];
                for (let F = 0; F < R.length; ++F) {
                  const z = R[F],
                    oe = j[F],
                    de = se[F],
                    ge = (l[r.axis] - z[r.size]) * ce + b,
                    Re = (l[u.axis] - R[u.size]) * ie + M;
                  for (let Te = 0; Te < z.length; ++Te) {
                    const Ne =
                      (z[u.size] - oe[Te][u.size]) * t.alignment[u.axis];
                    (de[Te][r.axis] += ge), (de[Te][u.axis] += Re + Ne);
                  }
                }
              }
              function ne(R, j, se) {
                for (let ce = 0; ce < R.length; ++ce) {
                  const ie = R[ce],
                    b = j[ce],
                    M = se[ce];
                  for (let F = 0; F < ie.length; ++F) {
                    const z = ie[F];
                    (z[r.calculatedSize] = b[F][r.size]),
                      (z[u.calculatedSize] = b[F][u.size]),
                      t.orientation === g.gC
                        ? z.entity.setLocalPosition(
                            M[F][r.axis],
                            M[F][u.axis],
                            z.entity.getLocalPosition().z
                          )
                        : z.entity.setLocalPosition(
                            M[F][u.axis],
                            M[F][r.axis],
                            z.entity.getLocalPosition().z
                          );
                  }
                }
              }
              function Y(R) {
                const j = R.width,
                  se = R.height,
                  ce = (l.x - j) * t.alignment.x + t.padding.x,
                  ie = (l.y - se) * t.alignment.y + t.padding.y;
                return { bounds: new T.T(ce, ie, j, se) };
              }
              function Z(R) {
                const j = [];
                for (let se = 0; se < R.length; ++se) {
                  const ce = R[se],
                    ie = Math.max(ye(ce, "minWidth"), 0),
                    b = Math.max(ye(ce, "minHeight"), 0),
                    M = Math.max(ye(ce, "maxWidth"), ie),
                    F = Math.max(ye(ce, "maxHeight"), b),
                    z = pe(ye(ce, "width"), ie, M),
                    oe = pe(ye(ce, "height"), b, F),
                    de = ye(ce, "fitWidthProportion"),
                    ge = ye(ce, "fitHeightProportion");
                  j.push({
                    minWidth: ie,
                    minHeight: b,
                    maxWidth: M,
                    maxHeight: F,
                    width: z,
                    height: oe,
                    fitWidthProportion: de,
                    fitHeightProportion: ge,
                  });
                }
                return j;
              }
              function ye(R, j) {
                const se = R.entity.layoutchild;
                return se && se.enabled && se[j] !== void 0 && se[j] !== null
                  ? se[j]
                  : R[j] !== void 0
                  ? R[j]
                  : f[j];
              }
              function pe(R, j, se) {
                return Math.min(Math.max(R, j), se);
              }
              function O(R, j) {
                return R.reduce(function (se, ce) {
                  return se + ce[j];
                }, 0);
              }
              function me(R, j) {
                const se = O(R, j),
                  ce = [],
                  ie = R.length;
                if (se === 0) for (let b = 0; b < ie; ++b) ce.push(1 / ie);
                else for (let b = 0; b < ie; ++b) ce.push(R[b][j] / se);
                return ce;
              }
              function N(R) {
                if (R.length === 1) return [1];
                const j = [],
                  se = R.length;
                for (let ce = 0; ce < se; ++ce) j.push((1 - R[ce]) / (se - 1));
                return j;
              }
              function V(R, j, se) {
                return (
                  R.forEach(L),
                  R.slice()
                    .sort(function (ce, ie) {
                      return se ? ie[j] - ce[j] : ce[j] - ie[j];
                    })
                    .map(J)
                );
              }
              function L(R, j) {
                R.index = j;
              }
              function J(R) {
                return R.index;
              }
              function ae(R, j) {
                const se = [];
                se[j[R.length - 1]] = R[j[R.length - 1]];
                for (let ce = R.length - 2; ce >= 0; --ce)
                  se[j[ce]] = se[j[ce + 1]] + R[j[ce]];
                return se;
              }
              return m;
            }
            const o = {};
            (o[g.gC] = n(g.gC)), (o[g.Gh] = n(g.Gh));
            class i {
              calculateLayout(t, r) {
                const u = o[r.orientation];
                if (u) return u(t, r);
                throw new Error(
                  "Unrecognized orientation value: " + r.orientation
                );
              }
            }
          },
          7847: (Se, W, a) => {
            "use strict";
            a.d(W, { T: () => l });
            var x = a(2978),
              T = a(6630),
              g = a(8620),
              c = a(6813),
              d = a(492);
            class h {
              constructor() {
                this.enabled = !0;
              }
            }
            const f = ["enabled"],
              s = 100;
            class l extends c.Q {
              constructor(o) {
                super(o),
                  (this.id = "layoutgroup"),
                  (this.ComponentType = d.k),
                  (this.DataType = h),
                  (this.schema = f),
                  (this._reflowQueue = []),
                  this.on("beforeremove", this._onRemoveComponent, this),
                  this.app.systems.on("postUpdate", this._onPostUpdate, this);
              }
              initializeComponentData(o, i, e) {
                i.enabled !== void 0 && (o.enabled = i.enabled),
                  i.orientation !== void 0 && (o.orientation = i.orientation),
                  i.reverseX !== void 0 && (o.reverseX = i.reverseX),
                  i.reverseY !== void 0 && (o.reverseY = i.reverseY),
                  i.alignment !== void 0 &&
                    (o.alignment = Array.isArray(i.alignment)
                      ? new x.S(i.alignment)
                      : i.alignment),
                  i.padding !== void 0 &&
                    (o.padding = Array.isArray(i.padding)
                      ? new T.T(i.padding)
                      : i.padding),
                  i.spacing !== void 0 &&
                    (o.spacing = Array.isArray(i.spacing)
                      ? new x.S(i.spacing)
                      : i.spacing),
                  i.widthFitting !== void 0 &&
                    (o.widthFitting = i.widthFitting),
                  i.heightFitting !== void 0 &&
                    (o.heightFitting = i.heightFitting),
                  i.wrap !== void 0 && (o.wrap = i.wrap),
                  super.initializeComponentData(o, i, e);
              }
              cloneComponent(o, i) {
                const e = o.layoutgroup;
                return this.addComponent(i, {
                  enabled: e.enabled,
                  orientation: e.orientation,
                  reverseX: e.reverseX,
                  reverseY: e.reverseY,
                  alignment: e.alignment,
                  padding: e.padding,
                  spacing: e.spacing,
                  widthFitting: e.widthFitting,
                  heightFitting: e.heightFitting,
                  wrap: e.wrap,
                });
              }
              scheduleReflow(o) {
                this._reflowQueue.indexOf(o) === -1 &&
                  this._reflowQueue.push(o);
              }
              _onPostUpdate() {
                this._processReflowQueue();
              }
              _processReflowQueue() {
                if (this._reflowQueue.length === 0) return;
                let o = 0;
                for (; this._reflowQueue.length > 0; ) {
                  const i = this._reflowQueue.slice();
                  (this._reflowQueue.length = 0),
                    i.sort(function (e, t) {
                      return e.entity.graphDepth - t.entity.graphDepth;
                    });
                  for (let e = 0; e < i.length; ++e) i[e].reflow();
                  if (++o >= s) {
                    console.warn(
                      "Max reflow iterations limit reached, bailing."
                    );
                    break;
                  }
                }
              }
              _onRemoveComponent(o, i) {
                i.onRemove();
              }
              destroy() {
                super.destroy(),
                  this.app.systems.off("postUpdate", this._onPostUpdate, this);
              }
            }
            g.w._buildAccessors(d.k.prototype, f);
          },
          5719: (Se, W, a) => {
            "use strict";
            a.d(W, { Vh: () => s, XO: () => f, r0: () => l });
            var x = a(4585),
              T = a(1367),
              g = a(6630),
              c = a(3114),
              d = a(6204),
              h = a(8620);
            const f = [],
              s = [];
            class l extends h.w {
              constructor(e, t) {
                super(e, t),
                  (this._cookieAsset = null),
                  (this._cookieAssetId = null),
                  (this._cookieAssetAdd = !1),
                  (this._cookieMatrix = null);
              }
              addLightToLayers() {
                for (let e = 0; e < this.layers.length; e++) {
                  const t = this.system.app.scene.layers.getLayerById(
                    this.layers[e]
                  );
                  t && t.addLight(this);
                }
              }
              removeLightFromLayers() {
                for (let e = 0; e < this.layers.length; e++) {
                  const t = this.system.app.scene.layers.getLayerById(
                    this.layers[e]
                  );
                  t && t.removeLight(this);
                }
              }
              onLayersChanged(e, t) {
                this.enabled && this.entity.enabled && this.addLightToLayers(),
                  e.off("add", this.onLayerAdded, this),
                  e.off("remove", this.onLayerRemoved, this),
                  t.on("add", this.onLayerAdded, this),
                  t.on("remove", this.onLayerRemoved, this);
              }
              onLayerAdded(e) {
                this.layers.indexOf(e.id) >= 0 &&
                  this.enabled &&
                  this.entity.enabled &&
                  e.addLight(this);
              }
              onLayerRemoved(e) {
                this.layers.indexOf(e.id) >= 0 && e.removeLight(this);
              }
              refreshProperties() {
                for (let e = 0; e < f.length; e++) {
                  const t = f[e];
                  this[t] = this[t];
                }
                this.enabled && this.entity.enabled && this.onEnable();
              }
              onCookieAssetSet() {
                let e = !1;
                this._cookieAsset.type === "cubemap" &&
                  !this._cookieAsset.loadFaces &&
                  ((this._cookieAsset.loadFaces = !0), (e = !0)),
                  (!this._cookieAsset.resource || e) &&
                    this.system.app.assets.load(this._cookieAsset),
                  this._cookieAsset.resource && this.onCookieAssetLoad();
              }
              onCookieAssetAdd(e) {
                this._cookieAssetId === e.id &&
                  ((this._cookieAsset = e),
                  this.light.enabled && this.onCookieAssetSet(),
                  this._cookieAsset.on("load", this.onCookieAssetLoad, this),
                  this._cookieAsset.on(
                    "remove",
                    this.onCookieAssetRemove,
                    this
                  ));
              }
              onCookieAssetLoad() {
                !this._cookieAsset ||
                  !this._cookieAsset.resource ||
                  (this.cookie = this._cookieAsset.resource);
              }
              onCookieAssetRemove() {
                this._cookieAssetId &&
                  (this._cookieAssetAdd &&
                    (this.system.app.assets.off(
                      "add:" + this._cookieAssetId,
                      this.onCookieAssetAdd,
                      this
                    ),
                    (this._cookieAssetAdd = !1)),
                  this._cookieAsset &&
                    (this._cookieAsset.off(
                      "load",
                      this.onCookieAssetLoad,
                      this
                    ),
                    this._cookieAsset.off(
                      "remove",
                      this.onCookieAssetRemove,
                      this
                    ),
                    (this._cookieAsset = null)),
                  (this.cookie = null));
              }
              onEnable() {
                (this.light.enabled = !0),
                  this.system.app.scene.on(
                    "set:layers",
                    this.onLayersChanged,
                    this
                  ),
                  this.system.app.scene.layers &&
                    (this.system.app.scene.layers.on(
                      "add",
                      this.onLayerAdded,
                      this
                    ),
                    this.system.app.scene.layers.on(
                      "remove",
                      this.onLayerRemoved,
                      this
                    )),
                  this.enabled &&
                    this.entity.enabled &&
                    this.addLightToLayers(),
                  this._cookieAsset && !this.cookie && this.onCookieAssetSet();
              }
              onDisable() {
                (this.light.enabled = !1),
                  this.system.app.scene.off(
                    "set:layers",
                    this.onLayersChanged,
                    this
                  ),
                  this.system.app.scene.layers &&
                    (this.system.app.scene.layers.off(
                      "add",
                      this.onLayerAdded,
                      this
                    ),
                    this.system.app.scene.layers.off(
                      "remove",
                      this.onLayerRemoved,
                      this
                    )),
                  this.removeLightFromLayers();
              }
              onRemove() {
                this.onDisable(),
                  this.light.destroy(),
                  (this.cookieAsset = null);
              }
              set shadowUpdateOverrides(e) {
                this.light.shadowUpdateOverrides = e;
              }
              get shadowUpdateOverrides() {
                return this.light.shadowUpdateOverrides;
              }
              set penumbraSize(e) {
                this.light.penumbraSize = e;
              }
              get penumbraSize() {
                return this.light.penumbraSize;
              }
            }
            function n(i, e, t, r) {
              const u = l.prototype;
              f.push(i),
                s.push(e),
                Object.defineProperty(u, i, {
                  get: function () {
                    return this.data[i];
                  },
                  set: function (y) {
                    const p = this.data,
                      _ = p[i];
                    (!r && _ === y) || ((p[i] = y), t && t.call(this, y, _));
                  },
                  configurable: !0,
                });
            }
            function o() {
              n("enabled", !0, function (i, e) {
                this.onSetEnabled(null, e, i);
              }),
                n("light", null),
                n("type", "directional", function (i, e) {
                  this.system.changeType(this, e, i), this.refreshProperties();
                }),
                n(
                  "color",
                  new T.I(1, 1, 1),
                  function (i, e) {
                    this.light.setColor(i);
                  },
                  !0
                ),
                n("intensity", 1, function (i, e) {
                  this.light.intensity = i;
                }),
                n("luminance", 0, function (i, e) {
                  this.light.luminance = i;
                }),
                n("shape", c.pI, function (i, e) {
                  this.light.shape = i;
                }),
                n("affectSpecularity", !0, function (i, e) {
                  this.light.affectSpecularity = i;
                }),
                n("castShadows", !1, function (i, e) {
                  this.light.castShadows = i;
                }),
                n("shadowDistance", 40, function (i, e) {
                  this.light.shadowDistance = i;
                }),
                n("shadowIntensity", 1, function (i, e) {
                  this.light.shadowIntensity = i;
                }),
                n("shadowResolution", 1024, function (i, e) {
                  this.light.shadowResolution = i;
                }),
                n("shadowBias", 0.05, function (i, e) {
                  this.light.shadowBias = -0.01 * x.m.clamp(i, 0, 1);
                }),
                n("numCascades", 1, function (i, e) {
                  this.light.numCascades = x.m.clamp(Math.floor(i), 1, 4);
                }),
                n("bakeNumSamples", 1, function (i, e) {
                  this.light.bakeNumSamples = x.m.clamp(Math.floor(i), 1, 255);
                }),
                n("bakeArea", 0, function (i, e) {
                  this.light.bakeArea = x.m.clamp(i, 0, 180);
                }),
                n("cascadeDistribution", 0.5, function (i, e) {
                  this.light.cascadeDistribution = x.m.clamp(i, 0, 1);
                }),
                n("normalOffsetBias", 0, function (i, e) {
                  this.light.normalOffsetBias = x.m.clamp(i, 0, 1);
                }),
                n("range", 10, function (i, e) {
                  this.light.attenuationEnd = i;
                }),
                n("innerConeAngle", 40, function (i, e) {
                  this.light.innerConeAngle = i;
                }),
                n("outerConeAngle", 45, function (i, e) {
                  this.light.outerConeAngle = i;
                }),
                n("falloffMode", c.MU, function (i, e) {
                  this.light.falloffMode = i;
                }),
                n("shadowType", c.iW, function (i, e) {
                  this.light.shadowType = i;
                }),
                n("vsmBlurSize", 11, function (i, e) {
                  this.light.vsmBlurSize = i;
                }),
                n("vsmBlurMode", c.J2, function (i, e) {
                  this.light.vsmBlurMode = i;
                }),
                n("vsmBias", 0.0025, function (i, e) {
                  this.light.vsmBias = x.m.clamp(i, 0, 1);
                }),
                n("cookieAsset", null, function (i, e) {
                  if (
                    !(
                      this._cookieAssetId &&
                      ((i instanceof d.x && i.id === this._cookieAssetId) ||
                        i === this._cookieAssetId)
                    )
                  ) {
                    if (
                      (this.onCookieAssetRemove(),
                      (this._cookieAssetId = null),
                      i instanceof d.x)
                    )
                      (this.data.cookieAsset = i.id),
                        (this._cookieAssetId = i.id),
                        this.onCookieAssetAdd(i);
                    else if (typeof i == "number") {
                      this._cookieAssetId = i;
                      const t = this.system.app.assets.get(i);
                      t
                        ? this.onCookieAssetAdd(t)
                        : ((this._cookieAssetAdd = !0),
                          this.system.app.assets.on(
                            "add:" + this._cookieAssetId,
                            this.onCookieAssetAdd,
                            this
                          ));
                    }
                  }
                }),
                n("cookie", null, function (i, e) {
                  this.light.cookie = i;
                }),
                n("cookieIntensity", 1, function (i, e) {
                  this.light.cookieIntensity = x.m.clamp(i, 0, 1);
                }),
                n("cookieFalloff", !0, function (i, e) {
                  this.light.cookieFalloff = i;
                }),
                n("cookieChannel", "rgb", function (i, e) {
                  this.light.cookieChannel = i;
                }),
                n("cookieAngle", 0, function (i, e) {
                  if (i !== 0 || this.cookieScale !== null) {
                    this._cookieMatrix || (this._cookieMatrix = new g.T());
                    let t = 1,
                      r = 1;
                    this.cookieScale &&
                      ((t = this.cookieScale.x), (r = this.cookieScale.y));
                    const u = Math.cos(i * x.m.DEG_TO_RAD),
                      y = Math.sin(i * x.m.DEG_TO_RAD);
                    this._cookieMatrix.set(u / t, -y / t, y / r, u / r),
                      (this.light.cookieTransform = this._cookieMatrix);
                  } else this.light.cookieTransform = null;
                }),
                n(
                  "cookieScale",
                  null,
                  function (i, e) {
                    if (i !== null || this.cookieAngle !== 0) {
                      this._cookieMatrix || (this._cookieMatrix = new g.T());
                      const t = i.x,
                        r = i.y,
                        u = Math.cos(this.cookieAngle * x.m.DEG_TO_RAD),
                        y = Math.sin(this.cookieAngle * x.m.DEG_TO_RAD);
                      this._cookieMatrix.set(u / t, -y / t, y / r, u / r),
                        (this.light.cookieTransform = this._cookieMatrix);
                    } else this.light.cookieTransform = null;
                  },
                  !0
                ),
                n(
                  "cookieOffset",
                  null,
                  function (i, e) {
                    this.light.cookieOffset = i;
                  },
                  !0
                ),
                n(
                  "shadowUpdateMode",
                  c.v5,
                  function (i, e) {
                    this.light.shadowUpdateMode = i;
                  },
                  !0
                ),
                n("mask", 1, function (i, e) {
                  this.light.mask = i;
                }),
                n("affectDynamic", !0, function (i, e) {
                  i ? (this.light.mask |= c.BN) : (this.light.mask &= ~c.BN),
                    this.light.layersDirty();
                }),
                n("affectLightmapped", !1, function (i, e) {
                  i
                    ? ((this.light.mask |= c.gN),
                      this.bake && (this.light.mask &= ~c.ew))
                    : ((this.light.mask &= ~c.gN),
                      this.bake && (this.light.mask |= c.ew));
                }),
                n("bake", !1, function (i, e) {
                  i
                    ? ((this.light.mask |= c.ew),
                      this.affectLightmapped && (this.light.mask &= ~c.gN))
                    : ((this.light.mask &= ~c.ew),
                      this.affectLightmapped && (this.light.mask |= c.gN)),
                    this.light.layersDirty();
                }),
                n("bakeDir", !0, function (i, e) {
                  this.light.bakeDir = i;
                }),
                n("isStatic", !1, function (i, e) {
                  this.light.isStatic = i;
                }),
                n("layers", [c.kY], function (i, e) {
                  for (let t = 0; t < e.length; t++) {
                    const r = this.system.app.scene.layers.getLayerById(e[t]);
                    r && r.removeLight(this);
                  }
                  for (let t = 0; t < i.length; t++) {
                    const r = this.system.app.scene.layers.getLayerById(i[t]);
                    r &&
                      this.enabled &&
                      this.entity.enabled &&
                      r.addLight(this);
                  }
                }),
                f.push("penumbraSize"),
                s.push(1);
            }
            o();
          },
          8320: (Se, W, a) => {
            "use strict";
            a.d(W, { i: () => s });
            var x = a(1367),
              T = a(2978),
              g = a(3114),
              c = a(8632),
              d = a(6813),
              h = a(5719);
            class f {
              constructor() {
                const n = h.XO,
                  o = h.Vh;
                for (let i = 0; i < n.length; i++) {
                  const e = o[i];
                  e && e.clone ? (this[n[i]] = e.clone()) : (this[n[i]] = e);
                }
              }
            }
            class s extends d.Q {
              constructor(n) {
                super(n),
                  (this.id = "light"),
                  (this.ComponentType = h.r0),
                  (this.DataType = f),
                  this.on("beforeremove", this._onRemoveComponent, this);
              }
              initializeComponentData(n, o) {
                const i = h.XO,
                  e = {};
                for (let r = 0, u = i.length; r < u; r++) {
                  const y = i[r];
                  e[y] = o[y];
                }
                e.type || (e.type = n.data.type),
                  (n.data.type = e.type),
                  e.layers &&
                    Array.isArray(e.layers) &&
                    (e.layers = e.layers.slice(0)),
                  e.color &&
                    Array.isArray(e.color) &&
                    (e.color = new x.I(e.color[0], e.color[1], e.color[2])),
                  e.cookieOffset &&
                    e.cookieOffset instanceof Array &&
                    (e.cookieOffset = new T.S(
                      e.cookieOffset[0],
                      e.cookieOffset[1]
                    )),
                  e.cookieScale &&
                    e.cookieScale instanceof Array &&
                    (e.cookieScale = new T.S(
                      e.cookieScale[0],
                      e.cookieScale[1]
                    )),
                  e.enable &&
                    (console.warn(
                      "WARNING: enable: Property is deprecated. Set enabled property instead."
                    ),
                    (e.enabled = e.enable)),
                  e.shape || (e.shape = g.pI);
                const t = new c._(this.app.graphicsDevice);
                (t.type = c.J[e.type]),
                  (t._node = n.entity),
                  (t._scene = this.app.scene),
                  (n.data.light = t),
                  super.initializeComponentData(n, e, i);
              }
              _onRemoveComponent(n, o) {
                o.onRemove();
              }
              cloneComponent(n, o) {
                const i = n.light,
                  e = [];
                let t;
                const r = h.XO;
                for (let u = 0; u < r.length; u++)
                  (t = r[u]),
                    t !== "light" &&
                      (i[t] && i[t].clone
                        ? (e[t] = i[t].clone())
                        : (e[t] = i[t]));
                return this.addComponent(o, e);
              }
              changeType(n, o, i) {
                o !== i && (n.light.type = c.J[i]);
              }
            }
          },
          5985: (Se, W, a) => {
            "use strict";
            a.d(W, { v: () => l });
            var x = a(3114),
              T = a(3240),
              g = a(7915),
              c = a(8792),
              d = a(9915),
              h = a(4611),
              f = a(6204),
              s = a(8620);
            class l extends s.w {
              constructor(o, i) {
                super(o, i),
                  (this._type = "asset"),
                  (this._asset = null),
                  (this._model = null),
                  (this._mapping = {}),
                  (this._castShadows = !0),
                  (this._receiveShadows = !0),
                  (this._materialAsset = null),
                  (this._material = void 0),
                  (this._castShadowsLightmap = !0),
                  (this._lightmapped = !1),
                  (this._lightmapSizeMultiplier = 1),
                  (this.isStatic = !1),
                  (this._layers = [x.kY]),
                  (this._batchGroupId = -1),
                  (this._customAabb = null),
                  (this._area = null),
                  (this._materialEvents = null),
                  (this._clonedModel = !1),
                  (this._material = o.defaultMaterial),
                  i.on("remove", this.onRemoveChild, this),
                  i.on("removehierarchy", this.onRemoveChild, this),
                  i.on("insert", this.onInsertChild, this),
                  i.on("inserthierarchy", this.onInsertChild, this);
              }
              set meshInstances(o) {
                this._model && (this._model.meshInstances = o);
              }
              get meshInstances() {
                return this._model ? this._model.meshInstances : null;
              }
              set customAabb(o) {
                if (((this._customAabb = o), this._model)) {
                  const i = this._model.meshInstances;
                  if (i)
                    for (let e = 0; e < i.length; e++)
                      i[e].setCustomAabb(this._customAabb);
                }
              }
              get customAabb() {
                return this._customAabb;
              }
              set type(o) {
                if (this._type !== o)
                  if (((this._area = null), (this._type = o), o === "asset"))
                    this._asset !== null
                      ? this._bindModelAsset(this._asset)
                      : (this.model = null);
                  else {
                    const i = (0, h.$r)(this.system.app.graphicsDevice, o);
                    this._area = i.area;
                    const e = i.mesh,
                      t = new g.A(),
                      r = new d.H();
                    (r.graph = t),
                      (r.meshInstances = [new c.l(e, this._material, t)]),
                      (this.model = r),
                      (this._asset = null);
                  }
              }
              get type() {
                return this._type;
              }
              set asset(o) {
                const i = this.system.app.assets;
                let e = o;
                if ((o instanceof f.x && (e = o.id), this._asset !== e)) {
                  if (this._asset) {
                    i.off("add:" + this._asset, this._onModelAssetAdded, this);
                    const t = i.get(this._asset);
                    t && this._unbindModelAsset(t);
                  }
                  if (((this._asset = e), this._asset)) {
                    const t = i.get(this._asset);
                    t
                      ? this._bindModelAsset(t)
                      : ((this.model = null),
                        i.on(
                          "add:" + this._asset,
                          this._onModelAssetAdded,
                          this
                        ));
                  } else this.model = null;
                }
              }
              get asset() {
                return this._asset;
              }
              set model(o) {
                if (
                  this._model !== o &&
                  !(o && o._immutable) &&
                  (this._model &&
                    ((this._model._immutable = !1),
                    this.removeModelFromLayers(),
                    this._model.getGraph().destroy(),
                    delete this._model._entity,
                    this._clonedModel &&
                      (this._model.destroy(), (this._clonedModel = !1))),
                  (this._model = o),
                  this._model)
                ) {
                  this._model._immutable = !0;
                  const i = this._model.meshInstances;
                  for (let e = 0; e < i.length; e++)
                    (i[e].castShadow = this._castShadows),
                      (i[e].receiveShadow = this._receiveShadows),
                      i[e].setCustomAabb(this._customAabb);
                  (this.lightmapped = this._lightmapped),
                    this.entity.addChild(this._model.graph),
                    this.enabled &&
                      this.entity.enabled &&
                      this.addModelToLayers(),
                    (this._model._entity = this.entity),
                    this.entity.animation &&
                      this.entity.animation.setModel(this._model),
                    this.entity.anim && this.entity.anim.rebind(),
                    this.type === "asset"
                      ? (this.mapping = this._mapping)
                      : this._unsetMaterialEvents();
                }
              }
              get model() {
                return this._model;
              }
              set lightmapped(o) {
                if (
                  o !== this._lightmapped &&
                  ((this._lightmapped = o), this._model)
                ) {
                  const i = this._model.meshInstances;
                  for (let e = 0; e < i.length; e++) i[e].setLightmapped(o);
                }
              }
              get lightmapped() {
                return this._lightmapped;
              }
              set castShadows(o) {
                if (this._castShadows === o) return;
                const i = this._model;
                if (i) {
                  const e = this.layers,
                    t = this.system.app.scene;
                  if (this._castShadows && !o)
                    for (let u = 0; u < e.length; u++) {
                      const y = this.system.app.scene.layers.getLayerById(
                        this.layers[u]
                      );
                      y && y.removeShadowCasters(i.meshInstances);
                    }
                  const r = i.meshInstances;
                  for (let u = 0; u < r.length; u++) r[u].castShadow = o;
                  if (!this._castShadows && o)
                    for (let u = 0; u < e.length; u++) {
                      const y = t.layers.getLayerById(e[u]);
                      y && y.addShadowCasters(i.meshInstances);
                    }
                }
                this._castShadows = o;
              }
              get castShadows() {
                return this._castShadows;
              }
              set receiveShadows(o) {
                if (
                  this._receiveShadows !== o &&
                  ((this._receiveShadows = o), this._model)
                ) {
                  const i = this._model.meshInstances;
                  for (let e = 0, t = i.length; e < t; e++)
                    i[e].receiveShadow = o;
                }
              }
              get receiveShadows() {
                return this._receiveShadows;
              }
              set castShadowsLightmap(o) {
                this._castShadowsLightmap = o;
              }
              get castShadowsLightmap() {
                return this._castShadowsLightmap;
              }
              set lightmapSizeMultiplier(o) {
                this._lightmapSizeMultiplier = o;
              }
              get lightmapSizeMultiplier() {
                return this._lightmapSizeMultiplier;
              }
              set layers(o) {
                const i = this.system.app.scene.layers;
                if (this.meshInstances)
                  for (let e = 0; e < this._layers.length; e++) {
                    const t = i.getLayerById(this._layers[e]);
                    t && t.removeMeshInstances(this.meshInstances);
                  }
                this._layers.length = 0;
                for (let e = 0; e < o.length; e++) this._layers[e] = o[e];
                if (
                  !(
                    !this.enabled ||
                    !this.entity.enabled ||
                    !this.meshInstances
                  )
                )
                  for (let e = 0; e < this._layers.length; e++) {
                    const t = i.getLayerById(this._layers[e]);
                    t && t.addMeshInstances(this.meshInstances);
                  }
              }
              get layers() {
                return this._layers;
              }
              set batchGroupId(o) {
                if (this._batchGroupId !== o) {
                  if (this.entity.enabled && this._batchGroupId >= 0) {
                    var i;
                    (i = this.system.app.batcher) == null ||
                      i.remove(T.y.MODEL, this.batchGroupId, this.entity);
                  }
                  if (this.entity.enabled && o >= 0) {
                    var e;
                    (e = this.system.app.batcher) == null ||
                      e.insert(T.y.MODEL, o, this.entity);
                  }
                  o < 0 &&
                    this._batchGroupId >= 0 &&
                    this.enabled &&
                    this.entity.enabled &&
                    this.addModelToLayers(),
                    (this._batchGroupId = o);
                }
              }
              get batchGroupId() {
                return this._batchGroupId;
              }
              set materialAsset(o) {
                let i = o;
                o instanceof f.x && (i = o.id);
                const e = this.system.app.assets;
                if (i !== this._materialAsset) {
                  if (this._materialAsset) {
                    e.off(
                      "add:" + this._materialAsset,
                      this._onMaterialAssetAdd,
                      this
                    );
                    const t = e.get(this._materialAsset);
                    t && this._unbindMaterialAsset(t);
                  }
                  if (((this._materialAsset = i), this._materialAsset)) {
                    const t = e.get(this._materialAsset);
                    t
                      ? this._bindMaterialAsset(t)
                      : (this._setMaterial(this.system.defaultMaterial),
                        e.on(
                          "add:" + this._materialAsset,
                          this._onMaterialAssetAdd,
                          this
                        ));
                  } else this._setMaterial(this.system.defaultMaterial);
                }
              }
              get materialAsset() {
                return this._materialAsset;
              }
              set material(o) {
                this._material !== o &&
                  ((this.materialAsset = null), this._setMaterial(o));
              }
              get material() {
                return this._material;
              }
              set mapping(o) {
                if (
                  this._type !== "asset" ||
                  (this._unsetMaterialEvents(),
                  o || (o = {}),
                  (this._mapping = o),
                  !this._model)
                )
                  return;
                const i = this._model.meshInstances,
                  e = this.asset
                    ? this.system.app.assets.get(this.asset)
                    : null,
                  t = e ? e.data.mapping : null;
                let r = null;
                for (let u = 0, y = i.length; u < y; u++)
                  if (o[u] !== void 0)
                    o[u]
                      ? ((r = this.system.app.assets.get(o[u])),
                        this._loadAndSetMeshInstanceMaterial(r, i[u], u))
                      : (i[u].material = this.system.defaultMaterial);
                  else if (t)
                    if (t[u] && (t[u].material || t[u].path)) {
                      if (t[u].material !== void 0)
                        r = this.system.app.assets.get(t[u].material);
                      else if (t[u].path !== void 0) {
                        const p = this._getMaterialAssetUrl(t[u].path);
                        p && (r = this.system.app.assets.getByUrl(p));
                      }
                      this._loadAndSetMeshInstanceMaterial(r, i[u], u);
                    } else i[u].material = this.system.defaultMaterial;
              }
              get mapping() {
                return this._mapping;
              }
              addModelToLayers() {
                const o = this.system.app.scene.layers;
                for (let i = 0; i < this._layers.length; i++) {
                  const e = o.getLayerById(this._layers[i]);
                  e && e.addMeshInstances(this.meshInstances);
                }
              }
              removeModelFromLayers() {
                const o = this.system.app.scene.layers;
                for (let i = 0; i < this._layers.length; i++) {
                  const e = o.getLayerById(this._layers[i]);
                  e && e.removeMeshInstances(this.meshInstances);
                }
              }
              onRemoveChild() {
                this._model && this.removeModelFromLayers();
              }
              onInsertChild() {
                this._model &&
                  this.enabled &&
                  this.entity.enabled &&
                  this.addModelToLayers();
              }
              onRemove() {
                (this.asset = null),
                  (this.model = null),
                  (this.materialAsset = null),
                  this._unsetMaterialEvents(),
                  this.entity.off("remove", this.onRemoveChild, this),
                  this.entity.off("insert", this.onInsertChild, this);
              }
              onLayersChanged(o, i) {
                this.addModelToLayers(),
                  o.off("add", this.onLayerAdded, this),
                  o.off("remove", this.onLayerRemoved, this),
                  i.on("add", this.onLayerAdded, this),
                  i.on("remove", this.onLayerRemoved, this);
              }
              onLayerAdded(o) {
                this.layers.indexOf(o.id) < 0 ||
                  o.addMeshInstances(this.meshInstances);
              }
              onLayerRemoved(o) {
                this.layers.indexOf(o.id) < 0 ||
                  o.removeMeshInstances(this.meshInstances);
              }
              _setMaterialEvent(o, i, e, t) {
                const r = i + ":" + e;
                this.system.app.assets.on(r, t, this),
                  this._materialEvents || (this._materialEvents = []),
                  this._materialEvents[o] || (this._materialEvents[o] = {}),
                  (this._materialEvents[o][r] = { id: e, handler: t });
              }
              _unsetMaterialEvents() {
                const o = this.system.app.assets,
                  i = this._materialEvents;
                if (i) {
                  for (let e = 0, t = i.length; e < t; e++) {
                    if (!i[e]) continue;
                    const r = i[e];
                    for (const u in r) o.off(u, r[u].handler, this);
                  }
                  this._materialEvents = null;
                }
              }
              _getAssetByIdOrPath(o) {
                let i = null;
                if (!isNaN(parseInt(o, 10))) i = this.system.app.assets.get(o);
                else if (this.asset) {
                  const t = this._getMaterialAssetUrl(o);
                  t && (i = this.system.app.assets.getByUrl(t));
                }
                return i;
              }
              _getMaterialAssetUrl(o) {
                if (!this.asset) return null;
                const i = this.system.app.assets.get(this.asset);
                return i ? i.getAbsoluteUrl(o) : null;
              }
              _loadAndSetMeshInstanceMaterial(o, i, e) {
                const t = this.system.app.assets;
                o &&
                  (o.resource
                    ? ((i.material = o.resource),
                      this._setMaterialEvent(e, "remove", o.id, function () {
                        i.material = this.system.defaultMaterial;
                      }))
                    : (this._setMaterialEvent(e, "load", o.id, function (r) {
                        (i.material = r.resource),
                          this._setMaterialEvent(
                            e,
                            "remove",
                            o.id,
                            function () {
                              i.material = this.system.defaultMaterial;
                            }
                          );
                      }),
                      this.enabled && this.entity.enabled && t.load(o)));
              }
              onEnable() {
                const o = this.system.app,
                  i = o.scene;
                i.on("set:layers", this.onLayersChanged, this),
                  i.layers &&
                    (i.layers.on("add", this.onLayerAdded, this),
                    i.layers.on("remove", this.onLayerRemoved, this));
                const e = this._type === "asset";
                let t;
                if (
                  (this._model
                    ? this.addModelToLayers()
                    : e &&
                      this._asset &&
                      ((t = o.assets.get(this._asset)),
                      t &&
                        t.resource !== this._model &&
                        this._bindModelAsset(t)),
                  this._materialAsset &&
                    ((t = o.assets.get(this._materialAsset)),
                    t &&
                      t.resource !== this._material &&
                      this._bindMaterialAsset(t)),
                  e && this._mapping)
                )
                  for (const u in this._mapping)
                    this._mapping[u] &&
                      ((t = this._getAssetByIdOrPath(this._mapping[u])),
                      t && !t.resource && o.assets.load(t));
                if (this._batchGroupId >= 0) {
                  var r;
                  (r = o.batcher) == null ||
                    r.insert(T.y.MODEL, this.batchGroupId, this.entity);
                }
              }
              onDisable() {
                const o = this.system.app,
                  i = o.scene;
                if (
                  (i.off("set:layers", this.onLayersChanged, this),
                  i.layers &&
                    (i.layers.off("add", this.onLayerAdded, this),
                    i.layers.off("remove", this.onLayerRemoved, this)),
                  this._batchGroupId >= 0)
                ) {
                  var e;
                  (e = o.batcher) == null ||
                    e.remove(T.y.MODEL, this.batchGroupId, this.entity);
                }
                this._model && this.removeModelFromLayers();
              }
              hide() {
                if (this._model) {
                  const o = this._model.meshInstances;
                  for (let i = 0, e = o.length; i < e; i++) o[i].visible = !1;
                }
              }
              show() {
                if (this._model) {
                  const o = this._model.meshInstances;
                  for (let i = 0, e = o.length; i < e; i++) o[i].visible = !0;
                }
              }
              _bindMaterialAsset(o) {
                if (
                  (o.on("load", this._onMaterialAssetLoad, this),
                  o.on("unload", this._onMaterialAssetUnload, this),
                  o.on("remove", this._onMaterialAssetRemove, this),
                  o.on("change", this._onMaterialAssetChange, this),
                  o.resource)
                )
                  this._onMaterialAssetLoad(o);
                else {
                  if (!this.enabled || !this.entity.enabled) return;
                  this.system.app.assets.load(o);
                }
              }
              _unbindMaterialAsset(o) {
                o.off("load", this._onMaterialAssetLoad, this),
                  o.off("unload", this._onMaterialAssetUnload, this),
                  o.off("remove", this._onMaterialAssetRemove, this),
                  o.off("change", this._onMaterialAssetChange, this);
              }
              _onMaterialAssetAdd(o) {
                this.system.app.assets.off(
                  "add:" + o.id,
                  this._onMaterialAssetAdd,
                  this
                ),
                  this._materialAsset === o.id && this._bindMaterialAsset(o);
              }
              _onMaterialAssetLoad(o) {
                this._setMaterial(o.resource);
              }
              _onMaterialAssetUnload(o) {
                this._setMaterial(this.system.defaultMaterial);
              }
              _onMaterialAssetRemove(o) {
                this._onMaterialAssetUnload(o);
              }
              _onMaterialAssetChange(o) {}
              _bindModelAsset(o) {
                if (
                  (this._unbindModelAsset(o),
                  o.on("load", this._onModelAssetLoad, this),
                  o.on("unload", this._onModelAssetUnload, this),
                  o.on("change", this._onModelAssetChange, this),
                  o.on("remove", this._onModelAssetRemove, this),
                  o.resource)
                )
                  this._onModelAssetLoad(o);
                else {
                  if (!this.enabled || !this.entity.enabled) return;
                  this.system.app.assets.load(o);
                }
              }
              _unbindModelAsset(o) {
                o.off("load", this._onModelAssetLoad, this),
                  o.off("unload", this._onModelAssetUnload, this),
                  o.off("change", this._onModelAssetChange, this),
                  o.off("remove", this._onModelAssetRemove, this);
              }
              _onModelAssetAdded(o) {
                this.system.app.assets.off(
                  "add:" + o.id,
                  this._onModelAssetAdded,
                  this
                ),
                  o.id === this._asset && this._bindModelAsset(o);
              }
              _onModelAssetLoad(o) {
                (this.model = o.resource.clone()), (this._clonedModel = !0);
              }
              _onModelAssetUnload(o) {
                this.model = null;
              }
              _onModelAssetChange(o, i, e, t) {
                i === "data" && (this.mapping = this._mapping);
              }
              _onModelAssetRemove(o) {
                this.model = null;
              }
              _setMaterial(o) {
                if (this._material === o) return;
                this._material = o;
                const i = this._model;
                if (i && this._type !== "asset") {
                  const e = i.meshInstances;
                  for (let t = 0, r = e.length; t < r; t++) e[t].material = o;
                }
              }
            }
          },
          1166: (Se, W, a) => {
            "use strict";
            a.d(W, { w: () => o });
            var x = a(9795),
              T = a(6556),
              g = a(3148),
              c = a(9373),
              d = a(6204),
              h = a(8620),
              f = a(6813),
              s = a(5985);
            class l {
              constructor() {
                this.enabled = !0;
              }
            }
            const n = ["enabled"];
            class o extends f.Q {
              constructor(e) {
                super(e),
                  (this.id = "model"),
                  (this.ComponentType = s.v),
                  (this.DataType = l),
                  (this.schema = n),
                  (this.defaultMaterial = (0, c.U)(e.graphicsDevice)),
                  this.on("beforeremove", this.onRemove, this);
              }
              initializeComponentData(e, t, r) {
                (r = [
                  "material",
                  "materialAsset",
                  "asset",
                  "castShadows",
                  "receiveShadows",
                  "castShadowsLightmap",
                  "lightmapped",
                  "lightmapSizeMultiplier",
                  "type",
                  "mapping",
                  "layers",
                  "isStatic",
                  "batchGroupId",
                ]),
                  (t.batchGroupId === null || t.batchGroupId === void 0) &&
                    (t.batchGroupId = -1),
                  t.layers && t.layers.length && (t.layers = t.layers.slice(0));
                for (let u = 0; u < r.length; u++)
                  t.hasOwnProperty(r[u]) && (e[r[u]] = t[r[u]]);
                t.aabbCenter &&
                  t.aabbHalfExtents &&
                  (e.customAabb = new g.k(
                    new T.A(t.aabbCenter),
                    new T.A(t.aabbHalfExtents)
                  )),
                  super.initializeComponentData(e, t, ["enabled"]);
              }
              cloneComponent(e, t) {
                const r = {
                  type: e.model.type,
                  asset: e.model.asset,
                  castShadows: e.model.castShadows,
                  receiveShadows: e.model.receiveShadows,
                  castShadowsLightmap: e.model.castShadowsLightmap,
                  lightmapped: e.model.lightmapped,
                  lightmapSizeMultiplier: e.model.lightmapSizeMultiplier,
                  isStatic: e.model.isStatic,
                  enabled: e.model.enabled,
                  layers: e.model.layers,
                  batchGroupId: e.model.batchGroupId,
                  mapping: (0, x.l7)({}, e.model.mapping),
                };
                let u = e.model.materialAsset;
                !(u instanceof d.x) &&
                  u != null &&
                  (u = this.app.assets.get(u));
                const y = e.model.material;
                (!y || y === this.defaultMaterial || !u || y === u.resource) &&
                  (r.materialAsset = u);
                const p = this.addComponent(t, r);
                if (
                  (e.model.model &&
                    e.model.type === "asset" &&
                    !e.model.asset &&
                    ((p.model = e.model.model.clone()), (p._clonedModel = !0)),
                  r.materialAsset || (p.material = y),
                  e.model.model)
                ) {
                  const _ = e.model.model.meshInstances,
                    m = p.model.meshInstances;
                  for (let E = 0; E < _.length; E++)
                    (m[E].mask = _[E].mask),
                      (m[E].material = _[E].material),
                      (m[E].layer = _[E].layer),
                      (m[E].receiveShadow = _[E].receiveShadow);
                }
                return (
                  e.model.customAabb &&
                    (p.customAabb = e.model.customAabb.clone()),
                  p
                );
              }
              onRemove(e, t) {
                t.onRemove();
              }
            }
            h.w._buildAccessors(s.v.prototype, n);
          },
          86: (Se, W, a) => {
            "use strict";
            a.d(W, { i: () => o });
            var x = a(3114),
              T = a(7678),
              g = a(3241),
              c = a(6204),
              d = a(8620);
            const h = [
                "emitterExtents",
                "emitterRadius",
                "emitterExtentsInner",
                "emitterRadiusInner",
                "loop",
                "initialVelocity",
                "animSpeed",
                "normalMap",
                "particleNormal",
              ],
              f = [
                "numParticles",
                "lifetime",
                "rate",
                "rate2",
                "startAngle",
                "startAngle2",
                "lighting",
                "halfLambert",
                "intensity",
                "wrap",
                "wrapBounds",
                "depthWrite",
                "noFog",
                "sort",
                "stretch",
                "alignToMotion",
                "preWarm",
                "emitterShape",
                "animTilesX",
                "animTilesY",
                "animStartFrame",
                "animNumFrames",
                "animNumAnimations",
                "animIndex",
                "randomizeAnimIndex",
                "animLoop",
                "colorMap",
                "localSpace",
                "screenSpace",
                "orientation",
              ],
              s = [
                "scaleGraph",
                "scaleGraph2",
                "colorGraph",
                "colorGraph2",
                "alphaGraph",
                "alphaGraph2",
                "velocityGraph",
                "velocityGraph2",
                "localVelocityGraph",
                "localVelocityGraph2",
                "rotationSpeedGraph",
                "rotationSpeedGraph2",
                "radialSpeedGraph",
                "radialSpeedGraph2",
              ],
              l = [
                "colorMapAsset",
                "normalMapAsset",
                "meshAsset",
                "renderAsset",
              ];
            let n;
            class o extends d.w {
              constructor(e, t) {
                super(e, t),
                  (this._requestedDepth = !1),
                  (this._drawOrder = 0),
                  this.on("set_colorMapAsset", this.onSetColorMapAsset, this),
                  this.on("set_normalMapAsset", this.onSetNormalMapAsset, this),
                  this.on("set_meshAsset", this.onSetMeshAsset, this),
                  this.on("set_mesh", this.onSetMesh, this),
                  this.on("set_renderAsset", this.onSetRenderAsset, this),
                  this.on("set_loop", this.onSetLoop, this),
                  this.on("set_blendType", this.onSetBlendType, this),
                  this.on("set_depthSoftening", this.onSetDepthSoftening, this),
                  this.on("set_layers", this.onSetLayers, this),
                  h.forEach((r) => {
                    this.on(`set_${r}`, this.onSetSimpleProperty, this);
                  }),
                  f.forEach((r) => {
                    this.on(`set_${r}`, this.onSetComplexProperty, this);
                  }),
                  s.forEach((r) => {
                    this.on(`set_${r}`, this.onSetGraphProperty, this);
                  });
              }
              set drawOrder(e) {
                (this._drawOrder = e),
                  this.emitter && (this.emitter.drawOrder = e);
              }
              get drawOrder() {
                return this._drawOrder;
              }
              addMeshInstanceToLayers() {
                if (this.emitter)
                  for (let e = 0; e < this.layers.length; e++) {
                    const t = this.system.app.scene.layers.getLayerById(
                      this.layers[e]
                    );
                    t &&
                      (t.addMeshInstances([this.emitter.meshInstance]),
                      (this.emitter._layer = t));
                  }
              }
              removeMeshInstanceFromLayers() {
                if (this.emitter)
                  for (let e = 0; e < this.layers.length; e++) {
                    const t = this.system.app.scene.layers.getLayerById(
                      this.layers[e]
                    );
                    t && t.removeMeshInstances([this.emitter.meshInstance]);
                  }
              }
              onSetLayers(e, t, r) {
                if (this.emitter) {
                  for (let u = 0; u < t.length; u++) {
                    const y = this.system.app.scene.layers.getLayerById(t[u]);
                    y && y.removeMeshInstances([this.emitter.meshInstance]);
                  }
                  if (!(!this.enabled || !this.entity.enabled))
                    for (let u = 0; u < r.length; u++) {
                      const y = this.system.app.scene.layers.getLayerById(r[u]);
                      y && y.addMeshInstances([this.emitter.meshInstance]);
                    }
                }
              }
              onLayersChanged(e, t) {
                this.addMeshInstanceToLayers(),
                  e.off("add", this.onLayerAdded, this),
                  e.off("remove", this.onLayerRemoved, this),
                  t.on("add", this.onLayerAdded, this),
                  t.on("remove", this.onLayerRemoved, this);
              }
              onLayerAdded(e) {
                !this.emitter ||
                  this.layers.indexOf(e.id) < 0 ||
                  e.addMeshInstances([this.emitter.meshInstance]);
              }
              onLayerRemoved(e) {
                !this.emitter ||
                  this.layers.indexOf(e.id) < 0 ||
                  e.removeMeshInstances([this.emitter.meshInstance]);
              }
              _bindColorMapAsset(e) {
                if (
                  (e.on("load", this._onColorMapAssetLoad, this),
                  e.on("unload", this._onColorMapAssetUnload, this),
                  e.on("remove", this._onColorMapAssetRemove, this),
                  e.on("change", this._onColorMapAssetChange, this),
                  e.resource)
                )
                  this._onColorMapAssetLoad(e);
                else {
                  if (!this.enabled || !this.entity.enabled) return;
                  this.system.app.assets.load(e);
                }
              }
              _unbindColorMapAsset(e) {
                e.off("load", this._onColorMapAssetLoad, this),
                  e.off("unload", this._onColorMapAssetUnload, this),
                  e.off("remove", this._onColorMapAssetRemove, this),
                  e.off("change", this._onColorMapAssetChange, this);
              }
              _onColorMapAssetLoad(e) {
                this.colorMap = e.resource;
              }
              _onColorMapAssetUnload(e) {
                this.colorMap = null;
              }
              _onColorMapAssetRemove(e) {
                this._onColorMapAssetUnload(e);
              }
              _onColorMapAssetChange(e) {}
              onSetColorMapAsset(e, t, r) {
                const u = this.system.app.assets;
                if (t) {
                  const y = u.get(t);
                  y && this._unbindColorMapAsset(y);
                }
                if (r) {
                  r instanceof c.x &&
                    ((this.data.colorMapAsset = r.id), (r = r.id));
                  const y = u.get(r);
                  y
                    ? this._bindColorMapAsset(y)
                    : u.once("add:" + r, (p) => {
                        this._bindColorMapAsset(p);
                      });
                } else this.colorMap = null;
              }
              _bindNormalMapAsset(e) {
                if (
                  (e.on("load", this._onNormalMapAssetLoad, this),
                  e.on("unload", this._onNormalMapAssetUnload, this),
                  e.on("remove", this._onNormalMapAssetRemove, this),
                  e.on("change", this._onNormalMapAssetChange, this),
                  e.resource)
                )
                  this._onNormalMapAssetLoad(e);
                else {
                  if (!this.enabled || !this.entity.enabled) return;
                  this.system.app.assets.load(e);
                }
              }
              _unbindNormalMapAsset(e) {
                e.off("load", this._onNormalMapAssetLoad, this),
                  e.off("unload", this._onNormalMapAssetUnload, this),
                  e.off("remove", this._onNormalMapAssetRemove, this),
                  e.off("change", this._onNormalMapAssetChange, this);
              }
              _onNormalMapAssetLoad(e) {
                this.normalMap = e.resource;
              }
              _onNormalMapAssetUnload(e) {
                this.normalMap = null;
              }
              _onNormalMapAssetRemove(e) {
                this._onNormalMapAssetUnload(e);
              }
              _onNormalMapAssetChange(e) {}
              onSetNormalMapAsset(e, t, r) {
                const u = this.system.app.assets;
                if (t) {
                  const y = u.get(t);
                  y && this._unbindNormalMapAsset(y);
                }
                if (r) {
                  r instanceof c.x &&
                    ((this.data.normalMapAsset = r.id), (r = r.id));
                  const y = u.get(r);
                  y
                    ? this._bindNormalMapAsset(y)
                    : u.once("add:" + r, (p) => {
                        this._bindNormalMapAsset(p);
                      });
                } else this.normalMap = null;
              }
              _bindMeshAsset(e) {
                if (
                  (e.on("load", this._onMeshAssetLoad, this),
                  e.on("unload", this._onMeshAssetUnload, this),
                  e.on("remove", this._onMeshAssetRemove, this),
                  e.on("change", this._onMeshAssetChange, this),
                  e.resource)
                )
                  this._onMeshAssetLoad(e);
                else {
                  if (!this.enabled || !this.entity.enabled) return;
                  this.system.app.assets.load(e);
                }
              }
              _unbindMeshAsset(e) {
                e.off("load", this._onMeshAssetLoad, this),
                  e.off("unload", this._onMeshAssetUnload, this),
                  e.off("remove", this._onMeshAssetRemove, this),
                  e.off("change", this._onMeshAssetChange, this);
              }
              _onMeshAssetLoad(e) {
                this._onMeshChanged(e.resource);
              }
              _onMeshAssetUnload(e) {
                this.mesh = null;
              }
              _onMeshAssetRemove(e) {
                this._onMeshAssetUnload(e);
              }
              _onMeshAssetChange(e) {}
              onSetMeshAsset(e, t, r) {
                const u = this.system.app.assets;
                if (t) {
                  const y = u.get(t);
                  y && this._unbindMeshAsset(y);
                }
                if (r) {
                  r instanceof c.x &&
                    ((this.data.meshAsset = r.id), (r = r.id));
                  const y = u.get(r);
                  y && this._bindMeshAsset(y);
                } else this._onMeshChanged(null);
              }
              onSetMesh(e, t, r) {
                !r || r instanceof c.x || typeof r == "number"
                  ? (this.meshAsset = r)
                  : this._onMeshChanged(r);
              }
              _onMeshChanged(e) {
                e &&
                  !(e instanceof T.K) &&
                  (e.meshInstances[0]
                    ? (e = e.meshInstances[0].mesh)
                    : (e = null)),
                  (this.data.mesh = e),
                  this.emitter &&
                    ((this.emitter.mesh = e),
                    this.emitter.resetMaterial(),
                    this.rebuild());
              }
              onSetRenderAsset(e, t, r) {
                const u = this.system.app.assets;
                if (t) {
                  const y = u.get(t);
                  y && this._unbindRenderAsset(y);
                }
                if (r) {
                  r instanceof c.x &&
                    ((this.data.renderAsset = r.id), (r = r.id));
                  const y = u.get(r);
                  y && this._bindRenderAsset(y);
                } else this._onRenderChanged(null);
              }
              _bindRenderAsset(e) {
                if (
                  (e.on("load", this._onRenderAssetLoad, this),
                  e.on("unload", this._onRenderAssetUnload, this),
                  e.on("remove", this._onRenderAssetRemove, this),
                  e.resource)
                )
                  this._onRenderAssetLoad(e);
                else {
                  if (!this.enabled || !this.entity.enabled) return;
                  this.system.app.assets.load(e);
                }
              }
              _unbindRenderAsset(e) {
                e.off("load", this._onRenderAssetLoad, this),
                  e.off("unload", this._onRenderAssetUnload, this),
                  e.off("remove", this._onRenderAssetRemove, this),
                  e.resource &&
                    e.resource.off("set:meshes", this._onRenderSetMeshes, this);
              }
              _onRenderAssetLoad(e) {
                this._onRenderChanged(e.resource);
              }
              _onRenderAssetUnload(e) {
                this._onRenderChanged(null);
              }
              _onRenderAssetRemove(e) {
                this._onRenderAssetUnload(e);
              }
              _onRenderChanged(e) {
                if (!e) {
                  this._onMeshChanged(null);
                  return;
                }
                e.off("set:meshes", this._onRenderSetMeshes, this),
                  e.on("set:meshes", this._onRenderSetMeshes, this),
                  e.meshes && this._onRenderSetMeshes(e.meshes);
              }
              _onRenderSetMeshes(e) {
                this._onMeshChanged(e && e[0]);
              }
              onSetLoop(e, t, r) {
                this.emitter &&
                  ((this.emitter[e] = r), this.emitter.resetTime());
              }
              onSetBlendType(e, t, r) {
                this.emitter &&
                  ((this.emitter[e] = r),
                  (this.emitter.material.blendType = r),
                  this.emitter.resetMaterial(),
                  this.rebuild());
              }
              _requestDepth() {
                this._requestedDepth ||
                  (n || (n = this.system.app.scene.layers.getLayerById(x.Pp)),
                  n && (n.incrementCounter(), (this._requestedDepth = !0)));
              }
              _releaseDepth() {
                this._requestedDepth &&
                  n &&
                  (n.decrementCounter(), (this._requestedDepth = !1));
              }
              onSetDepthSoftening(e, t, r) {
                t !== r &&
                  (r
                    ? (this.enabled &&
                        this.entity.enabled &&
                        this._requestDepth(),
                      this.emitter && (this.emitter[e] = r))
                    : (this.enabled &&
                        this.entity.enabled &&
                        this._releaseDepth(),
                      this.emitter && (this.emitter[e] = r)),
                  this.emitter &&
                    (this.reset(),
                    this.emitter.resetMaterial(),
                    this.rebuild()));
              }
              onSetSimpleProperty(e, t, r) {
                this.emitter &&
                  ((this.emitter[e] = r), this.emitter.resetMaterial());
              }
              onSetComplexProperty(e, t, r) {
                this.emitter &&
                  ((this.emitter[e] = r),
                  this.emitter.resetMaterial(),
                  this.rebuild(),
                  this.reset());
              }
              onSetGraphProperty(e, t, r) {
                this.emitter &&
                  ((this.emitter[e] = r),
                  this.emitter.rebuildGraphs(),
                  this.emitter.resetMaterial());
              }
              onEnable() {
                const e = this.data;
                for (let t = 0, r = l.length; t < r; t++) {
                  let u = e[l[t]];
                  if (u) {
                    if (!(u instanceof c.x))
                      if (parseInt(u, 10) >= 0)
                        u = this.system.app.assets.get(u);
                      else continue;
                    u && !u.resource && this.system.app.assets.load(u);
                  }
                }
                if (!this.system.app.graphicsDevice.disableParticleSystem) {
                  if (!this.emitter) {
                    let t = e.mesh;
                    t instanceof T.K || (t = null),
                      (this.emitter = new g.V(this.system.app.graphicsDevice, {
                        numParticles: e.numParticles,
                        emitterExtents: e.emitterExtents,
                        emitterExtentsInner: e.emitterExtentsInner,
                        emitterRadius: e.emitterRadius,
                        emitterRadiusInner: e.emitterRadiusInner,
                        emitterShape: e.emitterShape,
                        initialVelocity: e.initialVelocity,
                        wrap: e.wrap,
                        localSpace: e.localSpace,
                        screenSpace: e.screenSpace,
                        wrapBounds: e.wrapBounds,
                        lifetime: e.lifetime,
                        rate: e.rate,
                        rate2: e.rate2,
                        orientation: e.orientation,
                        particleNormal: e.particleNormal,
                        animTilesX: e.animTilesX,
                        animTilesY: e.animTilesY,
                        animStartFrame: e.animStartFrame,
                        animNumFrames: e.animNumFrames,
                        animNumAnimations: e.animNumAnimations,
                        animIndex: e.animIndex,
                        randomizeAnimIndex: e.randomizeAnimIndex,
                        animSpeed: e.animSpeed,
                        animLoop: e.animLoop,
                        startAngle: e.startAngle,
                        startAngle2: e.startAngle2,
                        scaleGraph: e.scaleGraph,
                        scaleGraph2: e.scaleGraph2,
                        colorGraph: e.colorGraph,
                        colorGraph2: e.colorGraph2,
                        alphaGraph: e.alphaGraph,
                        alphaGraph2: e.alphaGraph2,
                        localVelocityGraph: e.localVelocityGraph,
                        localVelocityGraph2: e.localVelocityGraph2,
                        velocityGraph: e.velocityGraph,
                        velocityGraph2: e.velocityGraph2,
                        rotationSpeedGraph: e.rotationSpeedGraph,
                        rotationSpeedGraph2: e.rotationSpeedGraph2,
                        radialSpeedGraph: e.radialSpeedGraph,
                        radialSpeedGraph2: e.radialSpeedGraph2,
                        colorMap: e.colorMap,
                        normalMap: e.normalMap,
                        loop: e.loop,
                        preWarm: e.preWarm,
                        sort: e.sort,
                        stretch: e.stretch,
                        alignToMotion: e.alignToMotion,
                        lighting: e.lighting,
                        halfLambert: e.halfLambert,
                        intensity: e.intensity,
                        depthSoftening: e.depthSoftening,
                        scene: this.system.app.scene,
                        mesh: t,
                        depthWrite: e.depthWrite,
                        noFog: e.noFog,
                        node: this.entity,
                        blendType: e.blendType,
                      })),
                      (this.emitter.meshInstance.node = this.entity),
                      (this.emitter.drawOrder = this.drawOrder),
                      e.autoPlay ||
                        (this.pause(),
                        (this.emitter.meshInstance.visible = !1));
                  }
                  this.emitter.colorMap && this.addMeshInstanceToLayers(),
                    this.system.app.scene.on(
                      "set:layers",
                      this.onLayersChanged,
                      this
                    ),
                    this.system.app.scene.layers &&
                      (this.system.app.scene.layers.on(
                        "add",
                        this.onLayerAdded,
                        this
                      ),
                      this.system.app.scene.layers.on(
                        "remove",
                        this.onLayerRemoved,
                        this
                      )),
                    this.enabled &&
                      this.entity.enabled &&
                      e.depthSoftening &&
                      this._requestDepth();
                }
              }
              onDisable() {
                this.system.app.scene.off(
                  "set:layers",
                  this.onLayersChanged,
                  this
                ),
                  this.system.app.scene.layers &&
                    (this.system.app.scene.layers.off(
                      "add",
                      this.onLayerAdded,
                      this
                    ),
                    this.system.app.scene.layers.off(
                      "remove",
                      this.onLayerRemoved,
                      this
                    )),
                  this.emitter &&
                    (this.removeMeshInstanceFromLayers(),
                    this.data.depthSoftening && this._releaseDepth(),
                    (this.emitter.camera = null));
              }
              onBeforeRemove() {
                this.enabled && (this.enabled = !1),
                  this.emitter &&
                    (this.emitter.destroy(), (this.emitter = null));
                for (let e = 0; e < l.length; e++) {
                  const t = l[e];
                  this.data[t] && (this[t] = null);
                }
                this.off();
              }
              reset() {
                this.emitter && this.emitter.reset();
              }
              stop() {
                this.emitter &&
                  ((this.emitter.loop = !1),
                  this.emitter.resetTime(),
                  this.emitter.addTime(0, !0));
              }
              pause() {
                this.data.paused = !0;
              }
              unpause() {
                this.data.paused = !1;
              }
              play() {
                (this.data.paused = !1),
                  this.emitter &&
                    ((this.emitter.meshInstance.visible = !0),
                    (this.emitter.loop = this.data.loop),
                    this.emitter.resetTime());
              }
              isPlaying() {
                return this.data.paused
                  ? !1
                  : this.emitter && this.emitter.loop
                  ? !0
                  : Date.now() <= this.emitter.endTime;
              }
              rebuild() {
                const e = this.enabled;
                (this.enabled = !1),
                  this.emitter &&
                    (this.emitter.rebuild(),
                    (this.emitter.meshInstance.node = this.entity)),
                  (this.enabled = e);
              }
            }
          },
          3678: (Se, W, a) => {
            "use strict";
            a.d(W, { _: () => o });
            var x = a(429),
              T = a(1239),
              g = a(6556),
              c = a(3114),
              d = a(6204),
              h = a(8620),
              f = a(6813),
              s = a(86);
            class l {
              constructor() {
                (this.numParticles = 1),
                  (this.rate = 1),
                  (this.rate2 = null),
                  (this.startAngle = 0),
                  (this.startAngle2 = null),
                  (this.lifetime = 50),
                  (this.emitterExtents = new g.A()),
                  (this.emitterExtentsInner = new g.A()),
                  (this.emitterRadius = 0),
                  (this.emitterRadiusInner = 0),
                  (this.emitterShape = c.EB),
                  (this.initialVelocity = 0),
                  (this.wrapBounds = new g.A()),
                  (this.localSpace = !1),
                  (this.screenSpace = !1),
                  (this.colorMap = null),
                  (this.colorMapAsset = null),
                  (this.normalMap = null),
                  (this.normalMapAsset = null),
                  (this.loop = !0),
                  (this.preWarm = !1),
                  (this.sort = 0),
                  (this.mode = c.Fg),
                  (this.scene = null),
                  (this.lighting = !1),
                  (this.halfLambert = !1),
                  (this.intensity = 1),
                  (this.stretch = 0),
                  (this.alignToMotion = !1),
                  (this.depthSoftening = 0),
                  (this.meshAsset = null),
                  (this.mesh = null),
                  (this.depthWrite = !1),
                  (this.noFog = !1),
                  (this.orientation = c.d3),
                  (this.particleNormal = new g.A(0, 1, 0)),
                  (this.animTilesX = 1),
                  (this.animTilesY = 1),
                  (this.animStartFrame = 0),
                  (this.animNumFrames = 1),
                  (this.animNumAnimations = 1),
                  (this.animIndex = 0),
                  (this.randomizeAnimIndex = !1),
                  (this.animSpeed = 1),
                  (this.animLoop = !0),
                  (this.scaleGraph = null),
                  (this.scaleGraph2 = null),
                  (this.colorGraph = null),
                  (this.colorGraph2 = null),
                  (this.alphaGraph = null),
                  (this.alphaGraph2 = null),
                  (this.localVelocityGraph = null),
                  (this.localVelocityGraph2 = null),
                  (this.velocityGraph = null),
                  (this.velocityGraph2 = null),
                  (this.rotationSpeedGraph = null),
                  (this.rotationSpeedGraph2 = null),
                  (this.radialSpeedGraph = null),
                  (this.radialSpeedGraph2 = null),
                  (this.blendType = c.lA),
                  (this.enabled = !0),
                  (this.paused = !1),
                  (this.autoPlay = !0),
                  (this.layers = [c.kY]);
              }
            }
            const n = [
              "enabled",
              "autoPlay",
              "numParticles",
              "lifetime",
              "rate",
              "rate2",
              "startAngle",
              "startAngle2",
              "loop",
              "preWarm",
              "lighting",
              "halfLambert",
              "intensity",
              "depthWrite",
              "noFog",
              "depthSoftening",
              "sort",
              "blendType",
              "stretch",
              "alignToMotion",
              "emitterShape",
              "emitterExtents",
              "emitterExtentsInner",
              "emitterRadius",
              "emitterRadiusInner",
              "initialVelocity",
              "wrap",
              "wrapBounds",
              "localSpace",
              "screenSpace",
              "colorMapAsset",
              "normalMapAsset",
              "mesh",
              "meshAsset",
              "renderAsset",
              "orientation",
              "particleNormal",
              "localVelocityGraph",
              "localVelocityGraph2",
              "velocityGraph",
              "velocityGraph2",
              "rotationSpeedGraph",
              "rotationSpeedGraph2",
              "radialSpeedGraph",
              "radialSpeedGraph2",
              "scaleGraph",
              "scaleGraph2",
              "colorGraph",
              "colorGraph2",
              "alphaGraph",
              "alphaGraph2",
              "colorMap",
              "normalMap",
              "animTilesX",
              "animTilesY",
              "animStartFrame",
              "animNumFrames",
              "animNumAnimations",
              "animIndex",
              "randomizeAnimIndex",
              "animSpeed",
              "animLoop",
              "layers",
            ];
            class o extends f.Q {
              constructor(e) {
                super(e),
                  (this.id = "particlesystem"),
                  (this.ComponentType = s.i),
                  (this.DataType = l),
                  (this.schema = n),
                  (this.propertyTypes = {
                    emitterExtents: "vec3",
                    emitterExtentsInner: "vec3",
                    particleNormal: "vec3",
                    wrapBounds: "vec3",
                    localVelocityGraph: "curveset",
                    localVelocityGraph2: "curveset",
                    velocityGraph: "curveset",
                    velocityGraph2: "curveset",
                    colorGraph: "curveset",
                    colorGraph2: "curveset",
                    alphaGraph: "curve",
                    alphaGraph2: "curve",
                    rotationSpeedGraph: "curve",
                    rotationSpeedGraph2: "curve",
                    radialSpeedGraph: "curve",
                    radialSpeedGraph2: "curve",
                    scaleGraph: "curve",
                    scaleGraph2: "curve",
                  }),
                  this.on("beforeremove", this.onBeforeRemove, this),
                  this.app.systems.on("update", this.onUpdate, this);
              }
              initializeComponentData(e, t, r) {
                const u = {};
                r = [];
                const y = this.propertyTypes;
                (t.mesh instanceof d.x || typeof t.mesh == "number") &&
                  ((t.meshAsset = t.mesh), delete t.mesh);
                for (const p in t) {
                  if (
                    (t.hasOwnProperty(p) && (r.push(p), (u[p] = t[p])),
                    y[p] === "vec3")
                  )
                    Array.isArray(u[p]) &&
                      (u[p] = new g.A(u[p][0], u[p][1], u[p][2]));
                  else if (y[p] === "curve") {
                    if (!(u[p] instanceof x.H)) {
                      const _ = u[p].type;
                      (u[p] = new x.H(u[p].keys)), (u[p].type = _);
                    }
                  } else if (y[p] === "curveset" && !(u[p] instanceof T.e)) {
                    const _ = u[p].type;
                    (u[p] = new T.e(u[p].keys)), (u[p].type = _);
                  }
                  u.layers &&
                    Array.isArray(u.layers) &&
                    (u.layers = u.layers.slice(0));
                }
                super.initializeComponentData(e, u, r);
              }
              cloneComponent(e, t) {
                const r = e.particlesystem.data,
                  u = this.schema,
                  y = {};
                for (let p = 0, _ = u.length; p < _; p++) {
                  const m = u[p];
                  let E = r[m];
                  E instanceof g.A || E instanceof x.H || E instanceof T.e
                    ? ((E = E.clone()), (y[m] = E))
                    : m === "layers"
                    ? (y.layers = r.layers.slice(0))
                    : E != null && (y[m] = E);
                }
                return this.addComponent(t, y);
              }
              onUpdate(e) {
                const t = this.store;
                let r;
                const u = this.app.stats.particles;
                for (const y in t)
                  if (t.hasOwnProperty(y)) {
                    const p = t[y],
                      _ = p.entity,
                      m = p.data;
                    if (m.enabled && _.enabled) {
                      const E = _.particlesystem.emitter;
                      if (!(E != null && E.meshInstance.visible)) continue;
                      if (E.lighting) {
                        const v = m.layers;
                        let P;
                        for (let I = 0; I < v.length; I++) {
                          const A = this.app.scene.layers.getLayerById(v[I]);
                          if (!A) continue;
                          A._lightCube || (A._lightCube = new Float32Array(18)),
                            (P = A._lightCube);
                          for (let C = 0; C < 6; C++)
                            (P[C * 3] = this.app.scene.ambientLight.r),
                              (P[C * 3 + 1] = this.app.scene.ambientLight.g),
                              (P[C * 3 + 2] = this.app.scene.ambientLight.b);
                          const B = A._splitLights[c.WQ];
                          for (let C = 0; C < B.length; C++)
                            for (let w = 0; w < 6; w++) {
                              const k =
                                Math.max(
                                  E.lightCubeDir[w].dot(B[C]._direction),
                                  0
                                ) * B[C]._intensity;
                              (P[w * 3] += B[C]._color.r * k),
                                (P[w * 3 + 1] += B[C]._color.g * k),
                                (P[w * 3 + 2] += B[C]._color.b * k);
                            }
                        }
                        E.constantLightCube.setValue(P);
                      }
                      if (!m.paused) {
                        if (
                          ((E.simTime += e),
                          E.simTime > E.fixedTimeStep &&
                            ((r = Math.floor(E.simTime / E.fixedTimeStep)),
                            (E.simTime -= r * E.fixedTimeStep)),
                          r)
                        ) {
                          r = Math.min(r, E.maxSubSteps);
                          for (let v = 0; v < r; v++)
                            E.addTime(E.fixedTimeStep, !1);
                          (u._updatesPerFrame += r),
                            (u._frameTime += E._addTimeTime),
                            (E._addTimeTime = 0);
                        }
                        E.finishFrame();
                      }
                    }
                  }
              }
              onBeforeRemove(e, t) {
                t.onBeforeRemove();
              }
              destroy() {
                super.destroy(),
                  this.app.systems.off("update", this.onUpdate, this);
              }
            }
            h.w._buildAccessors(s.i.prototype, n);
          },
          73: (Se, W, a) => {
            "use strict";
            a.d(W, { s: () => T });
            var x = a(5338);
            class T extends x.b {
              constructor() {
                super(),
                  (this.anim = void 0),
                  (this.animation = void 0),
                  (this.audiolistener = void 0),
                  (this.audiosource = void 0),
                  (this.button = void 0),
                  (this.camera = void 0),
                  (this.collision = void 0),
                  (this.element = void 0),
                  (this.joint = void 0),
                  (this.layoutchild = void 0),
                  (this.layoutgroup = void 0),
                  (this.light = void 0),
                  (this.model = void 0),
                  (this.particlesystem = void 0),
                  (this.render = void 0),
                  (this.rigidbody = void 0),
                  (this.screen = void 0),
                  (this.script = void 0),
                  (this.scrollbar = void 0),
                  (this.scrollview = void 0),
                  (this.sound = void 0),
                  (this.sprite = void 0),
                  (this.zone = void 0),
                  (this.list = []);
              }
              add(c) {
                const d = c.id;
                if (this[d])
                  throw new Error(
                    `ComponentSystem name '${d}' already registered or not allowed`
                  );
                (this[d] = c), this.list.push(c);
              }
              remove(c) {
                const d = c.id;
                if (!this[d])
                  throw new Error(`No ComponentSystem named '${d}' registered`);
                delete this[d];
                const h = this.list.indexOf(this[d]);
                h !== -1 && this.list.splice(h, 1);
              }
              destroy() {
                this.off();
                for (let c = 0; c < this.list.length; c++)
                  this.list[c].destroy();
              }
            }
          },
          8280: (Se, W, a) => {
            "use strict";
            a.d(W, { V: () => i });
            var x = a(3114),
              T = a(3240),
              g = a(8792),
              c = a(1259),
              d = a(4611),
              h = a(7915),
              f = a(5946),
              s = a(6204),
              l = a(5755),
              n = a(8620),
              o = a(5004);
            class i extends n.w {
              constructor(t, r) {
                super(t, r),
                  (this._type = "asset"),
                  (this._castShadows = !0),
                  (this._receiveShadows = !0),
                  (this._castShadowsLightmap = !0),
                  (this._lightmapped = !1),
                  (this._lightmapSizeMultiplier = 1),
                  (this.isStatic = !1),
                  (this._batchGroupId = -1),
                  (this._layers = [x.kY]),
                  (this._renderStyle = x.pr),
                  (this._meshInstances = []),
                  (this._customAabb = null),
                  (this._area = null),
                  (this._assetReference = []),
                  (this._materialReferences = []),
                  (this._material = void 0),
                  (this._rootBone = void 0),
                  (this._rootBone = new o.e(this, "rootBone")),
                  this._rootBone.on("set:entity", this._onSetRootBone, this),
                  (this._assetReference = new l.M(
                    "asset",
                    this,
                    t.app.assets,
                    {
                      add: this._onRenderAssetAdded,
                      load: this._onRenderAssetLoad,
                      remove: this._onRenderAssetRemove,
                      unload: this._onRenderAssetUnload,
                    },
                    this
                  )),
                  (this._material = t.defaultMaterial),
                  r.on("remove", this.onRemoveChild, this),
                  r.on("removehierarchy", this.onRemoveChild, this),
                  r.on("insert", this.onInsertChild, this),
                  r.on("inserthierarchy", this.onInsertChild, this);
              }
              set renderStyle(t) {
                this._renderStyle !== t &&
                  ((this._renderStyle = t),
                  g.l._prepareRenderStyleForArray(this._meshInstances, t));
              }
              get renderStyle() {
                return this._renderStyle;
              }
              set customAabb(t) {
                this._customAabb = t;
                const r = this._meshInstances;
                if (r)
                  for (let u = 0; u < r.length; u++)
                    r[u].setCustomAabb(this._customAabb);
              }
              get customAabb() {
                return this._customAabb;
              }
              set type(t) {
                if (
                  this._type !== t &&
                  ((this._area = null),
                  (this._type = t),
                  this.destroyMeshInstances(),
                  t !== "asset")
                ) {
                  let r = this._material;
                  (!r || r === this.system.defaultMaterial) &&
                    (r =
                      this._materialReferences[0] &&
                      this._materialReferences[0].asset &&
                      this._materialReferences[0].asset.resource);
                  const u = (0, d.$r)(this.system.app.graphicsDevice, t);
                  (this._area = u.area),
                    (this.meshInstances = [
                      new g.l(
                        u.mesh,
                        r || this.system.defaultMaterial,
                        this.entity
                      ),
                    ]);
                }
              }
              get type() {
                return this._type;
              }
              set meshInstances(t) {
                if (
                  (this.destroyMeshInstances(),
                  (this._meshInstances = t),
                  this._meshInstances)
                ) {
                  const r = this._meshInstances;
                  for (let u = 0; u < r.length; u++)
                    r[u].node || (r[u].node = this.entity),
                      (r[u].castShadow = this._castShadows),
                      (r[u].receiveShadow = this._receiveShadows),
                      (r[u].renderStyle = this._renderStyle),
                      r[u].setLightmapped(this._lightmapped),
                      r[u].setCustomAabb(this._customAabb);
                  this.enabled && this.entity.enabled && this.addToLayers();
                }
              }
              get meshInstances() {
                return this._meshInstances;
              }
              set lightmapped(t) {
                if (t !== this._lightmapped) {
                  this._lightmapped = t;
                  const r = this._meshInstances;
                  if (r)
                    for (let u = 0; u < r.length; u++) r[u].setLightmapped(t);
                }
              }
              get lightmapped() {
                return this._lightmapped;
              }
              set castShadows(t) {
                if (this._castShadows !== t) {
                  const r = this._meshInstances;
                  if (r) {
                    const u = this.layers,
                      y = this.system.app.scene;
                    if (this._castShadows && !t)
                      for (let p = 0; p < u.length; p++) {
                        const _ = y.layers.getLayerById(this.layers[p]);
                        _ && _.removeShadowCasters(r);
                      }
                    for (let p = 0; p < r.length; p++) r[p].castShadow = t;
                    if (!this._castShadows && t)
                      for (let p = 0; p < u.length; p++) {
                        const _ = y.layers.getLayerById(u[p]);
                        _ && _.addShadowCasters(r);
                      }
                  }
                  this._castShadows = t;
                }
              }
              get castShadows() {
                return this._castShadows;
              }
              set receiveShadows(t) {
                if (this._receiveShadows !== t) {
                  this._receiveShadows = t;
                  const r = this._meshInstances;
                  if (r)
                    for (let u = 0; u < r.length; u++) r[u].receiveShadow = t;
                }
              }
              get receiveShadows() {
                return this._receiveShadows;
              }
              set castShadowsLightmap(t) {
                this._castShadowsLightmap = t;
              }
              get castShadowsLightmap() {
                return this._castShadowsLightmap;
              }
              set lightmapSizeMultiplier(t) {
                this._lightmapSizeMultiplier = t;
              }
              get lightmapSizeMultiplier() {
                return this._lightmapSizeMultiplier;
              }
              set layers(t) {
                const r = this.system.app.scene.layers;
                let u;
                if (this._meshInstances)
                  for (let y = 0; y < this._layers.length; y++)
                    (u = r.getLayerById(this._layers[y])),
                      u && u.removeMeshInstances(this._meshInstances);
                this._layers.length = 0;
                for (let y = 0; y < t.length; y++) this._layers[y] = t[y];
                if (
                  !(
                    !this.enabled ||
                    !this.entity.enabled ||
                    !this._meshInstances
                  )
                )
                  for (let y = 0; y < this._layers.length; y++)
                    (u = r.getLayerById(this._layers[y])),
                      u && u.addMeshInstances(this._meshInstances);
              }
              get layers() {
                return this._layers;
              }
              set batchGroupId(t) {
                if (this._batchGroupId !== t) {
                  if (this.entity.enabled && this._batchGroupId >= 0) {
                    var r;
                    (r = this.system.app.batcher) == null ||
                      r.remove(T.y.RENDER, this.batchGroupId, this.entity);
                  }
                  if (this.entity.enabled && t >= 0) {
                    var u;
                    (u = this.system.app.batcher) == null ||
                      u.insert(T.y.RENDER, t, this.entity);
                  }
                  t < 0 &&
                    this._batchGroupId >= 0 &&
                    this.enabled &&
                    this.entity.enabled &&
                    this.addToLayers(),
                    (this._batchGroupId = t);
                }
              }
              get batchGroupId() {
                return this._batchGroupId;
              }
              set material(t) {
                if (
                  this._material !== t &&
                  ((this._material = t),
                  this._meshInstances && this._type !== "asset")
                )
                  for (let r = 0; r < this._meshInstances.length; r++)
                    this._meshInstances[r].material = t;
              }
              get material() {
                return this._material;
              }
              set materialAssets(t = []) {
                if (this._materialReferences.length > t.length) {
                  for (
                    let r = t.length;
                    r < this._materialReferences.length;
                    r++
                  )
                    this._materialReferences[r].id = null;
                  this._materialReferences.length = t.length;
                }
                for (let r = 0; r < t.length; r++)
                  if (
                    (this._materialReferences[r] ||
                      this._materialReferences.push(
                        new l.M(
                          r,
                          this,
                          this.system.app.assets,
                          {
                            add: this._onMaterialAdded,
                            load: this._onMaterialLoad,
                            remove: this._onMaterialRemove,
                            unload: this._onMaterialUnload,
                          },
                          this
                        )
                      ),
                    t[r])
                  ) {
                    const u = t[r] instanceof s.x ? t[r].id : t[r];
                    this._materialReferences[r].id !== u &&
                      (this._materialReferences[r].id = u),
                      this._materialReferences[r].asset &&
                        this._onMaterialAdded(
                          r,
                          this,
                          this._materialReferences[r].asset
                        );
                  } else
                    (this._materialReferences[r].id = null),
                      this._meshInstances[r] &&
                        (this._meshInstances[r].material =
                          this.system.defaultMaterial);
              }
              get materialAssets() {
                return this._materialReferences.map(function (t) {
                  return t.id;
                });
              }
              set asset(t) {
                const r = t instanceof s.x ? t.id : t;
                this._assetReference.id !== r &&
                  (this._assetReference.asset &&
                    this._assetReference.asset.resource &&
                    this._onRenderAssetRemove(),
                  (this._assetReference.id = r),
                  this._assetReference.asset && this._onRenderAssetAdded());
              }
              get asset() {
                return this._assetReference.id;
              }
              assignAsset(t) {
                const r = t instanceof s.x ? t.id : t;
                this._assetReference.id = r;
              }
              _onSetRootBone(t) {
                t && this._onRootBoneChanged();
              }
              _onRootBoneChanged() {
                this._clearSkinInstances(),
                  this.enabled &&
                    this.entity.enabled &&
                    this._cloneSkinInstances();
              }
              destroyMeshInstances() {
                const t = this._meshInstances;
                if (t) {
                  this.removeFromLayers(), this._clearSkinInstances();
                  for (let r = 0; r < t.length; r++) t[r].destroy();
                  this._meshInstances.length = 0;
                }
              }
              addToLayers() {
                const t = this.system.app.scene.layers;
                for (let r = 0; r < this._layers.length; r++) {
                  const u = t.getLayerById(this._layers[r]);
                  u && u.addMeshInstances(this._meshInstances);
                }
              }
              removeFromLayers() {
                if (this._meshInstances && this._meshInstances.length) {
                  const t = this.system.app.scene.layers;
                  for (let r = 0; r < this._layers.length; r++) {
                    const u = t.getLayerById(this._layers[r]);
                    u && u.removeMeshInstances(this._meshInstances);
                  }
                }
              }
              onRemoveChild() {
                this.removeFromLayers();
              }
              onInsertChild() {
                this._meshInstances &&
                  this.enabled &&
                  this.entity.enabled &&
                  this.addToLayers();
              }
              onRemove() {
                this.destroyMeshInstances(),
                  (this.asset = null),
                  (this.materialAsset = null),
                  (this._assetReference.id = null);
                for (let t = 0; t < this._materialReferences.length; t++)
                  this._materialReferences[t].id = null;
                this.entity.off("remove", this.onRemoveChild, this),
                  this.entity.off("insert", this.onInsertChild, this);
              }
              onLayersChanged(t, r) {
                this.addToLayers(),
                  t.off("add", this.onLayerAdded, this),
                  t.off("remove", this.onLayerRemoved, this),
                  r.on("add", this.onLayerAdded, this),
                  r.on("remove", this.onLayerRemoved, this);
              }
              onLayerAdded(t) {
                this.layers.indexOf(t.id) < 0 ||
                  t.addMeshInstances(this._meshInstances);
              }
              onLayerRemoved(t) {
                this.layers.indexOf(t.id) < 0 ||
                  t.removeMeshInstances(this._meshInstances);
              }
              onEnable() {
                const t = this.system.app,
                  r = t.scene;
                this._rootBone.onParentComponentEnable(),
                  this._cloneSkinInstances(),
                  r.on("set:layers", this.onLayersChanged, this),
                  r.layers &&
                    (r.layers.on("add", this.onLayerAdded, this),
                    r.layers.on("remove", this.onLayerRemoved, this));
                const u = this._type === "asset";
                this._meshInstances && this._meshInstances.length
                  ? this.addToLayers()
                  : u && this.asset && this._onRenderAssetAdded();
                for (let p = 0; p < this._materialReferences.length; p++)
                  this._materialReferences[p].asset &&
                    this.system.app.assets.load(
                      this._materialReferences[p].asset
                    );
                if (this._batchGroupId >= 0) {
                  var y;
                  (y = t.batcher) == null ||
                    y.insert(T.y.RENDER, this.batchGroupId, this.entity);
                }
              }
              onDisable() {
                const t = this.system.app,
                  r = t.scene;
                if (
                  (r.off("set:layers", this.onLayersChanged, this),
                  r.layers &&
                    (r.layers.off("add", this.onLayerAdded, this),
                    r.layers.off("remove", this.onLayerRemoved, this)),
                  this._batchGroupId >= 0)
                ) {
                  var u;
                  (u = t.batcher) == null ||
                    u.remove(T.y.RENDER, this.batchGroupId, this.entity);
                }
                this.removeFromLayers();
              }
              hide() {
                if (this._meshInstances)
                  for (let t = 0; t < this._meshInstances.length; t++)
                    this._meshInstances[t].visible = !1;
              }
              show() {
                if (this._meshInstances)
                  for (let t = 0; t < this._meshInstances.length; t++)
                    this._meshInstances[t].visible = !0;
              }
              _onRenderAssetAdded() {
                this._assetReference.asset &&
                  (this._assetReference.asset.resource
                    ? this._onRenderAssetLoad()
                    : this.enabled &&
                      this.entity.enabled &&
                      this.system.app.assets.load(this._assetReference.asset));
              }
              _onRenderAssetLoad() {
                if ((this.destroyMeshInstances(), this._assetReference.asset)) {
                  const t = this._assetReference.asset.resource;
                  t.off("set:meshes", this._onSetMeshes, this),
                    t.on("set:meshes", this._onSetMeshes, this),
                    t.meshes && this._onSetMeshes(t.meshes);
                }
              }
              _onSetMeshes(t) {
                this._cloneMeshes(t);
              }
              _clearSkinInstances() {
                for (let t = 0; t < this._meshInstances.length; t++) {
                  const r = this._meshInstances[t];
                  f.J.removeCachedSkinInstance(r.skinInstance),
                    (r.skinInstance = null);
                }
              }
              _cloneSkinInstances() {
                if (
                  this._meshInstances.length &&
                  this._rootBone.entity instanceof h.A
                )
                  for (let t = 0; t < this._meshInstances.length; t++) {
                    const r = this._meshInstances[t],
                      u = r.mesh;
                    u.skin &&
                      !r.skinInstance &&
                      (r.skinInstance = f.J.createCachedSkinInstance(
                        u.skin,
                        this._rootBone.entity,
                        this.entity
                      ));
                  }
              }
              _cloneMeshes(t) {
                if (t && t.length) {
                  const r = [];
                  for (let u = 0; u < t.length; u++) {
                    const y = t[u],
                      p =
                        this._materialReferences[u] &&
                        this._materialReferences[u].asset &&
                        this._materialReferences[u].asset.resource,
                      _ = new g.l(
                        y,
                        p || this.system.defaultMaterial,
                        this.entity
                      );
                    r.push(_), y.morph && (_.morphInstance = new c.w(y.morph));
                  }
                  (this.meshInstances = r), this._cloneSkinInstances();
                }
              }
              _onRenderAssetUnload() {
                this._type === "asset" && this.destroyMeshInstances();
              }
              _onRenderAssetRemove() {
                this._assetReference.asset &&
                  this._assetReference.asset.resource &&
                  this._assetReference.asset.resource.off(
                    "set:meshes",
                    this._onSetMeshes,
                    this
                  ),
                  this._onRenderAssetUnload();
              }
              _onMaterialAdded(t, r, u) {
                u.resource
                  ? this._onMaterialLoad(t, r, u)
                  : this.enabled &&
                    this.entity.enabled &&
                    this.system.app.assets.load(u);
              }
              _updateMainMaterial(t, r) {
                t === 0 && (this.material = r);
              }
              _onMaterialLoad(t, r, u) {
                this._meshInstances[t] &&
                  (this._meshInstances[t].material = u.resource),
                  this._updateMainMaterial(t, u.resource);
              }
              _onMaterialRemove(t, r, u) {
                this._meshInstances[t] &&
                  (this._meshInstances[t].material =
                    this.system.defaultMaterial),
                  this._updateMainMaterial(t, this.system.defaultMaterial);
              }
              _onMaterialUnload(t, r, u) {
                this._meshInstances[t] &&
                  (this._meshInstances[t].material =
                    this.system.defaultMaterial),
                  this._updateMainMaterial(t, this.system.defaultMaterial);
              }
              resolveDuplicatedEntityReferenceProperties(t, r) {
                t.rootBone && r[t.rootBone] && (this.rootBone = r[t.rootBone]),
                  this._clearSkinInstances();
              }
            }
          },
          3962: (Se, W, a) => {
            "use strict";
            a.d(W, { r: () => n });
            var x = a(6556),
              T = a(3148),
              g = a(9373),
              c = a(8620),
              d = a(6813),
              h = a(8280);
            class f {
              constructor() {
                (this.enabled = !0), (this.rootBone = null);
              }
            }
            const s = [{ name: "rootBone", type: "entity" }, "enabled"],
              l = [
                "material",
                "meshInstances",
                "asset",
                "materialAssets",
                "castShadows",
                "receiveShadows",
                "castShadowsLightmap",
                "lightmapped",
                "lightmapSizeMultiplier",
                "renderStyle",
                "type",
                "layers",
                "isStatic",
                "batchGroupId",
              ];
            class n extends d.Q {
              constructor(i) {
                super(i),
                  (this.id = "render"),
                  (this.ComponentType = h.V),
                  (this.DataType = f),
                  (this.schema = s),
                  (this.defaultMaterial = (0, g.U)(i.graphicsDevice)),
                  this.on("beforeremove", this.onRemove, this);
              }
              initializeComponentData(i, e, t) {
                (e.batchGroupId === null || e.batchGroupId === void 0) &&
                  (e.batchGroupId = -1),
                  e.layers && e.layers.length && (e.layers = e.layers.slice(0));
                for (let r = 0; r < l.length; r++)
                  e.hasOwnProperty(l[r]) && (i[l[r]] = e[l[r]]);
                e.aabbCenter &&
                  e.aabbHalfExtents &&
                  (i.customAabb = new T.k(
                    new x.A(e.aabbCenter),
                    new x.A(e.aabbHalfExtents)
                  )),
                  super.initializeComponentData(i, e, s);
              }
              cloneComponent(i, e) {
                const t = {};
                for (let p = 0; p < l.length; p++) t[l[p]] = i.render[l[p]];
                (t.enabled = i.render.enabled), delete t.meshInstances;
                const r = this.addComponent(e, t),
                  u = i.render.meshInstances,
                  y = u.map((p) => p.mesh);
                r._onSetMeshes(y);
                for (let p = 0; p < u.length; p++)
                  r.meshInstances[p].material = u[p].material;
                return (
                  i.render.customAabb &&
                    (r.customAabb = i.render.customAabb.clone()),
                  r
                );
              }
              onRemove(i, e) {
                e.onRemove();
              }
            }
            c.w._buildAccessors(h.V.prototype, s);
          },
          4608: (Se, W, a) => {
            "use strict";
            a.d(W, { D: () => i });
            var x = a(6847),
              T = a(6556),
              g = a(2628),
              c = a(8620);
            let d, h, f, s;
            const l = new x.D(),
              n = new x.D(),
              o = new T.A();
            class i extends c.w {
              constructor(t, r) {
                super(t, r),
                  (this._angularDamping = 0),
                  (this._angularFactor = new T.A(1, 1, 1)),
                  (this._angularVelocity = new T.A()),
                  (this._body = null),
                  (this._friction = 0.5),
                  (this._group = g.F8),
                  (this._linearDamping = 0),
                  (this._linearFactor = new T.A(1, 1, 1)),
                  (this._linearVelocity = new T.A()),
                  (this._mask = g.wn),
                  (this._mass = 1),
                  (this._restitution = 0),
                  (this._rollingFriction = 0),
                  (this._simulationEnabled = !1),
                  (this._type = g.eg);
              }
              static onLibraryLoaded() {
                typeof Ammo != "undefined" &&
                  ((d = new Ammo.btTransform()),
                  (h = new Ammo.btVector3()),
                  (f = new Ammo.btVector3()),
                  (s = new Ammo.btQuaternion()));
              }
              set angularDamping(t) {
                this._angularDamping !== t &&
                  ((this._angularDamping = t),
                  this._body && this._body.setDamping(this._linearDamping, t));
              }
              get angularDamping() {
                return this._angularDamping;
              }
              set angularFactor(t) {
                this._angularFactor.equals(t) ||
                  (this._angularFactor.copy(t),
                  this._body &&
                    this._type === g.YZ &&
                    (h.setValue(t.x, t.y, t.z),
                    this._body.setAngularFactor(h)));
              }
              get angularFactor() {
                return this._angularFactor;
              }
              set angularVelocity(t) {
                this._body &&
                  this._type === g.YZ &&
                  (this._body.activate(),
                  h.setValue(t.x, t.y, t.z),
                  this._body.setAngularVelocity(h),
                  this._angularVelocity.copy(t));
              }
              get angularVelocity() {
                if (this._body && this._type === g.YZ) {
                  const t = this._body.getAngularVelocity();
                  this._angularVelocity.set(t.x(), t.y(), t.z());
                }
                return this._angularVelocity;
              }
              set body(t) {
                this._body !== t &&
                  ((this._body = t),
                  t && this._simulationEnabled && t.activate());
              }
              get body() {
                return this._body;
              }
              set friction(t) {
                this._friction !== t &&
                  ((this._friction = t),
                  this._body && this._body.setFriction(t));
              }
              get friction() {
                return this._friction;
              }
              set group(t) {
                this._group !== t &&
                  ((this._group = t),
                  this.enabled &&
                    this.entity.enabled &&
                    (this.disableSimulation(), this.enableSimulation()));
              }
              get group() {
                return this._group;
              }
              set linearDamping(t) {
                this._linearDamping !== t &&
                  ((this._linearDamping = t),
                  this._body && this._body.setDamping(t, this._angularDamping));
              }
              get linearDamping() {
                return this._linearDamping;
              }
              set linearFactor(t) {
                this._linearFactor.equals(t) ||
                  (this._linearFactor.copy(t),
                  this._body &&
                    this._type === g.YZ &&
                    (h.setValue(t.x, t.y, t.z), this._body.setLinearFactor(h)));
              }
              get linearFactor() {
                return this._linearFactor;
              }
              set linearVelocity(t) {
                this._body &&
                  this._type === g.YZ &&
                  (this._body.activate(),
                  h.setValue(t.x, t.y, t.z),
                  this._body.setLinearVelocity(h),
                  this._linearVelocity.copy(t));
              }
              get linearVelocity() {
                if (this._body && this._type === g.YZ) {
                  const t = this._body.getLinearVelocity();
                  this._linearVelocity.set(t.x(), t.y(), t.z());
                }
                return this._linearVelocity;
              }
              set mask(t) {
                this._mask !== t &&
                  ((this._mask = t),
                  this.enabled &&
                    this.entity.enabled &&
                    (this.disableSimulation(), this.enableSimulation()));
              }
              get mask() {
                return this._mask;
              }
              set mass(t) {
                if (
                  this._mass !== t &&
                  ((this._mass = t), this._body && this._type === g.YZ)
                ) {
                  const r = this.enabled && this.entity.enabled;
                  r && this.disableSimulation(),
                    this._body.getCollisionShape().calculateLocalInertia(t, h),
                    this._body.setMassProps(t, h),
                    this._body.updateInertiaTensor(),
                    r && this.enableSimulation();
                }
              }
              get mass() {
                return this._mass;
              }
              set restitution(t) {
                this._restitution !== t &&
                  ((this._restitution = t),
                  this._body && this._body.setRestitution(t));
              }
              get restitution() {
                return this._restitution;
              }
              set rollingFriction(t) {
                this._rollingFriction !== t &&
                  ((this._rollingFriction = t),
                  this._body && this._body.setRollingFriction(t));
              }
              get rollingFriction() {
                return this._rollingFriction;
              }
              set type(t) {
                if (this._type !== t) {
                  switch (((this._type = t), this.disableSimulation(), t)) {
                    case g.YZ:
                      (this._group = g.hQ), (this._mask = g.jh);
                      break;
                    case g.oV:
                      (this._group = g.o9), (this._mask = g.jh);
                      break;
                    case g.eg:
                    default:
                      (this._group = g.F8), (this._mask = g.wn);
                      break;
                  }
                  this.createBody();
                }
              }
              get type() {
                return this._type;
              }
              createBody() {
                const t = this.entity;
                let r;
                if (
                  (t.collision &&
                    ((r = t.collision.shape),
                    t.trigger && (t.trigger.destroy(), delete t.trigger)),
                  r)
                ) {
                  this._body && this.system.onRemove(t, this);
                  const u = this._type === g.YZ ? this._mass : 0;
                  this._getEntityTransform(d);
                  const y = this.system.createBody(u, r, d);
                  if (
                    (y.setRestitution(this._restitution),
                    y.setFriction(this._friction),
                    y.setRollingFriction(this._rollingFriction),
                    y.setDamping(this._linearDamping, this._angularDamping),
                    this._type === g.YZ)
                  ) {
                    const p = this._linearFactor;
                    h.setValue(p.x, p.y, p.z), y.setLinearFactor(h);
                    const _ = this._angularFactor;
                    h.setValue(_.x, _.y, _.z), y.setAngularFactor(h);
                  } else
                    this._type === g.oV &&
                      (y.setCollisionFlags(y.getCollisionFlags() | g.tU),
                      y.setActivationState(g.Ln));
                  (y.entity = t),
                    (this.body = y),
                    this.enabled && t.enabled && this.enableSimulation();
                }
              }
              isActive() {
                return this._body ? this._body.isActive() : !1;
              }
              activate() {
                this._body && this._body.activate();
              }
              enableSimulation() {
                const t = this.entity;
                if (
                  t.collision &&
                  t.collision.enabled &&
                  !this._simulationEnabled
                ) {
                  const r = this._body;
                  if (r) {
                    switch (
                      (this.system.addBody(r, this._group, this._mask),
                      this._type)
                    ) {
                      case g.YZ:
                        this.system._dynamic.push(this),
                          r.forceActivationState(g.sc),
                          this.syncEntityToBody();
                        break;
                      case g.oV:
                        this.system._kinematic.push(this),
                          r.forceActivationState(g.Ln);
                        break;
                      case g.eg:
                        r.forceActivationState(g.sc), this.syncEntityToBody();
                        break;
                    }
                    t.collision.type === "compound" &&
                      this.system._compounds.push(t.collision),
                      r.activate(),
                      (this._simulationEnabled = !0);
                  }
                }
              }
              disableSimulation() {
                const t = this._body;
                if (t && this._simulationEnabled) {
                  const r = this.system;
                  let u = r._compounds.indexOf(this.entity.collision);
                  u > -1 && r._compounds.splice(u, 1),
                    (u = r._dynamic.indexOf(this)),
                    u > -1 && r._dynamic.splice(u, 1),
                    (u = r._kinematic.indexOf(this)),
                    u > -1 && r._kinematic.splice(u, 1),
                    r.removeBody(t),
                    t.forceActivationState(g.AE),
                    (this._simulationEnabled = !1);
                }
              }
              applyForce(t, r, u, y, p, _) {
                const m = this._body;
                m &&
                  (m.activate(),
                  t instanceof T.A
                    ? h.setValue(t.x, t.y, t.z)
                    : h.setValue(t, r, u),
                  r instanceof T.A
                    ? f.setValue(r.x, r.y, r.z)
                    : y !== void 0
                    ? f.setValue(y, p, _)
                    : f.setValue(0, 0, 0),
                  m.applyForce(h, f));
              }
              applyTorque(t, r, u) {
                const y = this._body;
                y &&
                  (y.activate(),
                  t instanceof T.A
                    ? h.setValue(t.x, t.y, t.z)
                    : h.setValue(t, r, u),
                  y.applyTorque(h));
              }
              applyImpulse(t, r, u, y, p, _) {
                const m = this._body;
                m &&
                  (m.activate(),
                  t instanceof T.A
                    ? h.setValue(t.x, t.y, t.z)
                    : h.setValue(t, r, u),
                  r instanceof T.A
                    ? f.setValue(r.x, r.y, r.z)
                    : y !== void 0
                    ? f.setValue(y, p, _)
                    : f.setValue(0, 0, 0),
                  m.applyImpulse(h, f));
              }
              applyTorqueImpulse(t, r, u) {
                const y = this._body;
                y &&
                  (y.activate(),
                  t instanceof T.A
                    ? h.setValue(t.x, t.y, t.z)
                    : h.setValue(t, r, u),
                  y.applyTorqueImpulse(h));
              }
              isStatic() {
                return this._type === g.eg;
              }
              isStaticOrKinematic() {
                return this._type === g.eg || this._type === g.oV;
              }
              isKinematic() {
                return this._type === g.oV;
              }
              _getEntityTransform(t) {
                const r = this.entity,
                  u = r.collision;
                if (u) {
                  const y = u.getShapePosition(),
                    p = u.getShapeRotation();
                  h.setValue(y.x, y.y, y.z), s.setValue(p.x, p.y, p.z, p.w);
                } else {
                  const y = r.getPosition(),
                    p = r.getRotation();
                  h.setValue(y.x, y.y, y.z), s.setValue(p.x, p.y, p.z, p.w);
                }
                t.setOrigin(h), t.setRotation(s);
              }
              syncEntityToBody() {
                const t = this._body;
                if (t) {
                  if (
                    (this._getEntityTransform(d),
                    t.setWorldTransform(d),
                    this._type === g.oV)
                  ) {
                    const r = t.getMotionState();
                    r && r.setWorldTransform(d);
                  }
                  t.activate();
                }
              }
              _updateDynamic() {
                const t = this._body;
                if (t.isActive()) {
                  const r = t.getMotionState();
                  if (r) {
                    const u = this.entity;
                    r.getWorldTransform(d);
                    const y = d.getOrigin(),
                      p = d.getRotation(),
                      _ = u.collision;
                    if (_ && _._hasOffset) {
                      const m = _.data.linearOffset,
                        E = _.data.angularOffset,
                        v = n.copy(E).invert(),
                        P = l.set(p.x(), p.y(), p.z(), p.w()).mul(v);
                      P.transformVector(m, o),
                        u.setPosition(y.x() - o.x, y.y() - o.y, y.z() - o.z),
                        u.setRotation(P);
                    } else
                      u.setPosition(y.x(), y.y(), y.z()),
                        u.setRotation(p.x(), p.y(), p.z(), p.w());
                  }
                }
              }
              _updateKinematic() {
                const t = this._body.getMotionState();
                t && (this._getEntityTransform(d), t.setWorldTransform(d));
              }
              teleport(t, r, u, y, p, _) {
                t instanceof T.A
                  ? this.entity.setPosition(t)
                  : this.entity.setPosition(t, r, u),
                  r instanceof x.D
                    ? this.entity.setRotation(r)
                    : r instanceof T.A
                    ? this.entity.setEulerAngles(r)
                    : y !== void 0 && this.entity.setEulerAngles(y, p, _),
                  this.syncEntityToBody();
              }
              onEnable() {
                this._body || this.createBody(), this.enableSimulation();
              }
              onDisable() {
                this.disableSimulation();
              }
            }
          },
          2628: (Se, W, a) => {
            "use strict";
            a.d(W, {
              $4: () => A,
              A4: () => _,
              AE: () => o,
              Es: () => P,
              F8: () => r,
              Im: () => p,
              KM: () => C,
              Kf: () => $,
              Kl: () => I,
              Ln: () => n,
              NF: () => v,
              RH: () => m,
              SN: () => l,
              VG: () => w,
              YZ: () => T,
              _V: () => te,
              ct: () => B,
              eg: () => x,
              ge: () => h,
              hQ: () => t,
              jh: () => K,
              jy: () => E,
              n2: () => i,
              o9: () => u,
              oV: () => g,
              pM: () => y,
              q9: () => k,
              qi: () => s,
              sc: () => f,
              tU: () => d,
              vp: () => e,
              wn: () => X,
              zG: () => c,
            });
            const x = "static",
              T = "dynamic",
              g = "kinematic",
              c = 1,
              d = 2,
              h = 4,
              f = 1,
              s = 2,
              l = 3,
              n = 4,
              o = 5,
              i = 0,
              e = 1,
              t = 1,
              r = 2,
              u = 4,
              y = 8,
              p = 16,
              _ = 32,
              m = 64,
              E = 128,
              v = 256,
              P = 512,
              I = 1024,
              A = 2048,
              B = 4096,
              C = 8192,
              w = 16384,
              k = 0,
              K = 65535,
              te = 2,
              X = 65533,
              $ = 65529;
          },
          8069: (Se, W, a) => {
            "use strict";
            a.d(W, {
              SQ: () => i,
              sT: () => e,
              Fv: () => n,
              Lz: () => r,
              u6: () => o,
            });
            class x {
              constructor(y, p) {
                (this._pool = []),
                  (this._count = 0),
                  (this._constructor = y),
                  this._resize(p);
              }
              _resize(y) {
                if (y > this._pool.length)
                  for (let p = this._pool.length; p < y; p++)
                    this._pool[p] = new this._constructor();
              }
              allocate() {
                return (
                  this._count >= this._pool.length &&
                    this._resize(this._pool.length * 2),
                  this._pool[this._count++]
                );
              }
              freeAll() {
                this._count = 0;
              }
            }
            var T = a(6556),
              g = a(8620),
              c = a(6813),
              d = a(2628),
              h = a(4608);
            class f {
              constructor() {
                this.enabled = !0;
              }
            }
            let s, l;
            class n {
              constructor(y, p, _, m) {
                (this.entity = y),
                  (this.point = p),
                  (this.normal = _),
                  (this.hitFraction = m);
              }
            }
            class o {
              constructor(y, p, _) {
                arguments.length === 0
                  ? ((this.a = null),
                    (this.b = null),
                    (this.impulse = 0),
                    (this.localPointA = new T.A()),
                    (this.localPointB = new T.A()),
                    (this.pointA = new T.A()),
                    (this.pointB = new T.A()),
                    (this.normal = new T.A()))
                  : ((this.a = y),
                    (this.b = p),
                    (this.impulse = _.impulse),
                    (this.localPointA = _.localPoint),
                    (this.localPointB = _.localPointOther),
                    (this.pointA = _.point),
                    (this.pointB = _.pointOther),
                    (this.normal = _.normal));
              }
            }
            class i {
              constructor(
                y = new T.A(),
                p = new T.A(),
                _ = new T.A(),
                m = new T.A(),
                E = new T.A(),
                v = 0
              ) {
                (this.localPoint = y),
                  (this.localPointOther = p),
                  (this.point = _),
                  (this.pointOther = m),
                  (this.normal = E),
                  (this.impulse = v);
              }
            }
            class e {
              constructor(y, p) {
                (this.other = y), (this.contacts = p);
              }
            }
            const t = ["enabled"];
            class r extends c.Q {
              constructor(y) {
                super(y),
                  (this.maxSubSteps = 10),
                  (this.fixedTimeStep = 0.016666666666666666),
                  (this.gravity = new T.A(0, -9.81, 0)),
                  (this._gravityFloat32 = new Float32Array(3)),
                  (this._dynamic = []),
                  (this._kinematic = []),
                  (this._triggers = []),
                  (this._compounds = []),
                  (this.id = "rigidbody"),
                  (this._stats = y.stats.frame),
                  (this.ComponentType = h.D),
                  (this.DataType = f),
                  (this.contactPointPool = null),
                  (this.contactResultPool = null),
                  (this.singleContactResultPool = null),
                  (this.schema = t),
                  (this.collisions = {}),
                  (this.frameCollisions = {}),
                  this.on("beforeremove", this.onBeforeRemove, this),
                  this.on("remove", this.onRemove, this);
              }
              onLibraryLoaded() {
                if (typeof Ammo != "undefined") {
                  if (
                    ((this.collisionConfiguration =
                      new Ammo.btDefaultCollisionConfiguration()),
                    (this.dispatcher = new Ammo.btCollisionDispatcher(
                      this.collisionConfiguration
                    )),
                    (this.overlappingPairCache = new Ammo.btDbvtBroadphase()),
                    (this.solver =
                      new Ammo.btSequentialImpulseConstraintSolver()),
                    (this.dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(
                      this.dispatcher,
                      this.overlappingPairCache,
                      this.solver,
                      this.collisionConfiguration
                    )),
                    this.dynamicsWorld.setInternalTickCallback)
                  ) {
                    const y = Ammo.addFunction(
                      this._checkForCollisions.bind(this),
                      "vif"
                    );
                    this.dynamicsWorld.setInternalTickCallback(y);
                  }
                  (s = new Ammo.btVector3()),
                    (l = new Ammo.btVector3()),
                    h.D.onLibraryLoaded(),
                    (this.contactPointPool = new x(i, 1)),
                    (this.contactResultPool = new x(e, 1)),
                    (this.singleContactResultPool = new x(o, 1)),
                    this.app.systems.on("update", this.onUpdate, this);
                } else this.app.systems.off("update", this.onUpdate, this);
              }
              initializeComponentData(y, p, _) {
                const m = [
                  "mass",
                  "linearDamping",
                  "angularDamping",
                  "linearFactor",
                  "angularFactor",
                  "friction",
                  "rollingFriction",
                  "restitution",
                  "type",
                  "group",
                  "mask",
                ];
                for (const E of m)
                  if (p.hasOwnProperty(E)) {
                    const v = p[E];
                    Array.isArray(v)
                      ? (y[E] = new T.A(v[0], v[1], v[2]))
                      : (y[E] = v);
                  }
                super.initializeComponentData(y, p, ["enabled"]);
              }
              cloneComponent(y, p) {
                const _ = y.rigidbody,
                  m = {
                    enabled: _.enabled,
                    mass: _.mass,
                    linearDamping: _.linearDamping,
                    angularDamping: _.angularDamping,
                    linearFactor: [
                      _.linearFactor.x,
                      _.linearFactor.y,
                      _.linearFactor.z,
                    ],
                    angularFactor: [
                      _.angularFactor.x,
                      _.angularFactor.y,
                      _.angularFactor.z,
                    ],
                    friction: _.friction,
                    rollingFriction: _.rollingFriction,
                    restitution: _.restitution,
                    type: _.type,
                    group: _.group,
                    mask: _.mask,
                  };
                return this.addComponent(p, m);
              }
              onBeforeRemove(y, p) {
                p.enabled && (p.enabled = !1);
              }
              onRemove(y, p) {
                const _ = p.body;
                _ && (this.removeBody(_), this.destroyBody(_), (p.body = null));
              }
              addBody(y, p, _) {
                p !== void 0 && _ !== void 0
                  ? this.dynamicsWorld.addRigidBody(y, p, _)
                  : this.dynamicsWorld.addRigidBody(y);
              }
              removeBody(y) {
                this.dynamicsWorld.removeRigidBody(y);
              }
              createBody(y, p, _) {
                const m = new Ammo.btVector3(0, 0, 0);
                y !== 0 && p.calculateLocalInertia(y, m);
                const E = new Ammo.btDefaultMotionState(_),
                  v = new Ammo.btRigidBodyConstructionInfo(y, E, p, m),
                  P = new Ammo.btRigidBody(v);
                return Ammo.destroy(v), Ammo.destroy(m), P;
              }
              destroyBody(y) {
                const p = y.getMotionState();
                p && Ammo.destroy(p), Ammo.destroy(y);
              }
              raycastFirst(y, p, _ = {}) {
                if (_.filterTags || _.filterCallback)
                  return (_.sort = !0), this.raycastAll(y, p, _)[0] || null;
                let m = null;
                s.setValue(y.x, y.y, y.z), l.setValue(p.x, p.y, p.z);
                const E = new Ammo.ClosestRayResultCallback(s, l);
                if (
                  (typeof _.filterCollisionGroup == "number" &&
                    E.set_m_collisionFilterGroup(_.filterCollisionGroup),
                  typeof _.filterCollisionMask == "number" &&
                    E.set_m_collisionFilterMask(_.filterCollisionMask),
                  this.dynamicsWorld.rayTest(s, l, E),
                  E.hasHit())
                ) {
                  const v = E.get_m_collisionObject(),
                    P = Ammo.castObject(v, Ammo.btRigidBody);
                  if (P) {
                    const I = E.get_m_hitPointWorld(),
                      A = E.get_m_hitNormalWorld();
                    m = new n(
                      P.entity,
                      new T.A(I.x(), I.y(), I.z()),
                      new T.A(A.x(), A.y(), A.z()),
                      E.get_m_closestHitFraction()
                    );
                  }
                }
                return Ammo.destroy(E), m;
              }
              raycastAll(y, p, _ = {}) {
                const m = [];
                s.setValue(y.x, y.y, y.z), l.setValue(p.x, p.y, p.z);
                const E = new Ammo.AllHitsRayResultCallback(s, l);
                if (
                  (typeof _.filterCollisionGroup == "number" &&
                    E.set_m_collisionFilterGroup(_.filterCollisionGroup),
                  typeof _.filterCollisionMask == "number" &&
                    E.set_m_collisionFilterMask(_.filterCollisionMask),
                  this.dynamicsWorld.rayTest(s, l, E),
                  E.hasHit())
                ) {
                  const v = E.get_m_collisionObjects(),
                    P = E.get_m_hitPointWorld(),
                    I = E.get_m_hitNormalWorld(),
                    A = E.get_m_hitFractions(),
                    B = v.size();
                  for (let C = 0; C < B; C++) {
                    const w = Ammo.castObject(v.at(C), Ammo.btRigidBody);
                    if (w && w.entity) {
                      if (
                        (_.filterTags && !w.entity.tags.has(..._.filterTags)) ||
                        (_.filterCallback && !_.filterCallback(w.entity))
                      )
                        continue;
                      const k = P.at(C),
                        K = I.at(C),
                        te = new n(
                          w.entity,
                          new T.A(k.x(), k.y(), k.z()),
                          new T.A(K.x(), K.y(), K.z()),
                          A.at(C)
                        );
                      m.push(te);
                    }
                  }
                  _.sort && m.sort((C, w) => C.hitFraction - w.hitFraction);
                }
                return Ammo.destroy(E), m;
              }
              _storeCollision(y, p) {
                let _ = !1;
                const m = y.getGuid();
                return (
                  (this.collisions[m] = this.collisions[m] || {
                    others: [],
                    entity: y,
                  }),
                  this.collisions[m].others.indexOf(p) < 0 &&
                    (this.collisions[m].others.push(p), (_ = !0)),
                  (this.frameCollisions[m] = this.frameCollisions[m] || {
                    others: [],
                    entity: y,
                  }),
                  this.frameCollisions[m].others.push(p),
                  _
                );
              }
              _createContactPointFromAmmo(y) {
                const p = y.get_m_localPointA(),
                  _ = y.get_m_localPointB(),
                  m = y.getPositionWorldOnA(),
                  E = y.getPositionWorldOnB(),
                  v = y.get_m_normalWorldOnB(),
                  P = this.contactPointPool.allocate();
                return (
                  P.localPoint.set(p.x(), p.y(), p.z()),
                  P.localPointOther.set(_.x(), _.y(), _.z()),
                  P.point.set(m.x(), m.y(), m.z()),
                  P.pointOther.set(E.x(), E.y(), E.z()),
                  P.normal.set(v.x(), v.y(), v.z()),
                  (P.impulse = y.getAppliedImpulse()),
                  P
                );
              }
              _createReverseContactPointFromAmmo(y) {
                const p = y.get_m_localPointA(),
                  _ = y.get_m_localPointB(),
                  m = y.getPositionWorldOnA(),
                  E = y.getPositionWorldOnB(),
                  v = y.get_m_normalWorldOnB(),
                  P = this.contactPointPool.allocate();
                return (
                  P.localPointOther.set(p.x(), p.y(), p.z()),
                  P.localPoint.set(_.x(), _.y(), _.z()),
                  P.pointOther.set(m.x(), m.y(), m.z()),
                  P.point.set(E.x(), E.y(), E.z()),
                  P.normal.set(v.x(), v.y(), v.z()),
                  (P.impulse = y.getAppliedImpulse()),
                  P
                );
              }
              _createSingleContactResult(y, p, _) {
                const m = this.singleContactResultPool.allocate();
                return (
                  (m.a = y),
                  (m.b = p),
                  (m.localPointA = _.localPoint),
                  (m.localPointB = _.localPointOther),
                  (m.pointA = _.point),
                  (m.pointB = _.pointOther),
                  (m.normal = _.normal),
                  (m.impulse = _.impulse),
                  m
                );
              }
              _createContactResult(y, p) {
                const _ = this.contactResultPool.allocate();
                return (_.other = y), (_.contacts = p), _;
              }
              _cleanOldCollisions() {
                for (const y in this.collisions)
                  if (this.collisions.hasOwnProperty(y)) {
                    const p = this.frameCollisions[y],
                      _ = this.collisions[y],
                      m = _.entity,
                      E = m.collision,
                      v = m.rigidbody,
                      P = _.others;
                    let A = P.length;
                    for (; A--; ) {
                      const B = P[A];
                      (!p || p.others.indexOf(B) < 0) &&
                        (P.splice(A, 1),
                        m.trigger
                          ? (E && E.fire("triggerleave", B),
                            B.rigidbody && B.rigidbody.fire("triggerleave", m))
                          : B.trigger ||
                            (v && v.fire("collisionend", B),
                            E && E.fire("collisionend", B)));
                    }
                    P.length === 0 && delete this.collisions[y];
                  }
              }
              _hasContactEvent(y) {
                const p = y.collision;
                if (
                  p &&
                  (p.hasEvent("collisionstart") ||
                    p.hasEvent("collisionend") ||
                    p.hasEvent("contact"))
                )
                  return !0;
                const _ = y.rigidbody;
                return (
                  _ &&
                  (_.hasEvent("collisionstart") ||
                    _.hasEvent("collisionend") ||
                    _.hasEvent("contact"))
                );
              }
              _checkForCollisions(y, p) {
                const m = Ammo.wrapPointer(
                    y,
                    Ammo.btDynamicsWorld
                  ).getDispatcher(),
                  E = m.getNumManifolds();
                this.frameCollisions = {};
                for (let v = 0; v < E; v++) {
                  const P = m.getManifoldByIndexInternal(v),
                    I = P.getBody0(),
                    A = P.getBody1(),
                    B = Ammo.castObject(I, Ammo.btRigidBody),
                    C = Ammo.castObject(A, Ammo.btRigidBody),
                    w = B.entity,
                    k = C.entity;
                  if (!w || !k) continue;
                  const K = B.getCollisionFlags(),
                    te = C.getCollisionFlags(),
                    X = P.getNumContacts(),
                    $ = [],
                    ne = [];
                  let Y;
                  if (X > 0)
                    if (K & d.ge || te & d.ge) {
                      const Z =
                          w.collision &&
                          (w.collision.hasEvent("triggerenter") ||
                            w.collision.hasEvent("triggerleave")),
                        ye =
                          k.collision &&
                          (k.collision.hasEvent("triggerenter") ||
                            k.collision.hasEvent("triggerleave")),
                        pe =
                          w.rigidbody &&
                          (w.rigidbody.hasEvent("triggerenter") ||
                            w.rigidbody.hasEvent("triggerleave")),
                        O =
                          k.rigidbody &&
                          (k.rigidbody.hasEvent("triggerenter") ||
                            k.rigidbody.hasEvent("triggerleave"));
                      Z &&
                        ((Y = this._storeCollision(w, k)),
                        Y &&
                          !(te & d.ge) &&
                          w.collision.fire("triggerenter", k)),
                        ye &&
                          ((Y = this._storeCollision(k, w)),
                          Y &&
                            !(K & d.ge) &&
                            k.collision.fire("triggerenter", w)),
                        pe &&
                          (Y || (Y = this._storeCollision(k, w)),
                          Y && w.rigidbody.fire("triggerenter", k)),
                        O &&
                          (Y || (Y = this._storeCollision(w, k)),
                          Y && k.rigidbody.fire("triggerenter", w));
                    } else {
                      const Z = this._hasContactEvent(w),
                        ye = this._hasContactEvent(k),
                        pe = this.hasEvent("contact");
                      if (pe || Z || ye) {
                        for (let O = 0; O < X; O++) {
                          const me = P.getContactPoint(O),
                            N = this._createContactPointFromAmmo(me);
                          if (Z || ye) {
                            $.push(N);
                            const V =
                              this._createReverseContactPointFromAmmo(me);
                            ne.push(V);
                          }
                          if (pe) {
                            const V = this._createSingleContactResult(w, k, N);
                            this.fire("contact", V);
                          }
                        }
                        if (Z) {
                          const O = this._createContactResult(k, $);
                          (Y = this._storeCollision(w, k)),
                            w.collision &&
                              (w.collision.fire("contact", O),
                              Y && w.collision.fire("collisionstart", O)),
                            w.rigidbody &&
                              (w.rigidbody.fire("contact", O),
                              Y && w.rigidbody.fire("collisionstart", O));
                        }
                        if (ye) {
                          const O = this._createContactResult(w, ne);
                          (Y = this._storeCollision(k, w)),
                            k.collision &&
                              (k.collision.fire("contact", O),
                              Y && k.collision.fire("collisionstart", O)),
                            k.rigidbody &&
                              (k.rigidbody.fire("contact", O),
                              Y && k.rigidbody.fire("collisionstart", O));
                        }
                      }
                    }
                }
                this._cleanOldCollisions(),
                  this.contactPointPool.freeAll(),
                  this.contactResultPool.freeAll(),
                  this.singleContactResultPool.freeAll();
              }
              onUpdate(y) {
                let p, _;
                (this._gravityFloat32[0] = this.gravity.x),
                  (this._gravityFloat32[1] = this.gravity.y),
                  (this._gravityFloat32[2] = this.gravity.z);
                const m = this.dynamicsWorld.getGravity();
                (m.x() !== this._gravityFloat32[0] ||
                  m.y() !== this._gravityFloat32[1] ||
                  m.z() !== this._gravityFloat32[2]) &&
                  (m.setValue(this.gravity.x, this.gravity.y, this.gravity.z),
                  this.dynamicsWorld.setGravity(m));
                const E = this._triggers;
                for (p = 0, _ = E.length; p < _; p++) E[p].updateTransform();
                const v = this._compounds;
                for (p = 0, _ = v.length; p < _; p++) v[p]._updateCompound();
                const P = this._kinematic;
                for (p = 0, _ = P.length; p < _; p++) P[p]._updateKinematic();
                this.dynamicsWorld.stepSimulation(
                  y,
                  this.maxSubSteps,
                  this.fixedTimeStep
                );
                const I = this._dynamic;
                for (p = 0, _ = I.length; p < _; p++) I[p]._updateDynamic();
                this.dynamicsWorld.setInternalTickCallback ||
                  this._checkForCollisions(
                    Ammo.getPointer(this.dynamicsWorld),
                    y
                  );
              }
              destroy() {
                super.destroy(),
                  this.app.systems.off("update", this.onUpdate, this),
                  typeof Ammo != "undefined" &&
                    (Ammo.destroy(this.dynamicsWorld),
                    Ammo.destroy(this.solver),
                    Ammo.destroy(this.overlappingPairCache),
                    Ammo.destroy(this.dispatcher),
                    Ammo.destroy(this.collisionConfiguration),
                    (this.dynamicsWorld = null),
                    (this.solver = null),
                    (this.overlappingPairCache = null),
                    (this.dispatcher = null),
                    (this.collisionConfiguration = null));
              }
            }
            g.w._buildAccessors(h.D.prototype, t);
          },
          3518: (Se, W, a) => {
            "use strict";
            a.d(W, { k: () => f });
            var x = a(9758),
              T = a(2978),
              g = a(258),
              c = a(7680),
              d = a(8620);
            const h = new x.y();
            class f extends d.w {
              constructor(l, n) {
                super(l, n),
                  (this._resolution = new T.S(640, 320)),
                  (this._referenceResolution = new T.S(640, 320)),
                  (this._scaleMode = c.f),
                  (this.scale = 1),
                  (this._scaleBlend = 0.5),
                  (this._priority = 0),
                  (this._screenSpace = !1),
                  (this.cull = this._screenSpace),
                  (this._screenMatrix = new x.y()),
                  (this._elements = new Set()),
                  l.app.graphicsDevice.on("resizecanvas", this._onResize, this);
              }
              syncDrawOrder() {
                this.system.queueDrawOrderSync(
                  this.entity.getGuid(),
                  this._processDrawOrderSync,
                  this
                );
              }
              _recurseDrawOrderSync(l, n) {
                if (!(l instanceof g.J)) return n;
                if (l.element) {
                  const e = l.element.drawOrder;
                  if (
                    ((l.element.drawOrder = n++),
                    l.element._batchGroupId >= 0 && e !== l.element.drawOrder)
                  ) {
                    var o;
                    (o = this.system.app.batcher) == null ||
                      o.markGroupDirty(l.element._batchGroupId);
                  }
                }
                l.particlesystem && (l.particlesystem.drawOrder = n++);
                const i = l.children;
                for (let e = 0; e < i.length; e++)
                  n = this._recurseDrawOrderSync(i[e], n);
                return n;
              }
              _processDrawOrderSync() {
                this._recurseDrawOrderSync(this.entity, 1),
                  this.fire("syncdraworder");
              }
              _calcProjectionMatrix() {
                const l = this._resolution.x / this.scale,
                  n = this._resolution.y / this.scale,
                  o = 0,
                  i = l,
                  e = -n,
                  t = 0,
                  r = 1,
                  u = -1;
                this._screenMatrix.setOrtho(o, i, e, t, r, u),
                  this._screenSpace ||
                    (h.setScale(0.5 * l, 0.5 * n, 1),
                    this._screenMatrix.mul2(h, this._screenMatrix));
              }
              _updateScale() {
                this.scale = this._calcScale(
                  this._resolution,
                  this.referenceResolution
                );
              }
              _calcScale(l, n) {
                const o = Math.log2(l.x / n.x),
                  i = Math.log2(l.y / n.y);
                return Math.pow(
                  2,
                  o * (1 - this._scaleBlend) + i * this._scaleBlend
                );
              }
              _onResize(l, n) {
                this._screenSpace &&
                  (this._resolution.set(l, n),
                  (this.resolution = this._resolution));
              }
              _bindElement(l) {
                this._elements.add(l);
              }
              _unbindElement(l) {
                this._elements.delete(l);
              }
              onRemove() {
                this.system.app.graphicsDevice.off(
                  "resizecanvas",
                  this._onResize,
                  this
                ),
                  this.fire("remove"),
                  this._elements.forEach((l) => l._onScreenRemove()),
                  this._elements.clear(),
                  this.off();
              }
              set resolution(l) {
                this._screenSpace
                  ? this._resolution.set(
                      this.system.app.graphicsDevice.width,
                      this.system.app.graphicsDevice.height
                    )
                  : this._resolution.set(l.x, l.y),
                  this._updateScale(),
                  this._calcProjectionMatrix(),
                  this.entity._dirtyLocal || this.entity._dirtifyLocal(),
                  this.fire("set:resolution", this._resolution),
                  this._elements.forEach((n) =>
                    n._onScreenResize(this._resolution)
                  );
              }
              get resolution() {
                return this._resolution;
              }
              set referenceResolution(l) {
                this._referenceResolution.set(l.x, l.y),
                  this._updateScale(),
                  this._calcProjectionMatrix(),
                  this.entity._dirtyLocal || this.entity._dirtifyLocal(),
                  this.fire("set:referenceresolution", this._resolution),
                  this._elements.forEach((n) =>
                    n._onScreenResize(this._resolution)
                  );
              }
              get referenceResolution() {
                return this._scaleMode === c.f
                  ? this._resolution
                  : this._referenceResolution;
              }
              set screenSpace(l) {
                (this._screenSpace = l),
                  this._screenSpace &&
                    this._resolution.set(
                      this.system.app.graphicsDevice.width,
                      this.system.app.graphicsDevice.height
                    ),
                  (this.resolution = this._resolution),
                  this.entity._dirtyLocal || this.entity._dirtifyLocal(),
                  this.fire("set:screenspace", this._screenSpace),
                  this._elements.forEach((n) => n._onScreenSpaceChange());
              }
              get screenSpace() {
                return this._screenSpace;
              }
              set scaleMode(l) {
                l !== c.f && l !== c.A && (l = c.f),
                  !this._screenSpace && l !== c.f && (l = c.f),
                  (this._scaleMode = l),
                  (this.resolution = this._resolution),
                  this.fire("set:scalemode", this._scaleMode);
              }
              get scaleMode() {
                return this._scaleMode;
              }
              set scaleBlend(l) {
                (this._scaleBlend = l),
                  this._updateScale(),
                  this._calcProjectionMatrix(),
                  this.entity._dirtyLocal || this.entity._dirtifyLocal(),
                  this.fire("set:scaleblend", this._scaleBlend),
                  this._elements.forEach((n) =>
                    n._onScreenResize(this._resolution)
                  );
              }
              get scaleBlend() {
                return this._scaleBlend;
              }
              set priority(l) {
                l > 255 && (l = 255),
                  this._priority !== l &&
                    ((this._priority = l), this.syncDrawOrder());
              }
              get priority() {
                return this._priority;
              }
            }
          },
          7680: (Se, W, a) => {
            "use strict";
            a.d(W, { A: () => T, f: () => x });
            const x = "none",
              T = "blend";
          },
          3659: (Se, W, a) => {
            "use strict";
            a.d(W, { P: () => s });
            var x = a(743),
              T = a(2978),
              g = a(8620),
              c = a(6813),
              d = a(3518);
            class h {
              constructor() {
                this.enabled = !0;
              }
            }
            const f = ["enabled"];
            class s extends c.Q {
              constructor(n) {
                super(n),
                  (this.id = "screen"),
                  (this.ComponentType = d.k),
                  (this.DataType = h),
                  (this.schema = f),
                  (this.windowResolution = new T.S()),
                  (this._drawOrderSyncQueue = new x._()),
                  this.app.graphicsDevice.on(
                    "resizecanvas",
                    this._onResize,
                    this
                  ),
                  this.app.systems.on("update", this._onUpdate, this),
                  this.on("beforeremove", this.onRemoveComponent, this);
              }
              initializeComponentData(n, o, i) {
                o.priority !== void 0 && (n.priority = o.priority),
                  o.screenSpace !== void 0 && (n.screenSpace = o.screenSpace),
                  (n.cull = n.screenSpace),
                  o.scaleMode !== void 0 && (n.scaleMode = o.scaleMode),
                  o.scaleBlend !== void 0 && (n.scaleBlend = o.scaleBlend),
                  o.resolution !== void 0 &&
                    (o.resolution instanceof T.S
                      ? n._resolution.copy(o.resolution)
                      : n._resolution.set(o.resolution[0], o.resolution[1]),
                    (n.resolution = n._resolution)),
                  o.referenceResolution !== void 0 &&
                    (o.referenceResolution instanceof T.S
                      ? n._referenceResolution.copy(o.referenceResolution)
                      : n._referenceResolution.set(
                          o.referenceResolution[0],
                          o.referenceResolution[1]
                        ),
                    (n.referenceResolution = n._referenceResolution)),
                  n.syncDrawOrder(),
                  super.initializeComponentData(n, o, i);
              }
              destroy() {
                super.destroy(),
                  this.app.graphicsDevice.off(
                    "resizecanvas",
                    this._onResize,
                    this
                  ),
                  this.app.systems.off("update", this._onUpdate, this);
              }
              _onUpdate(n) {
                const o = this.store;
                for (const i in o)
                  o[i].entity.screen.update && o[i].entity.screen.update(n);
              }
              _onResize(n, o) {
                (this.windowResolution.x = n), (this.windowResolution.y = o);
              }
              cloneComponent(n, o) {
                const i = n.screen;
                return this.addComponent(o, {
                  enabled: i.enabled,
                  screenSpace: i.screenSpace,
                  scaleMode: i.scaleMode,
                  resolution: i.resolution.clone(),
                  referenceResolution: i.referenceResolution.clone(),
                });
              }
              onRemoveComponent(n, o) {
                o.onRemove();
              }
              processDrawOrderSyncQueue() {
                const n = this._drawOrderSyncQueue.list();
                for (let o = 0; o < n.length; o++) {
                  const i = n[o];
                  i.callback.call(i.scope);
                }
                this._drawOrderSyncQueue.clear();
              }
              queueDrawOrderSync(n, o, i) {
                this._drawOrderSyncQueue.list().length ||
                  this.app.once(
                    "prerender",
                    this.processDrawOrderSyncQueue,
                    this
                  ),
                  this._drawOrderSyncQueue.has(n) ||
                    this._drawOrderSyncQueue.push(n, { callback: o, scope: i });
              }
            }
            g.w._buildAccessors(d.k.prototype, f);
          },
          6527: (Se, W, a) => {
            "use strict";
            a.d(W, { w: () => g });
            var x = a(9296),
              T = a(8620);
            class g extends T.w {
              constructor(d, h) {
                super(d, h), this.on("set_scripts", this.onSetScripts, this);
              }
              send(d, h) {
                const f = Array.prototype.slice.call(arguments, 2),
                  s = this.entity.script.instances;
                let l;
                if (s && s[d] && ((l = s[d].instance[h]), l))
                  return l.apply(s[d].instance, f);
              }
              onEnable() {
                this.data.areScriptsLoaded &&
                  !this.system.preloading &&
                  (this.data.initialized
                    ? this.system._enableScriptComponent(this)
                    : this.system._initializeScriptComponent(this),
                  this.data.postInitialized ||
                    this.system._postInitializeScriptComponent(this));
              }
              onDisable() {
                this.system._disableScriptComponent(this);
              }
              onSetScripts(d, h, f) {
                if (!this.system._inTools || this.runInTools) {
                  if (this._updateScriptAttributes(h, f)) return;
                  this.enabled && this.system._disableScriptComponent(this),
                    this.system._destroyScriptComponent(this),
                    (this.data.areScriptsLoaded = !1);
                  const l = f.map(function (n) {
                    return n.url;
                  });
                  if (this._loadFromCache(l)) return;
                  this._loadScripts(l);
                }
              }
              _updateScriptAttributes(d, h) {
                let f = !0;
                if (d.length !== h.length) f = !1;
                else
                  for (let s = 0, l = h.length; s < l; s++)
                    if (d[s].url !== h[s].url) {
                      f = !1;
                      break;
                    }
                if (f)
                  for (const s in this.instances)
                    this.instances.hasOwnProperty(s) &&
                      this.system._updateAccessors(
                        this.entity,
                        this.instances[s]
                      );
                return f;
              }
              _loadFromCache(d) {
                const h = [],
                  f = this.system.app._scriptPrefix || "",
                  s = /^http(s)?:\/\//i;
                for (let l = 0, n = d.length; l < n; l++) {
                  let o = d[l];
                  s.test(o) || (o = x.E.join(f, o));
                  const i = this.system.app.loader.getFromCache(o, "script");
                  if (!i) return !1;
                  h.push(i);
                }
                for (let l = 0, n = h.length; l < n; l++) {
                  const o = h[l];
                  if (
                    o !== !0 &&
                    o &&
                    this.entity.script &&
                    !this.entity.script.instances[o._pcScriptName]
                  ) {
                    const i = new o(this.entity);
                    this.system._preRegisterInstance(
                      this.entity,
                      d[l],
                      o._pcScriptName,
                      i
                    );
                  }
                }
                return (
                  this.data && (this.data.areScriptsLoaded = !0),
                  this.system.preloading ||
                    (this.system.onInitialize(this.entity),
                    this.system.onPostInitialize(this.entity)),
                  !0
                );
              }
              _loadScripts(d) {
                let h = d.length;
                const f = this.system.app._scriptPrefix || "";
                d.forEach((s) => {
                  let l = null,
                    n = null;
                  s.toLowerCase().startsWith("http://") ||
                  s.toLowerCase().startsWith("https://")
                    ? ((n = s), (l = s))
                    : ((n = s), (l = x.E.join(f, s))),
                    this.system.app.loader.load(l, "script", (o, i) => {
                      if ((h--, o)) console.error(o);
                      else if (
                        i &&
                        this.entity.script &&
                        !this.entity.script.instances[i._pcScriptName]
                      ) {
                        const e = new i(this.entity);
                        this.system._preRegisterInstance(
                          this.entity,
                          n,
                          i._pcScriptName,
                          e
                        );
                      }
                      h === 0 &&
                        ((this.data.areScriptsLoaded = !0),
                        this.system.preloading ||
                          (this.system.onInitialize(this.entity),
                          this.system.onPostInitialize(this.entity)));
                    });
                });
              }
            }
          },
          8345: (Se, W, a) => {
            "use strict";
            a.d(W, { I: () => P });
            var x = a(9795),
              T = a(5843),
              g = a(1367),
              c = a(429),
              d = a(1239),
              h = a(2978),
              f = a(6556),
              s = a(6630),
              l = a(258),
              n = a(8620),
              o = a(6813),
              i = a(6527);
            class e {
              constructor() {
                (this.scripts = []),
                  (this.enabled = !0),
                  (this.instances = {}),
                  (this._instances = {}),
                  (this.runInTools = !1),
                  (this.attributes = {}),
                  (this.initialized = !1),
                  (this.postInitialized = !1),
                  (this.areScriptsLoaded = !1);
              }
            }
            const t = ["enabled", "scripts", "instances", "runInTools"],
              r = "initialize",
              u = "postInitialize",
              y = "update",
              p = "postUpdate",
              _ = "fixedUpdate",
              m = "toolsUpdate",
              E = "onEnable",
              v = "onDisable";
            class P extends o.Q {
              constructor(A) {
                super(A),
                  (this.id = "script"),
                  (this.ComponentType = i.w),
                  (this.DataType = e),
                  (this.schema = t),
                  (this.preloading = !1),
                  (this.instancesWithUpdate = []),
                  (this.instancesWithFixedUpdate = []),
                  (this.instancesWithPostUpdate = []),
                  (this.instancesWithToolsUpdate = []),
                  this.on("beforeremove", this.onBeforeRemove, this),
                  this.app.systems.on(r, this.onInitialize, this),
                  this.app.systems.on(u, this.onPostInitialize, this),
                  this.app.systems.on(y, this.onUpdate, this),
                  this.app.systems.on(_, this.onFixedUpdate, this),
                  this.app.systems.on(p, this.onPostUpdate, this),
                  this.app.systems.on(m, this.onToolsUpdate, this);
              }
              initializeComponentData(A, B, C) {
                (C = ["runInTools", "enabled", "scripts"]),
                  B.scripts &&
                    B.scripts.length &&
                    B.scripts.forEach(function (w) {
                      if (w.attributes && Array.isArray(w.attributes)) {
                        const k = {};
                        for (let K = 0; K < w.attributes.length; K++)
                          k[w.attributes[K].name] = w.attributes[K];
                        w.attributes = k;
                      }
                    }),
                  super.initializeComponentData(A, B, C);
              }
              cloneComponent(A, B) {
                const C = this.store[A.getGuid()],
                  w = {
                    runInTools: C.data.runInTools,
                    scripts: [],
                    enabled: C.data.enabled,
                  },
                  k = C.data.scripts;
                for (let K = 0, te = k.length; K < te; K++) {
                  const X = k[K].attributes;
                  X && delete k[K].attributes,
                    w.scripts.push((0, x.l7)({}, k[K])),
                    X &&
                      ((w.scripts[K].attributes = this._cloneAttributes(X)),
                      (k[K].attributes = X));
                }
                return this.addComponent(B, w);
              }
              onBeforeRemove(A, B) {
                B.enabled && this._disableScriptComponent(B),
                  this._destroyScriptComponent(B);
              }
              onInitialize(A) {
                if ((this._registerInstances(A), A.enabled)) {
                  A.script &&
                    A.script.enabled &&
                    this._initializeScriptComponent(A.script);
                  const B = A._children;
                  for (let C = 0, w = B.length; C < w; C++)
                    B[C] instanceof l.J && this.onInitialize(B[C]);
                }
              }
              onPostInitialize(A) {
                if (A.enabled) {
                  A.script &&
                    A.script.enabled &&
                    this._postInitializeScriptComponent(A.script);
                  const B = A._children;
                  for (let C = 0, w = B.length; C < w; C++)
                    B[C] instanceof l.J && this.onPostInitialize(B[C]);
                }
              }
              _callInstancesMethod(A, B) {
                const C = A.data.instances;
                for (const w in C)
                  if (C.hasOwnProperty(w)) {
                    const k = C[w].instance;
                    k[B] && k[B]();
                  }
              }
              _initializeScriptComponent(A) {
                this._callInstancesMethod(A, r),
                  (A.data.initialized = !0),
                  A.enabled &&
                    A.entity.enabled &&
                    this._enableScriptComponent(A);
              }
              _enableScriptComponent(A) {
                this._callInstancesMethod(A, E);
              }
              _disableScriptComponent(A) {
                this._callInstancesMethod(A, v);
              }
              _destroyScriptComponent(A) {
                const B = A.data.instances;
                for (const C in B)
                  if (B.hasOwnProperty(C)) {
                    const w = B[C].instance;
                    if ((w.destroy && w.destroy(), w.update)) {
                      const k = this.instancesWithUpdate.indexOf(w);
                      k >= 0 && this.instancesWithUpdate.splice(k, 1);
                    }
                    if (w.fixedUpdate) {
                      const k = this.instancesWithFixedUpdate.indexOf(w);
                      k >= 0 && this.instancesWithFixedUpdate.splice(k, 1);
                    }
                    if (w.postUpdate) {
                      const k = this.instancesWithPostUpdate.indexOf(w);
                      k >= 0 && this.instancesWithPostUpdate.splice(k, 1);
                    }
                    if (w.toolsUpdate) {
                      const k = this.instancesWithToolsUpdate.indexOf(w);
                      k >= 0 && this.instancesWithToolsUpdate.splice(k, 1);
                    }
                    A.instances[C].instance === A[C] && delete A[C],
                      delete A.instances[C];
                  }
              }
              _postInitializeScriptComponent(A) {
                this._callInstancesMethod(A, u), (A.data.postInitialized = !0);
              }
              _updateInstances(A, B, C) {
                for (let w = 0, k = B.length; w < k; w++) {
                  const K = B[w];
                  K &&
                    K.entity &&
                    K.entity.enabled &&
                    K.entity.script.enabled &&
                    K[A](C);
                }
              }
              onUpdate(A) {
                this._updateInstances(y, this.instancesWithUpdate, A);
              }
              onFixedUpdate(A) {
                this._updateInstances(_, this.instancesWithFixedUpdate, A);
              }
              onPostUpdate(A) {
                this._updateInstances(p, this.instancesWithPostUpdate, A);
              }
              onToolsUpdate(A) {
                this._updateInstances(m, this.instancesWithToolsUpdate, A);
              }
              broadcast(A, B) {
                const C = Array.prototype.slice.call(arguments, 2),
                  w = this.store;
                for (const k in w)
                  if (w.hasOwnProperty(k)) {
                    const K = w[k].data;
                    if (K.instances[A]) {
                      const te = K.instances[A].instance[B];
                      te && te.apply(K.instances[A].instance, C);
                    }
                  }
              }
              _preRegisterInstance(A, B, C, w) {
                if (A.script) {
                  if (
                    ((A.script.data._instances =
                      A.script.data._instances || {}),
                    A.script.data._instances[C])
                  )
                    throw Error(
                      `Script name collision '${C}'. Scripts from '${B}' and '${
                        A.script.data._instances[C].url
                      }' {${A.getGuid()}}`
                    );
                  A.script.data._instances[C] = {
                    url: B,
                    name: C,
                    instance: w,
                  };
                }
              }
              _registerInstances(A) {
                if (A.script && A.script.data._instances) {
                  A.script.instances = A.script.data._instances;
                  for (const C in A.script.instances) {
                    const w = A.script.instances[C],
                      k = w.instance;
                    if (
                      (T.U.attach(k),
                      k.update && this.instancesWithUpdate.push(k),
                      k.fixedUpdate && this.instancesWithFixedUpdate.push(k),
                      k.postUpdate && this.instancesWithPostUpdate.push(k),
                      k.toolsUpdate && this.instancesWithToolsUpdate.push(k),
                      A.script.scripts && this._createAccessors(A, w),
                      A.script[C])
                    )
                      throw Error(
                        `Script with name '${C}' is already attached to Script Component`
                      );
                    A.script[C] = k;
                  }
                  delete A.script.data._instances;
                }
                const B = A._children;
                for (let C = 0, w = B.length; C < w; C++)
                  B[C] instanceof l.J && this._registerInstances(B[C]);
              }
              _cloneAttributes(A) {
                const B = {};
                for (const C in A)
                  if (A.hasOwnProperty(C))
                    if (A[C].type !== "entity") B[C] = (0, x.l7)({}, A[C]);
                    else {
                      const w = A[C].value;
                      delete A[C].value,
                        (B[C] = (0, x.l7)({}, A[C])),
                        (B[C].value = w),
                        (A[C].value = w);
                    }
                return B;
              }
              _createAccessors(A, B) {
                const C = A.script.scripts.length,
                  w = B.url;
                for (let k = 0; k < C; k++) {
                  const K = A.script.scripts[k];
                  if (K.url === w) {
                    const te = K.attributes;
                    if (K.name && te) {
                      for (const X in te)
                        te.hasOwnProperty(X) && this._createAccessor(te[X], B);
                      A.script.data.attributes[K.name] =
                        this._cloneAttributes(te);
                    }
                    break;
                  }
                }
              }
              _createAccessor(A, B) {
                const C = this;
                (A = { name: A.name, value: A.value, type: A.type }),
                  this._convertAttributeValue(A),
                  Object.defineProperty(B.instance, A.name, {
                    get: function () {
                      return A.value;
                    },
                    set: function (w) {
                      const k = A.value;
                      (A.value = w),
                        C._convertAttributeValue(A),
                        B.instance.fire("set", A.name, k, A.value);
                    },
                    configurable: !0,
                  });
              }
              _updateAccessors(A, B) {
                const C = A.script.scripts.length,
                  w = B.url;
                for (let k = 0; k < C; k++) {
                  const K = A.script,
                    te = K.scripts[k];
                  if (te.url === w) {
                    const X = te.name,
                      $ = te.attributes;
                    if (X) {
                      if ($)
                        for (const Y in $)
                          $.hasOwnProperty(Y) && this._createAccessor($[Y], B);
                      const ne = K.data.attributes[X];
                      if (ne)
                        for (const Y in ne) {
                          const Z = ne[Y];
                          Y in $
                            ? $[Y].value !== Z.value &&
                              B.instance.onAttributeChanged &&
                              B.instance.onAttributeChanged(
                                Z.name,
                                Z.value,
                                $[Y].value
                              )
                            : delete B.instance[Z.name];
                        }
                      $
                        ? (K.data.attributes[X] = this._cloneAttributes($))
                        : delete K.data.attributes[X];
                    }
                    break;
                  }
                }
              }
              _convertAttributeValue(A) {
                if (A.type === "rgb" || A.type === "rgba")
                  Array.isArray(A.value) &&
                    (A.value =
                      A.value.length === 3
                        ? new g.I(A.value[0], A.value[1], A.value[2])
                        : new g.I(
                            A.value[0],
                            A.value[1],
                            A.value[2],
                            A.value[3]
                          ));
                else if (A.type === "vec2")
                  Array.isArray(A.value) &&
                    (A.value = new h.S(A.value[0], A.value[1]));
                else if (A.type === "vec3" || A.type === "vector")
                  Array.isArray(A.value) &&
                    (A.value = new f.A(A.value[0], A.value[1], A.value[2]));
                else if (A.type === "vec4")
                  Array.isArray(A.value) &&
                    (A.value = new s.T(
                      A.value[0],
                      A.value[1],
                      A.value[2],
                      A.value[3]
                    ));
                else if (A.type === "entity")
                  A.value !== null &&
                    typeof A.value == "string" &&
                    (A.value = this.app.root.findByGuid(A.value));
                else if (A.type === "curve" || A.type === "colorcurve") {
                  const B = A.value.keys[0] instanceof Array ? d.e : c.H;
                  (A.value = new B(A.value.keys)),
                    (A.value.type = A.value.type);
                }
              }
              destroy() {
                super.destroy(),
                  this.app.systems.off(r, this.onInitialize, this),
                  this.app.systems.off(u, this.onPostInitialize, this),
                  this.app.systems.off(y, this.onUpdate, this),
                  this.app.systems.off(_, this.onFixedUpdate, this),
                  this.app.systems.off(p, this.onPostUpdate, this),
                  this.app.systems.off(m, this.onToolsUpdate, this);
              }
            }
            n.w._buildAccessors(i.w.prototype, t);
          },
          24: (Se, W, a) => {
            "use strict";
            a.d(W, { Z: () => h });
            var x = a(9595),
              T = a(36),
              g = a(1118),
              c = a(8620),
              d = a(258);
            class h extends c.w {
              constructor(s, l) {
                super(s, l),
                  (this._scripts = []),
                  (this._updateList = new x._({ sortBy: "__executionOrder" })),
                  (this._postUpdateList = new x._({
                    sortBy: "__executionOrder",
                  })),
                  (this._scriptsIndex = {}),
                  (this._destroyedScripts = []),
                  (this._destroyed = !1),
                  (this._scriptsData = null),
                  (this._oldState = !0),
                  (this._enabled = !0),
                  (this._beingEnabled = !1),
                  (this._isLoopingThroughScripts = !1),
                  (this._executionOrder = -1),
                  this.on("set_enabled", this._onSetEnabled, this);
              }
              set scripts(s) {
                this._scriptsData = s;
                for (const l in s) {
                  if (!s.hasOwnProperty(l)) continue;
                  const n = this._scriptsIndex[l];
                  if (n) {
                    if (
                      (typeof s[l].enabled == "boolean" &&
                        (n.enabled = !!s[l].enabled),
                      typeof s[l].attributes == "object")
                    ) {
                      for (const o in s[l].attributes)
                        if (!T.s.reservedNames.has(o)) {
                          if (!n.__attributes.hasOwnProperty(o)) {
                            const i = this.system.app.scripts.get(l);
                            i && i.attributes.add(o, {});
                          }
                          n[o] = s[l].attributes[o];
                        }
                    }
                  } else console.log(this.order);
                }
              }
              get scripts() {
                return this._scripts;
              }
              set enabled(s) {
                const l = this._enabled;
                (this._enabled = s), this.fire("set", "enabled", l, s);
              }
              get enabled() {
                return this._enabled;
              }
              onEnable() {
                (this._beingEnabled = !0),
                  this._checkState(),
                  this.entity._beingEnabled || this.onPostStateChange(),
                  (this._beingEnabled = !1);
              }
              onDisable() {
                this._checkState();
              }
              onPostStateChange() {
                const s = this._beginLooping();
                for (let l = 0, n = this.scripts.length; l < n; l++) {
                  const o = this.scripts[l];
                  o._initialized &&
                    !o._postInitialized &&
                    o.enabled &&
                    ((o._postInitialized = !0),
                    o.postInitialize && this._scriptMethod(o, g.wJ));
                }
                this._endLooping(s);
              }
              _beginLooping() {
                const s = this._isLoopingThroughScripts;
                return (this._isLoopingThroughScripts = !0), s;
              }
              _endLooping(s) {
                (this._isLoopingThroughScripts = s),
                  this._isLoopingThroughScripts ||
                    this._removeDestroyedScripts();
              }
              _onSetEnabled(s, l, n) {
                (this._beingEnabled = !0),
                  this._checkState(),
                  (this._beingEnabled = !1);
              }
              _checkState() {
                const s = this.enabled && this.entity.enabled;
                if (s === this._oldState) return;
                (this._oldState = s),
                  this.fire(s ? "enable" : "disable"),
                  this.fire("state", s),
                  s
                    ? this.system._addComponentToEnabled(this)
                    : this.system._removeComponentFromEnabled(this);
                const l = this._beginLooping();
                for (let n = 0, o = this.scripts.length; n < o; n++) {
                  const i = this.scripts[n];
                  i.enabled = i._enabled;
                }
                this._endLooping(l);
              }
              _onBeforeRemove() {
                this.fire("remove");
                const s = this._beginLooping();
                for (let l = 0; l < this.scripts.length; l++) {
                  const n = this.scripts[l];
                  n && this.destroy(n.__scriptType.__name);
                }
                this._endLooping(s);
              }
              _removeDestroyedScripts() {
                const s = this._destroyedScripts.length;
                if (s) {
                  for (let l = 0; l < s; l++) {
                    const n = this._destroyedScripts[l];
                    this._removeScriptInstance(n);
                  }
                  (this._destroyedScripts.length = 0),
                    this._resetExecutionOrder(0, this._scripts.length);
                }
              }
              _onInitializeAttributes() {
                for (let s = 0, l = this.scripts.length; s < l; s++)
                  this.scripts[s].__initializeAttributes();
              }
              _scriptMethod(s, l, n) {
                s[l](n);
              }
              _onInitialize() {
                const s = this._scripts,
                  l = this._beginLooping();
                for (let n = 0, o = s.length; n < o; n++) {
                  const i = s[n];
                  !i._initialized &&
                    i.enabled &&
                    ((i._initialized = !0),
                    i.initialize && this._scriptMethod(i, g.Bg));
                }
                this._endLooping(l);
              }
              _onPostInitialize() {
                this.onPostStateChange();
              }
              _onUpdate(s) {
                const l = this._updateList;
                if (!l.length) return;
                const n = this._beginLooping();
                for (l.loopIndex = 0; l.loopIndex < l.length; l.loopIndex++) {
                  const o = l.items[l.loopIndex];
                  o.enabled && this._scriptMethod(o, g.k2, s);
                }
                this._endLooping(n);
              }
              _onPostUpdate(s) {
                const l = this._postUpdateList;
                if (!l.length) return;
                const n = this._beginLooping();
                for (l.loopIndex = 0; l.loopIndex < l.length; l.loopIndex++) {
                  const o = l.items[l.loopIndex];
                  o.enabled && this._scriptMethod(o, g.Ms, s);
                }
                this._endLooping(n);
              }
              _insertScriptInstance(s, l, n) {
                l === -1
                  ? (this._scripts.push(s),
                    (s.__executionOrder = n),
                    s.update && this._updateList.append(s),
                    s.postUpdate && this._postUpdateList.append(s))
                  : (this._scripts.splice(l, 0, s),
                    (s.__executionOrder = l),
                    this._resetExecutionOrder(l + 1, n + 1),
                    s.update && this._updateList.insert(s),
                    s.postUpdate && this._postUpdateList.insert(s));
              }
              _removeScriptInstance(s) {
                const l = this._scripts.indexOf(s);
                return (
                  l === -1 ||
                    (this._scripts.splice(l, 1),
                    s.update && this._updateList.remove(s),
                    s.postUpdate && this._postUpdateList.remove(s)),
                  l
                );
              }
              _resetExecutionOrder(s, l) {
                for (let n = s; n < l; n++)
                  this._scripts[n].__executionOrder = n;
              }
              _resolveEntityScriptAttribute(s, l, n, o, i, e) {
                if (s.array) {
                  const t = n.length;
                  if (!t) return;
                  const r = n.slice();
                  for (let u = 0; u < t; u++) {
                    const y = r[u] instanceof d.J ? r[u].getGuid() : r[u];
                    e[y] && (r[u] = o ? e[y].getGuid() : e[y]);
                  }
                  i[l] = r;
                } else {
                  if (n instanceof d.J) n = n.getGuid();
                  else if (typeof n != "string") return;
                  e[n] && (i[l] = e[n]);
                }
              }
              has(s) {
                if (typeof s == "string") return !!this._scriptsIndex[s];
                if (!s) return !1;
                const l = s,
                  n = l.__name,
                  o = this._scriptsIndex[n];
                return (o && o.instance) instanceof l;
              }
              get(s) {
                if (typeof s == "string") {
                  const e = this._scriptsIndex[s];
                  return e ? e.instance : null;
                }
                if (!s) return null;
                const l = s,
                  n = l.__name,
                  o = this._scriptsIndex[n],
                  i = o && o.instance;
                return i instanceof l ? i : null;
              }
              create(s, l = {}) {
                const n = this;
                let o = s,
                  i = s;
                if (
                  (typeof o == "string"
                    ? (o = this.system.app.scripts.get(o))
                    : o && (i = o.__name),
                  o)
                ) {
                  if (
                    !this._scriptsIndex[i] ||
                    !this._scriptsIndex[i].instance
                  ) {
                    const e = new o({
                        app: this.system.app,
                        entity: this.entity,
                        enabled: l.hasOwnProperty("enabled") ? l.enabled : !0,
                        attributes: l.attributes,
                      }),
                      t = this._scripts.length;
                    let r = -1;
                    return (
                      typeof l.ind == "number" &&
                        l.ind !== -1 &&
                        t > l.ind &&
                        (r = l.ind),
                      this._insertScriptInstance(e, r, t),
                      (this._scriptsIndex[i] = {
                        instance: e,
                        onSwap: function () {
                          n.swap(i);
                        },
                      }),
                      (this[i] = e),
                      l.preloading || e.__initializeAttributes(),
                      this.fire("create", i, e),
                      this.fire("create:" + i, e),
                      this.system.app.scripts.on(
                        "swap:" + i,
                        this._scriptsIndex[i].onSwap
                      ),
                      l.preloading ||
                        (e.enabled &&
                          !e._initialized &&
                          ((e._initialized = !0),
                          e.initialize && this._scriptMethod(e, g.Bg)),
                        e.enabled &&
                          !e._postInitialized &&
                          ((e._postInitialized = !0),
                          e.postInitialize && this._scriptMethod(e, g.wJ))),
                      e
                    );
                  }
                } else
                  this._scriptsIndex[i] = {
                    awaiting: !0,
                    ind: this._scripts.length,
                  };
                return null;
              }
              destroy(s) {
                let l = s,
                  n = s;
                typeof n == "string"
                  ? (n = this.system.app.scripts.get(n))
                  : n && (l = n.__name);
                const o = this._scriptsIndex[l];
                if ((delete this._scriptsIndex[l], !o)) return !1;
                const i = o.instance;
                if (i && !i._destroyed)
                  if (
                    ((i.enabled = !1),
                    (i._destroyed = !0),
                    this._isLoopingThroughScripts)
                  )
                    this._destroyedScripts.push(i);
                  else {
                    const e = this._removeScriptInstance(i);
                    e >= 0 &&
                      this._resetExecutionOrder(e, this._scripts.length);
                  }
                return (
                  this.system.app.scripts.off("swap:" + l, o.onSwap),
                  delete this[l],
                  this.fire("destroy", l, i || null),
                  this.fire("destroy:" + l, i || null),
                  i && i.fire("destroy"),
                  !0
                );
              }
              swap(s) {
                let l = s,
                  n = s;
                typeof n == "string"
                  ? (n = this.system.app.scripts.get(n))
                  : n && (l = n.__name);
                const o = this._scriptsIndex[l];
                if (!o || !o.instance) return !1;
                const i = o.instance,
                  e = this._scripts.indexOf(i),
                  t = new n({
                    app: this.system.app,
                    entity: this.entity,
                    enabled: i.enabled,
                    attributes: i.__attributes,
                  });
                return t.swap
                  ? (t.__initializeAttributes(),
                    (this._scripts[e] = t),
                    (this._scriptsIndex[l].instance = t),
                    (this[l] = t),
                    (t.__executionOrder = e),
                    i.update && this._updateList.remove(i),
                    i.postUpdate && this._postUpdateList.remove(i),
                    t.update && this._updateList.insert(t),
                    t.postUpdate && this._postUpdateList.insert(t),
                    this._scriptMethod(t, g.qM, i),
                    this.fire("swap", l, t),
                    this.fire("swap:" + l, t),
                    !0)
                  : !1;
              }
              resolveDuplicatedEntityReferenceProperties(s, l) {
                const n = this.entity.script;
                for (const o in s._scriptsIndex) {
                  const i = this.system.app.scripts.get(o);
                  if (!i) continue;
                  const e = s._scriptsIndex[o];
                  if (!e || !e.instance) continue;
                  const t = n[o].__attributesRaw,
                    r = n[o].__attributes;
                  if (!t && !r) continue;
                  const u = !!t,
                    y = e.instance.__attributes;
                  for (const p in y) {
                    if (!y[p]) continue;
                    const _ = i.attributes.get(p);
                    if (_) {
                      if (_.type === "entity")
                        this._resolveEntityScriptAttribute(
                          _,
                          p,
                          y[p],
                          u,
                          t || r,
                          l
                        );
                      else if (_.type === "json" && Array.isArray(_.schema)) {
                        const m = y[p],
                          E = t ? t[p] : r[p];
                        for (let v = 0; v < _.schema.length; v++) {
                          const P = _.schema[v];
                          if (P.type === "entity")
                            if (_.array)
                              for (let I = 0; I < m.length; I++)
                                this._resolveEntityScriptAttribute(
                                  P,
                                  P.name,
                                  m[I][P.name],
                                  u,
                                  E[I],
                                  l
                                );
                            else
                              this._resolveEntityScriptAttribute(
                                P,
                                P.name,
                                m[P.name],
                                u,
                                E,
                                l
                              );
                        }
                      }
                    }
                  }
                }
              }
              move(s, l) {
                const n = this._scripts.length;
                if (l >= n || l < 0) return !1;
                let o = s,
                  i = s;
                typeof i != "string" ? (i = s.__name) : (o = null);
                const e = this._scriptsIndex[i];
                if (!e || !e.instance) return !1;
                const t = e.instance;
                if (o && !(t instanceof o)) return !1;
                const r = this._scripts.indexOf(t);
                return r === -1 || r === l
                  ? !1
                  : (this._scripts.splice(l, 0, this._scripts.splice(r, 1)[0]),
                    this._resetExecutionOrder(0, n),
                    this._updateList.sort(),
                    this._postUpdateList.sort(),
                    this.fire("move", i, t, l, r),
                    this.fire("move:" + i, t, l, r),
                    !0);
              }
            }
          },
          1345: (Se, W, a) => {
            "use strict";
            a.d(W, { q: () => o });
            var x = a(9595),
              T = a(6813),
              g = a(24);
            class c {
              constructor() {
                this.enabled = !0;
              }
            }
            const d = "_onInitializeAttributes",
              h = "_onInitialize",
              f = "_onPostInitialize",
              s = "_onUpdate",
              l = "_onPostUpdate";
            let n = 0;
            class o extends T.Q {
              constructor(e) {
                super(e),
                  (this.id = "script"),
                  (this.ComponentType = g.Z),
                  (this.DataType = c),
                  (this._components = new x._({ sortBy: "_executionOrder" })),
                  (this._enabledComponents = new x._({
                    sortBy: "_executionOrder",
                  })),
                  (this.preloading = !0),
                  this.on("beforeremove", this._onBeforeRemove, this),
                  this.app.systems.on("initialize", this._onInitialize, this),
                  this.app.systems.on(
                    "postInitialize",
                    this._onPostInitialize,
                    this
                  ),
                  this.app.systems.on("update", this._onUpdate, this),
                  this.app.systems.on("postUpdate", this._onPostUpdate, this);
              }
              initializeComponentData(e, t) {
                if (
                  ((e._executionOrder = n++),
                  this._components.append(e),
                  n > Number.MAX_SAFE_INTEGER && this._resetExecutionOrder(),
                  (e.enabled = t.hasOwnProperty("enabled") ? !!t.enabled : !0),
                  e.enabled &&
                    e.entity.enabled &&
                    this._enabledComponents.append(e),
                  t.hasOwnProperty("order") && t.hasOwnProperty("scripts"))
                ) {
                  e._scriptsData = t.scripts;
                  for (let r = 0; r < t.order.length; r++)
                    e.create(t.order[r], {
                      enabled: t.scripts[t.order[r]].enabled,
                      attributes: t.scripts[t.order[r]].attributes,
                      preloading: this.preloading,
                    });
                }
              }
              cloneComponent(e, t) {
                const r = [],
                  u = {};
                for (let p = 0; p < e.script._scripts.length; p++) {
                  const _ = e.script._scripts[p],
                    m = _.__scriptType.__name;
                  r.push(m);
                  const E = {};
                  for (const v in _.__attributes) E[v] = _.__attributes[v];
                  u[m] = { enabled: _._enabled, attributes: E };
                }
                for (const p in e.script._scriptsIndex)
                  p.awaiting && r.splice(p.ind, 0, p);
                const y = { enabled: e.script.enabled, order: r, scripts: u };
                return this.addComponent(t, y);
              }
              _resetExecutionOrder() {
                n = 0;
                for (let e = 0, t = this._components.length; e < t; e++)
                  this._components.items[e]._executionOrder = n++;
              }
              _callComponentMethod(e, t, r) {
                for (e.loopIndex = 0; e.loopIndex < e.length; e.loopIndex++)
                  e.items[e.loopIndex][t](r);
              }
              _onInitialize() {
                (this.preloading = !1),
                  this._callComponentMethod(this._components, d),
                  this._callComponentMethod(this._enabledComponents, h);
              }
              _onPostInitialize() {
                this._callComponentMethod(this._enabledComponents, f);
              }
              _onUpdate(e) {
                this._callComponentMethod(this._enabledComponents, s, e);
              }
              _onPostUpdate(e) {
                this._callComponentMethod(this._enabledComponents, l, e);
              }
              _addComponentToEnabled(e) {
                this._enabledComponents.insert(e);
              }
              _removeComponentFromEnabled(e) {
                this._enabledComponents.remove(e);
              }
              _onBeforeRemove(e, t) {
                this._components.items.indexOf(t) >= 0 && t._onBeforeRemove(),
                  this._removeComponentFromEnabled(t),
                  this._components.remove(t);
              }
              destroy() {
                super.destroy(),
                  this.app.systems.off("initialize", this._onInitialize, this),
                  this.app.systems.off(
                    "postInitialize",
                    this._onPostInitialize,
                    this
                  ),
                  this.app.systems.off("update", this._onUpdate, this),
                  this.app.systems.off("postUpdate", this._onPostUpdate, this);
              }
            }
          },
          8580: (Se, W, a) => {
            "use strict";
            a.d(W, { W: () => o });
            var x = a(4585),
              T = a(2978),
              g = a(6556),
              c = a(3114),
              d = a(5004),
              h = a(4647),
              f = a(2583),
              s = a(8620),
              l = a(5675);
            const n = new T.S();
            class o extends s.w {
              constructor(e, t) {
                super(e, t),
                  (this._viewportReference = new d.e(this, "viewportEntity", {
                    "element#gain": this._onViewportElementGain,
                    "element#resize": this._onSetContentOrViewportSize,
                  })),
                  (this._contentReference = new d.e(this, "contentEntity", {
                    "element#gain": this._onContentElementGain,
                    "element#lose": this._onContentElementLose,
                    "element#resize": this._onSetContentOrViewportSize,
                  })),
                  (this._scrollbarUpdateFlags = {}),
                  (this._scrollbarReferences = {}),
                  (this._scrollbarReferences[c.gC] = new d.e(
                    this,
                    "horizontalScrollbarEntity",
                    {
                      "scrollbar#set:value":
                        this._onSetHorizontalScrollbarValue,
                      "scrollbar#gain": this._onHorizontalScrollbarGain,
                    }
                  )),
                  (this._scrollbarReferences[c.Gh] = new d.e(
                    this,
                    "verticalScrollbarEntity",
                    {
                      "scrollbar#set:value": this._onSetVerticalScrollbarValue,
                      "scrollbar#gain": this._onVerticalScrollbarGain,
                    }
                  )),
                  (this._prevContentSizes = {}),
                  (this._prevContentSizes[c.gC] = null),
                  (this._prevContentSizes[c.Gh] = null),
                  (this._scroll = new T.S()),
                  (this._velocity = new g.A()),
                  (this._dragStartPosition = new g.A()),
                  (this._disabledContentInput = !1),
                  (this._disabledContentInputEntities = []),
                  this._toggleLifecycleListeners("on", e),
                  this._toggleElementListeners("on");
              }
              _toggleLifecycleListeners(e, t) {
                this[e](
                  "set_horizontal",
                  this._onSetHorizontalScrollingEnabled,
                  this
                ),
                  this[e](
                    "set_vertical",
                    this._onSetVerticalScrollingEnabled,
                    this
                  ),
                  t.app.systems.element[e](
                    "add",
                    this._onElementComponentAdd,
                    this
                  ),
                  t.app.systems.element[e](
                    "beforeremove",
                    this._onElementComponentRemove,
                    this
                  );
              }
              _toggleElementListeners(e) {
                if (this.entity.element) {
                  if (e === "on" && this._hasElementListeners) return;
                  this.entity.element[e](
                    "resize",
                    this._onSetContentOrViewportSize,
                    this
                  ),
                    this.entity.element[e](l.SN, this._onMouseWheel, this),
                    (this._hasElementListeners = e === "on");
                }
              }
              _onElementComponentAdd(e) {
                this.entity === e && this._toggleElementListeners("on");
              }
              _onElementComponentRemove(e) {
                this.entity === e && this._toggleElementListeners("off");
              }
              _onViewportElementGain() {
                this._syncAll();
              }
              _onContentElementGain() {
                this._destroyDragHelper(),
                  (this._contentDragHelper = new h.d(
                    this._contentReference.entity.element
                  )),
                  this._contentDragHelper.on(
                    "drag:start",
                    this._onContentDragStart,
                    this
                  ),
                  this._contentDragHelper.on(
                    "drag:end",
                    this._onContentDragEnd,
                    this
                  ),
                  this._contentDragHelper.on(
                    "drag:move",
                    this._onContentDragMove,
                    this
                  ),
                  (this._prevContentSizes[c.gC] = null),
                  (this._prevContentSizes[c.Gh] = null),
                  this._syncAll();
              }
              _onContentElementLose() {
                this._destroyDragHelper();
              }
              _onContentDragStart() {
                this._contentReference.entity &&
                  this.enabled &&
                  this.entity.enabled &&
                  this._dragStartPosition.copy(
                    this._contentReference.entity.getLocalPosition()
                  );
              }
              _onContentDragEnd() {
                (this._prevContentDragPosition = null),
                  this._enableContentInput();
              }
              _onContentDragMove(e) {
                if (
                  this._contentReference.entity &&
                  this.enabled &&
                  this.entity.enabled &&
                  ((this._wasDragged = !0),
                  this._setScrollFromContentPosition(e),
                  this._setVelocityFromContentPositionDelta(e),
                  !this._disabledContentInput)
                ) {
                  const t = e.x - this._dragStartPosition.x,
                    r = e.y - this._dragStartPosition.y;
                  (Math.abs(t) > this.dragThreshold ||
                    Math.abs(r) > this.dragThreshold) &&
                    this._disableContentInput();
                }
              }
              _onSetContentOrViewportSize() {
                this._syncAll();
              }
              _onSetHorizontalScrollbarValue(e) {
                !this._scrollbarUpdateFlags[c.gC] &&
                  this.enabled &&
                  this.entity.enabled &&
                  this._onSetScroll(e, null);
              }
              _onSetVerticalScrollbarValue(e) {
                !this._scrollbarUpdateFlags[c.Gh] &&
                  this.enabled &&
                  this.entity.enabled &&
                  this._onSetScroll(null, e);
              }
              _onSetHorizontalScrollingEnabled() {
                this._syncScrollbarEnabledState(c.gC);
              }
              _onSetVerticalScrollingEnabled() {
                this._syncScrollbarEnabledState(c.Gh);
              }
              _onHorizontalScrollbarGain() {
                this._syncScrollbarEnabledState(c.gC),
                  this._syncScrollbarPosition(c.gC);
              }
              _onVerticalScrollbarGain() {
                this._syncScrollbarEnabledState(c.Gh),
                  this._syncScrollbarPosition(c.Gh);
              }
              _onSetScroll(e, t, r) {
                r !== !1 && this._velocity.set(0, 0, 0);
                const u = this._updateAxis(e, "x", c.gC),
                  y = this._updateAxis(t, "y", c.Gh);
                (u || y) && this.fire("set:scroll", this._scroll);
              }
              _updateAxis(e, t, r) {
                const u = e !== null && Math.abs(e - this._scroll[t]) > 1e-5;
                return (
                  (u || this._isDragging() || e === 0) &&
                    ((this._scroll[t] = this._determineNewScrollValue(e, t, r)),
                    this._syncContentPosition(r),
                    this._syncScrollbarPosition(r)),
                  u
                );
              }
              _determineNewScrollValue(e, t, r) {
                if (!this._getScrollingEnabled(r)) return this._scroll[t];
                switch (this.scrollMode) {
                  case f.Wb:
                    return x.m.clamp(e, 0, this._getMaxScrollValue(r));
                  case f.V6:
                    return this._setVelocityFromOvershoot(e, t, r), e;
                  case f.q2:
                    return e;
                  default:
                    return (
                      console.warn("Unhandled scroll mode:" + this.scrollMode),
                      e
                    );
                }
              }
              _syncAll() {
                this._syncContentPosition(c.gC),
                  this._syncContentPosition(c.Gh),
                  this._syncScrollbarPosition(c.gC),
                  this._syncScrollbarPosition(c.Gh),
                  this._syncScrollbarEnabledState(c.gC),
                  this._syncScrollbarEnabledState(c.Gh);
              }
              _syncContentPosition(e) {
                const t = this._getAxis(e),
                  r = this._getSign(e),
                  u = this._contentReference.entity;
                if (u) {
                  const y = this._prevContentSizes[e],
                    p = this._getContentSize(e);
                  if (y !== null && Math.abs(y - p) > 1e-4) {
                    const E = this._getMaxOffset(e, y),
                      v = this._getMaxOffset(e, p);
                    v === 0
                      ? (this._scroll[t] = 1)
                      : (this._scroll[t] = x.m.clamp(
                          (this._scroll[t] * E) / v,
                          0,
                          1
                        ));
                  }
                  const _ = this._scroll[t] * this._getMaxOffset(e),
                    m = u.getLocalPosition();
                  (m[t] = _ * r),
                    u.setLocalPosition(m),
                    (this._prevContentSizes[e] = p);
                }
              }
              _syncScrollbarPosition(e) {
                const t = this._getAxis(e),
                  r = this._scrollbarReferences[e].entity;
                r &&
                  r.scrollbar &&
                  ((this._scrollbarUpdateFlags[e] = !0),
                  (r.scrollbar.value = this._scroll[t]),
                  (r.scrollbar.handleSize = this._getScrollbarHandleSize(t, e)),
                  (this._scrollbarUpdateFlags[e] = !1));
              }
              _syncScrollbarEnabledState(e) {
                const t = this._scrollbarReferences[e].entity;
                if (t) {
                  const r = this._getScrollingEnabled(e),
                    u = this._getScrollbarVisibility(e);
                  switch (u) {
                    case f.Cz:
                      t.enabled = r;
                      return;
                    case f.ek:
                      t.enabled = r && this._contentIsLargerThanViewport(e);
                      return;
                    default:
                      console.warn("Unhandled scrollbar visibility:" + u),
                        (t.enabled = r);
                  }
                }
              }
              _contentIsLargerThanViewport(e) {
                return this._getContentSize(e) > this._getViewportSize(e);
              }
              _contentPositionToScrollValue(e) {
                const t = this._getMaxOffset(c.gC),
                  r = this._getMaxOffset(c.Gh);
                return (
                  t === 0 ? (n.x = 0) : (n.x = e.x / t),
                  r === 0 ? (n.y = 0) : (n.y = e.y / -r),
                  n
                );
              }
              _getMaxOffset(e, t) {
                t = t === void 0 ? this._getContentSize(e) : t;
                const r = this._getViewportSize(e);
                return t < r ? -this._getViewportSize(e) : r - t;
              }
              _getMaxScrollValue(e) {
                return this._contentIsLargerThanViewport(e) ? 1 : 0;
              }
              _getScrollbarHandleSize(e, t) {
                const r = this._getViewportSize(t),
                  u = this._getContentSize(t);
                if (Math.abs(u) < 0.001) return 1;
                const y = Math.min(r / u, 1),
                  p = this._toOvershoot(this._scroll[e], t);
                return p === 0 ? y : y / (1 + Math.abs(p));
              }
              _getViewportSize(e) {
                return this._getSize(e, this._viewportReference);
              }
              _getContentSize(e) {
                return this._getSize(e, this._contentReference);
              }
              _getSize(e, t) {
                return t.entity && t.entity.element
                  ? t.entity.element[this._getCalculatedDimension(e)]
                  : 0;
              }
              _getScrollingEnabled(e) {
                if (e === c.gC) return this.horizontal;
                if (e === c.Gh) return this.vertical;
              }
              _getScrollbarVisibility(e) {
                if (e === c.gC) return this.horizontalScrollbarVisibility;
                if (e === c.Gh) return this.verticalScrollbarVisibility;
              }
              _getSign(e) {
                return e === c.gC ? 1 : -1;
              }
              _getAxis(e) {
                return e === c.gC ? "x" : "y";
              }
              _getCalculatedDimension(e) {
                return e === c.gC ? "calculatedWidth" : "calculatedHeight";
              }
              _destroyDragHelper() {
                this._contentDragHelper && this._contentDragHelper.destroy();
              }
              onUpdate() {
                this._contentReference.entity &&
                  (this._updateVelocity(),
                  this._syncScrollbarEnabledState(c.gC),
                  this._syncScrollbarEnabledState(c.Gh));
              }
              _updateVelocity() {
                if (!this._isDragging()) {
                  if (
                    (this.scrollMode === f.V6 &&
                      (this._hasOvershoot("x", c.gC) &&
                        this._setVelocityFromOvershoot(
                          this.scroll.x,
                          "x",
                          c.gC
                        ),
                      this._hasOvershoot("y", c.Gh) &&
                        this._setVelocityFromOvershoot(
                          this.scroll.y,
                          "y",
                          c.Gh
                        )),
                    Math.abs(this._velocity.x) > 1e-4 ||
                      Math.abs(this._velocity.y) > 1e-4)
                  ) {
                    const e = this._contentReference.entity.getLocalPosition();
                    (e.x += this._velocity.x),
                      (e.y += this._velocity.y),
                      this._contentReference.entity.setLocalPosition(e),
                      this._setScrollFromContentPosition(e);
                  }
                  (this._velocity.x *= 1 - this.friction),
                    (this._velocity.y *= 1 - this.friction);
                }
              }
              _hasOvershoot(e, t) {
                return Math.abs(this._toOvershoot(this.scroll[e], t)) > 0.001;
              }
              _toOvershoot(e, t) {
                const r = this._getMaxScrollValue(t);
                return e < 0 ? e : e > r ? e - r : 0;
              }
              _setVelocityFromOvershoot(e, t, r) {
                const y =
                  this._toOvershoot(e, r) *
                  this._getMaxOffset(r) *
                  this._getSign(r);
                Math.abs(y) > 0 &&
                  (this._velocity[t] = -y / (this.bounceAmount * 50 + 1));
              }
              _setVelocityFromContentPositionDelta(e) {
                this._prevContentDragPosition
                  ? (this._velocity.sub2(e, this._prevContentDragPosition),
                    this._prevContentDragPosition.copy(e))
                  : (this._velocity.set(0, 0, 0),
                    (this._prevContentDragPosition = e.clone()));
              }
              _setScrollFromContentPosition(e) {
                let t = this._contentPositionToScrollValue(e);
                this._isDragging() && (t = this._applyScrollValueTension(t)),
                  this._onSetScroll(t.x, t.y, !1);
              }
              _applyScrollValueTension(e) {
                let r = this._getMaxScrollValue(c.gC),
                  u = this._toOvershoot(e.x, c.gC);
                return (
                  u > 0
                    ? (e.x = r + 1 * Math.log10(1 + u))
                    : u < 0 && (e.x = -1 * Math.log10(1 - u)),
                  (r = this._getMaxScrollValue(c.Gh)),
                  (u = this._toOvershoot(e.y, c.Gh)),
                  u > 0
                    ? (e.y = r + 1 * Math.log10(1 + u))
                    : u < 0 && (e.y = -1 * Math.log10(1 - u)),
                  e
                );
              }
              _isDragging() {
                return (
                  this._contentDragHelper && this._contentDragHelper.isDragging
                );
              }
              _setScrollbarComponentsEnabled(e) {
                this._scrollbarReferences[c.gC].hasComponent("scrollbar") &&
                  (this._scrollbarReferences[c.gC].entity.scrollbar.enabled =
                    e),
                  this._scrollbarReferences[c.Gh].hasComponent("scrollbar") &&
                    (this._scrollbarReferences[c.Gh].entity.scrollbar.enabled =
                      e);
              }
              _setContentDraggingEnabled(e) {
                this._contentDragHelper &&
                  (this._contentDragHelper.enabled = e);
              }
              _onMouseWheel(e) {
                if (this.useMouseWheel) {
                  const t = e.event,
                    r =
                      (t.deltaX /
                        this._contentReference.entity.element.calculatedWidth) *
                      this.mouseWheelSensitivity.x,
                    u =
                      (t.deltaY /
                        this._contentReference.entity.element
                          .calculatedHeight) *
                      this.mouseWheelSensitivity.y,
                    y = x.m.clamp(
                      this._scroll.x + r,
                      0,
                      this._getMaxScrollValue(c.gC)
                    ),
                    p = x.m.clamp(
                      this._scroll.y + u,
                      0,
                      this._getMaxScrollValue(c.Gh)
                    );
                  this.scroll = new T.S(y, p);
                }
              }
              _enableContentInput() {
                for (; this._disabledContentInputEntities.length; ) {
                  const e = this._disabledContentInputEntities.pop();
                  e.element && (e.element.useInput = !0);
                }
                this._disabledContentInput = !1;
              }
              _disableContentInput() {
                const e = (r) => {
                    r.element &&
                      r.element.useInput &&
                      (this._disabledContentInputEntities.push(r),
                      (r.element.useInput = !1));
                    const u = r.children;
                    for (let y = 0, p = u.length; y < p; y++) e(u[y]);
                  },
                  t = this._contentReference.entity;
                if (t) {
                  const r = t.children;
                  for (let u = 0, y = r.length; u < y; u++) e(r[u]);
                }
                this._disabledContentInput = !0;
              }
              onEnable() {
                this._viewportReference.onParentComponentEnable(),
                  this._contentReference.onParentComponentEnable(),
                  this._scrollbarReferences[c.gC].onParentComponentEnable(),
                  this._scrollbarReferences[c.Gh].onParentComponentEnable(),
                  this._setScrollbarComponentsEnabled(!0),
                  this._setContentDraggingEnabled(!0),
                  this._syncAll();
              }
              onDisable() {
                this._setScrollbarComponentsEnabled(!1),
                  this._setContentDraggingEnabled(!1);
              }
              onRemove() {
                this._toggleLifecycleListeners("off", this.system),
                  this._toggleElementListeners("off"),
                  this._destroyDragHelper();
              }
              set scroll(e) {
                this._onSetScroll(e.x, e.y);
              }
              get scroll() {
                return this._scroll;
              }
            }
          },
          2583: (Se, W, a) => {
            "use strict";
            a.d(W, {
              Cz: () => c,
              V6: () => T,
              Wb: () => x,
              ek: () => d,
              q2: () => g,
            });
            const x = 0,
              T = 1,
              g = 2,
              c = 0,
              d = 1;
          },
          6795: (Se, W, a) => {
            "use strict";
            a.d(W, { c: () => s });
            var x = a(8620),
              T = a(6813),
              g = a(8580);
            class c {
              constructor() {
                this.enabled = !0;
              }
            }
            var d = a(2978);
            const h = [
                { name: "enabled", type: "boolean" },
                { name: "horizontal", type: "boolean" },
                { name: "vertical", type: "boolean" },
                { name: "scrollMode", type: "number" },
                { name: "bounceAmount", type: "number" },
                { name: "friction", type: "number" },
                { name: "dragThreshold", type: "number" },
                { name: "useMouseWheel", type: "boolean" },
                { name: "mouseWheelSensitivity", type: "vec2" },
                { name: "horizontalScrollbarVisibility", type: "number" },
                { name: "verticalScrollbarVisibility", type: "number" },
                { name: "viewportEntity", type: "entity" },
                { name: "contentEntity", type: "entity" },
                { name: "horizontalScrollbarEntity", type: "entity" },
                { name: "verticalScrollbarEntity", type: "entity" },
              ],
              f = 10;
            class s extends T.Q {
              constructor(n) {
                super(n),
                  (this.id = "scrollview"),
                  (this.ComponentType = g.W),
                  (this.DataType = c),
                  (this.schema = h),
                  this.on("beforeremove", this._onRemoveComponent, this),
                  this.app.systems.on("update", this.onUpdate, this);
              }
              initializeComponentData(n, o, i) {
                o.dragThreshold === void 0 && (o.dragThreshold = f),
                  o.useMouseWheel === void 0 && (o.useMouseWheel = !0),
                  o.mouseWheelSensitivity === void 0 &&
                    (o.mouseWheelSensitivity = new d.S(1, 1)),
                  super.initializeComponentData(n, o, h);
              }
              onUpdate(n) {
                const o = this.store;
                for (const i in o) {
                  const e = o[i].entity,
                    t = e.scrollview;
                  t.enabled && e.enabled && t.onUpdate();
                }
              }
              _onRemoveComponent(n, o) {
                o.onRemove();
              }
              destroy() {
                super.destroy(),
                  this.app.systems.off("update", this.onUpdate, this);
              }
            }
            x.w._buildAccessors(g.W.prototype, h);
          },
          7379: (Se, W, a) => {
            "use strict";
            a.d(W, { x: () => h });
            var x = a(4585),
              T = a(3114),
              g = a(8620),
              c = a(4647),
              d = a(5004);
            class h extends g.w {
              constructor(s, l) {
                super(s, l),
                  (this._handleReference = new d.e(this, "handleEntity", {
                    "element#gain": this._onHandleElementGain,
                    "element#lose": this._onHandleElementLose,
                    "element#set:anchor": this._onSetHandleAlignment,
                    "element#set:margin": this._onSetHandleAlignment,
                    "element#set:pivot": this._onSetHandleAlignment,
                  })),
                  this._toggleLifecycleListeners("on");
              }
              _toggleLifecycleListeners(s) {
                this[s]("set_value", this._onSetValue, this),
                  this[s]("set_handleSize", this._onSetHandleSize, this),
                  this[s]("set_orientation", this._onSetOrientation, this);
              }
              _onHandleElementGain() {
                this._destroyDragHelper(),
                  (this._handleDragHelper = new c.d(
                    this._handleReference.entity.element,
                    this._getAxis()
                  )),
                  this._handleDragHelper.on(
                    "drag:move",
                    this._onHandleDrag,
                    this
                  ),
                  this._updateHandlePositionAndSize();
              }
              _onHandleElementLose() {
                this._destroyDragHelper();
              }
              _onHandleDrag(s) {
                this._handleReference.entity &&
                  this.enabled &&
                  this.entity.enabled &&
                  (this.value = this._handlePositionToScrollValue(
                    s[this._getAxis()]
                  ));
              }
              _onSetValue(s, l, n) {
                Math.abs(n - l) > 1e-5 &&
                  ((this.data.value = x.m.clamp(n, 0, 1)),
                  this._updateHandlePositionAndSize(),
                  this.fire("set:value", this.data.value));
              }
              _onSetHandleSize(s, l, n) {
                Math.abs(n - l) > 1e-5 &&
                  ((this.data.handleSize = x.m.clamp(n, 0, 1)),
                  this._updateHandlePositionAndSize());
              }
              _onSetHandleAlignment() {
                this._updateHandlePositionAndSize();
              }
              _onSetOrientation(s, l, n) {
                n !== l &&
                  this._handleReference.hasComponent("element") &&
                  (this._handleReference.entity.element[
                    this._getOppositeDimension()
                  ] = 0);
              }
              _updateHandlePositionAndSize() {
                const s = this._handleReference.entity,
                  l = s && s.element;
                if (s) {
                  const n = s.getLocalPosition();
                  (n[this._getAxis()] = this._getHandlePosition()),
                    this._handleReference.entity.setLocalPosition(n);
                }
                l && (l[this._getDimension()] = this._getHandleLength());
              }
              _handlePositionToScrollValue(s) {
                return (s * this._getSign()) / this._getUsableTrackLength();
              }
              _scrollValueToHandlePosition(s) {
                return s * this._getSign() * this._getUsableTrackLength();
              }
              _getUsableTrackLength() {
                return Math.max(
                  this._getTrackLength() - this._getHandleLength(),
                  0.001
                );
              }
              _getTrackLength() {
                return this.entity.element
                  ? this.orientation === T.gC
                    ? this.entity.element.calculatedWidth
                    : this.entity.element.calculatedHeight
                  : 0;
              }
              _getHandleLength() {
                return this._getTrackLength() * this.handleSize;
              }
              _getHandlePosition() {
                return this._scrollValueToHandlePosition(this.value);
              }
              _getSign() {
                return this.orientation === T.gC ? 1 : -1;
              }
              _getAxis() {
                return this.orientation === T.gC ? "x" : "y";
              }
              _getDimension() {
                return this.orientation === T.gC ? "width" : "height";
              }
              _getOppositeDimension() {
                return this.orientation === T.gC ? "height" : "width";
              }
              _destroyDragHelper() {
                this._handleDragHelper && this._handleDragHelper.destroy();
              }
              _setHandleDraggingEnabled(s) {
                this._handleDragHelper && (this._handleDragHelper.enabled = s);
              }
              onEnable() {
                this._handleReference.onParentComponentEnable(),
                  this._setHandleDraggingEnabled(!0);
              }
              onDisable() {
                this._setHandleDraggingEnabled(!1);
              }
              onRemove() {
                this._destroyDragHelper(),
                  this._toggleLifecycleListeners("off");
              }
            }
          },
          8874: (Se, W, a) => {
            "use strict";
            a.d(W, { $: () => h });
            var x = a(8620),
              T = a(6813),
              g = a(7379);
            class c {
              constructor() {
                this.enabled = !0;
              }
            }
            const d = [
              { name: "enabled", type: "boolean" },
              { name: "orientation", type: "number" },
              { name: "value", type: "number" },
              { name: "handleSize", type: "number" },
              { name: "handleEntity", type: "entity" },
            ];
            class h extends T.Q {
              constructor(s) {
                super(s),
                  (this.id = "scrollbar"),
                  (this.ComponentType = g.x),
                  (this.DataType = c),
                  (this.schema = d),
                  this.on("beforeremove", this._onRemoveComponent, this);
              }
              initializeComponentData(s, l, n) {
                super.initializeComponentData(s, l, d);
              }
              _onRemoveComponent(s, l) {
                l.onRemove();
              }
            }
            x.w._buildAccessors(g.x.prototype, d);
          },
          9386: (Se, W, a) => {
            "use strict";
            a.d(W, { x: () => c });
            var x = a(1304),
              T = a(8620),
              g = a(5849);
            class c extends T.w {
              constructor(h, f) {
                super(h, f),
                  (this._volume = 1),
                  (this._pitch = 1),
                  (this._positional = !0),
                  (this._refDistance = 1),
                  (this._maxDistance = 1e4),
                  (this._rollOffFactor = 1),
                  (this._distanceModel = x.WY),
                  (this._slots = {}),
                  (this._playingBeforeDisable = {});
              }
              _updateSoundInstances(h, f, s) {
                const l = this._slots;
                for (const n in l) {
                  const o = l[n];
                  if (!o.overlap) {
                    const i = o.instances;
                    for (let e = 0, t = i.length; e < t; e++)
                      i[e][h] = s ? o[h] * f : f;
                  }
                }
              }
              set distanceModel(h) {
                (this._distanceModel = h),
                  this._updateSoundInstances("distanceModel", h, !1);
              }
              get distanceModel() {
                return this._distanceModel;
              }
              set maxDistance(h) {
                (this._maxDistance = h),
                  this._updateSoundInstances("maxDistance", h, !1);
              }
              get maxDistance() {
                return this._maxDistance;
              }
              set refDistance(h) {
                (this._refDistance = h),
                  this._updateSoundInstances("refDistance", h, !1);
              }
              get refDistance() {
                return this._refDistance;
              }
              set rollOffFactor(h) {
                (this._rollOffFactor = h),
                  this._updateSoundInstances("rollOffFactor", h, !1);
              }
              get rollOffFactor() {
                return this._rollOffFactor;
              }
              set pitch(h) {
                (this._pitch = h), this._updateSoundInstances("pitch", h, !0);
              }
              get pitch() {
                return this._pitch;
              }
              set volume(h) {
                (this._volume = h), this._updateSoundInstances("volume", h, !0);
              }
              get volume() {
                return this._volume;
              }
              set positional(h) {
                this._positional = h;
                const f = this._slots;
                for (const s in f) {
                  const l = f[s];
                  if (!l.overlap) {
                    const n = l.instances,
                      o = n.length;
                    for (let i = o - 1; i >= 0; i--) {
                      const e = n[i].isPlaying || n[i].isSuspended,
                        t = n[i].currentTime;
                      e && n[i].stop();
                      const r = l._createInstance();
                      e && (r.play(), (r.currentTime = t)), n.push(r);
                    }
                  }
                }
              }
              get positional() {
                return this._positional;
              }
              set slots(h) {
                const f = this._slots;
                if (f) for (const l in f) f[l].stop();
                const s = {};
                for (const l in h)
                  h[l] instanceof g.Y
                    ? (s[h[l].name] = h[l])
                    : h[l].name &&
                      (s[h[l].name] = new g.Y(this, h[l].name, h[l]));
                (this._slots = s),
                  this.enabled && this.entity.enabled && this.onEnable();
              }
              get slots() {
                return this._slots;
              }
              onEnable() {
                if (this.system._inTools) return;
                const h = this._slots,
                  f = this._playingBeforeDisable;
                for (const s in h) {
                  const l = h[s];
                  l.autoPlay && l.isStopped
                    ? l.play()
                    : f[s]
                    ? l.resume()
                    : l.isLoaded || l.load();
                }
              }
              onDisable() {
                const h = this._slots,
                  f = {};
                for (const s in h)
                  h[s].overlap ||
                    (h[s].isPlaying && (h[s].pause(), (f[s] = !0)));
                this._playingBeforeDisable = f;
              }
              onRemove() {
                this.off();
              }
              addSlot(h, f) {
                const s = this._slots;
                if (s[h]) return null;
                const l = new g.Y(this, h, f);
                return (
                  (s[h] = l),
                  l.autoPlay && this.enabled && this.entity.enabled && l.play(),
                  l
                );
              }
              removeSlot(h) {
                const f = this._slots;
                f[h] && (f[h].stop(), delete f[h]);
              }
              slot(h) {
                return this._slots[h];
              }
              _getSlotProperty(h, f) {
                if (!this.enabled || !this.entity.enabled) return;
                const s = this._slots[h];
                if (s) return s[f];
              }
              isPlaying(h) {
                return this._getSlotProperty(h, "isPlaying") || !1;
              }
              isLoaded(h) {
                return this._getSlotProperty(h, "isLoaded") || !1;
              }
              isPaused(h) {
                return this._getSlotProperty(h, "isPaused") || !1;
              }
              isStopped(h) {
                return this._getSlotProperty(h, "isStopped") || !1;
              }
              play(h) {
                if (!this.enabled || !this.entity.enabled) return null;
                const f = this._slots[h];
                return f ? f.play() : null;
              }
              pause(h) {
                const f = this._slots;
                if (h) {
                  const s = f[h];
                  if (!s) return;
                  s.pause();
                } else for (const s in f) f[s].pause();
              }
              resume(h) {
                const f = this._slots;
                if (h) {
                  const s = f[h];
                  if (!s) return;
                  s.isPaused && s.resume();
                } else for (const s in f) f[s].resume();
              }
              stop(h) {
                const f = this._slots;
                if (h) {
                  const s = f[h];
                  if (!s) return;
                  s.stop();
                } else for (const s in f) f[s].stop();
              }
            }
          },
          5849: (Se, W, a) => {
            "use strict";
            a.d(W, { Y: () => s });
            var x = a(5338),
              T = a(4585),
              g = a(6556),
              c = a(6204),
              d = a(3467),
              h = a(7302);
            const f = {
              volume: 0,
              pitch: 0,
              loop: !1,
              startTime: 0,
              duration: 0,
              position: new g.A(),
              maxDistance: 0,
              refDistance: 0,
              rollOffFactor: 0,
              distanceModel: 0,
              onPlay: null,
              onPause: null,
              onResume: null,
              onStop: null,
              onEnd: null,
            };
            class s extends x.b {
              constructor(n, o = "Untitled", i = {}) {
                super(),
                  (this.name = void 0),
                  (this.instances = []),
                  (this._component = n),
                  (this._assets = n.system.app.assets),
                  (this._manager = n.system.manager),
                  (this.name = o),
                  (this._volume =
                    i.volume !== void 0
                      ? T.m.clamp(Number(i.volume) || 0, 0, 1)
                      : 1),
                  (this._pitch =
                    i.pitch !== void 0
                      ? Math.max(0.01, Number(i.pitch) || 0)
                      : 1),
                  (this._loop = !!(i.loop !== void 0 && i.loop)),
                  (this._duration = i.duration > 0 ? i.duration : null),
                  (this._startTime = Math.max(0, Number(i.startTime) || 0)),
                  (this._overlap = !!i.overlap),
                  (this._autoPlay = !!i.autoPlay),
                  (this._firstNode = null),
                  (this._lastNode = null),
                  (this._asset = i.asset),
                  this._asset instanceof c.x && (this._asset = this._asset.id),
                  (this._onInstancePlayHandler =
                    this._onInstancePlay.bind(this)),
                  (this._onInstancePauseHandler =
                    this._onInstancePause.bind(this)),
                  (this._onInstanceResumeHandler =
                    this._onInstanceResume.bind(this)),
                  (this._onInstanceStopHandler =
                    this._onInstanceStop.bind(this)),
                  (this._onInstanceEndHandler = this._onInstanceEnd.bind(this));
              }
              play() {
                if (
                  (this.overlap || this.stop(),
                  !this.isLoaded && !this._hasAsset())
                )
                  return;
                const n = this._createInstance();
                if ((this.instances.push(n), this.isLoaded)) n.play();
                else {
                  const o = function (e) {
                    const t = n._playWhenLoaded;
                    (n.sound = e), t && n.play();
                  };
                  this.off("load", o), this.once("load", o), this.load();
                }
                return n;
              }
              pause() {
                let n = !1;
                const o = this.instances;
                for (let i = 0, e = o.length; i < e; i++)
                  o[i].pause() && (n = !0);
                return n;
              }
              resume() {
                let n = !1;
                const o = this.instances;
                for (let i = 0, e = o.length; i < e; i++)
                  o[i].resume() && (n = !0);
                return n;
              }
              stop() {
                let n = !1;
                const o = this.instances;
                let i = o.length;
                for (; i--; ) o[i].stop(), (n = !0);
                return (o.length = 0), n;
              }
              load() {
                if (!this._hasAsset()) return;
                const n = this._assets.get(this._asset);
                if (!n) {
                  this._assets.off(
                    "add:" + this._asset,
                    this._onAssetAdd,
                    this
                  ),
                    this._assets.once(
                      "add:" + this._asset,
                      this._onAssetAdd,
                      this
                    );
                  return;
                }
                if (
                  (n.off("remove", this._onAssetRemoved, this),
                  n.on("remove", this._onAssetRemoved, this),
                  !n.resource)
                ) {
                  n.off("load", this._onAssetLoad, this),
                    n.once("load", this._onAssetLoad, this),
                    this._assets.load(n);
                  return;
                }
                this.fire("load", n.resource);
              }
              setExternalNodes(n, o) {
                if (!n) {
                  console.error("The firstNode must have a valid AudioNode");
                  return;
                }
                if (
                  (o || (o = n),
                  (this._firstNode = n),
                  (this._lastNode = o),
                  !this._overlap)
                ) {
                  const i = this.instances;
                  for (let e = 0, t = i.length; e < t; e++)
                    i[e].setExternalNodes(n, o);
                }
              }
              clearExternalNodes() {
                if (
                  ((this._firstNode = null),
                  (this._lastNode = null),
                  !this._overlap)
                ) {
                  const n = this.instances;
                  for (let o = 0, i = n.length; o < i; o++)
                    n[o].clearExternalNodes();
                }
              }
              getExternalNodes() {
                return [this._firstNode, this._lastNode];
              }
              _hasAsset() {
                return this._asset != null;
              }
              _createInstance() {
                let n = null;
                const o = this._component;
                let i = null;
                if (this._hasAsset()) {
                  const t = this._assets.get(this._asset);
                  t && (i = t.resource);
                }
                const e = f;
                return (
                  (e.volume = this._volume * o.volume),
                  (e.pitch = this._pitch * o.pitch),
                  (e.loop = this._loop),
                  (e.startTime = this._startTime),
                  (e.duration = this._duration),
                  (e.onPlay = this._onInstancePlayHandler),
                  (e.onPause = this._onInstancePauseHandler),
                  (e.onResume = this._onInstanceResumeHandler),
                  (e.onStop = this._onInstanceStopHandler),
                  (e.onEnd = this._onInstanceEndHandler),
                  o.positional
                    ? (e.position.copy(o.entity.getPosition()),
                      (e.maxDistance = o.maxDistance),
                      (e.refDistance = o.refDistance),
                      (e.rollOffFactor = o.rollOffFactor),
                      (e.distanceModel = o.distanceModel),
                      (n = new h.b(this._manager, i, e)))
                    : (n = new d.J(this._manager, i, e)),
                  this._firstNode &&
                    n.setExternalNodes(this._firstNode, this._lastNode),
                  n
                );
              }
              _onInstancePlay(n) {
                this.fire("play", n), this._component.fire("play", this, n);
              }
              _onInstancePause(n) {
                this.fire("pause", n), this._component.fire("pause", this, n);
              }
              _onInstanceResume(n) {
                this.fire("resume", n), this._component.fire("resume", this, n);
              }
              _onInstanceStop(n) {
                const o = this.instances.indexOf(n);
                o !== -1 && this.instances.splice(o, 1),
                  this.fire("stop", n),
                  this._component.fire("stop", this, n);
              }
              _onInstanceEnd(n) {
                const o = this.instances.indexOf(n);
                o !== -1 && this.instances.splice(o, 1),
                  this.fire("end", n),
                  this._component.fire("end", this, n);
              }
              _onAssetAdd(n) {
                this.load();
              }
              _onAssetLoad(n) {
                this.load();
              }
              _onAssetRemoved(n) {
                n.off("remove", this._onAssetRemoved, this),
                  this._assets.off("add:" + n.id, this._onAssetAdd, this),
                  this.stop();
              }
              updatePosition(n) {
                const o = this.instances;
                for (let i = 0, e = o.length; i < e; i++) o[i].position = n;
              }
              set asset(n) {
                const o = this._asset;
                if (o) {
                  this._assets.off("add:" + o, this._onAssetAdd, this);
                  const i = this._assets.get(o);
                  i && i.off("remove", this._onAssetRemoved, this);
                }
                (this._asset = n),
                  this._asset instanceof c.x && (this._asset = this._asset.id),
                  this._hasAsset() &&
                    this._component.enabled &&
                    this._component.entity.enabled &&
                    this.load();
              }
              get asset() {
                return this._asset;
              }
              set autoPlay(n) {
                this._autoPlay = !!n;
              }
              get autoPlay() {
                return this._autoPlay;
              }
              set duration(n) {
                if (
                  ((this._duration = Math.max(0, Number(n) || 0) || null),
                  !this._overlap)
                ) {
                  const o = this.instances;
                  for (let i = 0, e = o.length; i < e; i++)
                    o[i].duration = this._duration;
                }
              }
              get duration() {
                let n = 0;
                if (this._hasAsset()) {
                  const o = this._assets.get(this._asset);
                  n = o != null && o.resource ? o.resource.duration : 0;
                }
                return this._duration != null ? this._duration % (n || 1) : n;
              }
              get isLoaded() {
                if (this._hasAsset()) {
                  const n = this._assets.get(this._asset);
                  if (n) return !!n.resource;
                }
                return !1;
              }
              get isPaused() {
                const n = this.instances,
                  o = n.length;
                if (o === 0) return !1;
                for (let i = 0; i < o; i++) if (!n[i].isPaused) return !1;
                return !0;
              }
              get isPlaying() {
                const n = this.instances;
                for (let o = 0, i = n.length; o < i; o++)
                  if (n[o].isPlaying) return !0;
                return !1;
              }
              get isStopped() {
                const n = this.instances;
                for (let o = 0, i = n.length; o < i; o++)
                  if (!n[o].isStopped) return !1;
                return !0;
              }
              set loop(n) {
                this._loop = !!n;
                const o = this.instances;
                for (let i = 0, e = o.length; i < e; i++)
                  o[i].loop = this._loop;
              }
              get loop() {
                return this._loop;
              }
              set overlap(n) {
                this._overlap = !!n;
              }
              get overlap() {
                return this._overlap;
              }
              set pitch(n) {
                if (
                  ((this._pitch = Math.max(Number(n) || 0, 0.01)),
                  !this._overlap)
                ) {
                  const o = this.instances;
                  for (let i = 0, e = o.length; i < e; i++)
                    o[i].pitch = this.pitch * this._component.pitch;
                }
              }
              get pitch() {
                return this._pitch;
              }
              set startTime(n) {
                if (
                  ((this._startTime = Math.max(0, Number(n) || 0)),
                  !this._overlap)
                ) {
                  const o = this.instances;
                  for (let i = 0, e = o.length; i < e; i++)
                    o[i].startTime = this._startTime;
                }
              }
              get startTime() {
                return this._startTime;
              }
              set volume(n) {
                if (
                  ((this._volume = T.m.clamp(Number(n) || 0, 0, 1)),
                  !this._overlap)
                ) {
                  const o = this.instances;
                  for (let i = 0, e = o.length; i < e; i++)
                    o[i].volume = this._volume * this._component.volume;
                }
              }
              get volume() {
                return this._volume;
              }
            }
          },
          1873: (Se, W, a) => {
            "use strict";
            a.d(W, { T: () => f });
            var x = a(2100),
              T = a(8620),
              g = a(6813),
              c = a(9386);
            class d {
              constructor() {
                this.enabled = !0;
              }
            }
            const h = ["enabled"];
            class f extends g.Q {
              constructor(l) {
                super(l),
                  (this.id = "sound"),
                  (this.ComponentType = c.x),
                  (this.DataType = d),
                  (this.schema = h),
                  (this.manager = l.soundManager),
                  this.app.systems.on("update", this.onUpdate, this),
                  this.on("beforeremove", this.onBeforeRemove, this);
              }
              set volume(l) {
                this.manager.volume = l;
              }
              get volume() {
                return this.manager.volume;
              }
              get context() {
                return (0, x.b)() ? this.manager.context : null;
              }
              initializeComponentData(l, n, o) {
                o = [
                  "volume",
                  "pitch",
                  "positional",
                  "refDistance",
                  "maxDistance",
                  "rollOffFactor",
                  "distanceModel",
                  "slots",
                ];
                for (let i = 0; i < o.length; i++)
                  n.hasOwnProperty(o[i]) && (l[o[i]] = n[o[i]]);
                super.initializeComponentData(l, n, ["enabled"]);
              }
              cloneComponent(l, n) {
                const o = l.sound,
                  i = o.slots,
                  e = {};
                for (const r in i) {
                  const u = i[r];
                  e[r] = {
                    name: u.name,
                    volume: u.volume,
                    pitch: u.pitch,
                    loop: u.loop,
                    duration: u.duration,
                    startTime: u.startTime,
                    overlap: u.overlap,
                    autoPlay: u.autoPlay,
                    asset: u.asset,
                  };
                }
                const t = {
                  distanceModel: o.distanceModel,
                  enabled: o.enabled,
                  maxDistance: o.maxDistance,
                  pitch: o.pitch,
                  positional: o.positional,
                  refDistance: o.refDistance,
                  rollOffFactor: o.rollOffFactor,
                  slots: e,
                  volume: o.volume,
                };
                return this.addComponent(n, t);
              }
              onUpdate(l) {
                const n = this.store;
                for (const o in n)
                  if (n.hasOwnProperty(o)) {
                    const e = n[o].entity;
                    if (e.enabled) {
                      const t = e.sound;
                      if (t.enabled && t.positional) {
                        const r = e.getPosition(),
                          u = t.slots;
                        for (const y in u) u[y].updatePosition(r);
                      }
                    }
                  }
              }
              onBeforeRemove(l, n) {
                const o = n.slots;
                for (const i in o) o[i].overlap || o[i].stop();
                n.onRemove();
              }
              destroy() {
                super.destroy(),
                  this.app.systems.off("update", this.onUpdate, this);
              }
            }
            T.w._buildAccessors(c.x.prototype, h);
          },
          5425: (Se, W, a) => {
            "use strict";
            a.d(W, { i: () => m });
            var x = a(4585),
              T = a(1367),
              g = a(2978),
              c = a(6630),
              d = a(3114),
              h = a(3240),
              f = a(7915),
              s = a(8792),
              l = a(9915),
              n = a(8620),
              o = a(4534),
              i = a(4656);
            const e = "texture_emissiveMap",
              t = "texture_opacityMap",
              r = "material_emissive",
              u = "material_opacity",
              y = "innerOffset",
              p = "outerScale",
              _ = "atlasRect";
            class m extends n.w {
              constructor(v, P) {
                super(v, P),
                  (this._type = o.V),
                  (this._material = v.defaultMaterial),
                  (this._color = new T.I(1, 1, 1, 1)),
                  (this._colorUniform = new Float32Array(3)),
                  (this._speed = 1),
                  (this._flipX = !1),
                  (this._flipY = !1),
                  (this._width = 1),
                  (this._height = 1),
                  (this._drawOrder = 0),
                  (this._layers = [d.kY]),
                  (this._outerScale = new g.S(1, 1)),
                  (this._outerScaleUniform = new Float32Array(2)),
                  (this._innerOffset = new c.T()),
                  (this._innerOffsetUniform = new Float32Array(4)),
                  (this._atlasRect = new c.T()),
                  (this._atlasRectUniform = new Float32Array(4)),
                  (this._batchGroupId = -1),
                  (this._batchGroup = null),
                  (this._node = new f.A()),
                  (this._model = new l.H()),
                  (this._model.graph = this._node),
                  (this._meshInstance = null),
                  P.addChild(this._model.graph),
                  (this._model._entity = P),
                  (this._updateAabbFunc = this._updateAabb.bind(this)),
                  (this._addedModel = !1),
                  (this._autoPlayClip = null),
                  (this._clips = {}),
                  (this._defaultClip = new i.p(this, {
                    name: this.entity.name,
                    fps: 0,
                    loop: !1,
                    spriteAsset: null,
                  })),
                  (this._currentClip = this._defaultClip);
              }
              set type(v) {
                this._type !== v &&
                  ((this._type = v),
                  this._type === o.V
                    ? (this.stop(),
                      (this._currentClip = this._defaultClip),
                      this.enabled &&
                        this.entity.enabled &&
                        ((this._currentClip.frame = this.frame),
                        this._currentClip.sprite
                          ? this._showModel()
                          : this._hideModel()))
                    : this._type === o.C &&
                      (this.stop(),
                      this._autoPlayClip && this._tryAutoPlay(),
                      this._currentClip &&
                      this._currentClip.isPlaying &&
                      this.enabled &&
                      this.entity.enabled
                        ? this._showModel()
                        : this._hideModel()));
              }
              get type() {
                return this._type;
              }
              set frame(v) {
                this._currentClip.frame = v;
              }
              get frame() {
                return this._currentClip.frame;
              }
              set spriteAsset(v) {
                this._defaultClip.spriteAsset = v;
              }
              get spriteAsset() {
                return this._defaultClip._spriteAsset;
              }
              set sprite(v) {
                this._currentClip.sprite = v;
              }
              get sprite() {
                return this._currentClip.sprite;
              }
              set material(v) {
                (this._material = v),
                  this._meshInstance && (this._meshInstance.material = v);
              }
              get material() {
                return this._material;
              }
              set color(v) {
                (this._color.r = v.r),
                  (this._color.g = v.g),
                  (this._color.b = v.b),
                  this._meshInstance &&
                    ((this._colorUniform[0] = this._color.r),
                    (this._colorUniform[1] = this._color.g),
                    (this._colorUniform[2] = this._color.b),
                    this._meshInstance.setParameter(r, this._colorUniform));
              }
              get color() {
                return this._color;
              }
              set opacity(v) {
                (this._color.a = v),
                  this._meshInstance && this._meshInstance.setParameter(u, v);
              }
              get opacity() {
                return this._color.a;
              }
              set clips(v) {
                if (!v) {
                  for (const P in this._clips) this.removeClip(P);
                  return;
                }
                for (const P in this._clips) {
                  let I = !1;
                  for (const A in v)
                    if (v[A].name === P) {
                      (I = !0),
                        (this._clips[P].fps = v[A].fps),
                        (this._clips[P].loop = v[A].loop),
                        v[A].hasOwnProperty("sprite")
                          ? (this._clips[P].sprite = v[A].sprite)
                          : v[A].hasOwnProperty("spriteAsset") &&
                            (this._clips[P].spriteAsset = v[A].spriteAsset);
                      break;
                    }
                  I || this.removeClip(P);
                }
                for (const P in v) this._clips[v[P].name] || this.addClip(v[P]);
                this._autoPlayClip && this._tryAutoPlay(),
                  (!this._currentClip || !this._currentClip.sprite) &&
                    this._hideModel();
              }
              get clips() {
                return this._clips;
              }
              get currentClip() {
                return this._currentClip;
              }
              set speed(v) {
                this._speed = v;
              }
              get speed() {
                return this._speed;
              }
              set flipX(v) {
                this._flipX !== v &&
                  ((this._flipX = v), this._updateTransform());
              }
              get flipX() {
                return this._flipX;
              }
              set flipY(v) {
                this._flipY !== v &&
                  ((this._flipY = v), this._updateTransform());
              }
              get flipY() {
                return this._flipY;
              }
              set width(v) {
                v !== this._width &&
                  ((this._width = v),
                  (this._outerScale.x = this._width),
                  this.sprite &&
                    (this.sprite.renderMode === d.DD ||
                      this.sprite.renderMode === d.ei) &&
                    this._updateTransform());
              }
              get width() {
                return this._width;
              }
              set height(v) {
                v !== this._height &&
                  ((this._height = v),
                  (this._outerScale.y = this.height),
                  this.sprite &&
                    (this.sprite.renderMode === d.DD ||
                      this.sprite.renderMode === d.ei) &&
                    this._updateTransform());
              }
              get height() {
                return this._height;
              }
              set batchGroupId(v) {
                if (this._batchGroupId === v) return;
                const P = this._batchGroupId;
                if (((this._batchGroupId = v), this.entity.enabled && P >= 0)) {
                  var I;
                  (I = this.system.app.batcher) == null ||
                    I.remove(h.y.SPRITE, P, this.entity);
                }
                if (this.entity.enabled && v >= 0) {
                  var A;
                  (A = this.system.app.batcher) == null ||
                    A.insert(h.y.SPRITE, v, this.entity);
                } else
                  P >= 0 &&
                    this._currentClip &&
                    this._currentClip.sprite &&
                    this.enabled &&
                    this.entity.enabled &&
                    this._showModel();
              }
              get batchGroupId() {
                return this._batchGroupId;
              }
              set autoPlayClip(v) {
                (this._autoPlayClip = v instanceof i.p ? v.name : v),
                  this._tryAutoPlay();
              }
              get autoPlayClip() {
                return this._autoPlayClip;
              }
              set drawOrder(v) {
                (this._drawOrder = v),
                  this._meshInstance && (this._meshInstance.drawOrder = v);
              }
              get drawOrder() {
                return this._drawOrder;
              }
              set layers(v) {
                this._addedModel && this._hideModel(),
                  (this._layers = v),
                  this._meshInstance &&
                    this.enabled &&
                    this.entity.enabled &&
                    this._showModel();
              }
              get layers() {
                return this._layers;
              }
              get aabb() {
                return this._meshInstance ? this._meshInstance.aabb : null;
              }
              onEnable() {
                const v = this.system.app,
                  P = v.scene;
                if (
                  (P.on("set:layers", this._onLayersChanged, this),
                  P.layers &&
                    (P.layers.on("add", this._onLayerAdded, this),
                    P.layers.on("remove", this._onLayerRemoved, this)),
                  this._showModel(),
                  this._autoPlayClip && this._tryAutoPlay(),
                  this._batchGroupId >= 0)
                ) {
                  var I;
                  (I = v.batcher) == null ||
                    I.insert(h.y.SPRITE, this._batchGroupId, this.entity);
                }
              }
              onDisable() {
                const v = this.system.app,
                  P = v.scene;
                if (
                  (P.off("set:layers", this._onLayersChanged, this),
                  P.layers &&
                    (P.layers.off("add", this._onLayerAdded, this),
                    P.layers.off("remove", this._onLayerRemoved, this)),
                  this.stop(),
                  this._hideModel(),
                  this._batchGroupId >= 0)
                ) {
                  var I;
                  (I = v.batcher) == null ||
                    I.remove(h.y.SPRITE, this._batchGroupId, this.entity);
                }
              }
              onDestroy() {
                var v;
                (this._currentClip = null),
                  this._defaultClip &&
                    (this._defaultClip._destroy(), (this._defaultClip = null));
                for (const P in this._clips) this._clips[P]._destroy();
                (this._clips = null),
                  this._hideModel(),
                  (this._model = null),
                  (v = this._node) == null || v.remove(),
                  (this._node = null),
                  this._meshInstance &&
                    ((this._meshInstance.material = null),
                    (this._meshInstance.mesh = null),
                    (this._meshInstance = null));
              }
              _showModel() {
                if (this._addedModel || !this._meshInstance) return;
                const v = [this._meshInstance];
                for (let P = 0, I = this._layers.length; P < I; P++) {
                  const A = this.system.app.scene.layers.getLayerById(
                    this._layers[P]
                  );
                  A && A.addMeshInstances(v);
                }
                this._addedModel = !0;
              }
              _hideModel() {
                if (!this._addedModel || !this._meshInstance) return;
                const v = [this._meshInstance];
                for (let P = 0, I = this._layers.length; P < I; P++) {
                  const A = this.system.app.scene.layers.getLayerById(
                    this._layers[P]
                  );
                  A && A.removeMeshInstances(v);
                }
                this._addedModel = !1;
              }
              _showFrame(v) {
                if (!this.sprite) return;
                const P = this.sprite.meshes[v];
                if (!P) {
                  this._meshInstance &&
                    ((this._meshInstance.mesh = null),
                    (this._meshInstance.visible = !1));
                  return;
                }
                let I;
                if (
                  (this.sprite.renderMode === d.ei
                    ? (I = this.system.default9SlicedMaterialSlicedMode)
                    : this.sprite.renderMode === d.DD
                    ? (I = this.system.default9SlicedMaterialTiledMode)
                    : (I = this.system.defaultMaterial),
                  this._meshInstance ||
                    ((this._meshInstance = new s.l(
                      P,
                      this._material,
                      this._node
                    )),
                    (this._meshInstance.castShadow = !1),
                    (this._meshInstance.receiveShadow = !1),
                    (this._meshInstance.drawOrder = this._drawOrder),
                    this._model.meshInstances.push(this._meshInstance),
                    (this._colorUniform[0] = this._color.r),
                    (this._colorUniform[1] = this._color.g),
                    (this._colorUniform[2] = this._color.b),
                    this._meshInstance.setParameter(r, this._colorUniform),
                    this._meshInstance.setParameter(u, this._color.a),
                    this.enabled && this.entity.enabled && this._showModel()),
                  this._meshInstance.material !== I &&
                    (this._meshInstance.material = I),
                  this._meshInstance.mesh !== P &&
                    ((this._meshInstance.mesh = P),
                    (this._meshInstance.visible = !0),
                    (this._meshInstance._aabbVer = -1)),
                  this.sprite.atlas && this.sprite.atlas.texture
                    ? (this._meshInstance.setParameter(
                        e,
                        this.sprite.atlas.texture
                      ),
                      this._meshInstance.setParameter(
                        t,
                        this.sprite.atlas.texture
                      ))
                    : (this._meshInstance.deleteParameter(e),
                      this._meshInstance.deleteParameter(t)),
                  this.sprite.atlas &&
                    (this.sprite.renderMode === d.ei ||
                      this.sprite.renderMode === d.DD))
                ) {
                  this._meshInstance._updateAabbFunc = this._updateAabbFunc;
                  const A = this.sprite.atlas.frames[this.sprite.frameKeys[v]];
                  if (A) {
                    const B = 2 / A.rect.z,
                      C = 2 / A.rect.w;
                    this._innerOffset.set(
                      A.border.x * B,
                      A.border.y * C,
                      A.border.z * B,
                      A.border.w * C
                    );
                    const w = this.sprite.atlas.texture;
                    this._atlasRect.set(
                      A.rect.x / w.width,
                      A.rect.y / w.height,
                      A.rect.z / w.width,
                      A.rect.w / w.height
                    );
                  } else this._innerOffset.set(0, 0, 0, 0);
                  (this._innerOffsetUniform[0] = this._innerOffset.x),
                    (this._innerOffsetUniform[1] = this._innerOffset.y),
                    (this._innerOffsetUniform[2] = this._innerOffset.z),
                    (this._innerOffsetUniform[3] = this._innerOffset.w),
                    this._meshInstance.setParameter(
                      y,
                      this._innerOffsetUniform
                    ),
                    (this._atlasRectUniform[0] = this._atlasRect.x),
                    (this._atlasRectUniform[1] = this._atlasRect.y),
                    (this._atlasRectUniform[2] = this._atlasRect.z),
                    (this._atlasRectUniform[3] = this._atlasRect.w),
                    this._meshInstance.setParameter(_, this._atlasRectUniform);
                } else this._meshInstance._updateAabbFunc = null;
                this._updateTransform();
              }
              _updateTransform() {
                let v = this.flipX ? -1 : 1,
                  P = this.flipY ? -1 : 1,
                  I = 0,
                  A = 0;
                if (
                  this.sprite &&
                  (this.sprite.renderMode === d.ei ||
                    this.sprite.renderMode === d.DD)
                ) {
                  let B = 1,
                    C = 1;
                  if (this.sprite.atlas) {
                    const K =
                      this.sprite.atlas.frames[
                        this.sprite.frameKeys[this.frame]
                      ];
                    K &&
                      ((B = K.rect.z),
                      (C = K.rect.w),
                      (I = (0.5 - K.pivot.x) * this._width),
                      (A = (0.5 - K.pivot.y) * this._height));
                  }
                  const w = B / this.sprite.pixelsPerUnit,
                    k = C / this.sprite.pixelsPerUnit;
                  this._outerScale.set(
                    Math.max(this._width, this._innerOffset.x * w),
                    Math.max(this._height, this._innerOffset.y * k)
                  ),
                    (v *= w),
                    (P *= k),
                    (this._outerScale.x /= w),
                    (this._outerScale.y /= k),
                    (v *= x.m.clamp(
                      this._width / (this._innerOffset.x * w),
                      1e-4,
                      1
                    )),
                    (P *= x.m.clamp(
                      this._height / (this._innerOffset.y * k),
                      1e-4,
                      1
                    )),
                    this._meshInstance &&
                      ((this._outerScaleUniform[0] = this._outerScale.x),
                      (this._outerScaleUniform[1] = this._outerScale.y),
                      this._meshInstance.setParameter(
                        p,
                        this._outerScaleUniform
                      ));
                }
                this._node.setLocalScale(v, P, 1),
                  this._node.setLocalPosition(I, A, 0);
              }
              _updateAabb(v) {
                return (
                  v.center.set(0, 0, 0),
                  v.halfExtents.set(
                    this._outerScale.x * 0.5,
                    this._outerScale.y * 0.5,
                    0.001
                  ),
                  v.setFromTransformedAabb(v, this._node.getWorldTransform()),
                  v
                );
              }
              _tryAutoPlay() {
                if (!this._autoPlayClip || this.type !== o.C) return;
                const v = this._clips[this._autoPlayClip];
                v &&
                  !v.isPlaying &&
                  (!this._currentClip || !this._currentClip.isPlaying) &&
                  this.enabled &&
                  this.entity.enabled &&
                  this.play(v.name);
              }
              _onLayersChanged(v, P) {
                v.off("add", this.onLayerAdded, this),
                  v.off("remove", this.onLayerRemoved, this),
                  P.on("add", this.onLayerAdded, this),
                  P.on("remove", this.onLayerRemoved, this),
                  this.enabled && this.entity.enabled && this._showModel();
              }
              _onLayerAdded(v) {
                this.layers.indexOf(v.id) < 0 ||
                  (this._addedModel &&
                    this.enabled &&
                    this.entity.enabled &&
                    this._meshInstance &&
                    v.addMeshInstances([this._meshInstance]));
              }
              _onLayerRemoved(v) {
                !this._meshInstance ||
                  this.layers.indexOf(v.id) < 0 ||
                  v.removeMeshInstances([this._meshInstance]);
              }
              removeModelFromLayers() {
                for (let v = 0; v < this.layers.length; v++) {
                  const P = this.system.app.scene.layers.getLayerById(
                    this.layers[v]
                  );
                  P && P.removeMeshInstances([this._meshInstance]);
                }
              }
              addClip(v) {
                const P = new i.p(this, {
                  name: v.name,
                  fps: v.fps,
                  loop: v.loop,
                  spriteAsset: v.spriteAsset,
                });
                return (
                  (this._clips[v.name] = P),
                  P.name &&
                    P.name === this._autoPlayClip &&
                    this._tryAutoPlay(),
                  P
                );
              }
              removeClip(v) {
                delete this._clips[v];
              }
              clip(v) {
                return this._clips[v];
              }
              play(v) {
                const P = this._clips[v],
                  I = this._currentClip;
                return (
                  I && I !== P && (I._playing = !1),
                  (this._currentClip = P),
                  this._currentClip &&
                    ((this._currentClip = P), this._currentClip.play()),
                  P
                );
              }
              pause() {
                this._currentClip !== this._defaultClip &&
                  this._currentClip.isPlaying &&
                  this._currentClip.pause();
              }
              resume() {
                this._currentClip !== this._defaultClip &&
                  this._currentClip.isPaused &&
                  this._currentClip.resume();
              }
              stop() {
                this._currentClip !== this._defaultClip &&
                  this._currentClip.stop();
              }
            }
          },
          4534: (Se, W, a) => {
            "use strict";
            a.d(W, { C: () => T, V: () => x });
            const x = "simple",
              T = "animated";
          },
          4656: (Se, W, a) => {
            "use strict";
            a.d(W, { p: () => d });
            var x = a(5338),
              T = a(4585),
              g = a(6204),
              c = a(3114);
            class d extends x.b {
              constructor(f, s) {
                super(),
                  (this._component = f),
                  (this._frame = 0),
                  (this._sprite = null),
                  (this._spriteAsset = null),
                  (this.spriteAsset = s.spriteAsset),
                  (this.name = s.name),
                  (this.fps = s.fps || 0),
                  (this.loop = s.loop || !1),
                  (this._playing = !1),
                  (this._paused = !1),
                  (this._time = 0);
              }
              get duration() {
                if (this._sprite) {
                  const f = this.fps || Number.MIN_VALUE;
                  return this._sprite.frameKeys.length / Math.abs(f);
                }
                return 0;
              }
              set frame(f) {
                this._setFrame(f);
                const s = this.fps || Number.MIN_VALUE;
                this._setTime(this._frame / s);
              }
              get frame() {
                return this._frame;
              }
              get isPaused() {
                return this._paused;
              }
              get isPlaying() {
                return this._playing;
              }
              set sprite(f) {
                if (
                  (this._sprite &&
                    (this._sprite.off(
                      "set:meshes",
                      this._onSpriteMeshesChange,
                      this
                    ),
                    this._sprite.off(
                      "set:pixelsPerUnit",
                      this._onSpritePpuChanged,
                      this
                    ),
                    this._sprite.off(
                      "set:atlas",
                      this._onSpriteMeshesChange,
                      this
                    ),
                    this._sprite.atlas &&
                      this._sprite.atlas.off(
                        "set:texture",
                        this._onSpriteMeshesChange,
                        this
                      )),
                  (this._sprite = f),
                  this._sprite &&
                    (this._sprite.on(
                      "set:meshes",
                      this._onSpriteMeshesChange,
                      this
                    ),
                    this._sprite.on(
                      "set:pixelsPerUnit",
                      this._onSpritePpuChanged,
                      this
                    ),
                    this._sprite.on(
                      "set:atlas",
                      this._onSpriteMeshesChange,
                      this
                    ),
                    this._sprite.atlas &&
                      this._sprite.atlas.on(
                        "set:texture",
                        this._onSpriteMeshesChange,
                        this
                      )),
                  this._component.currentClip === this)
                ) {
                  let s;
                  !f || !f.atlas
                    ? ((s = this._component._meshInstance),
                      s &&
                        (s.deleteParameter("texture_emissiveMap"),
                        s.deleteParameter("texture_opacityMap")),
                      this._component._hideModel())
                    : (f.atlas.texture &&
                        ((s = this._component._meshInstance),
                        s &&
                          (s.setParameter(
                            "texture_emissiveMap",
                            f.atlas.texture
                          ),
                          s.setParameter(
                            "texture_opacityMap",
                            f.atlas.texture
                          )),
                        this._component.enabled &&
                          this._component.entity.enabled &&
                          this._component._showModel()),
                      this.time && this.fps
                        ? (this.time = this.time)
                        : (this.frame = this.frame));
                }
              }
              get sprite() {
                return this._sprite;
              }
              set spriteAsset(f) {
                const s = this._component.system.app.assets;
                let l = f;
                if ((f instanceof g.x && (l = f.id), this._spriteAsset !== l)) {
                  if (this._spriteAsset) {
                    const n = s.get(this._spriteAsset);
                    n && this._unbindSpriteAsset(n);
                  }
                  if (((this._spriteAsset = l), this._spriteAsset)) {
                    const n = s.get(this._spriteAsset);
                    n
                      ? this._bindSpriteAsset(n)
                      : ((this.sprite = null),
                        s.on(
                          "add:" + this._spriteAsset,
                          this._onSpriteAssetAdded,
                          this
                        ));
                  } else this.sprite = null;
                }
              }
              get spriteAsset() {
                return this._spriteAsset;
              }
              set time(f) {
                this._setTime(f),
                  this._sprite
                    ? (this.frame = Math.min(
                        this._sprite.frameKeys.length - 1,
                        Math.floor(this._time * Math.abs(this.fps))
                      ))
                    : (this.frame = 0);
              }
              get time() {
                return this._time;
              }
              _onSpriteAssetAdded(f) {
                this._component.system.app.assets.off(
                  "add:" + f.id,
                  this._onSpriteAssetAdded,
                  this
                ),
                  this._spriteAsset === f.id && this._bindSpriteAsset(f);
              }
              _bindSpriteAsset(f) {
                f.on("load", this._onSpriteAssetLoad, this),
                  f.on("remove", this._onSpriteAssetRemove, this),
                  f.resource
                    ? this._onSpriteAssetLoad(f)
                    : this._component.system.app.assets.load(f);
              }
              _unbindSpriteAsset(f) {
                f &&
                  (f.off("load", this._onSpriteAssetLoad, this),
                  f.off("remove", this._onSpriteAssetRemove, this),
                  f.resource &&
                    !f.resource.atlas &&
                    this._component.system.app.assets.off(
                      "load:" + f.data.textureAtlasAsset,
                      this._onTextureAtlasLoad,
                      this
                    ));
              }
              _onSpriteAssetLoad(f) {
                if (!f.resource) this.sprite = null;
                else if (f.resource.atlas) this.sprite = f.resource;
                else {
                  const s = f.data.textureAtlasAsset,
                    l = this._component.system.app.assets;
                  l.off("load:" + s, this._onTextureAtlasLoad, this),
                    l.once("load:" + s, this._onTextureAtlasLoad, this);
                }
              }
              _onTextureAtlasLoad(f) {
                const s = this._spriteAsset;
                s instanceof g.x
                  ? this._onSpriteAssetLoad(s)
                  : this._onSpriteAssetLoad(
                      this._component.system.app.assets.get(s)
                    );
              }
              _onSpriteAssetRemove(f) {
                this.sprite = null;
              }
              _onSpriteMeshesChange() {
                this._component.currentClip === this &&
                  this._component._showFrame(this.frame);
              }
              _onSpritePpuChanged() {
                this._component.currentClip === this &&
                  this.sprite.renderMode !== c._r &&
                  this._component._showFrame(this.frame);
              }
              _update(f) {
                if (
                  this.fps === 0 ||
                  !this._playing ||
                  this._paused ||
                  !this._sprite
                )
                  return;
                const s = this.fps < 0 ? -1 : 1,
                  l = this._time + f * this._component.speed * s,
                  n = this.duration,
                  o = l > n || l < 0;
                this._setTime(l);
                let i = this.frame;
                this._sprite
                  ? (i = Math.floor(
                      (this._sprite.frameKeys.length * this._time) / n
                    ))
                  : (i = 0),
                  i !== this._frame && this._setFrame(i),
                  o &&
                    (this.loop
                      ? (this.fire("loop"), this._component.fire("loop", this))
                      : ((this._playing = !1),
                        (this._paused = !1),
                        this.fire("end"),
                        this._component.fire("end", this)));
              }
              _setTime(f) {
                this._time = f;
                const s = this.duration;
                this._time < 0
                  ? this.loop
                    ? (this._time = (this._time % s) + s)
                    : (this._time = 0)
                  : this._time > s &&
                    (this.loop ? (this._time %= s) : (this._time = s));
              }
              _setFrame(f) {
                this._sprite
                  ? (this._frame = T.m.clamp(
                      f,
                      0,
                      this._sprite.frameKeys.length - 1
                    ))
                  : (this._frame = f),
                  this._component.currentClip === this &&
                    this._component._showFrame(this._frame);
              }
              _destroy() {
                if (this._spriteAsset) {
                  const f = this._component.system.app.assets;
                  this._unbindSpriteAsset(f.get(this._spriteAsset));
                }
                this._sprite && (this.sprite = null),
                  this._spriteAsset && (this.spriteAsset = null);
              }
              play() {
                this._playing ||
                  ((this._playing = !0),
                  (this._paused = !1),
                  (this.frame = 0),
                  this.fire("play"),
                  this._component.fire("play", this));
              }
              pause() {
                !this._playing ||
                  this._paused ||
                  ((this._paused = !0),
                  this.fire("pause"),
                  this._component.fire("pause", this));
              }
              resume() {
                this._paused &&
                  ((this._paused = !1),
                  this.fire("resume"),
                  this._component.fire("resume", this));
              }
              stop() {
                this._playing &&
                  ((this._playing = !1),
                  (this._paused = !1),
                  (this._time = 0),
                  (this.frame = 0),
                  this.fire("stop"),
                  this._component.fire("stop", this));
              }
            }
          },
          1485: (Se, W, a) => {
            "use strict";
            a.d(W, { P: () => o });
            var x = a(1367),
              T = a(7921),
              g = a(8869),
              c = a(3114),
              d = a(8944),
              h = a(8620),
              f = a(6813),
              s = a(5425);
            class l {
              constructor() {
                this.enabled = !0;
              }
            }
            const n = ["enabled"];
            class o extends f.Q {
              constructor(e) {
                super(e),
                  (this.id = "sprite"),
                  (this.ComponentType = s.i),
                  (this.DataType = l),
                  (this.schema = n),
                  (this._defaultTexture = null),
                  (this._defaultMaterial = null),
                  (this._default9SlicedMaterialSlicedMode = null),
                  (this._default9SlicedMaterialTiledMode = null),
                  this.app.systems.on("update", this.onUpdate, this),
                  this.on("beforeremove", this.onBeforeRemove, this);
              }
              set defaultMaterial(e) {
                this._defaultMaterial = e;
              }
              get defaultMaterial() {
                if (!this._defaultMaterial) {
                  const e = new g.x(this.app.graphicsDevice, {
                      width: 1,
                      height: 1,
                      format: T.jKI,
                      name: "sprite",
                    }),
                    t = new Uint8Array(e.lock());
                  (t[0] = t[1] = t[2] = t[3] = 255), e.unlock();
                  const r = new d.K();
                  r.diffuse.set(0, 0, 0),
                    r.emissive.set(0.5, 0.5, 0.5),
                    (r.emissiveMap = e),
                    (r.emissiveTint = !0),
                    (r.opacityMap = e),
                    (r.opacityMapChannel = "a"),
                    (r.opacityTint = !0),
                    (r.opacity = 0),
                    (r.useLighting = !1),
                    (r.useGammaTonemap = !1),
                    (r.useFog = !1),
                    (r.useSkybox = !1),
                    (r.blendType = c.yp),
                    (r.depthWrite = !1),
                    (r.pixelSnap = !1),
                    (r.cull = T.OL2),
                    r.update(),
                    (this._defaultTexture = e),
                    (this._defaultMaterial = r);
                }
                return this._defaultMaterial;
              }
              set default9SlicedMaterialSlicedMode(e) {
                this._default9SlicedMaterialSlicedMode = e;
              }
              get default9SlicedMaterialSlicedMode() {
                if (!this._default9SlicedMaterialSlicedMode) {
                  const e = this.defaultMaterial.clone();
                  (e.nineSlicedMode = c.ei),
                    e.update(),
                    (this._default9SlicedMaterialSlicedMode = e);
                }
                return this._default9SlicedMaterialSlicedMode;
              }
              set default9SlicedMaterialTiledMode(e) {
                this._default9SlicedMaterialTiledMode = e;
              }
              get default9SlicedMaterialTiledMode() {
                if (!this._default9SlicedMaterialTiledMode) {
                  const e = this.defaultMaterial.clone();
                  (e.nineSlicedMode = c.DD),
                    e.update(),
                    (this._default9SlicedMaterialTiledMode = e);
                }
                return this._default9SlicedMaterialTiledMode;
              }
              destroy() {
                super.destroy(),
                  this.app.systems.off("update", this.onUpdate, this),
                  this._defaultTexture &&
                    (this._defaultTexture.destroy(),
                    (this._defaultTexture = null));
              }
              initializeComponentData(e, t, r) {
                if (
                  (t.enabled !== void 0 && (e.enabled = t.enabled),
                  (e.type = t.type),
                  t.layers &&
                    Array.isArray(t.layers) &&
                    (e.layers = t.layers.slice(0)),
                  t.drawOrder !== void 0 && (e.drawOrder = t.drawOrder),
                  t.color !== void 0)
                ) {
                  if (t.color instanceof x.I) {
                    var u;
                    e.color.set(
                      t.color.r,
                      t.color.g,
                      t.color.b,
                      (u = t.opacity) != null ? u : 1
                    );
                  } else {
                    var y;
                    e.color.set(
                      t.color[0],
                      t.color[1],
                      t.color[2],
                      (y = t.opacity) != null ? y : 1
                    );
                  }
                  e.color = e.color;
                }
                if (
                  (t.opacity !== void 0 && (e.opacity = t.opacity),
                  t.flipX !== void 0 && (e.flipX = t.flipX),
                  t.flipY !== void 0 && (e.flipY = t.flipY),
                  t.width !== void 0 && (e.width = t.width),
                  t.height !== void 0 && (e.height = t.height),
                  t.spriteAsset !== void 0 && (e.spriteAsset = t.spriteAsset),
                  t.sprite && (e.sprite = t.sprite),
                  t.frame !== void 0 && (e.frame = t.frame),
                  t.clips)
                )
                  for (const p in t.clips) e.addClip(t.clips[p]);
                t.speed !== void 0 && (e.speed = t.speed),
                  t.autoPlayClip && (e.autoPlayClip = t.autoPlayClip),
                  (e.batchGroupId =
                    t.batchGroupId === void 0 || t.batchGroupId === null
                      ? -1
                      : t.batchGroupId),
                  super.initializeComponentData(e, t, r);
              }
              cloneComponent(e, t) {
                const r = e.sprite;
                return this.addComponent(t, {
                  enabled: r.enabled,
                  type: r.type,
                  spriteAsset: r.spriteAsset,
                  sprite: r.sprite,
                  frame: r.frame,
                  color: r.color.clone(),
                  opacity: r.opacity,
                  flipX: r.flipX,
                  flipY: r.flipY,
                  speed: r.speed,
                  clips: r.clips,
                  autoPlayClip: r.autoPlayClip,
                  batchGroupId: r.batchGroupId,
                  drawOrder: r.drawOrder,
                  layers: r.layers.slice(0),
                });
              }
              onUpdate(e) {
                const t = this.store;
                for (const r in t)
                  if (t.hasOwnProperty(r)) {
                    const u = t[r];
                    if (u.data.enabled && u.entity.enabled) {
                      const y = u.entity.sprite;
                      y._currentClip && y._currentClip._update(e);
                    }
                  }
              }
              onBeforeRemove(e, t) {
                t.onDestroy();
              }
            }
            h.w._buildAccessors(s.i.prototype, n);
          },
          6813: (Se, W, a) => {
            "use strict";
            a.d(W, { Q: () => h });
            var x = a(5338),
              T = a(1367),
              g = a(2978),
              c = a(6556),
              d = a(6630);
            class h extends x.b {
              constructor(l) {
                super(), (this.app = l), (this.store = {}), (this.schema = []);
              }
              addComponent(l, n = {}) {
                const o = new this.ComponentType(this, l),
                  i = new this.DataType();
                return (
                  (this.store[l.getGuid()] = { entity: l, data: i }),
                  (l[this.id] = o),
                  (l.c[this.id] = o),
                  this.initializeComponentData(o, n, []),
                  this.fire("add", l, o),
                  o
                );
              }
              removeComponent(l) {
                const n = this.store[l.getGuid()],
                  o = l.c[this.id];
                this.fire("beforeremove", l, o),
                  delete this.store[l.getGuid()],
                  (l[this.id] = void 0),
                  delete l.c[this.id],
                  this.fire("remove", l, n.data);
              }
              cloneComponent(l, n) {
                const o = this.store[l.getGuid()];
                return this.addComponent(n, o.data);
              }
              initializeComponentData(l, n = {}, o) {
                for (let i = 0, e = o.length; i < e; i++) {
                  const t = o[i];
                  let r, u;
                  typeof t == "object"
                    ? ((r = t.name), (u = t.type))
                    : ((r = t), (u = void 0));
                  let y = n[r];
                  y !== void 0
                    ? (u !== void 0 && (y = f(y, u)), (l[r] = y))
                    : (l[r] = l.data[r]);
                }
                l.enabled && l.entity.enabled && l.onEnable();
              }
              getPropertiesOfType(l) {
                const n = [];
                return (
                  (this.schema || []).forEach(function (i) {
                    i && typeof i == "object" && i.type === l && n.push(i);
                  }),
                  n
                );
              }
              destroy() {
                this.off();
              }
            }
            function f(s, l) {
              if (!s) return s;
              switch (l) {
                case "rgb":
                  return s instanceof T.I
                    ? s.clone()
                    : new T.I(s[0], s[1], s[2]);
                case "rgba":
                  return s instanceof T.I
                    ? s.clone()
                    : new T.I(s[0], s[1], s[2], s[3]);
                case "vec2":
                  return s instanceof g.S ? s.clone() : new g.S(s[0], s[1]);
                case "vec3":
                  return s instanceof c.A
                    ? s.clone()
                    : new c.A(s[0], s[1], s[2]);
                case "vec4":
                  return s instanceof d.T
                    ? s.clone()
                    : new d.T(s[0], s[1], s[2], s[3]);
                case "boolean":
                case "number":
                case "string":
                  return s;
                case "entity":
                  return s;
                default:
                  throw new Error("Could not convert unhandled type: " + l);
              }
            }
          },
          9521: (Se, W, a) => {
            "use strict";
            a.d(W, { k: () => g });
            var x = a(6556),
              T = a(8620);
            class g extends T.w {
              constructor(d, h) {
                super(d, h),
                  (this._oldState = !0),
                  (this._size = new x.A()),
                  this.on("set_enabled", this._onSetEnabled, this);
              }
              set size(d) {
                d instanceof x.A
                  ? this._size.copy(d)
                  : d instanceof Array &&
                    d.length >= 3 &&
                    this.size.set(d[0], d[1], d[2]);
              }
              get size() {
                return this._size;
              }
              onEnable() {
                this._checkState();
              }
              onDisable() {
                this._checkState();
              }
              _onSetEnabled(d, h, f) {
                this._checkState();
              }
              _checkState() {
                const d = this.enabled && this.entity.enabled;
                d !== this._oldState &&
                  ((this._oldState = d),
                  this.fire("enable"),
                  this.fire("state", this.enabled));
              }
              _onBeforeRemove() {
                this.fire("remove");
              }
            }
          },
          5441: (Se, W, a) => {
            "use strict";
            a.d(W, { x: () => f });
            var x = a(6556),
              T = a(8620),
              g = a(6813),
              c = a(9521);
            class d {
              constructor() {
                this.enabled = !0;
              }
            }
            const h = ["enabled"];
            class f extends g.Q {
              constructor(l) {
                super(l),
                  (this.id = "zone"),
                  (this.ComponentType = c.k),
                  (this.DataType = d),
                  (this.schema = h),
                  this.on("beforeremove", this._onBeforeRemove, this);
              }
              initializeComponentData(l, n, o) {
                (l.enabled = n.hasOwnProperty("enabled") ? !!n.enabled : !0),
                  n.size &&
                    (n.size instanceof x.A
                      ? l.size.copy(n.size)
                      : n.size instanceof Array &&
                        n.size.length >= 3 &&
                        l.size.set(n.size[0], n.size[1], n.size[2]));
              }
              cloneComponent(l, n) {
                const o = { size: l.zone.size };
                return this.addComponent(n, o);
              }
              _onBeforeRemove(l, n) {
                n._onBeforeRemove();
              }
            }
            T.w._buildAccessors(c.k.prototype, h);
          },
          8713: (Se, W, a) => {
            "use strict";
            a.d(W, {
              DP: () => x,
              Qb: () => T,
              Qd: () => c,
              Qx: () => d,
              Wx: () => g,
            });
            const x = "NONE",
              T = "FILL_WINDOW",
              g = "KEEP_ASPECT",
              c = "AUTO",
              d = "FIXED";
          },
          258: (Se, W, a) => {
            "use strict";
            a.d(W, { J: () => d });
            var x = a(6724),
              T = a(7915),
              g = a(4355);
            const c = [];
            class d extends T.A {
              constructor(s, l = (0, g.i)()) {
                super(s),
                  (this.anim = void 0),
                  (this.animation = void 0),
                  (this.audiolistener = void 0),
                  (this.button = void 0),
                  (this.camera = void 0),
                  (this.collision = void 0),
                  (this.element = void 0),
                  (this.layoutchild = void 0),
                  (this.layoutgroup = void 0),
                  (this.light = void 0),
                  (this.model = void 0),
                  (this.particlesystem = void 0),
                  (this.render = void 0),
                  (this.rigidbody = void 0),
                  (this.screen = void 0),
                  (this.script = void 0),
                  (this.scrollbar = void 0),
                  (this.scrollview = void 0),
                  (this.sound = void 0),
                  (this.sprite = void 0),
                  (this.c = {}),
                  (this._app = void 0),
                  (this._destroying = !1),
                  (this._guid = null),
                  (this._template = !1),
                  (this._app = l);
              }
              addComponent(s, l) {
                const n = this._app.systems[s];
                return !n || this.c[s] ? null : n.addComponent(this, l);
              }
              removeComponent(s) {
                const l = this._app.systems[s];
                l && this.c[s] && l.removeComponent(this);
              }
              findComponent(s) {
                const l = this.findOne(function (n) {
                  return n.c && n.c[s];
                });
                return l && l.c[s];
              }
              findComponents(s) {
                return this.find(function (n) {
                  return n.c && n.c[s];
                }).map(function (n) {
                  return n.c[s];
                });
              }
              getGuid() {
                return this._guid || this.setGuid(x.M.create()), this._guid;
              }
              setGuid(s) {
                const l = this._app._entityIndex;
                this._guid && delete l[this._guid],
                  (this._guid = s),
                  (l[this._guid] = this);
              }
              _notifyHierarchyStateChanged(s, l) {
                let n = !1;
                s === this && c.length === 0 && (n = !0),
                  (s._beingEnabled = !0),
                  s._onHierarchyStateChanged(l),
                  s._onHierarchyStatePostChanged && c.push(s);
                const o = s._children;
                for (let i = 0, e = o.length; i < e; i++)
                  o[i]._enabled && this._notifyHierarchyStateChanged(o[i], l);
                if (((s._beingEnabled = !1), n)) {
                  for (let i = 0; i < c.length; i++)
                    c[i]._onHierarchyStatePostChanged();
                  c.length = 0;
                }
              }
              _onHierarchyStateChanged(s) {
                super._onHierarchyStateChanged(s);
                const l = this.c;
                for (const n in l)
                  if (l.hasOwnProperty(n)) {
                    const o = l[n];
                    o.enabled && (s ? o.onEnable() : o.onDisable());
                  }
              }
              _onHierarchyStatePostChanged() {
                const s = this.c;
                for (const l in s)
                  s.hasOwnProperty(l) && s[l].onPostStateChange();
              }
              findByGuid(s) {
                if (this._guid === s) return this;
                const l = this._app._entityIndex[s];
                return l && (l === this || l.isDescendantOf(this)) ? l : null;
              }
              destroy() {
                this._destroying = !0;
                for (const s in this.c) this.c[s].enabled = !1;
                for (const s in this.c) this.c[s].system.removeComponent(this);
                super.destroy(),
                  this._guid && delete this._app._entityIndex[this._guid],
                  (this._destroying = !1);
              }
              clone() {
                const s = {},
                  l = this._cloneRecursively(s);
                return (s[this.getGuid()] = l), h(this, this, l, s), l;
              }
              _cloneRecursively(s) {
                const l = new this.constructor(void 0, this._app);
                super._cloneInternal(l);
                for (const n in this.c)
                  this.c[n].system.cloneComponent(this, l);
                for (let n = 0; n < this._children.length; n++) {
                  const o = this._children[n];
                  if (o instanceof d) {
                    const i = o._cloneRecursively(s);
                    l.addChild(i), (s[o.getGuid()] = i);
                  }
                }
                return l;
              }
            }
            function h(f, s, l, n) {
              if (s instanceof d) {
                const o = s.c;
                for (const t in o) {
                  const r = o[t],
                    u = r.system.getPropertiesOfType("entity");
                  for (let y = 0, p = u.length; y < p; y++) {
                    const m = u[y].name,
                      E = r[m];
                    if (!!f.findByGuid(E)) {
                      const P = n[E].getGuid();
                      P && (l.c[t][m] = P);
                    }
                  }
                }
                o.script &&
                  !l._app.useLegacyScriptAttributeCloning &&
                  l.script.resolveDuplicatedEntityReferenceProperties(
                    o.script,
                    n
                  ),
                  o.render &&
                    l.render.resolveDuplicatedEntityReferenceProperties(
                      o.render,
                      n
                    ),
                  o.anim &&
                    l.anim.resolveDuplicatedEntityReferenceProperties(
                      o.anim,
                      n
                    );
                const i = s.children.filter(function (t) {
                    return t instanceof d;
                  }),
                  e = l.children.filter(function (t) {
                    return t instanceof d;
                  });
                for (let t = 0, r = i.length; t < r; t++) h(f, i[t], e[t], n);
              }
            }
          },
          5611: (Se, W, a) => {
            "use strict";
            a.d(W, { E: () => x, M: () => T });
            const x = "msdf",
              T = "bitmap";
          },
          2794: (Se, W, a) => {
            "use strict";
            a.d(W, { Z: () => T });
            var x = a(5611);
            class T {
              constructor(c, d) {
                (this.type = (d && d.type) || x.E),
                  (this.em = 1),
                  (this.textures = c),
                  (this.intensity = 0),
                  (this._data = null),
                  (this.data = d);
              }
              set data(c) {
                if (
                  ((this._data = c),
                  !!c &&
                    (this._data.intensity !== void 0 &&
                      (this.intensity = this._data.intensity),
                    this._data.info || (this._data.info = {}),
                    (!this._data.version || this._data.version < 2) &&
                      ((this._data.info.maps = [
                        {
                          width: this._data.info.width,
                          height: this._data.info.height,
                        },
                      ]),
                      this._data.chars)))
                )
                  for (const d in this._data.chars) this._data.chars[d].map = 0;
              }
              get data() {
                return this._data;
              }
            }
          },
          4355: (Se, W, a) => {
            "use strict";
            a.d(W, { b: () => c, i: () => g });
            var x = a(7982);
            let T;
            function g() {
              return T;
            }
            function c(d) {
              (T = d), x.j.set(d == null ? void 0 : d.graphicsDevice);
            }
          },
          6604: (Se, W, a) => {
            "use strict";
            a.d(W, { c: () => u });
            var x = a(1367),
              T = a(7921),
              g = a(4738),
              c = a(3412),
              d = a(8869),
              h = a(3114),
              f = a(6165),
              s = a(8792),
              l = a(7934),
              n = a(6462),
              o = a(4355),
              i = a(258),
              e = a(8277);
            const t = new Set(),
              r = { depth: 1, flags: T.zk9 };
            class u {
              constructor(p, _, m) {
                (this.renderTarget = null),
                  p instanceof g.$ && (p = (0, o.i)()),
                  (this.app = p),
                  (this.device = p.graphicsDevice),
                  (this.pickColor = new Float32Array(4)),
                  (this.pickColor[3] = 1),
                  (this.mapping = []),
                  (this.cameraEntity = null),
                  (this.layer = null),
                  (this.layerComp = null),
                  this.initLayerComposition();
                const E = this.device;
                (this.clearDepthCommand = new s.m(0, 0, function () {
                  E.clear(r);
                })),
                  (this.width = 0),
                  (this.height = 0),
                  this.resize(_, m);
              }
              getSelection(p, _, m, E) {
                const v = this.device;
                if (typeof p == "object") {
                  const C = p;
                  (p = C.x), (_ = C.y), (m = C.width), (E = C.height);
                } else _ = this.renderTarget.height - (_ + (E || 1));
                (p = Math.floor(p)),
                  (_ = Math.floor(_)),
                  (m = Math.floor(Math.max(m || 1, 1))),
                  (E = Math.floor(Math.max(E || 1, 1)));
                const P = v.renderTarget;
                v.setRenderTarget(this.renderTarget), v.updateBegin();
                const I = new Uint8Array(4 * m * E);
                v.readPixels(p, _, m, E, I),
                  v.updateEnd(),
                  v.setRenderTarget(P);
                const A = this.mapping;
                for (let C = 0; C < m * E; C++) {
                  const w = I[4 * C + 0],
                    k = I[4 * C + 1],
                    K = I[4 * C + 2],
                    te = (w << 16) | (k << 8) | K;
                  te !== 16777215 && t.add(A[te]);
                }
                const B = [];
                return t.forEach((C) => B.push(C)), t.clear(), B;
              }
              allocateRenderTarget() {
                const p = new d.x(this.device, {
                  format: T.jKI,
                  width: this.width,
                  height: this.height,
                  mipmaps: !1,
                  minFilter: T.yib,
                  magFilter: T.yib,
                  addressU: T.uFb,
                  addressV: T.uFb,
                  name: "pick",
                });
                this.renderTarget = new c.A({ colorBuffer: p, depth: !0 });
              }
              releaseRenderTarget() {
                (this.cameraEntity.camera.renderTarget = null),
                  this.renderTarget &&
                    (this.renderTarget.destroyTextureBuffers(),
                    this.renderTarget.destroy(),
                    (this.renderTarget = null));
              }
              initLayerComposition() {
                const p = this.device,
                  _ = this,
                  m = p.scope.resolve("uColor");
                (this.cameraEntity = new i.J()),
                  this.cameraEntity.addComponent("camera"),
                  (this.layer = new l.m({
                    name: "Picker",
                    shaderPass: h.WW,
                    opaqueSortMode: h.sB,
                    onDrawCall: function (E, v) {
                      (_.pickColor[0] = ((v >> 16) & 255) / 255),
                        (_.pickColor[1] = ((v >> 8) & 255) / 255),
                        (_.pickColor[2] = (v & 255) / 255),
                        m.setValue(_.pickColor),
                        p.setBlendState(e.a.NOBLEND),
                        (_.mapping[v] = E);
                    },
                  })),
                  this.layer.addCamera(this.cameraEntity.camera),
                  (this.layerComp = new n.d("picker")),
                  this.layerComp.pushOpaque(this.layer);
              }
              prepare(p, _, m) {
                p instanceof f.V && (p = p.node.camera),
                  m instanceof l.m && (m = [m]),
                  this.layer.clearMeshInstances();
                const E = this.layer.opaqueMeshInstances,
                  v = _.layers.layerList,
                  P = _.layers.subLayerEnabled,
                  I = _.layers.subLayerList;
                for (let A = 0; A < v.length; A++) {
                  const B = v[A];
                  if (
                    !(m && m.indexOf(B) < 0) &&
                    B.enabled &&
                    P[A] &&
                    B.cameras.indexOf(p) >= 0
                  ) {
                    B._clearDepthBuffer && E.push(this.clearDepthCommand);
                    const w = I[A]
                      ? B.instances.transparentMeshInstances
                      : B.instances.opaqueMeshInstances;
                    for (let k = 0; k < w.length; k++) {
                      const K = w[k];
                      K.pick && E.push(K);
                    }
                  }
                }
                (!this.renderTarget ||
                  this.width !== this.renderTarget.width ||
                  this.height !== this.renderTarget.height) &&
                  (this.releaseRenderTarget(), this.allocateRenderTarget()),
                  this.updateCamera(p),
                  (this.mapping.length = 0),
                  this.app.renderComposition(this.layerComp);
              }
              updateCamera(p) {
                this.cameraEntity.copy(p.entity),
                  (this.cameraEntity.name = "PickerCamera");
                const _ = this.cameraEntity.camera;
                _.copy(p),
                  (_.clearColorBuffer = !0),
                  (_.clearDepthBuffer = !0),
                  (_.clearStencilBuffer = !0),
                  (_.clearColor = x.I.WHITE),
                  (_.renderTarget = this.renderTarget),
                  this.layer.clearCameras(),
                  this.layer.addCamera(_),
                  (_.layers = [this.layer.id]);
              }
              resize(p, _) {
                (this.width = Math.floor(p)), (this.height = Math.floor(_));
              }
            }
          },
          5229: (Se, W, a) => {
            "use strict";
            a.d(W, { m: () => d });
            var x = a(1467),
              T = a(7061),
              g = a(3248),
              c = a(8949);
            class d {
              constructor(f) {
                (this.handlerType = "animclip"), (this.maxRetries = 0);
              }
              load(f, s) {
                typeof f == "string" && (f = { load: f, original: f });
                const l = {
                  retry: this.maxRetries > 0,
                  maxRetries: this.maxRetries,
                };
                f.load.startsWith("blob:") &&
                  (l.responseType = x.e.ResponseType.JSON),
                  x.d.get(f.load, l, function (n, o) {
                    n
                      ? s(
                          `Error loading animation clip resource: ${f.original} [${n}]`
                        )
                      : s(null, o);
                  });
              }
              open(f, s) {
                const l = s.name,
                  n = s.duration,
                  o = s.inputs.map(function (t) {
                    return new g.X(1, t);
                  }),
                  i = s.outputs.map(function (t) {
                    return new g.X(t.components, t.data);
                  }),
                  e = s.curves.map(function (t) {
                    return new T.c(
                      [t.path],
                      t.inputIndex,
                      t.outputIndex,
                      t.interpolation
                    );
                  });
                return new c.k(l, n, o, i, e);
              }
              patch(f, s) {}
            }
          },
          6706: (Se, W, a) => {
            "use strict";
            a.d(W, { O: () => g });
            var x = a(1467),
              T = a(6608);
            class g {
              constructor(d) {
                (this.handlerType = "animstategraph"), (this.maxRetries = 0);
              }
              load(d, h) {
                typeof d == "string" && (d = { load: d, original: d });
                const f = {
                  retry: this.maxRetries > 0,
                  maxRetries: this.maxRetries,
                };
                d.load.startsWith("blob:") &&
                  (f.responseType = x.e.ResponseType.JSON),
                  x.d.get(d.load, f, function (s, l) {
                    s
                      ? h(
                          `Error loading animation state graph resource: ${d.original} [${s}]`
                        )
                      : h(null, l);
                  });
              }
              open(d, h) {
                return new T.Z(h);
              }
              patch(d, h) {}
            }
          },
          1257: (Se, W, a) => {
            "use strict";
            a.d(W, { n: () => s });
            var x = a(9296),
              T = a(6847),
              g = a(6556),
              c = a(1467),
              d = a(8451),
              h = a(2761),
              f = a(5768);
            class s {
              constructor(n) {
                (this.handlerType = "animation"),
                  (this.device = n.graphicsDevice),
                  (this.assets = n.assets),
                  (this.maxRetries = 0);
              }
              load(n, o, i) {
                typeof n == "string" && (n = { load: n, original: n });
                const e = {
                  retry: this.maxRetries > 0,
                  maxRetries: this.maxRetries,
                };
                (n.load.startsWith("blob:") || n.load.startsWith("data:")) &&
                  (x.E.getExtension(n.original).toLowerCase() === ".glb"
                    ? (e.responseType = c.e.ResponseType.ARRAY_BUFFER)
                    : (e.responseType = c.e.ResponseType.JSON)),
                  c.d.get(n.load, e, (t, r) => {
                    if (t)
                      o(
                        `Error loading animation resource: ${n.original} [${t}]`
                      );
                    else if (
                      x.E.getExtension(n.original).toLowerCase() === ".glb"
                    ) {
                      var u;
                      f.Z.parse(
                        "filename.glb",
                        "",
                        r,
                        this.device,
                        this.assets,
                        (u = i == null ? void 0 : i.options) != null ? u : {},
                        (y, p) => {
                          if (y) o(y);
                          else {
                            var _;
                            const m = p.animations;
                            if (i != null && (_ = i.data) != null && _.events)
                              for (let E = 0; E < m.length; E++)
                                m[E].events = new h.D(
                                  Object.values(i.data.events)
                                );
                            p.destroy(), o(null, m);
                          }
                        }
                      );
                    } else
                      o(
                        null,
                        this["_parseAnimationV" + r.animation.version](r)
                      );
                  });
              }
              open(n, o, i) {
                return o;
              }
              patch(n, o) {}
              _parseAnimationV3(n) {
                const o = n.animation,
                  i = new d.fw();
                (i.name = o.name), (i.duration = o.duration);
                for (let e = 0; e < o.nodes.length; e++) {
                  const t = new d.NB(),
                    r = o.nodes[e];
                  t._name = r.name;
                  for (let u = 0; u < r.keys.length; u++) {
                    const y = r.keys[u],
                      p = y.time,
                      _ = y.pos,
                      m = y.rot,
                      E = y.scale,
                      v = new g.A(_[0], _[1], _[2]),
                      P = new T.D().setFromEulerAngles(m[0], m[1], m[2]),
                      I = new g.A(E[0], E[1], E[2]),
                      A = new d.sr(p, v, P, I);
                    t._keys.push(A);
                  }
                  i.addNode(t);
                }
                return i;
              }
              _parseAnimationV4(n) {
                const o = n.animation,
                  i = new d.fw();
                (i.name = o.name), (i.duration = o.duration);
                for (let e = 0; e < o.nodes.length; e++) {
                  const t = new d.NB(),
                    r = o.nodes[e];
                  t._name = r.name;
                  const u = r.defaults.p,
                    y = r.defaults.r,
                    p = r.defaults.s;
                  for (let _ = 0; _ < r.keys.length; _++) {
                    const m = r.keys[_],
                      E = m.t,
                      v = u || m.p,
                      P = y || m.r,
                      I = p || m.s,
                      A = new g.A(v[0], v[1], v[2]),
                      B = new T.D().setFromEulerAngles(P[0], P[1], P[2]),
                      C = new g.A(I[0], I[1], I[2]),
                      w = new d.sr(E, A, B, C);
                    t._keys.push(w);
                  }
                  i.addNode(t);
                }
                return i;
              }
            }
          },
          8652: (Se, W, a) => {
            "use strict";
            a.d(W, { Z: () => f });
            var x = a(9296),
              T = a(1467),
              g = a(2100),
              c = a(9095);
            const d = (function () {
                if (typeof window == "undefined") return !1;
                const s = window.navigator.userAgent,
                  l = s.indexOf("MSIE ");
                if (l > 0)
                  return parseInt(s.substring(l + 5, s.indexOf(".", l)), 10);
                if (s.indexOf("Trident/") > 0) {
                  const o = s.indexOf("rv:");
                  return parseInt(s.substring(o + 3, s.indexOf(".", o)), 10);
                }
                return !1;
              })(),
              h = [
                ".ogg",
                ".mp3",
                ".wav",
                ".mp4a",
                ".m4a",
                ".mp4",
                ".aac",
                ".opus",
              ];
            class f {
              constructor(l) {
                (this.handlerType = "audio"),
                  (this.manager = l.soundManager),
                  (this.maxRetries = 0);
              }
              _isSupported(l) {
                const n = x.E.getExtension(l);
                return h.indexOf(n) > -1;
              }
              load(l, n) {
                typeof l == "string" && (l = { load: l, original: l });
                const o = function (t) {
                    n(null, new c.$(t));
                  },
                  i = function (t) {
                    let r = "Error loading audio url: " + l.original;
                    t && (r += ": " + (t.message || t)), console.warn(r), n(r);
                  };
                if (this._createSound) {
                  if (!this._isSupported(l.original)) {
                    i(`Audio format for ${l.original} not supported`);
                    return;
                  }
                  this._createSound(l.load, o, i);
                } else i(null);
              }
              open(l, n) {
                return n;
              }
              patch(l, n) {}
              _createSound(l, n, o) {
                if ((0, g.b)()) {
                  const i = this.manager;
                  if (!i.context) {
                    o("Audio manager has no audio context");
                    return;
                  }
                  const e = {
                    retry: this.maxRetries > 0,
                    maxRetries: this.maxRetries,
                  };
                  (l.startsWith("blob:") || l.startsWith("data:")) &&
                    (e.responseType = T.e.ResponseType.ARRAY_BUFFER),
                    T.d.get(l, e, function (t, r) {
                      if (t) {
                        o(t);
                        return;
                      }
                      i.context.decodeAudioData(r, n, o);
                    });
                } else {
                  let i = null;
                  try {
                    i = new Audio();
                  } catch (t) {
                    o("No support for Audio element");
                    return;
                  }
                  d && document.body.appendChild(i);
                  const e = function t() {
                    i.removeEventListener("canplaythrough", t),
                      d && document.body.removeChild(i),
                      n(i);
                  };
                  (i.onerror = function () {
                    (i.onerror = null), d && document.body.removeChild(i), o();
                  }),
                    i.addEventListener("canplaythrough", e),
                    (i.src = l);
                }
              }
            }
          },
          3009: (Se, W, a) => {
            "use strict";
            a.d(W, { h: () => u, f: () => p });
            var x = a(8391),
              T = a(7921);
            function g() {
              const _ = {
                  cTFETC1: 0,
                  cTFETC2: 1,
                  cTFBC1: 2,
                  cTFBC3: 3,
                  cTFPVRTC1_4_RGB: 8,
                  cTFPVRTC1_4_RGBA: 9,
                  cTFASTC_4x4: 10,
                  cTFATC_RGB: 11,
                  cTFATC_RGBA_INTERPOLATED_ALPHA: 12,
                  cTFRGBA32: 13,
                  cTFRGB565: 14,
                  cTFRGBA4444: 16,
                },
                m = {
                  astc: _.cTFASTC_4x4,
                  dxt: _.cTFBC1,
                  etc1: _.cTFETC1,
                  etc2: _.cTFETC1,
                  pvr: _.cTFPVRTC1_4_RGB,
                  atc: _.cTFATC_RGB,
                  none: _.cTFRGB565,
                },
                E = {
                  astc: _.cTFASTC_4x4,
                  dxt: _.cTFBC3,
                  etc1: _.cTFRGBA4444,
                  etc2: _.cTFETC2,
                  pvr: _.cTFPVRTC1_4_RGBA,
                  atc: _.cTFATC_RGBA_INTERPOLATED_ALPHA,
                  none: _.cTFRGBA4444,
                },
                v = {
                  ETC1: 21,
                  ETC2_RGB: 22,
                  ETC2_RGBA: 23,
                  DXT1: 8,
                  DXT5: 10,
                  PVRTC_4BPP_RGB_1: 26,
                  PVRTC_4BPP_RGBA_1: 27,
                  ASTC_4x4: 28,
                  ATC_RGB: 29,
                  ATC_RGBA: 30,
                  R8_G8_B8_A8: 7,
                  R5_G6_B5: 3,
                  R4_G4_B4_A4: 5,
                },
                P = (O, me) => {
                  switch (O) {
                    case _.cTFETC1:
                      return me.formats.etc1 ? v.ETC1 : v.ETC2_RGB;
                    case _.cTFETC2:
                      return v.ETC2_RGBA;
                    case _.cTFBC1:
                      return v.DXT1;
                    case _.cTFBC3:
                      return v.DXT5;
                    case _.cTFPVRTC1_4_RGB:
                      return v.PVRTC_4BPP_RGB_1;
                    case _.cTFPVRTC1_4_RGBA:
                      return v.PVRTC_4BPP_RGBA_1;
                    case _.cTFASTC_4x4:
                      return v.ASTC_4x4;
                    case _.cTFATC_RGB:
                      return v.ATC_RGB;
                    case _.cTFATC_RGBA_INTERPOLATED_ALPHA:
                      return v.ATC_RGBA;
                    case _.cTFRGBA32:
                      return v.R8_G8_B8_A8;
                    case _.cTFRGB565:
                      return v.R5_G6_B5;
                    case _.cTFRGBA4444:
                      return v.R4_G4_B4_A4;
                  }
                },
                I = (O) => {
                  const me = function (V, L) {
                    const J = V * 0.00784313725490196 - 1,
                      ae = L * (2 / 255) - 1,
                      R = Math.sqrt(1 - Math.min(1, J * J + ae * ae));
                    return Math.max(
                      0,
                      Math.min(255, Math.floor((R + 1) * 0.5 * 255))
                    );
                  };
                  for (let N = 0; N < O.length; N += 4) {
                    const V = O[N + 3],
                      L = O[N + 1];
                    (O[N + 0] = V), (O[N + 2] = me(V, L)), (O[N + 3] = 255);
                  }
                  return O;
                },
                A = (O) => {
                  const me = new Uint16Array(O.length / 4);
                  for (let N = 0; N < O.length; N += 4) {
                    const V = O[N + 0],
                      L = O[N + 1],
                      J = O[N + 2];
                    me[N / 4] = ((V & 248) << 8) | ((L & 252) << 3) | (J >> 3);
                  }
                  return me;
                },
                B = (O, me) => (O & (O - 1)) === 0 && (me & (me - 1)) === 0,
                C = () =>
                  typeof performance != "undefined" ? performance.now() : 0;
              let w, k, K;
              const te = (O, me, N) => {
                  if (N) {
                    if (O.formats.astc) return "astc";
                  } else if (me) {
                    if (O.formats.etc2) return "etc2";
                  } else if (O.formats.etc1 || O.formats.etc2) return "etc1";
                  return ((L) => {
                    for (let J = 0; J < L.length; ++J) {
                      const ae = L[J];
                      if (O.formats[ae]) return ae;
                    }
                    return "none";
                  })(me ? K : k);
                },
                X = (O, me, N, V) => {
                  switch (N) {
                    case _.cTFETC1:
                    case _.cTFETC2:
                      return !0;
                    case _.cTFBC1:
                    case _.cTFBC3:
                      return (O & 3) === 0 && (me & 3) === 0;
                    case _.cTFPVRTC1_4_RGB:
                    case _.cTFPVRTC1_4_RGBA:
                      return B(O, me) && (O === me || V);
                    case _.cTFASTC_4x4:
                      return !0;
                    case _.cTFATC_RGB:
                    case _.cTFATC_RGBA_INTERPOLATED_ALPHA:
                      return !0;
                  }
                },
                $ = (O, me, N) => {
                  if (!w.KTX2File)
                    throw new Error(
                      "Basis transcoder module does not include support for KTX2."
                    );
                  const V = C(),
                    L = new w.KTX2File(new Uint8Array(me)),
                    J = L.getWidth(),
                    ae = L.getHeight(),
                    R = L.getLevels(),
                    j = !!L.getHasAlpha(),
                    se = L.isUASTC && L.isUASTC();
                  if (!J || !ae || !R)
                    throw (
                      (L.close(),
                      L.delete(),
                      new Error(
                        `Invalid image dimensions url=${O} width=${J} height=${ae} levels=${R}`
                      ))
                    );
                  const ce = te(N.deviceDetails, j, se),
                    ie = !!N.isGGGR && ce === "pvr";
                  let b;
                  if (
                    (ie
                      ? (b = _.cTFRGBA32)
                      : ((b = j ? E[ce] : m[ce]),
                        X(J, ae, b, N.deviceDetails.webgl2) ||
                          (b = j ? _.cTFRGBA32 : _.cTFRGB565)),
                    !L.startTranscoding())
                  )
                    throw (
                      (L.close(),
                      L.delete(),
                      new Error("Failed to start transcoding url=" + O))
                    );
                  let M;
                  const F = [];
                  for (let z = 0; z < R; ++z) {
                    const oe = L.getImageTranscodedSizeInBytes(z, 0, 0, b),
                      de = new Uint8Array(oe);
                    if (!L.transcodeImage(de, z, 0, 0, b, 0, -1, -1))
                      throw (
                        (L.close(),
                        L.delete(),
                        new Error("Failed to transcode image url=" + O))
                      );
                    const ge = b === _.cTFRGB565 || b === _.cTFRGBA4444;
                    F.push(ge ? new Uint16Array(de.buffer) : de);
                  }
                  if ((L.close(), L.delete(), ie))
                    for (b = _.cTFRGB565, M = 0; M < F.length; ++M)
                      F[M] = A(I(F[M]));
                  return {
                    format: P(b, N.deviceDetails),
                    width: J,
                    height: ae,
                    levels: F,
                    cubemap: !1,
                    transcodeTime: C() - V,
                    url: O,
                    unswizzledGGGR: ie,
                  };
                },
                ne = (O, me, N) => {
                  const V = C(),
                    L = new w.BasisFile(new Uint8Array(me)),
                    J = L.getImageWidth(0, 0),
                    ae = L.getImageHeight(0, 0),
                    R = L.getNumImages(),
                    j = L.getNumLevels(0),
                    se = !!L.getHasAlpha(),
                    ce = L.isUASTC && L.isUASTC();
                  if (!J || !ae || !R || !j)
                    throw (
                      (L.close(),
                      L.delete(),
                      new Error(
                        `Invalid image dimensions url=${O} width=${J} height=${ae} images=${R} levels=${j}`
                      ))
                    );
                  const ie = te(N.deviceDetails, se, ce),
                    b = !!N.isGGGR && ie === "pvr";
                  let M;
                  if (
                    (b
                      ? (M = _.cTFRGBA32)
                      : ((M = se ? E[ie] : m[ie]),
                        X(J, ae, M, N.deviceDetails.webgl2) ||
                          (M = se ? _.cTFRGBA32 : _.cTFRGB565)),
                    !L.startTranscoding())
                  )
                    throw (
                      (L.close(),
                      L.delete(),
                      new Error("Failed to start transcoding url=" + O))
                    );
                  let F;
                  const z = [];
                  for (let oe = 0; oe < j; ++oe) {
                    const de = L.getImageTranscodedSizeInBytes(0, oe, M),
                      ge = new Uint8Array(de);
                    if (!L.transcodeImage(ge, 0, oe, M, 0, 0))
                      throw (
                        (L.close(),
                        L.delete(),
                        new Error("Failed to transcode image url=" + O))
                      );
                    const Re = M === _.cTFRGB565 || M === _.cTFRGBA4444;
                    z.push(Re ? new Uint16Array(ge.buffer) : ge);
                  }
                  if ((L.close(), L.delete(), b))
                    for (M = _.cTFRGB565, F = 0; F < z.length; ++F)
                      z[F] = A(I(z[F]));
                  return {
                    format: P(M, N.deviceDetails),
                    width: J,
                    height: ae,
                    levels: z,
                    cubemap: !1,
                    transcodeTime: C() - V,
                    url: O,
                    unswizzledGGGR: b,
                  };
                },
                Y = (O, me, N) => (N.isKTX2 ? $(O, me, N) : ne(O, me, N)),
                Z = (O, me, N) => {
                  try {
                    const V = Y(O, me, N);
                    (V.levels = V.levels.map((L) => L.buffer)),
                      self.postMessage({ url: O, data: V }, V.levels);
                  } catch (V) {
                    self.postMessage({ url: O, err: V }, null);
                  }
                },
                ye = (O, me) => {
                  const N = (V, L) => (
                    WebAssembly.instantiate(O.module, V)
                      .then((J) => {
                        L(J);
                      })
                      .catch((J) => {
                        console.error("instantiate failed + " + J);
                      }),
                    {}
                  );
                  self
                    .BASIS(O.module ? { instantiateWasm: N } : null)
                    .then((V) => {
                      V.initializeBasis(),
                        (w = V),
                        (k = O.rgbPriority),
                        (K = O.rgbaPriority),
                        me(null);
                    });
                },
                pe = [];
              self.onmessage = (O) => {
                const me = O.data;
                switch (me.type) {
                  case "init":
                    ye(me.config, () => {
                      for (let N = 0; N < pe.length; ++N)
                        Z(pe[N].url, pe[N].data, pe[N].options);
                      pe.length = 0;
                    });
                    break;
                  case "transcode":
                    w ? Z(me.url, me.data, me.options) : pe.push(me);
                    break;
                }
              };
            }
            var c = a(1467);
            const d = (_) => ({
                astc: !!_.extCompressedTextureASTC,
                atc: !!_.extCompressedTextureATC,
                dxt: !!_.extCompressedTextureS3TC,
                etc1: !!_.extCompressedTextureETC1,
                etc2: !!_.extCompressedTextureETC,
                pvr: !!_.extCompressedTexturePVRTC,
              }),
              h = (_, m) => {
                const E = (A) => {
                    const B = [
                      "/* basis */",
                      A,
                      "",
                      "(" +
                        g.toString() +
                        `)()

`,
                    ].join(`
`);
                    return new Blob([B], { type: "application/javascript" });
                  },
                  v = () => {
                    try {
                      if (
                        typeof WebAssembly == "object" &&
                        typeof WebAssembly.instantiate == "function"
                      ) {
                        const A = new WebAssembly.Module(
                          Uint8Array.of(0, 97, 115, 109, 1, 0, 0, 0)
                        );
                        if (A instanceof WebAssembly.Module)
                          return (
                            new WebAssembly.Instance(A) instanceof
                            WebAssembly.Instance
                          );
                      }
                    } catch (A) {}
                    return !1;
                  },
                  P = (A, B) => {
                    m(null, {
                      workerUrl: URL.createObjectURL(E(A)),
                      module: B,
                      rgbPriority: _.rgbPriority,
                      rgbaPriority: _.rgbaPriority,
                    });
                  },
                  I = {
                    cache: !0,
                    responseType: "text",
                    retry: _.maxRetries > 0,
                    maxRetries: _.maxRetries,
                  };
                if (_.glueUrl && _.wasmUrl && v()) {
                  let A = null,
                    B = null;
                  c.d.get(_.glueUrl, I, (k, K) => {
                    k ? m(k) : B ? P(K, B) : (A = K);
                  });
                  const C = fetch(_.wasmUrl),
                    w = () => {
                      C.then((k) => k.arrayBuffer())
                        .then((k) => WebAssembly.compile(k))
                        .then((k) => {
                          A ? P(A, k) : (B = k);
                        })
                        .catch((k) => {
                          m(k, null);
                        });
                    };
                  WebAssembly.compileStreaming
                    ? WebAssembly.compileStreaming(C)
                        .then((k) => {
                          A ? P(A, k) : (B = k);
                        })
                        .catch((k) => {
                          w();
                        })
                    : w();
                } else
                  c.d.get(_.fallbackUrl, I, (A, B) => {
                    A ? m(A, null) : P(B, null);
                  });
              };
            class f {
              constructor() {
                (this.callbacks = {}), (this.queue = []), (this.clients = []);
              }
              enqueueJob(m, E, v, P) {
                if (this.callbacks.hasOwnProperty(m)) this.callbacks[m].push(v);
                else {
                  this.callbacks[m] = [v];
                  const I = { url: m, data: E, options: P };
                  this.clients.length > 0
                    ? this.clients.shift().run(I)
                    : this.queue.push(I);
                }
              }
              enqueueClient(m) {
                this.queue.length > 0
                  ? m.run(this.queue.shift())
                  : this.clients.push(m);
              }
              handleResponse(m, E, v) {
                const P = this.callbacks[m];
                if (E) for (let I = 0; I < P.length; ++I) P[I](E);
                else {
                  v.format === T.Rbg || v.format === T.UUS
                    ? (v.levels = v.levels.map(function (I) {
                        return new Uint16Array(I);
                      }))
                    : (v.levels = v.levels.map(function (I) {
                        return new Uint8Array(I);
                      }));
                  for (let I = 0; I < P.length; ++I) P[I](null, v);
                }
                delete this.callbacks[m];
              }
            }
            class s {
              constructor(m, E, v) {
                (this.queue = m),
                  (this.worker = new Worker(E.workerUrl)),
                  this.worker.addEventListener("message", (P) => {
                    const I = P.data;
                    this.queue.handleResponse(I.url, I.err, I.data),
                      this.eager || this.queue.enqueueClient(this);
                  }),
                  this.worker.postMessage({ type: "init", config: E }),
                  (this.eager = v);
              }
              run(m) {
                const E = [];
                m.data instanceof ArrayBuffer && E.push(m.data),
                  this.worker.postMessage(
                    {
                      type: "transcode",
                      url: m.url,
                      format: m.format,
                      data: m.data,
                      options: m.options,
                    },
                    E
                  ),
                  this.eager && this.queue.enqueueClient(this);
              }
            }
            const l = 1,
              n = ["etc1", "etc2", "astc", "dxt", "pvr", "atc"],
              o = ["astc", "dxt", "etc2", "pvr", "atc"],
              i = 5,
              e = new f();
            let t = null,
              r = !1;
            function u(_) {
              if (!r) {
                if (!_) _ = t || {};
                else if (_.lazyInit) {
                  t = _;
                  return;
                }
                if (!_.glueUrl || !_.wasmUrl || !_.fallbackUrl) {
                  const m = x.F.getConfig("BASIS");
                  m &&
                    (_ = {
                      glueUrl: m.glueUrl,
                      wasmUrl: m.wasmUrl,
                      fallbackUrl: m.fallbackUrl,
                      numWorkers: m.numWorkers,
                    });
                }
                if (_.glueUrl || _.wasmUrl || _.fallbackUrl) {
                  r = !0;
                  const m = Math.max(1, Math.min(16, _.numWorkers || l)),
                    E =
                      _.numWorkers === 1 ||
                      (_.hasOwnProperty("eagerWorkers") ? _.eagerWorkers : !0);
                  (_.rgbPriority = _.rgbPriority || n),
                    (_.rgbaPriority = _.rgbaPriority || o),
                    (_.maxRetries = _.hasOwnProperty("maxRetries")
                      ? _.maxRetries
                      : i),
                    h(_, (v, P) => {
                      if (v)
                        console.error(
                          `failed to initialize basis worker: ${v}`
                        );
                      else
                        for (let I = 0; I < m; ++I)
                          e.enqueueClient(new s(e, P, E));
                    });
                }
              }
            }
            let y = null;
            function p(_, m, E, v, P) {
              return (
                u(),
                y || (y = { webgl2: _.webgl2, formats: d(_) }),
                e.enqueueJob(m, E, v, {
                  deviceDetails: y,
                  isGGGR: !!(P != null && P.isGGGR),
                  isKTX2: !!(P != null && P.isKTX2),
                }),
                r
              );
            }
          },
          3913: (Se, W, a) => {
            "use strict";
            a.d(W, { o: () => T });
            var x = a(1467);
            class T {
              constructor(c) {
                (this.handlerType = "binary"), (this.maxRetries = 0);
              }
              load(c, d) {
                typeof c == "string" && (c = { load: c, original: c }),
                  x.d.get(
                    c.load,
                    {
                      responseType: x.e.ResponseType.ARRAY_BUFFER,
                      retry: this.maxRetries > 0,
                      maxRetries: this.maxRetries,
                    },
                    function (h, f) {
                      h
                        ? d(
                            `Error loading binary resource: ${c.original} [${h}]`
                          )
                        : d(null, f);
                    }
                  );
              }
              open(c, d) {
                return d;
              }
              patch(c, d) {}
            }
          },
          8586: (Se, W, a) => {
            "use strict";
            a.d(W, { p: () => l });
            var x = a(4444),
              T = a(1467),
              g = a(8804);
            let c;
            function d(n) {
              let o, i;
              if (typeof TextDecoder != "undefined")
                try {
                  (o = new TextDecoder("utf-8")),
                    (i = new TextDecoder("windows-1252"));
                } catch (r) {
                  console.warn(
                    "TextDecoder not supported - pc.Untar module will not work"
                  );
                }
              else
                console.warn(
                  "TextDecoder not supported - pc.Untar module will not work"
                );
              function e(r) {
                this._fields = r;
              }
              (e.parse = function (r, u, y) {
                const p = new Uint8Array(r, u, y);
                let _ = 0;
                const m = [];
                for (; _ < y; ) {
                  let E;
                  for (E = _; E < y && p[E] !== 32; E++);
                  if (E >= y)
                    throw new Error("Invalid PAX header data format.");
                  const v = parseInt(
                      o.decode(new Uint8Array(r, u + _, E - _)),
                      10
                    ),
                    I = o
                      .decode(new Uint8Array(r, u + E + 1, v - (E - _) - 2))
                      .split("=");
                  if (I.length !== 2)
                    throw new Error("Invalid PAX header data format.");
                  I[1].length === 0 && (I[1] = null),
                    m.push({ name: I[0], value: I[1] }),
                    (_ += v);
                }
                return new e(m);
              }),
                (e.prototype.applyHeader = function (r) {
                  for (let u = 0; u < this._fields.length; u++) {
                    let y = this._fields[u].name;
                    const p = this._fields[u].value;
                    y === "path" && (y = "name"),
                      p === null ? delete r[y] : (r[y] = p);
                  }
                });
              function t(r) {
                (this._arrayBuffer = r || new ArrayBuffer(0)),
                  (this._bufferView = new DataView(this._arrayBuffer)),
                  (this._globalPaxHeader = null),
                  (this._paxHeader = null),
                  (this._bytesRead = 0);
              }
              n || (c = t),
                (t.prototype._hasNext = function () {
                  return (
                    this._bytesRead + 4 < this._arrayBuffer.byteLength &&
                    this._bufferView.getUint32(this._bytesRead) !== 0
                  );
                }),
                (t.prototype._readNextFile = function () {
                  const r = new DataView(
                      this._arrayBuffer,
                      this._bytesRead,
                      512
                    ),
                    u = i.decode(r);
                  this._bytesRead += 512;
                  let y = u.substring(0, 100).replace(/\0/g, "");
                  const p = u.substring(257, 263),
                    _ = parseInt(u.substring(124, 136), 8),
                    m = u.substring(156, 157),
                    E = this._bytesRead;
                  let v = null,
                    P = !1;
                  switch (m) {
                    case "0":
                    case "":
                      if (((P = !0), !n)) {
                        const B = new Blob([
                          this._arrayBuffer.slice(
                            this._bytesRead,
                            this._bytesRead + _
                          ),
                        ]);
                        v = URL.createObjectURL(B);
                      }
                      break;
                    case "g":
                      this._globalPaxHeader = e.parse(
                        this._arrayBuffer,
                        this._bytesRead,
                        _
                      );
                      break;
                    case "x":
                      this._paxHeader = e.parse(
                        this._arrayBuffer,
                        this._bytesRead,
                        _
                      );
                      break;
                  }
                  this._bytesRead += _;
                  const I = _ % 512;
                  if ((I !== 0 && (this._bytesRead += 512 - I), !P))
                    return null;
                  if (p.indexOf("ustar") !== -1) {
                    const B = u.substring(345, 500).replace(/\0/g, "");
                    B.length > 0 && (y = B.trim() + y.trim());
                  }
                  const A = { name: y, start: E, size: _, url: v };
                  return (
                    this._globalPaxHeader &&
                      this._globalPaxHeader.applyHeader(A),
                    this._paxHeader &&
                      (this._paxHeader.applyHeader(A),
                      (this._paxHeader = null)),
                    A
                  );
                }),
                (t.prototype.untar = function (r) {
                  if (!o)
                    return (
                      console.error(
                        "Cannot untar because TextDecoder interface is not available for this platform."
                      ),
                      []
                    );
                  const u = [];
                  for (; this._hasNext(); ) {
                    const y = this._readNextFile();
                    y && (r && y.name && (y.name = r + y.name), u.push(y));
                  }
                  return u;
                }),
                n &&
                  (self.onmessage = function (r) {
                    const u = r.data.id;
                    try {
                      const p = new t(r.data.arrayBuffer).untar(r.data.prefix);
                      postMessage(
                        { id: u, files: p, arrayBuffer: r.data.arrayBuffer },
                        [r.data.arrayBuffer]
                      );
                    } catch (y) {
                      postMessage({ id: u, error: y.toString() });
                    }
                  });
            }
            let h = null;
            function f() {
              if (!h) {
                const n =
                    "(" +
                    d.toString() +
                    `)(true)

`,
                  o = new Blob([n], { type: "application/javascript" });
                h = URL.createObjectURL(o);
              }
              return h;
            }
            class s {
              constructor(o) {
                (this._requestId = 0),
                  (this._pendingRequests = {}),
                  (this._filenamePrefix = o),
                  (this._worker = new Worker(f())),
                  this._worker.addEventListener(
                    "message",
                    this._onMessage.bind(this)
                  );
              }
              _onMessage(o) {
                const i = o.data.id;
                if (!this._pendingRequests[i]) return;
                const e = this._pendingRequests[i];
                if ((delete this._pendingRequests[i], o.data.error))
                  e(o.data.error);
                else {
                  const t = o.data.arrayBuffer;
                  for (let r = 0, u = o.data.files.length; r < u; r++) {
                    const y = o.data.files[r],
                      p = new Blob([t.slice(y.start, y.start + y.size)]);
                    y.url = URL.createObjectURL(p);
                  }
                  e(null, o.data.files);
                }
              }
              untar(o, i) {
                const e = this._requestId++;
                (this._pendingRequests[e] = i),
                  this._worker.postMessage(
                    { id: e, prefix: this._filenamePrefix, arrayBuffer: o },
                    [o]
                  );
              }
              hasPendingRequests() {
                return Object.keys(this._pendingRequests).length > 0;
              }
              destroy() {
                this._worker &&
                  (this._worker.terminate(),
                  (this._worker = null),
                  (this._pendingRequests = null));
              }
            }
            d();
            class l {
              constructor(o) {
                (this.handlerType = "bundle"),
                  (this._assets = o.assets),
                  (this._worker = null),
                  (this.maxRetries = 0);
              }
              load(o, i) {
                typeof o == "string" && (o = { load: o, original: o });
                const e = this;
                T.d.get(
                  o.load,
                  {
                    responseType: T.e.ResponseType.ARRAY_BUFFER,
                    retry: this.maxRetries > 0,
                    maxRetries: this.maxRetries,
                  },
                  function (t, r) {
                    if (t)
                      i(
                        "Error loading bundle resource " + o.original + ": " + t
                      );
                    else
                      try {
                        e._untar(r, i);
                      } catch (u) {
                        i(
                          "Error loading bundle resource " +
                            o.original +
                            ": " +
                            u
                        );
                      }
                  }
                );
              }
              _untar(o, i) {
                const e = this;
                if (x.J.workers)
                  e._worker || (e._worker = new s(e._assets.prefix)),
                    e._worker.untar(o, function (t, r) {
                      i(t, r),
                        e._worker.hasPendingRequests() ||
                          (e._worker.destroy(), (e._worker = null));
                    });
                else {
                  const r = new c(o).untar(e._assets.prefix);
                  i(null, r);
                }
              }
              open(o, i) {
                return new g.b(i);
              }
              patch(o, i) {}
            }
          },
          8493: (Se, W, a) => {
            "use strict";
            a.d(W, { F: () => f, T: () => h });
            var x = a(9296),
              T = a(6204),
              g = a(5768),
              c = a(1542);
            class d {
              constructor(l, n, o) {
                (this._device = l),
                  (this._assets = n),
                  (this._defaultMaterial = g.Z.createDefaultMaterial()),
                  (this.maxRetries = o);
              }
              _getUrlWithoutParams(l) {
                return l.indexOf("?") >= 0 ? l.split("?")[0] : l;
              }
              load(l, n, o) {
                T.x.fetchArrayBuffer(
                  l.load,
                  (i, e) => {
                    i
                      ? n(i)
                      : g.Z.parse(
                          this._getUrlWithoutParams(l.original),
                          x.E.extractPath(l.load),
                          e,
                          this._device,
                          o.registry,
                          o.options,
                          (t, r) => {
                            t
                              ? n(t)
                              : n(
                                  null,
                                  new c.y(
                                    r,
                                    o,
                                    this._assets,
                                    this._defaultMaterial
                                  )
                                );
                          }
                        );
                  },
                  o,
                  this.maxRetries
                );
              }
              open(l, n, o) {
                return n;
              }
              patch(l, n) {}
            }
            class h {
              instantiateModelEntity(l) {
                return null;
              }
              instantiateRenderEntity(l) {
                return null;
              }
              getMaterialVariants() {
                return null;
              }
              applyMaterialVariant(l, n) {}
              applyMaterialVariantInstances(l, n) {}
            }
            class f {
              constructor(l) {
                (this.handlerType = "container"),
                  (this.glbContainerParser = new d(
                    l.graphicsDevice,
                    l.assets,
                    0
                  )),
                  (this.parsers = {});
              }
              set maxRetries(l) {
                this.glbContainerParser.maxRetries = l;
                for (const n in this.parsers)
                  this.parsers.hasOwnProperty(n) &&
                    (this.parsers[n].maxRetries = l);
              }
              get maxRetries() {
                return this.glbContainerParser.maxRetries;
              }
              _getUrlWithoutParams(l) {
                return l.indexOf("?") >= 0 ? l.split("?")[0] : l;
              }
              _getParser(l) {
                const n = l
                  ? x.E.getExtension(this._getUrlWithoutParams(l))
                      .toLowerCase()
                      .replace(".", "")
                  : null;
                return this.parsers[n] || this.glbContainerParser;
              }
              load(l, n, o) {
                typeof l == "string" && (l = { load: l, original: l }),
                  this._getParser(l.original).load(l, n, o);
              }
              open(l, n, o) {
                return this._getParser(l).open(l, n, o);
              }
              patch(l, n) {}
            }
          },
          3671: (Se, W, a) => {
            "use strict";
            a.d(W, { s: () => T });
            var x = a(1467);
            class T {
              constructor(c) {
                (this.handlerType = "css"), (this.maxRetries = 0);
              }
              load(c, d) {
                typeof c == "string" && (c = { load: c, original: c }),
                  x.d.get(
                    c.load,
                    { retry: this.maxRetries > 0, maxRetries: this.maxRetries },
                    function (h, f) {
                      h
                        ? d(`Error loading css resource: ${c.original} [${h}]`)
                        : d(null, f);
                    }
                  );
              }
              open(c, d) {
                return d;
              }
              patch(c, d) {}
            }
          },
          216: (Se, W, a) => {
            "use strict";
            a.d(W, { o: () => c });
            var x = a(7921),
              T = a(8869),
              g = a(6204);
            class c {
              constructor(h) {
                (this.handlerType = "cubemap"),
                  (this._device = h.graphicsDevice),
                  (this._registry = h.assets),
                  (this._loader = h.loader);
              }
              load(h, f, s) {
                this.loadAssets(s, f);
              }
              open(h, f, s) {
                return s ? s.resource : null;
              }
              patch(h, f) {
                this.loadAssets(h, function (s, l) {
                  s &&
                    (f.fire("error", h),
                    f.fire("error:" + h.id, s, h),
                    h.fire("error", h));
                });
              }
              getAssetIds(h) {
                const f = [];
                if (
                  ((f[0] = h.file),
                  (h.loadFaces || !h.file) && h.data && h.data.textures)
                )
                  for (let s = 0; s < 6; ++s) f[s + 1] = h.data.textures[s];
                else f[1] = f[2] = f[3] = f[4] = f[5] = f[6] = null;
                return f;
              }
              compareAssetIds(h, f) {
                return h && f
                  ? parseInt(h, 10) === h || typeof h == "string"
                    ? h === f
                    : h.url === f.url
                  : (h !== null) == (f !== null);
              }
              update(h, f, s) {
                const l = h.data || {},
                  n = h._handlerState.assets,
                  o = h._resources;
                let i, e, t;
                const r = [null, null, null, null, null, null, null],
                  u = function () {
                    return l.hasOwnProperty("type")
                      ? l.type
                      : l.hasOwnProperty("rgbm")
                      ? l.rgbm
                        ? x.xIP
                        : x.zZc
                      : null;
                  };
                if (!h.loaded || s[0] !== n[0]) {
                  if (s[0])
                    if (((i = s[0].resource), i.cubemap))
                      for (t = 0; t < 6; ++t)
                        r[t + 1] = new T.x(this._device, {
                          name: h.name + "_prelitCubemap" + (i.width >> t),
                          cubemap: !0,
                          type: u() || i.type,
                          width: i.width >> t,
                          height: i.height >> t,
                          format: i.format,
                          levels: [i._levels[t]],
                          fixCubemapSeams: !0,
                          addressU: x.uFb,
                          addressV: x.uFb,
                          mipmaps: t === 0,
                        });
                    else (i.type = x.kVJ), (r[1] = i);
                } else
                  (r[1] = o[1] || null),
                    (r[2] = o[2] || null),
                    (r[3] = o[3] || null),
                    (r[4] = o[4] || null),
                    (r[5] = o[5] || null),
                    (r[6] = o[6] || null);
                const y = s.slice(1);
                if (!h.loaded || !this.cmpArrays(y, n.slice(1))) {
                  if (y.indexOf(null) === -1) {
                    var p;
                    const _ = y.map(function (P) {
                        return P.resource;
                      }),
                      m = [];
                    for (e = 0; e < _[0]._levels.length; ++e)
                      m.push(
                        _.map(function (P) {
                          return P._levels[e];
                        })
                      );
                    const E = _[0].format,
                      v = new T.x(this._device, {
                        name: h.name + "_faces",
                        cubemap: !0,
                        type: u() || _[0].type,
                        width: _[0].width,
                        height: _[0].height,
                        format: E === x.Hsr ? x.jKI : E,
                        mipmaps: (p = l.mipmaps) != null ? p : !0,
                        levels: m,
                        minFilter: l.hasOwnProperty("minFilter")
                          ? l.minFilter
                          : _[0].minFilter,
                        magFilter: l.hasOwnProperty("magFilter")
                          ? l.magFilter
                          : _[0].magFilter,
                        anisotropy: l.hasOwnProperty("anisotropy")
                          ? l.anisotropy
                          : 1,
                        addressU: x.uFb,
                        addressV: x.uFb,
                        fixCubemapSeams: !!s[0],
                      });
                    r[0] = v;
                  }
                } else r[0] = o[0] || null;
                if (!this.cmpArrays(r, o))
                  for (
                    h.resources = r,
                      h._handlerState.assetIds = f,
                      h._handlerState.assets = s,
                      t = 0;
                    t < o.length;
                    ++t
                  )
                    o[t] !== null && r.indexOf(o[t]) === -1 && o[t].destroy();
                for (t = 0; t < n.length; ++t)
                  n[t] !== null && s.indexOf(n[t]) === -1 && n[t].unload();
              }
              cmpArrays(h, f) {
                if (h.length !== f.length) return !1;
                for (let s = 0; s < h.length; ++s) if (h[s] !== f[s]) return !1;
                return !0;
              }
              resolveId(h) {
                const f = parseInt(h, 10);
                return f === h || f.toString() === h ? f : h;
              }
              loadAssets(h, f) {
                h.hasOwnProperty("_handlerState") ||
                  (h._handlerState = {
                    assetIds: [null, null, null, null, null, null, null],
                    assets: [null, null, null, null, null, null, null],
                  });
                const s = this,
                  l = s.getAssetIds(h),
                  n = [null, null, null, null, null, null, null],
                  o = h._handlerState.assetIds,
                  i = h._handlerState.assets,
                  e = s._registry;
                let t = 7;
                const r = function (m, E) {
                    (n[m] = E),
                      t--,
                      t === 0 && (s.update(h, l, n), f(null, h.resources));
                  },
                  u = function (m, E, v) {
                    f(E);
                  },
                  y = function (m, E) {
                    E.loaded
                      ? r(m, E)
                      : (e.once("load:" + E.id, r.bind(s, m)),
                        e.once("error:" + E.id, u.bind(s, m)),
                        E.loading || e.load(E));
                  };
                let p;
                for (let _ = 0; _ < 7; ++_) {
                  const m = this.resolveId(l[_]);
                  if (!m) r(_, null);
                  else if (s.compareAssetIds(m, o[_])) r(_, i[_]);
                  else if (parseInt(m, 10) === m)
                    (p = e.get(m)),
                      p
                        ? y(_, p)
                        : setTimeout(
                            function (E, v) {
                              const P = e.get(v);
                              P
                                ? y(E, P)
                                : u(
                                    E,
                                    "failed to find dependent cubemap asset=" +
                                      v
                                  );
                            }.bind(null, _, m)
                          );
                  else {
                    const E =
                      typeof m == "string" ? { url: m, filename: m } : m;
                    (p = new g.x(h.name + "_part_" + _, "texture", E)),
                      e.add(p),
                      e.once("load:" + p.id, r.bind(s, _)),
                      e.once("error:" + p.id, u.bind(s, _)),
                      e.load(p);
                  }
                }
              }
            }
          },
          1912: (Se, W, a) => {
            "use strict";
            a.d(W, { s: () => x });
            class x {
              constructor() {
                this.handlerType = "folder";
              }
              load(g, c) {
                c(null, null);
              }
              open(g, c) {
                return c;
              }
            }
          },
          8001: (Se, W, a) => {
            "use strict";
            a.d(W, { G: () => h });
            var x = a(9296),
              T = a(9351),
              g = a(1467),
              c = a(2794);
            function d(f) {
              return (
                f.version < 3 &&
                  (f.version < 2 &&
                    (f.info.maps = f.info.maps || [
                      { width: f.info.width, height: f.info.height },
                    ]),
                  (f.chars = Object.keys(f.chars || {}).reduce(function (s, l) {
                    const n = f.chars[l],
                      o = n.letter !== void 0 ? n.letter : T.Z.fromCodePoint(l);
                    return f.version < 2 && (n.map = n.map || 0), (s[o] = n), s;
                  }, {})),
                  (f.version = 3)),
                f
              );
            }
            class h {
              constructor(s) {
                (this.handlerType = "font"),
                  (this._loader = s.loader),
                  (this.maxRetries = 0);
              }
              load(s, l, n) {
                typeof s == "string" && (s = { load: s, original: s });
                const o = this;
                x.E.getExtension(s.original) === ".json"
                  ? g.d.get(
                      s.load,
                      {
                        retry: this.maxRetries > 0,
                        maxRetries: this.maxRetries,
                      },
                      function (i, e) {
                        if (i)
                          l(
                            `Error loading font resource: ${s.original} [${i}]`
                          );
                        else {
                          const t = d(e);
                          o._loadTextures(
                            s.load.replace(".json", ".png"),
                            t,
                            function (r, u) {
                              if (r) return l(r);
                              l(null, { data: t, textures: u });
                            }
                          );
                        }
                      }
                    )
                  : (n && n.data && (n.data = d(n.data)),
                    this._loadTextures(s.load, n && n.data, l));
              }
              _loadTextures(s, l, n) {
                const o = l.info.maps.length;
                let i = 0,
                  e = null;
                const t = new Array(o),
                  r = this._loader,
                  u = function (p) {
                    const _ = function (E, v) {
                      if (!e) {
                        if (E) return (e = E), n(E);
                        v.upload(), (t[p] = v), i++, i === o && n(null, t);
                      }
                    };
                    p === 0
                      ? r.load(s, "texture", _)
                      : r.load(s.replace(".png", p + ".png"), "texture", _);
                  };
                for (let y = 0; y < o; y++) u(y);
              }
              open(s, l, n) {
                let o;
                return (
                  l.textures
                    ? (o = new c.Z(l.textures, l.data))
                    : (o = new c.Z(l, null)),
                  o
                );
              }
              patch(s, l) {
                const n = s.resource;
                !n.data && s.data
                  ? (n.data = s.data)
                  : !s.data && n.data && (s.data = n.data),
                  s.data && (s.data = d(s.data));
              }
            }
          },
          325: (Se, W, a) => {
            "use strict";
            a.d(W, { c: () => g });
            var x = a(544),
              T = a(8297);
            class g {
              constructor(d) {
                (this.handlerType = "hierarchy"),
                  (this._app = d),
                  (this.maxRetries = 0);
              }
              load(d, h) {
                T.p.load(d, this.maxRetries, h);
              }
              open(d, h) {
                this._app.systems.script.preloading = !0;
                const s = new x.n(this._app, !1).parse(h);
                return (this._app.systems.script.preloading = !1), s;
              }
            }
          },
          2353: (Se, W, a) => {
            "use strict";
            a.d(W, { x: () => T });
            var x = a(1467);
            class T {
              constructor(c) {
                (this.handlerType = "html"), (this.maxRetries = 0);
              }
              load(c, d) {
                typeof c == "string" && (c = { load: c, original: c }),
                  x.d.get(
                    c.load,
                    { retry: this.maxRetries > 0, maxRetries: this.maxRetries },
                    function (h, f) {
                      h
                        ? d(`Error loading html resource: ${c.original} [${h}]`)
                        : d(null, f);
                    }
                  );
              }
              open(c, d) {
                return d;
              }
              patch(c, d) {}
            }
          },
          496: (Se, W, a) => {
            "use strict";
            a.d(W, { G: () => T });
            var x = a(1467);
            class T {
              constructor(c) {
                (this.handlerType = "json"), (this.maxRetries = 0);
              }
              load(c, d) {
                typeof c == "string" && (c = { load: c, original: c });
                const h = {
                  retry: this.maxRetries > 0,
                  maxRetries: this.maxRetries,
                };
                c.load.startsWith("blob:") &&
                  (h.responseType = x.e.ResponseType.JSON),
                  x.d.get(c.load, h, function (f, s) {
                    f
                      ? d(`Error loading JSON resource: ${c.original} [${f}]`)
                      : d(null, s);
                  });
              }
              open(c, d) {
                return d;
              }
              patch(c, d) {}
            }
          },
          8936: (Se, W, a) => {
            "use strict";
            a.d(W, { h: () => x });
            class x {
              constructor(g) {
                (this._handlers = {}),
                  (this._requests = {}),
                  (this._cache = {}),
                  (this._app = g);
              }
              addHandler(g, c) {
                (this._handlers[g] = c), (c._loader = this);
              }
              removeHandler(g) {
                delete this._handlers[g];
              }
              getHandler(g) {
                return this._handlers[g];
              }
              static makeKey(g, c) {
                return `${g}-${c}`;
              }
              load(g, c, d, h) {
                const f = this._handlers[c];
                if (!f) {
                  const l = `No resource handler for asset type: '${c}' when loading [${g}]`;
                  d(l);
                  return;
                }
                if (!g) {
                  this._loadNull(f, d, h);
                  return;
                }
                const s = x.makeKey(g, c);
                if (this._cache[s] !== void 0) d(null, this._cache[s]);
                else if (this._requests[s]) this._requests[s].push(d);
                else {
                  this._requests[s] = [d];
                  const l = this,
                    n = function (e, t) {
                      if (e) {
                        l._onFailure(s, e);
                        return;
                      }
                      f.load(
                        t,
                        function (r, u, y) {
                          if (l._requests[s]) {
                            if (r) {
                              l._onFailure(s, r);
                              return;
                            }
                            try {
                              l._onSuccess(s, f.open(t.original, u, h), y);
                            } catch (p) {
                              l._onFailure(s, p);
                            }
                          }
                        },
                        h
                      );
                    },
                    o = g.split("?")[0];
                  if (this._app.enableBundles && this._app.bundles.hasUrl(o)) {
                    if (!this._app.bundles.canLoadUrl(o)) {
                      n(`Bundle for ${g} not loaded yet`);
                      return;
                    }
                    this._app.bundles.loadUrl(o, function (i, e) {
                      n(i, { load: e, original: o });
                    });
                  } else
                    n(null, { load: g, original: (h && h.file.filename) || g });
                }
              }
              _loadNull(g, c, d) {
                const h = function (s, l, n) {
                  if (s) c(s);
                  else
                    try {
                      c(null, g.open(null, l, d), n);
                    } catch (o) {
                      c(o);
                    }
                };
                g.load(null, h, d);
              }
              _onSuccess(g, c, d) {
                c !== null ? (this._cache[g] = c) : delete this._cache[g];
                for (let h = 0; h < this._requests[g].length; h++)
                  this._requests[g][h](null, c, d);
                delete this._requests[g];
              }
              _onFailure(g, c) {
                if ((console.error(c), this._requests[g])) {
                  for (let d = 0; d < this._requests[g].length; d++)
                    this._requests[g][d](c);
                  delete this._requests[g];
                }
              }
              open(g, c) {
                const d = this._handlers[g];
                return d
                  ? d.open(null, c)
                  : (console.warn("No resource handler found for: " + g), c);
              }
              patch(g, c) {
                const d = this._handlers[g.type];
                if (!d) {
                  console.warn("No resource handler found for: " + g.type);
                  return;
                }
                d.patch && d.patch(g, c);
              }
              clearCache(g, c) {
                const d = x.makeKey(g, c);
                delete this._cache[d];
              }
              getFromCache(g, c) {
                const d = x.makeKey(g, c);
                if (this._cache[d]) return this._cache[d];
              }
              enableRetry(g = 5) {
                g = Math.max(0, g) || 0;
                for (const c in this._handlers)
                  this._handlers[c].maxRetries = g;
              }
              disableRetry() {
                for (const g in this._handlers)
                  this._handlers[g].maxRetries = 0;
              }
              destroy() {
                (this._handlers = {}),
                  (this._requests = {}),
                  (this._cache = {});
              }
            }
          },
          1676: (Se, W, a) => {
            "use strict";
            a.d(W, { r: () => l });
            var x = a(1467),
              T = a(7921),
              g = a(8869),
              c = a(3114),
              d = a(6672),
              h = a(5755),
              f = a(2710);
            const s = {
              aoMap: "white",
              diffuseMap: "gray",
              specularMap: "gray",
              specularityFactorMap: "white",
              metalnessMap: "black",
              glossMap: "gray",
              sheenMap: "black",
              sheenGlossinessMap: "gray",
              clearCoatMap: "black",
              clearCoatGlossMap: "gray",
              clearCoatNormalMap: "normal",
              refractionMap: "white",
              emissiveMap: "gray",
              normalMap: "normal",
              heightMap: "gray",
              opacityMap: "gray",
              sphereMap: "gray",
              lightMap: "white",
            };
            class l {
              constructor(o) {
                (this.handlerType = "material"),
                  (this._assets = o.assets),
                  (this._device = o.graphicsDevice),
                  (this._placeholderTextures = null),
                  (this._parser = new f.r()),
                  (this.maxRetries = 0);
              }
              load(o, i) {
                typeof o == "string" && (o = { load: o, original: o }),
                  x.d.get(
                    o.load,
                    { retry: this.maxRetries > 0, maxRetries: this.maxRetries },
                    function (e, t) {
                      e
                        ? i && i(`Error loading material: ${o.original} [${e}]`)
                        : i && ((t._engine = !0), i(null, t));
                    }
                  );
              }
              open(o, i) {
                const e = this._parser.parse(i);
                return i._engine && ((e._data = i), delete i._engine), e;
              }
              _createPlaceholders() {
                this._placeholderTextures = {};
                const o = {
                  white: [255, 255, 255, 255],
                  gray: [128, 128, 128, 255],
                  black: [0, 0, 0, 255],
                  normal: [128, 128, 255, 255],
                };
                for (const i in o) {
                  if (!o.hasOwnProperty(i)) continue;
                  this._placeholderTextures[i] = new g.x(this._device, {
                    width: 2,
                    height: 2,
                    format: T.jKI,
                    name: "material_placeholder",
                  });
                  const e = this._placeholderTextures[i].lock();
                  for (let t = 0; t < 4; t++)
                    for (let r = 0; r < 4; r++) e[t * 4 + r] = o[i][r];
                  this._placeholderTextures[i].unlock();
                }
              }
              patch(o, i) {
                o.resource._data &&
                  ((o._data = o.resource._data), delete o.resource._data),
                  (o.data.name = o.name),
                  (o.resource.name = o.name),
                  this._bindAndAssignAssets(o, i),
                  o.off("unload", this._onAssetUnload, this),
                  o.on("unload", this._onAssetUnload, this);
              }
              _onAssetUnload(o) {
                delete o.data.parameters,
                  delete o.data.chunks,
                  delete o.data.name;
              }
              _assignTexture(o, i, e) {
                i.resource[o] = e;
              }
              _getPlaceholderTexture(o) {
                this._placeholderTextures || this._createPlaceholders();
                const i = s[o];
                return this._placeholderTextures[i];
              }
              _assignPlaceholderTexture(o, i) {
                i.resource[o] = this._getPlaceholderTexture(o);
              }
              _onTextureLoad(o, i, e) {
                this._assignTexture(o, i, e.resource), i.resource.update();
              }
              _onTextureAdd(o, i, e) {
                this._assets.load(e);
              }
              _onTextureRemoveOrUnload(o, i, e) {
                const t = i.resource;
                t &&
                  i.resource[o] === e.resource &&
                  (this._assignPlaceholderTexture(o, i), t.update());
              }
              _assignCubemap(o, i, e) {
                (i.resource[o] = e[0]),
                  o === "cubeMap" &&
                    (i.resource.prefilteredCubemaps = e.slice(1));
              }
              _onCubemapLoad(o, i, e) {
                this._assignCubemap(o, i, e.resources),
                  this._parser.initialize(i.resource, i.data);
              }
              _onCubemapAdd(o, i, e) {
                i.data.shadingModel === c.yd && (i.loadFaces = !0),
                  this._assets.load(e);
              }
              _onCubemapRemoveOrUnload(o, i, e) {
                const t = i.resource;
                i.data.prefilteredCubeMap128 === e.resources[1] &&
                  (this._assignCubemap(o, i, [
                    null,
                    null,
                    null,
                    null,
                    null,
                    null,
                    null,
                  ]),
                  t.update());
              }
              _bindAndAssignAssets(o, i) {
                const e = this._parser.migrate(o.data),
                  t = o.resource,
                  r = e.mappingFormat === "path",
                  u = d.Eh;
                let y, p, _;
                for (y = 0; y < u.length; y++) {
                  (p = u[y]), (_ = t._assetReferences[p]);
                  const E = e[p],
                    v = t[p],
                    P = v === this._getPlaceholderTexture(p),
                    I = e.validated;
                  E && (!v || !I || P)
                    ? (_ ||
                        ((_ = new h.M(
                          p,
                          o,
                          i,
                          {
                            load: this._onTextureLoad,
                            add: this._onTextureAdd,
                            remove: this._onTextureRemoveOrUnload,
                            unload: this._onTextureRemoveOrUnload,
                          },
                          this
                        )),
                        (t._assetReferences[p] = _)),
                      r ? (_.url = o.getAbsoluteUrl(E)) : (_.id = E),
                      _.asset &&
                        (_.asset.resource
                          ? this._assignTexture(p, o, _.asset.resource)
                          : this._assignPlaceholderTexture(p, o),
                        i.load(_.asset)))
                    : _ && (r ? (_.url = null) : (_.id = null));
                }
                const m = d.Ft;
                for (y = 0; y < m.length; y++)
                  (p = m[y]),
                    (_ = t._assetReferences[p]),
                    e[p] &&
                      !o.data.prefilteredCubeMap128 &&
                      (_ ||
                        ((_ = new h.M(
                          p,
                          o,
                          i,
                          {
                            load: this._onCubemapLoad,
                            add: this._onCubemapAdd,
                            remove: this._onCubemapRemoveOrUnload,
                            unload: this._onCubemapRemoveOrUnload,
                          },
                          this
                        )),
                        (t._assetReferences[p] = _)),
                      r ? (_.url = e[p]) : (_.id = e[p]),
                      _.asset &&
                        (_.asset.loaded &&
                          this._assignCubemap(p, o, _.asset.resources),
                        i.load(_.asset)));
                this._parser.initialize(t, e);
              }
            }
          },
          5404: (Se, W, a) => {
            "use strict";
            a.d(W, { U: () => w });
            var x = a(9296),
              T = a(1467),
              g = a(9373),
              c = a(1542),
              d = a(5768);
            class h {
              constructor(K) {
                (this._device = K.device),
                  (this._defaultMaterial = K.defaultMaterial),
                  (this._assets = K.assets);
              }
              parse(K, te, X) {
                var $;
                d.Z.parse(
                  "filename.glb",
                  "",
                  K,
                  this._device,
                  this._assets,
                  ($ = X == null ? void 0 : X.options) != null ? $ : {},
                  (ne, Y) => {
                    if (ne) te(ne);
                    else {
                      const Z = c.y.createModel(Y, this._defaultMaterial);
                      Y.destroy(), te(null, Z);
                    }
                  }
                );
              }
            }
            var f = a(9758),
              s = a(6556),
              l = a(3148),
              n = a(7921),
              o = a(9459),
              i = a(6615),
              e = a(8385),
              t = a(6938),
              r = a(120),
              u = a(7915),
              y = a(7678),
              p = a(8792),
              _ = a(9915),
              m = a(3823),
              E = a(1259),
              v = a(7551),
              P = a(4390),
              I = a(8691);
            const A = {
                points: n.KtK,
                lines: n.Y7R,
                lineloop: n.QSU,
                linestrip: n.HWi,
                triangles: n.LAy,
                trianglestrip: n.fmY,
                trianglefan: n.x5Y,
              },
              B = {
                int8: n.NPC,
                uint8: n.vyI,
                int16: n.S81,
                uint16: n.Spw,
                int32: n.$Rf,
                uint32: n.$GK,
                float32: n.r8O,
              };
            class C {
              constructor(K) {
                (this._device = K.device),
                  (this._defaultMaterial = K.defaultMaterial);
              }
              parse(K, te) {
                const X = K.model;
                if (!X) {
                  te(null, null);
                  return;
                }
                if (X.version <= 1) {
                  te(
                    "JsonModelParser#parse: Trying to parse unsupported model format."
                  );
                  return;
                }
                const $ = this._parseNodes(K),
                  ne = this._parseSkins(K, $),
                  Y = this._parseVertexBuffers(K),
                  Z = this._parseIndexBuffers(K, Y),
                  ye = this._parseMorphs(K, $, Y),
                  pe = this._parseMeshes(
                    K,
                    ne.skins,
                    ye.morphs,
                    Y,
                    Z.buffer,
                    Z.data
                  ),
                  O = this._parseMeshInstances(
                    K,
                    $,
                    pe,
                    ne.skins,
                    ne.instances,
                    ye.morphs,
                    ye.instances
                  ),
                  me = new _.H();
                (me.graph = $[0]),
                  (me.meshInstances = O),
                  (me.skinInstances = ne.instances),
                  (me.morphInstances = ye.instances),
                  me.getGraph().syncHierarchy(),
                  te(null, me);
              }
              _parseNodes(K) {
                const te = K.model,
                  X = [];
                let $;
                for ($ = 0; $ < te.nodes.length; $++) {
                  const ne = te.nodes[$],
                    Y = new u.A(ne.name);
                  Y.setLocalPosition(
                    ne.position[0],
                    ne.position[1],
                    ne.position[2]
                  ),
                    Y.setLocalEulerAngles(
                      ne.rotation[0],
                      ne.rotation[1],
                      ne.rotation[2]
                    ),
                    Y.setLocalScale(ne.scale[0], ne.scale[1], ne.scale[2]),
                    (Y.scaleCompensation = !!ne.scaleCompensation),
                    X.push(Y);
                }
                for ($ = 1; $ < te.parents.length; $++)
                  X[te.parents[$]].addChild(X[$]);
                return X;
              }
              _parseSkins(K, te) {
                const X = K.model,
                  $ = [],
                  ne = [];
                let Y, Z;
                if (!this._device.supportsBoneTextures && X.skins.length > 0) {
                  const ye = this._device.getBoneLimit();
                  (0, r.A)(X, null, ye);
                }
                for (Y = 0; Y < X.skins.length; Y++) {
                  const ye = X.skins[Y],
                    pe = [];
                  for (Z = 0; Z < ye.inverseBindMatrices.length; Z++) {
                    const V = ye.inverseBindMatrices[Z];
                    pe[Z] = new f.y().set(V);
                  }
                  const O = new P.Z(this._device, pe, ye.boneNames);
                  $.push(O);
                  const me = new I.u(O),
                    N = [];
                  for (Z = 0; Z < O.boneNames.length; Z++) {
                    const V = O.boneNames[Z],
                      L = te[0].findByName(V);
                    N.push(L);
                  }
                  (me.bones = N), ne.push(me);
                }
                return { skins: $, instances: ne };
              }
              _getMorphVertexCount(K, te, X) {
                for (let $ = 0; $ < K.meshes.length; $++) {
                  const ne = K.meshes[$];
                  if (ne.morph === te) return X[ne.vertices].numVertices;
                }
              }
              _parseMorphs(K, te, X) {
                const $ = K.model,
                  ne = [],
                  Y = [];
                let Z, ye, pe, O, me, N;
                if ($.morphs) {
                  const V = function (J, ae, R) {
                    const j = new Float32Array(R * 3);
                    for (let se = 0; se < ae.length; se++) {
                      const ce = ae[se] * 3;
                      (j[ce] = J[se * 3]),
                        (j[ce + 1] = J[se * 3 + 1]),
                        (j[ce + 2] = J[se * 3 + 2]);
                    }
                    return j;
                  };
                  for (Z = 0; Z < $.morphs.length; Z++) {
                    for (
                      O = $.morphs[Z].targets,
                        N = [],
                        pe = this._getMorphVertexCount($, Z, X),
                        ye = 0;
                      ye < O.length;
                      ye++
                    ) {
                      const ae = O[ye].aabb,
                        R = ae.min,
                        j = ae.max,
                        se = new l.k(
                          new s.A(
                            (j[0] + R[0]) * 0.5,
                            (j[1] + R[1]) * 0.5,
                            (j[2] + R[2]) * 0.5
                          ),
                          new s.A(
                            (j[0] - R[0]) * 0.5,
                            (j[1] - R[1]) * 0.5,
                            (j[2] - R[2]) * 0.5
                          )
                        ),
                        ce = O[ye].indices;
                      let ie = O[ye].deltaPositions,
                        b = O[ye].deltaNormals;
                      ce && ((ie = V(ie, ce, pe)), (b = V(b, ce, pe))),
                        (me = new v.Y({
                          deltaPositions: ie,
                          deltaNormals: b,
                          name: O[ye].name,
                          aabb: se,
                        })),
                        N.push(me);
                    }
                    const L = new m._(N, this._device);
                    ne.push(L);
                    const J = new E.w(L);
                    Y.push(J);
                  }
                }
                return { morphs: ne, instances: Y };
              }
              _parseVertexBuffers(K) {
                const te = K.model,
                  X = [],
                  $ = {
                    position: n.Q5v,
                    normal: n.SA$,
                    tangent: n.ipN,
                    blendWeight: n.d1j,
                    blendIndices: n.MgX,
                    color: n.wD$,
                    texCoord0: n.$fY,
                    texCoord1: n.Q0q,
                    texCoord2: n.WtN,
                    texCoord3: n.SSp,
                    texCoord4: n.uOW,
                    texCoord5: n.EKq,
                    texCoord6: n.Vcj,
                    texCoord7: n.$8O,
                  };
                for (let ne = 0; ne < te.vertices.length; ne++) {
                  const Y = te.vertices[ne],
                    Z = [];
                  for (const N in Y) {
                    const V = Y[N];
                    Z.push({
                      semantic: $[N],
                      components: V.components,
                      type: B[V.type],
                      normalize: $[N] === n.wD$,
                    });
                  }
                  const ye = new e.g(this._device, Z),
                    pe = Y.position.data.length / Y.position.components,
                    O = new i.o(this._device, ye, pe),
                    me = new t.O(O);
                  for (let N = 0; N < pe; N++) {
                    for (const V in Y) {
                      const L = Y[V];
                      switch (L.components) {
                        case 1:
                          me.element[$[V]].set(L.data[N]);
                          break;
                        case 2:
                          me.element[$[V]].set(
                            L.data[N * 2],
                            1 - L.data[N * 2 + 1]
                          );
                          break;
                        case 3:
                          me.element[$[V]].set(
                            L.data[N * 3],
                            L.data[N * 3 + 1],
                            L.data[N * 3 + 2]
                          );
                          break;
                        case 4:
                          me.element[$[V]].set(
                            L.data[N * 4],
                            L.data[N * 4 + 1],
                            L.data[N * 4 + 2],
                            L.data[N * 4 + 3]
                          );
                          break;
                      }
                    }
                    me.next();
                  }
                  me.end(), X.push(O);
                }
                return X;
              }
              _parseIndexBuffers(K, te) {
                const X = K.model;
                let $ = null,
                  ne = null,
                  Y,
                  Z = 0;
                for (Y = 0; Y < X.meshes.length; Y++) {
                  const pe = X.meshes[Y];
                  pe.indices !== void 0 && (Z += pe.indices.length);
                }
                let ye = 0;
                for (Y = 0; Y < te.length; Y++)
                  ye = Math.max(ye, te[Y].numVertices);
                return (
                  Z > 0 &&
                    (ye > 65535 && this._device.extUintElement
                      ? (($ = new o.G(this._device, n.qCh, Z)),
                        (ne = new Uint32Array($.lock())))
                      : (($ = new o.G(this._device, n.q0F, Z)),
                        (ne = new Uint16Array($.lock())))),
                  { buffer: $, data: ne }
                );
              }
              _parseMeshes(K, te, X, $, ne, Y) {
                const Z = K.model,
                  ye = [];
                let pe = 0;
                for (let O = 0; O < Z.meshes.length; O++) {
                  const me = Z.meshes[O],
                    N = me.aabb,
                    V = N.min,
                    L = N.max,
                    J = new l.k(
                      new s.A(
                        (L[0] + V[0]) * 0.5,
                        (L[1] + V[1]) * 0.5,
                        (L[2] + V[2]) * 0.5
                      ),
                      new s.A(
                        (L[0] - V[0]) * 0.5,
                        (L[1] - V[1]) * 0.5,
                        (L[2] - V[2]) * 0.5
                      )
                    ),
                    ae = me.indices !== void 0,
                    R = new y.K(this._device);
                  (R.vertexBuffer = $[me.vertices]),
                    (R.indexBuffer[0] = ae ? ne : null),
                    (R.primitive[0].type = A[me.type]),
                    (R.primitive[0].base = ae ? me.base + pe : me.base),
                    (R.primitive[0].count = me.count),
                    (R.primitive[0].indexed = ae),
                    (R.skin = me.skin !== void 0 ? te[me.skin] : null),
                    (R.morph = me.morph !== void 0 ? X[me.morph] : null),
                    (R.aabb = J),
                    ae && (Y.set(me.indices, pe), (pe += me.indices.length)),
                    ye.push(R);
                }
                return ne !== null && ne.unlock(), ye;
              }
              _parseMeshInstances(K, te, X, $, ne, Y, Z) {
                const ye = K.model,
                  pe = [];
                let O;
                for (O = 0; O < ye.meshInstances.length; O++) {
                  const me = ye.meshInstances[O],
                    N = te[me.node],
                    V = X[me.mesh],
                    L = new p.l(V, this._defaultMaterial, N);
                  if (V.skin) {
                    const J = $.indexOf(V.skin);
                    L.skinInstance = ne[J];
                  }
                  if (V.morph) {
                    const J = Y.indexOf(V.morph);
                    L.morphInstance = Z[J];
                  }
                  pe.push(L);
                }
                return pe;
              }
            }
            class w {
              constructor(K) {
                (this.handlerType = "model"),
                  (this._parsers = []),
                  (this.device = K.graphicsDevice),
                  (this.assets = K.assets),
                  (this.defaultMaterial = (0, g.U)(this.device)),
                  (this.maxRetries = 0),
                  this.addParser(new C(this), function (te, X) {
                    return x.E.getExtension(te) === ".json";
                  }),
                  this.addParser(new h(this), function (te, X) {
                    return x.E.getExtension(te) === ".glb";
                  });
              }
              load(K, te, X) {
                typeof K == "string" && (K = { load: K, original: K });
                const $ = {
                  retry: this.maxRetries > 0,
                  maxRetries: this.maxRetries,
                };
                (K.load.startsWith("blob:") || K.load.startsWith("data:")) &&
                  (x.E.getExtension(K.original).toLowerCase() === ".glb"
                    ? ($.responseType = T.e.ResponseType.ARRAY_BUFFER)
                    : ($.responseType = T.e.ResponseType.JSON)),
                  T.d.get(K.load, $, (ne, Y) => {
                    if (te)
                      if (ne) te(`Error loading model: ${K.original} [${ne}]`);
                      else {
                        for (let Z = 0; Z < this._parsers.length; Z++) {
                          const ye = this._parsers[Z];
                          if (ye.decider(K.original, Y)) {
                            ye.parser.parse(
                              Y,
                              (pe, O) => {
                                pe ? te(pe) : te(null, O);
                              },
                              X
                            );
                            return;
                          }
                        }
                        te("No parsers found");
                      }
                  });
              }
              open(K, te) {
                return te;
              }
              patch(K, te) {
                if (!K.resource) return;
                const X = K.data,
                  $ = this;
                K.resource.meshInstances.forEach(function (ne, Y) {
                  if (X.mapping) {
                    const Z = function me(N) {
                      N.resource
                        ? (ne.material = N.resource)
                        : (N.once("load", me), te.load(N)),
                        N.once("remove", function (V) {
                          ne.material === V.resource &&
                            (ne.material = $.defaultMaterial);
                        });
                    };
                    if (!X.mapping[Y]) {
                      ne.material = $.defaultMaterial;
                      return;
                    }
                    const ye = X.mapping[Y].material,
                      pe = X.mapping[Y].path;
                    let O;
                    if (ye !== void 0)
                      ye
                        ? ((O = te.get(ye)), O ? Z(O) : te.once("add:" + ye, Z))
                        : (ne.material = $.defaultMaterial);
                    else if (pe) {
                      const me = K.getAbsoluteUrl(X.mapping[Y].path);
                      (O = te.getByUrl(me)),
                        O ? Z(O) : te.once("add:url:" + me, Z);
                    }
                  }
                });
              }
              addParser(K, te) {
                this._parsers.push({ parser: K, decider: te });
              }
            }
          },
          1642: (Se, W, a) => {
            "use strict";
            a.d(W, { c: () => d });
            var x = a(6598);
            function T(h) {
              const f = this;
              if (!f.resource) return;
              const s = h.resource,
                l = s.renders && s.renders[f.data.renderIndex];
              l && (f.resource.meshes = l.resource.meshes);
            }
            function g(h) {
              const f = this;
              f.registry.off("load:" + h.id, T, f),
                f.registry.on("load:" + h.id, T, f),
                f.registry.off("remove:" + h.id, c, f),
                f.registry.once("remove:" + h.id, c, f),
                h.resource ? T.call(f, h) : f.registry.load(h);
            }
            function c(h) {
              const f = this;
              f.registry.off("load:" + h.id, T, f),
                f.resource && f.resource.destroy();
            }
            class d {
              constructor(f) {
                (this.handlerType = "render"), (this._registry = f.assets);
              }
              load(f, s, l) {}
              open(f, s) {
                return new x.H();
              }
              patch(f, s) {
                if (!f.data.containerAsset) return;
                const l = s.get(f.data.containerAsset);
                if (!l) {
                  s.once("add:" + f.data.containerAsset, g, f);
                  return;
                }
                g.call(f, l);
              }
            }
          },
          8297: (Se, W, a) => {
            "use strict";
            a.d(W, { p: () => T });
            var x = a(1467);
            const T = {
              load: function (g, c, d) {
                typeof g == "string" && (g = { load: g, original: g }),
                  x.d.get(
                    g.load,
                    { retry: c > 0, maxRetries: c },
                    function (h, f) {
                      if (!h) d(h, f);
                      else {
                        let s = "Error while loading scene JSON " + g.original;
                        h.message
                          ? ((s += ": " + h.message),
                            h.stack &&
                              (s +=
                                `
` + h.stack))
                          : (s += ": " + h),
                          d(s);
                      }
                    }
                  );
              },
            };
          },
          8169: (Se, W, a) => {
            "use strict";
            a.d(W, { d: () => g });
            var x = a(8297),
              T = a(544);
            class g {
              constructor(d) {
                (this.handlerType = "scene"),
                  (this._app = d),
                  (this.maxRetries = 0);
              }
              load(d, h) {
                x.p.load(d, this.maxRetries, h);
              }
              open(d, h) {
                this._app.systems.script.preloading = !0;
                const s = new T.n(this._app, !1).parse(h),
                  l = this._app.scene;
                return (
                  (l.root = s),
                  this._app.applySceneSettings(h.settings),
                  (this._app.systems.script.preloading = !1),
                  l
                );
              }
              patch(d, h) {}
            }
          },
          1297: (Se, W, a) => {
            "use strict";
            a.d(W, { z: () => c });
            var x = a(5751),
              T = a(8615),
              g = a(8936);
            class c {
              constructor(h) {
                (this.handlerType = "script"),
                  (this._app = h),
                  (this._scripts = {}),
                  (this._cache = {});
              }
              clearCache() {
                for (const h in this._cache) {
                  const f = this._cache[h],
                    s = f.parentNode;
                  s && s.removeChild(f);
                }
                this._cache = {};
              }
              load(h, f) {
                typeof h == "string" && (h = { load: h, original: h });
                const s = this;
                (x._.app = this._app),
                  this._loadScript(h.load, (l, n, o) => {
                    if (l) f(l);
                    else if (x._.legacy) {
                      let i = null;
                      T.t._types.length && (i = T.t._types.pop()),
                        i ? (this._scripts[n] = i) : (i = null),
                        f(null, i, o);
                    } else {
                      const i = {};
                      for (let e = 0; e < T.t._types.length; e++)
                        i[T.t._types[e].name] = T.t._types[e];
                      (T.t._types.length = 0),
                        f(null, i, o),
                        delete s._loader._cache[g.h.makeKey(n, "script")];
                    }
                  });
              }
              open(h, f) {
                return f;
              }
              patch(h, f) {}
              _loadScript(h, f) {
                const s = document.head,
                  l = document.createElement("script");
                (this._cache[h] = l),
                  (l.async = !1),
                  l.addEventListener(
                    "error",
                    function (o) {
                      f(`Script: ${o.target.src} failed to load`);
                    },
                    !1
                  );
                let n = !1;
                (l.onload = l.onreadystatechange =
                  function () {
                    !n &&
                      (!this.readyState ||
                        this.readyState === "loaded" ||
                        this.readyState === "complete") &&
                      ((n = !0), f(null, h, l));
                  }),
                  (l.src = h),
                  s.appendChild(l);
              }
            }
          },
          8115: (Se, W, a) => {
            "use strict";
            a.d(W, { C: () => T });
            var x = a(1467);
            class T {
              constructor(c) {
                (this.handlerType = "shader"), (this.maxRetries = 0);
              }
              load(c, d) {
                typeof c == "string" && (c = { load: c, original: c }),
                  x.d.get(
                    c.load,
                    { retry: this.maxRetries > 0, maxRetries: this.maxRetries },
                    function (h, f) {
                      h
                        ? d(
                            `Error loading shader resource: ${c.original} [${h}]`
                          )
                        : d(null, f);
                    }
                  );
              }
              open(c, d) {
                return d;
              }
              patch(c, d) {}
            }
          },
          1761: (Se, W, a) => {
            "use strict";
            a.d(W, { B: () => h });
            var x = a(9296),
              T = a(1467),
              g = a(9432);
            function c(f) {
              const s = this;
              s.resource && (s.resource.atlas = f.resource);
            }
            function d(f) {
              this.registry.load(f);
            }
            class h {
              constructor(s) {
                (this.handlerType = "sprite"),
                  (this._assets = s.assets),
                  (this._device = s.graphicsDevice),
                  (this.maxRetries = 0);
              }
              load(s, l) {
                typeof s == "string" && (s = { load: s, original: s }),
                  x.E.getExtension(s.original) === ".json" &&
                    T.d.get(
                      s.load,
                      {
                        retry: this.maxRetries > 0,
                        maxRetries: this.maxRetries,
                      },
                      function (n, o) {
                        n ? l(n) : l(null, o);
                      }
                    );
              }
              open(s, l) {
                const n = new g.j(this._device);
                return s && (n.__data = l), n;
              }
              patch(s, l) {
                const n = s.resource;
                if (
                  n.__data &&
                  ((s.data.pixelsPerUnit = n.__data.pixelsPerUnit),
                  (s.data.renderMode = n.__data.renderMode),
                  (s.data.frameKeys = n.__data.frameKeys),
                  n.__data.textureAtlasAsset)
                ) {
                  const o = l.getByUrl(n.__data.textureAtlasAsset);
                  o
                    ? (s.data.textureAtlasAsset = o.id)
                    : console.warn(
                        "Could not find textureatlas with url: " +
                          n.__data.textureAtlasAsset
                      );
                }
                n.startUpdate(),
                  (n.renderMode = s.data.renderMode),
                  (n.pixelsPerUnit = s.data.pixelsPerUnit),
                  (n.frameKeys = s.data.frameKeys),
                  this._updateAtlas(s),
                  n.endUpdate(),
                  s.off("change", this._onAssetChange, this),
                  s.on("change", this._onAssetChange, this);
              }
              _updateAtlas(s) {
                const l = s.resource;
                if (!s.data.textureAtlasAsset) {
                  l.atlas = null;
                  return;
                }
                this._assets.off("load:" + s.data.textureAtlasAsset, c, s),
                  this._assets.on("load:" + s.data.textureAtlasAsset, c, s);
                const n = this._assets.get(s.data.textureAtlasAsset);
                n && n.resource
                  ? (l.atlas = n.resource)
                  : n
                  ? this._assets.load(n)
                  : (this._assets.off("add:" + s.data.textureAtlasAsset, d, s),
                    this._assets.on("add:" + s.data.textureAtlasAsset, d, s));
              }
              _onAssetChange(s, l, n, o) {
                l === "data" &&
                  n &&
                  n.textureAtlasAsset &&
                  o &&
                  n.textureAtlasAsset !== o.textureAtlasAsset &&
                  (this._assets.off("load:" + o.textureAtlasAsset, c, s),
                  this._assets.off("add:" + o.textureAtlasAsset, d, s));
              }
            }
          },
          7265: (Se, W, a) => {
            "use strict";
            a.d(W, { V: () => g });
            var x = a(1467),
              T = a(7088);
            class g {
              constructor(d) {
                (this.handlerType = "template"),
                  (this._app = d),
                  (this.maxRetries = 0);
              }
              load(d, h) {
                typeof d == "string" && (d = { load: d, original: d });
                const f = {
                  retry: this.maxRetries > 0,
                  maxRetries: this.maxRetries,
                };
                x.d.get(d.load, f, function (s, l) {
                  s ? h("Error requesting template: " + d.original) : h(s, l);
                });
              }
              open(d, h) {
                return new T.Y(this._app, h);
              }
            }
          },
          8769: (Se, W, a) => {
            "use strict";
            a.d(W, { q: () => T });
            var x = a(1467);
            class T {
              constructor(c) {
                (this.handlerType = "text"), (this.maxRetries = 0);
              }
              load(c, d) {
                typeof c == "string" && (c = { load: c, original: c }),
                  x.d.get(
                    c.load,
                    { retry: this.maxRetries > 0, maxRetries: this.maxRetries },
                    function (h, f) {
                      h
                        ? d(`Error loading text resource: ${c.original} [${h}]`)
                        : d(null, f);
                    }
                  );
              }
              open(c, d) {
                return d;
              }
              patch(c, d) {}
            }
          },
          5275: (Se, W, a) => {
            "use strict";
            a.d(W, { d: () => n });
            var x = a(9296),
              T = a(2978),
              g = a(6630),
              c = a(7921),
              d = a(1467),
              h = a(6567);
            const f = { repeat: c.SuC, clamp: c.uFb, mirror: c.nVg },
              s = {
                nearest: c.yib,
                linear: c.I5X,
                nearest_mip_nearest: c.Aap,
                linear_mip_nearest: c.feq,
                nearest_mip_linear: c.$_P,
                linear_mip_linear: c.Snx,
              },
              l = /^data\.frames\.(\d+)$/;
            class n {
              constructor(i) {
                (this.handlerType = "textureatlas"),
                  (this._loader = i.loader),
                  (this.maxRetries = 0);
              }
              load(i, e) {
                typeof i == "string" && (i = { load: i, original: i });
                const t = this,
                  r = this._loader.getHandler("texture");
                if (x.E.getExtension(i.original) === ".json")
                  d.d.get(
                    i.load,
                    { retry: this.maxRetries > 0, maxRetries: this.maxRetries },
                    function (u, y) {
                      if (u) e(u);
                      else {
                        const p = i.original.replace(".json", ".png");
                        t._loader.load(p, "texture", function (_, m) {
                          _ ? e(_) : e(null, { data: y, texture: m });
                        });
                      }
                    }
                  );
                else return r.load(i, e);
              }
              open(i, e) {
                const t = new h.Y();
                if (e.texture && e.data)
                  (t.texture = e.texture), (t.__data = e.data);
                else {
                  const u = this._loader.getHandler("texture").open(i, e);
                  if (!u) return null;
                  t.texture = u;
                }
                return t;
              }
              patch(i, e) {
                if (!i.resource) return;
                i.resource.__data &&
                  (i.resource.__data.minfilter !== void 0 &&
                    (i.data.minfilter = i.resource.__data.minfilter),
                  i.resource.__data.magfilter !== void 0 &&
                    (i.data.magfilter = i.resource.__data.magfilter),
                  i.resource.__data.addressu !== void 0 &&
                    (i.data.addressu = i.resource.__data.addressu),
                  i.resource.__data.addressv !== void 0 &&
                    (i.data.addressv = i.resource.__data.addressv),
                  i.resource.__data.mipmaps !== void 0 &&
                    (i.data.mipmaps = i.resource.__data.mipmaps),
                  i.resource.__data.anisotropy !== void 0 &&
                    (i.data.anisotropy = i.resource.__data.anisotropy),
                  i.resource.__data.rgbm !== void 0 &&
                    (i.data.rgbm = !!i.resource.__data.rgbm),
                  (i.data.frames = i.resource.__data.frames),
                  delete i.resource.__data);
                const t = i.resource.texture;
                if (
                  t &&
                  ((t.name = i.name),
                  i.data.hasOwnProperty("minfilter") &&
                    t.minFilter !== s[i.data.minfilter] &&
                    (t.minFilter = s[i.data.minfilter]),
                  i.data.hasOwnProperty("magfilter") &&
                    t.magFilter !== s[i.data.magfilter] &&
                    (t.magFilter = s[i.data.magfilter]),
                  i.data.hasOwnProperty("addressu") &&
                    t.addressU !== f[i.data.addressu] &&
                    (t.addressU = f[i.data.addressu]),
                  i.data.hasOwnProperty("addressv") &&
                    t.addressV !== f[i.data.addressv] &&
                    (t.addressV = f[i.data.addressv]),
                  i.data.hasOwnProperty("mipmaps") &&
                    t.mipmaps !== i.data.mipmaps &&
                    (t.mipmaps = i.data.mipmaps),
                  i.data.hasOwnProperty("anisotropy") &&
                    t.anisotropy !== i.data.anisotropy &&
                    (t.anisotropy = i.data.anisotropy),
                  i.data.hasOwnProperty("rgbm"))
                ) {
                  const u = i.data.rgbm ? c.xIP : c.zZc;
                  t.type !== u && (t.type = u);
                }
                i.resource.texture = t;
                const r = {};
                for (const u in i.data.frames) {
                  const y = i.data.frames[u];
                  r[u] = {
                    rect: new g.T(y.rect),
                    pivot: new T.S(y.pivot),
                    border: new g.T(y.border),
                  };
                }
                (i.resource.frames = r),
                  i.off("change", this._onAssetChange, this),
                  i.on("change", this._onAssetChange, this);
              }
              _onAssetChange(i, e, t) {
                let r;
                if (e === "data" || e === "data.frames") {
                  const u = {};
                  for (const y in t.frames)
                    (r = t.frames[y]),
                      (u[y] = {
                        rect: new g.T(r.rect),
                        pivot: new T.S(r.pivot),
                        border: new g.T(r.border),
                      });
                  i.resource.frames = u;
                } else {
                  const u = e.match(l);
                  if (u) {
                    const y = u[1];
                    t
                      ? (i.resource.frames[y]
                          ? ((r = i.resource.frames[y]),
                            r.rect.set(
                              t.rect[0],
                              t.rect[1],
                              t.rect[2],
                              t.rect[3]
                            ),
                            r.pivot.set(t.pivot[0], t.pivot[1]),
                            r.border.set(
                              t.border[0],
                              t.border[1],
                              t.border[2],
                              t.border[3]
                            ))
                          : (i.resource.frames[y] = {
                              rect: new g.T(t.rect),
                              pivot: new T.S(t.pivot),
                              border: new g.T(t.border),
                            }),
                        i.resource.fire("set:frame", y, i.resource.frames[y]))
                      : i.resource.frames[y] &&
                        (delete i.resource.frames[y],
                        i.resource.fire("remove:frame", y));
                  }
                }
              }
            }
          },
          8020: (Se, W, a) => {
            "use strict";
            a.d(W, { A: () => A, _: () => P });
            var x = a(9296),
              T = a(7921),
              g = a(8869),
              c = a(9078),
              d = a(6204),
              h = a(3009);
            class f {
              constructor(C, w) {
                (this.device = w), (this.maxRetries = 0);
              }
              load(C, w, k) {
                const K = this.device,
                  te = (X) => {
                    var $;
                    (0, h.f)(K, C.load, X, w, {
                      isGGGR:
                        ((k == null ||
                        ($ = k.file) == null ||
                        ($ = $.variants) == null ||
                        ($ = $.basis) == null
                          ? void 0
                          : $.opt) &
                          8) !==
                        0,
                    }) ||
                      w(
                        `Basis module not found. Asset '${k.name}' basis texture variant will not be loaded.`
                      );
                  };
                d.x.fetchArrayBuffer(
                  C.load,
                  (X, $) => {
                    X ? w(X) : te($);
                  },
                  k,
                  this.maxRetries
                );
              }
              open(C, w, k, K = {}) {
                const te = new g.x(
                  k,
                  (0, c.g)(
                    {
                      name: C,
                      addressU: w.cubemap ? T.uFb : T.SuC,
                      addressV: w.cubemap ? T.uFb : T.SuC,
                      width: w.width,
                      height: w.height,
                      format: w.format,
                      cubemap: w.cubemap,
                      levels: w.levels,
                    },
                    K
                  )
                );
                return te.upload(), te;
              }
            }
            var s = a(1467),
              l = a(8462);
            class n {
              constructor(C, w) {
                (this.crossOrigin = C.prefix ? "anonymous" : null),
                  (this.maxRetries = 0),
                  (this.device = w);
              }
              load(C, w, k) {
                var K;
                const te = !!(k != null && (K = k.file) != null && K.contents);
                if (te) {
                  if (this.device.supportsImageBitmap) {
                    this._loadImageBitmapFromBlob(
                      new Blob([k.file.contents]),
                      w
                    );
                    return;
                  }
                  C = {
                    load: URL.createObjectURL(new Blob([k.file.contents])),
                    original: C.original,
                  };
                }
                const X = (ne, Y) => {
                  te && URL.revokeObjectURL(C.load), w(ne, Y);
                };
                let $;
                k && k.options && k.options.hasOwnProperty("crossOrigin")
                  ? ($ = k.options.crossOrigin)
                  : l.P1.test(C.load) && ($ = this.crossOrigin),
                  this.device.supportsImageBitmap
                    ? this._loadImageBitmap(C.load, C.original, $, X)
                    : this._loadImage(C.load, C.original, $, X);
              }
              open(C, w, k, K = {}) {
                const te = new g.x(
                  k,
                  (0, c.g)(
                    {
                      name: C,
                      width: w.width,
                      height: w.height,
                      format: T.jKI,
                    },
                    K
                  )
                );
                return te.setSource(w), te;
              }
              _loadImage(C, w, k, K) {
                const te = new Image();
                k && (te.crossOrigin = k);
                let X = 0;
                const $ = this.maxRetries;
                let ne;
                (te.onload = function () {
                  K(null, te);
                }),
                  (te.onerror = function () {
                    if (!ne)
                      if ($ > 0 && ++X <= $) {
                        const Y = Math.pow(2, X) * 100;
                        console.log(
                          `Error loading Texture from: '${w}' - Retrying in ${Y}ms...`
                        );
                        const ye = C.indexOf("?") >= 0 ? "&" : "?";
                        ne = setTimeout(function () {
                          (te.src = C + ye + "retry=" + Date.now()),
                            (ne = null);
                        }, Y);
                      } else K(`Error loading Texture from: '${w}'`);
                  }),
                  (te.src = C);
              }
              _loadImageBitmap(C, w, k, K) {
                const te = {
                  cache: !0,
                  responseType: "blob",
                  retry: this.maxRetries > 0,
                  maxRetries: this.maxRetries,
                };
                s.d.get(C, te, (X, $) => {
                  X ? K(X) : this._loadImageBitmapFromBlob($, K);
                });
              }
              _loadImageBitmapFromBlob(C, w) {
                createImageBitmap(C, {
                  premultiplyAlpha: "none",
                  colorSpaceConversion: "none",
                })
                  .then((k) => w(null, k))
                  .catch((k) => w(k));
              }
            }
            const o = [1481919403, 3140563232, 169478669],
              i = {
                33776: T.TES,
                33778: T.UPc,
                33779: T.ZtC,
                36196: T.IAT,
                37492: T.krP,
                37496: T.MwV,
                35840: T.NeV,
                35841: T.eV7,
                35842: T._t$,
                35843: T.g0o,
                32849: T.Hsr,
                32856: T.jKI,
                35905: T.wNl,
                35907: T.X8g,
                35898: T.kYl,
                34843: T.q_o,
                34842: T.a7f,
              };
            function e(B, C, w, k) {
              return B === T.kYl
                ? new Uint32Array(C, w, k / 4)
                : new Uint8Array(C, w, k);
            }
            class t {
              constructor(C) {
                this.maxRetries = 0;
              }
              load(C, w, k) {
                d.x.fetchArrayBuffer(C.load, w, k, this.maxRetries);
              }
              open(C, w, k, K = {}) {
                const te = this.parse(w);
                if (!te) return null;
                const X = new g.x(
                  k,
                  (0, c.g)(
                    {
                      name: C,
                      addressU: te.cubemap ? T.uFb : T.SuC,
                      addressV: te.cubemap ? T.uFb : T.SuC,
                      width: te.width,
                      height: te.height,
                      format: te.format,
                      cubemap: te.cubemap,
                      levels: te.levels,
                    },
                    K
                  )
                );
                return X.upload(), X;
              }
              parse(C) {
                const w = new Uint32Array(C);
                if (o[0] !== w[0] || o[1] !== w[1] || o[2] !== w[2])
                  return null;
                const k = {
                  endianness: w[3],
                  glType: w[4],
                  glTypeSize: w[5],
                  glFormat: w[6],
                  glInternalFormat: w[7],
                  glBaseInternalFormat: w[8],
                  pixelWidth: w[9],
                  pixelHeight: w[10],
                  pixelDepth: w[11],
                  numberOfArrayElements: w[12],
                  numberOfFaces: w[13],
                  numberOfMipmapLevels: w[14],
                  bytesOfKeyValueData: w[15],
                };
                if (k.pixelDepth > 1 || k.numberOfArrayElements !== 0)
                  return null;
                const K = i[k.glInternalFormat];
                if (K === void 0) return null;
                let te = 16 + k.bytesOfKeyValueData / 4;
                const X = k.numberOfFaces > 1,
                  $ = [];
                for (let ne = 0; ne < (k.numberOfMipmapLevels || 1); ne++) {
                  const Y = w[te++];
                  X && $.push([]);
                  const Z = X ? $[ne] : $;
                  for (let ye = 0; ye < (X ? 6 : 1); ++ye)
                    Z.push(e(K, C, te * 4, Y)), (te += (Y + 3) >> 2);
                }
                return {
                  format: K,
                  width: k.pixelWidth,
                  height: k.pixelHeight,
                  levels: $,
                  cubemap: X,
                };
              }
            }
            var r = a(6458);
            const u = { KHR_DF_MODEL_ETC1S: 163, KHR_DF_MODEL_UASTC: 166 };
            class y {
              constructor(C, w) {
                (this.maxRetries = 0), (this.device = w);
              }
              load(C, w, k) {
                d.x.fetchArrayBuffer(
                  C.load,
                  (K, te) => {
                    K ? w(K, te) : this.parse(te, C, w, k);
                  },
                  k,
                  this.maxRetries
                );
              }
              open(C, w, k, K = {}) {
                const te = new g.x(
                  k,
                  (0, c.g)(
                    {
                      name: C,
                      addressU: w.cubemap ? T.uFb : T.SuC,
                      addressV: w.cubemap ? T.uFb : T.SuC,
                      width: w.width,
                      height: w.height,
                      format: w.format,
                      cubemap: w.cubemap,
                      levels: w.levels,
                    },
                    K
                  )
                );
                return te.upload(), te;
              }
              parse(C, w, k, K) {
                const te = new r.H(C),
                  X = [te.readU32be(), te.readU32be(), te.readU32be()];
                if (
                  X[0] !== 2873840728 ||
                  X[1] !== 540160187 ||
                  X[2] !== 218765834
                )
                  return null;
                const $ = {
                    vkFormat: te.readU32(),
                    typeSize: te.readU32(),
                    pixelWidth: te.readU32(),
                    pixelHeight: te.readU32(),
                    pixelDepth: te.readU32(),
                    layerCount: te.readU32(),
                    faceCount: te.readU32(),
                    levelCount: te.readU32(),
                    supercompressionScheme: te.readU32(),
                  },
                  ne = {
                    dfdByteOffset: te.readU32(),
                    dfdByteLength: te.readU32(),
                    kvdByteOffset: te.readU32(),
                    kvdByteLength: te.readU32(),
                    sgdByteOffset: te.readU64(),
                    sgdByteLength: te.readU64(),
                  },
                  Y = [];
                for (let O = 0; O < Math.max(1, $.levelCount); ++O)
                  Y.push({
                    byteOffset: te.readU64(),
                    byteLength: te.readU64(),
                    uncompressedByteLength: te.readU64(),
                  });
                if (te.readU32() !== ne.kvdByteOffset - ne.dfdByteOffset)
                  return null;
                te.skip(8);
                const ye = te.readU8();
                if (
                  (te.skip(ne.dfdByteLength - 9),
                  te.skip(ne.kvdByteLength),
                  $.supercompressionScheme === 1 || ye === u.KHR_DF_MODEL_UASTC)
                ) {
                  var pe;
                  (0, h.f)(this.device, w.load, C, k, {
                    isGGGR:
                      ((K == null ||
                      (pe = K.file) == null ||
                      (pe = pe.variants) == null ||
                      (pe = pe.basis) == null
                        ? void 0
                        : pe.opt) &
                        8) !==
                      0,
                    isKTX2: !0,
                  }) ||
                    k(
                      'Basis module not found. Asset "' +
                        K.name +
                        '" basis texture variant will not be loaded.'
                    );
                } else k("unsupported KTX2 pixel format");
              }
            }
            class p {
              constructor(C) {
                this.maxRetries = 0;
              }
              load(C, w, k) {
                d.x.fetchArrayBuffer(C.load, w, k, this.maxRetries);
              }
              open(C, w, k, K = {}) {
                const te = new Uint32Array(w, 0, 32),
                  X = te[4],
                  $ = te[3],
                  ne = Math.max(te[7], 1),
                  Y = te[20] === 4,
                  Z = te[21],
                  ye = te[22],
                  pe = te[28] === 65024,
                  O = 827611204,
                  me = 894720068,
                  N = 113,
                  V = 116,
                  L = 826496069,
                  J = 825438800,
                  ae = 825504336,
                  R = 825439312,
                  j = 825504848;
                let se = !1,
                  ce = !1,
                  ie = !1,
                  b = !1,
                  M = null,
                  F = 1,
                  z;
                if (
                  (Y
                    ? Z === O
                      ? ((M = T.TES), (se = !0))
                      : Z === me
                      ? ((M = T.ZtC), (se = !0))
                      : Z === N
                      ? ((M = T.a7f), (F = 2))
                      : Z === V
                      ? ((M = T.uC3), (F = 4))
                      : Z === L
                      ? ((M = T.IAT), (se = !0), (ce = !0))
                      : Z === J || Z === ae
                      ? ((M = Z === J ? T.eV7 : T.g0o), (se = !0), (ie = !0))
                      : (Z === R || Z === j) &&
                        ((M = Z === R ? T.NeV : T._t$), (se = !0), (b = !0))
                    : ye === 32 && (M = T.jKI),
                  !M)
                )
                  return (
                    (z = new g.x(k, {
                      width: 4,
                      height: 4,
                      format: T.Hsr,
                      name: "dds-legacy-empty",
                    })),
                    z
                  );
                z = new g.x(
                  k,
                  (0, c.g)(
                    {
                      name: C,
                      addressU: pe ? T.uFb : T.SuC,
                      addressV: pe ? T.uFb : T.SuC,
                      width: X,
                      height: $,
                      format: M,
                      cubemap: pe,
                      mipmaps: ne > 1,
                    },
                    K
                  )
                );
                let oe = 128;
                const de = pe ? 6 : 1;
                let ge;
                const Re = 4,
                  Te = 4,
                  Ne = Z === O ? 8 : 16;
                let Le, ke, ht;
                for (let _e = 0; _e < de; _e++) {
                  let U = X,
                    H = $;
                  for (let Ee = 0; Ee < ne; Ee++) {
                    se
                      ? ce
                        ? (ge =
                            Math.floor((U + 3) / 4) *
                            Math.floor((H + 3) / 4) *
                            8)
                        : ie
                        ? (ge = (Math.max(U, 16) * Math.max(H, 8)) / 4)
                        : b
                        ? (ge = (Math.max(U, 8) * Math.max(H, 8)) / 2)
                        : ((Le = Math.floor((U + Re - 1) / Re)),
                          (ke = Math.floor((H + Te - 1) / Te)),
                          (ht = Le * ke),
                          (ge = ht * Ne))
                      : (ge = U * H * 4);
                    const G =
                      M === T.uC3
                        ? new Float32Array(w, oe, ge)
                        : M === T.a7f
                        ? new Uint16Array(w, oe, ge)
                        : new Uint8Array(w, oe, ge);
                    pe
                      ? (z._levels[Ee] || (z._levels[Ee] = []),
                        (z._levels[Ee][_e] = G))
                      : (z._levels[Ee] = G),
                      (oe += ge * F),
                      (U = Math.max(U * 0.5, 1)),
                      (H = Math.max(H * 0.5, 1));
                  }
                }
                return z.upload(), z;
              }
            }
            class _ {
              constructor(C) {
                this.maxRetries = 0;
              }
              load(C, w, k) {
                d.x.fetchArrayBuffer(C.load, w, k, this.maxRetries);
              }
              open(C, w, k, K = {}) {
                const te = this.parse(w);
                if (!te) return null;
                const X = new g.x(
                  k,
                  (0, c.g)(
                    {
                      name: C,
                      addressU: T.SuC,
                      addressV: T.uFb,
                      minFilter: T.yib,
                      magFilter: T.yib,
                      width: te.width,
                      height: te.height,
                      levels: te.levels,
                      format: T.jKI,
                      type: T.puI,
                      mipmaps: !1,
                    },
                    K
                  )
                );
                return X.upload(), X;
              }
              parse(C) {
                const w = new r.H(C);
                if (!w.readLine().startsWith("#?RADIANCE")) return null;
                const K = {};
                for (;;) {
                  const Y = w.readLine();
                  if (Y.length === 0) break;
                  {
                    const Z = Y.split("=");
                    Z.length === 2 && (K[Z[0]] = Z[1]);
                  }
                }
                if (!K.hasOwnProperty("FORMAT")) return null;
                const te = w.readLine().split(" ");
                if (te.length !== 4) return null;
                const X = parseInt(te[1], 10),
                  $ = parseInt(te[3], 10),
                  ne = this._readPixels(w, $, X, te[0] === "-Y");
                return ne ? { width: $, height: X, levels: [ne] } : null;
              }
              _readPixels(C, w, k, K) {
                if (w < 8 || w > 32767) return this._readPixelsFlat(C, w, k);
                const te = [0, 0, 0, 0];
                if (
                  (C.readArray(te), te[0] !== 2 || te[1] !== 2 || te[2] & 128)
                )
                  return C.skip(-4), this._readPixelsFlat(C, w, k);
                const X = new ArrayBuffer(w * k * 4),
                  $ = new Uint8Array(X);
                let ne = K ? 0 : w * 4 * (k - 1),
                  Y,
                  Z,
                  ye,
                  pe,
                  O,
                  me;
                for (Z = 0; Z < k; ++Z) {
                  if ((Z && C.readArray(te), (te[2] << 8) + te[3] !== w))
                    return null;
                  for (pe = 0; pe < 4; ++pe)
                    for (Y = 0; Y < w; )
                      if (((O = C.readU8()), O > 128)) {
                        if (((O -= 128), Y + O > w)) return null;
                        for (me = C.readU8(), ye = 0; ye < O; ++ye)
                          $[ne + pe + 4 * Y++] = me;
                      } else {
                        if (O === 0 || Y + O > w) return null;
                        for (ye = 0; ye < O; ++ye)
                          $[ne + pe + 4 * Y++] = C.readU8();
                      }
                  ne += w * 4 * (K ? 1 : -1);
                }
                return $;
              }
              _readPixelsFlat(C, w, k) {
                return C.remainingBytes === w * k * 4
                  ? new Uint8Array(C.arraybuffer, C.offset)
                  : null;
              }
            }
            const m = { repeat: T.SuC, clamp: T.uFb, mirror: T.nVg },
              E = {
                nearest: T.yib,
                linear: T.I5X,
                nearest_mip_nearest: T.Aap,
                linear_mip_nearest: T.feq,
                nearest_mip_linear: T.$_P,
                linear_mip_linear: T.Snx,
              },
              v = {
                default: T.zZc,
                rgbm: T.xIP,
                rgbe: T.puI,
                rgbp: T.kVJ,
                swizzleGGGR: T.anS,
              };
            class P {
              load(C, w, k) {
                throw new Error("not implemented");
              }
              open(C, w, k) {
                throw new Error("not implemented");
              }
            }
            const I = function (C) {
              const w = Math.log2(Math.max(C._width, C._height)) + 1,
                k = function (X) {
                  return (
                    X instanceof HTMLCanvasElement ||
                    X instanceof HTMLImageElement ||
                    X instanceof HTMLVideoElement
                  );
                };
              if (
                !(C._format === T.jKI || C._format === T.uC3) ||
                C._volume ||
                C._compressed ||
                C._levels.length === 1 ||
                C._levels.length === w ||
                k(C._cubemap ? C._levels[0][0] : C._levels[0])
              )
                return;
              const K = function (X, $, ne) {
                const Y = Math.max(1, X >> 1),
                  Z = Math.max(1, $ >> 1),
                  ye = new ne.constructor(Y * Z * 4),
                  pe = Math.floor(X / Y),
                  O = Math.floor($ / Z),
                  me = pe * O;
                for (let N = 0; N < Z; ++N)
                  for (let V = 0; V < Y; ++V)
                    for (let L = 0; L < 4; ++L) {
                      let J = 0;
                      for (let ae = 0; ae < O; ++ae)
                        for (let R = 0; R < pe; ++R)
                          J += ne[(V * pe + R + (N * O + ae) * X) * 4 + L];
                      ye[(V + N * Y) * 4 + L] = J / me;
                    }
                return ye;
              };
              for (let te = C._levels.length; te < w; ++te) {
                const X = Math.max(1, C._width >> (te - 1)),
                  $ = Math.max(1, C._height >> (te - 1));
                if (C._cubemap) {
                  const ne = [];
                  for (let Y = 0; Y < 6; ++Y)
                    ne.push(K(X, $, C._levels[te - 1][Y]));
                  C._levels.push(ne);
                } else C._levels.push(K(X, $, C._levels[te - 1]));
              }
              C._levelsUpdated = C._cubemap ? [[!0, !0, !0, !0, !0, !0]] : [!0];
            };
            class A {
              constructor(C) {
                this.handlerType = "texture";
                const w = C.assets,
                  k = C.graphicsDevice;
                (this._device = k),
                  (this._assets = w),
                  (this.imgParser = new n(w, k)),
                  (this.parsers = {
                    dds: new p(w),
                    ktx: new t(w),
                    ktx2: new y(w, k),
                    basis: new f(w, k),
                    hdr: new _(w),
                  });
              }
              set crossOrigin(C) {
                this.imgParser.crossOrigin = C;
              }
              get crossOrigin() {
                return this.imgParser.crossOrigin;
              }
              set maxRetries(C) {
                this.imgParser.maxRetries = C;
                for (const w in this.parsers)
                  this.parsers.hasOwnProperty(w) &&
                    (this.parsers[w].maxRetries = C);
              }
              get maxRetries() {
                return this.imgParser.maxRetries;
              }
              _getUrlWithoutParams(C) {
                return C.indexOf("?") >= 0 ? C.split("?")[0] : C;
              }
              _getParser(C) {
                const w = x.E.getExtension(this._getUrlWithoutParams(C))
                  .toLowerCase()
                  .replace(".", "");
                return this.parsers[w] || this.imgParser;
              }
              _getTextureOptions(C) {
                const w = {};
                if (C) {
                  var k;
                  ((k = C.name) == null ? void 0 : k.length) > 0 &&
                    (w.name = C.name);
                  const K = C.data;
                  K.hasOwnProperty("minfilter") &&
                    (w.minFilter = E[K.minfilter]),
                    K.hasOwnProperty("magfilter") &&
                      (w.magFilter = E[K.magfilter]),
                    K.hasOwnProperty("addressu") &&
                      (w.addressU = m[K.addressu]),
                    K.hasOwnProperty("addressv") &&
                      (w.addressV = m[K.addressv]),
                    K.hasOwnProperty("mipmaps") && (w.mipmaps = K.mipmaps),
                    K.hasOwnProperty("anisotropy") &&
                      (w.anisotropy = K.anisotropy),
                    K.hasOwnProperty("flipY") && (w.flipY = !!K.flipY),
                    K.hasOwnProperty("type")
                      ? (w.type = v[K.type])
                      : K.hasOwnProperty("rgbm") && K.rgbm
                      ? (w.type = T.xIP)
                      : C.file && C.file.opt & 8 && (w.type = T.anS);
                }
                return w;
              }
              load(C, w, k) {
                typeof C == "string" && (C = { load: C, original: C }),
                  this._getParser(C.original).load(C, w, k);
              }
              open(C, w, k) {
                if (!C) return;
                const K = this._getTextureOptions(k);
                let te = this._getParser(C).open(C, w, this._device, K);
                return (
                  te === null
                    ? (te = new g.x(this._device, {
                        width: 4,
                        height: 4,
                        format: T.Hsr,
                      }))
                    : (I(te),
                      w.unswizzledGGGR && (k.file.variants.basis.opt &= -9)),
                  te
                );
              }
              patch(C, w) {
                const k = C.resource;
                if (!k) return;
                const K = this._getTextureOptions(C);
                for (const te of Object.keys(K)) k[te] = K[te];
              }
            }
          },
          4055: (Se, W, a) => {
            "use strict";
            a.d(W, { Z: () => x, p: () => T });
            const x = "en-US",
              T = {
                en: "en-US",
                es: "en-ES",
                zh: "zh-CN",
                "zh-HK": "zh-TW",
                "zh-TW": "zh-HK",
                "zh-MO": "zh-HK",
                fr: "fr-FR",
                de: "de-DE",
                it: "it-IT",
                ru: "ru-RU",
                ja: "ja-JP",
              };
          },
          68: (Se, W, a) => {
            "use strict";
            a.d(W, { o: () => h });
            var x = a(5338),
              T = a(6204);
            class g {
              _validate(s) {
                if (!s.header)
                  throw new Error('pc.I18n#addData: Missing "header" field');
                if (!s.header.version)
                  throw new Error(
                    'pc.I18n#addData: Missing "header.version" field'
                  );
                if (s.header.version !== 1)
                  throw new Error(
                    'pc.I18n#addData: Invalid "header.version" field'
                  );
                if (s.data) {
                  if (!Array.isArray(s.data))
                    throw new Error(
                      'pc.I18n#addData: "data" field must be an array'
                    );
                } else throw new Error('pc.I18n#addData: Missing "data" field');
                for (let l = 0, n = s.data.length; l < n; l++) {
                  const o = s.data[l];
                  if (!o.info)
                    throw new Error(
                      `pc.I18n#addData: missing "data[${l}].info" field`
                    );
                  if (!o.info.locale)
                    throw new Error(
                      `pc.I18n#addData: missing "data[${l}].info.locale" field`
                    );
                  if (typeof o.info.locale != "string")
                    throw new Error(
                      `pc.I18n#addData: "data[${l}].info.locale" must be a string`
                    );
                  if (!o.messages)
                    throw new Error(
                      `pc.I18n#addData: missing "data[${l}].messages" field`
                    );
                }
              }
              parse(s) {
                return s.data;
              }
            }
            var c = a(4055),
              d = a(9735);
            class h extends x.b {
              constructor(s) {
                super(),
                  (this.locale = c.Z),
                  (this._translations = {}),
                  (this._availableLangs = {}),
                  (this._app = s),
                  (this._assets = []),
                  (this._parser = new g());
              }
              set assets(s) {
                const l = {};
                for (let o = 0, i = s.length; o < i; o++) {
                  const e = s[o] instanceof T.x ? s[o].id : s[o];
                  l[e] = !0;
                }
                let n = this._assets.length;
                for (; n--; ) {
                  const o = this._assets[n];
                  if (!l[o]) {
                    this._app.assets.off("add:" + o, this._onAssetAdd, this);
                    const i = this._app.assets.get(o);
                    i && this._onAssetRemove(i), this._assets.splice(n, 1);
                  }
                }
                for (const o in l) {
                  const i = parseInt(o, 10);
                  if (this._assets.indexOf(i) !== -1) continue;
                  this._assets.push(i);
                  const e = this._app.assets.get(i);
                  e
                    ? this._onAssetAdd(e)
                    : this._app.assets.once("add:" + i, this._onAssetAdd, this);
                }
              }
              get assets() {
                return this._assets;
              }
              set locale(s) {
                if (this._locale === s) return;
                let l = (0, d.VQ)(s);
                if (
                  l === "in" &&
                  ((l = "id"), (s = (0, d.$U)(s, l)), this._locale === s)
                )
                  return;
                const n = this._locale;
                (this._locale = s),
                  (this._lang = l),
                  (this._pluralFn = (0, d.g)(this._lang)),
                  this.fire("set:locale", s, n);
              }
              get locale() {
                return this._locale;
              }
              static findAvailableLocale(s, l) {
                return (0, d.Vj)(s, l);
              }
              findAvailableLocale(s) {
                if (this._translations[s]) return s;
                const l = (0, d.VQ)(s);
                return this._findFallbackLocale(s, l);
              }
              getText(s, l) {
                let n = s,
                  o;
                l || ((l = this._locale), (o = this._lang));
                let i = this._translations[l];
                return (
                  i ||
                    (o || (o = (0, d.VQ)(l)),
                    (l = this._findFallbackLocale(l, o)),
                    (i = this._translations[l])),
                  i &&
                    i.hasOwnProperty(s) &&
                    ((n = i[s]),
                    Array.isArray(n) && (n = n[0]),
                    n == null && (n = s)),
                  n
                );
              }
              getPluralText(s, l, n) {
                let o = s,
                  i,
                  e;
                n
                  ? ((i = (0, d.VQ)(n)), (e = (0, d.g)(i)))
                  : ((n = this._locale),
                    (i = this._lang),
                    (e = this._pluralFn));
                let t = this._translations[n];
                if (
                  (t ||
                    ((n = this._findFallbackLocale(n, i)),
                    (i = (0, d.VQ)(n)),
                    (e = (0, d.g)(i)),
                    (t = this._translations[n])),
                  t && t[s] && e)
                ) {
                  const r = e(l);
                  (o = t[s][r]), o == null && (o = s);
                }
                return o;
              }
              addData(s) {
                let l;
                try {
                  l = this._parser.parse(s);
                } catch (n) {
                  console.error(n);
                  return;
                }
                for (let n = 0, o = l.length; n < o; n++) {
                  const i = l[n],
                    e = i.info.locale,
                    t = i.messages;
                  if (!this._translations[e]) {
                    this._translations[e] = {};
                    const r = (0, d.VQ)(e);
                    this._availableLangs[r] || (this._availableLangs[r] = e);
                  }
                  Object.assign(this._translations[e], t),
                    this.fire("data:add", e, t);
                }
              }
              removeData(s) {
                let l;
                try {
                  l = this._parser.parse(s);
                } catch (n) {
                  console.error(n);
                  return;
                }
                for (let n = 0, o = l.length; n < o; n++) {
                  const i = l[n],
                    e = i.info.locale,
                    t = this._translations[e];
                  if (!t) continue;
                  const r = i.messages;
                  for (const u in r) delete t[u];
                  Object.keys(t).length === 0 &&
                    (delete this._translations[e],
                    delete this._availableLangs[(0, d.VQ)(e)]),
                    this.fire("data:remove", e, r);
                }
              }
              destroy() {
                (this._translations = null),
                  (this._availableLangs = null),
                  (this._assets = null),
                  (this._parser = null),
                  this.off();
              }
              _findFallbackLocale(s, l) {
                let n = c.p[s];
                return (n && this._translations[n]) ||
                  ((n = c.p[l]), n && this._translations[n]) ||
                  ((n = this._availableLangs[l]), n && this._translations[n])
                  ? n
                  : c.Z;
              }
              _onAssetAdd(s) {
                s.on("load", this._onAssetLoad, this),
                  s.on("change", this._onAssetChange, this),
                  s.on("remove", this._onAssetRemove, this),
                  s.on("unload", this._onAssetUnload, this),
                  s.resource && this._onAssetLoad(s);
              }
              _onAssetLoad(s) {
                this.addData(s.resource);
              }
              _onAssetChange(s) {
                s.resource && this.addData(s.resource);
              }
              _onAssetRemove(s) {
                s.off("load", this._onAssetLoad, this),
                  s.off("change", this._onAssetChange, this),
                  s.off("remove", this._onAssetRemove, this),
                  s.off("unload", this._onAssetUnload, this),
                  s.resource && this.removeData(s.resource),
                  this._app.assets.once("add:" + s.id, this._onAssetAdd, this);
              }
              _onAssetUnload(s) {
                s.resource && this.removeData(s.resource);
              }
            }
          },
          9735: (Se, W, a) => {
            "use strict";
            a.d(W, { $U: () => d, VQ: () => c, Vj: () => h, g: () => s });
            var x = a(4055);
            const T = {};
            function g(l, n) {
              for (let o = 0, i = l.length; o < i; o++) T[l[o]] = n;
            }
            function c(l) {
              const n = l.indexOf("-");
              return n !== -1 ? l.substring(0, n) : l;
            }
            function d(l, n) {
              const o = l.indexOf("-");
              return o !== -1 ? n + l.substring(o) : n;
            }
            function h(l, n) {
              if (n[l]) return l;
              let o = x.p[l];
              if (o && n[o]) return o;
              const i = c(l);
              return (o = x.p[i]), n[o] ? o : n[i] ? i : x.Z;
            }
            g(["ja", "ko", "th", "vi", "zh", "id"], function (l) {
              return 0;
            }),
              g(["fa", "hi"], function (l) {
                return l >= 0 && l <= 1 ? 0 : 1;
              }),
              g(["fr", "pt"], function (l) {
                return l >= 0 && l < 2 ? 0 : 1;
              }),
              g(["da"], function (l) {
                return l === 1 || (!Number.isInteger(l) && l >= 0 && l <= 1)
                  ? 0
                  : 1;
              }),
              g(
                [
                  "de",
                  "en",
                  "it",
                  "el",
                  "es",
                  "tr",
                  "fi",
                  "sv",
                  "nb",
                  "no",
                  "ur",
                ],
                function (l) {
                  return l === 1 ? 0 : 1;
                }
              ),
              g(["ru", "uk"], function (l) {
                if (Number.isInteger(l)) {
                  const n = l % 10,
                    o = l % 100;
                  if (n === 1 && o !== 11) return 0;
                  if (n >= 2 && n <= 4 && (o < 12 || o > 14)) return 1;
                  if (n === 0 || (n >= 5 && n <= 9) || (o >= 11 && o <= 14))
                    return 2;
                }
                return 3;
              }),
              g(["pl"], function (l) {
                if (Number.isInteger(l)) {
                  if (l === 1) return 0;
                  const n = l % 10,
                    o = l % 100;
                  if (n >= 2 && n <= 4 && (o < 12 || o > 14)) return 1;
                  if (
                    (n >= 0 && n <= 1) ||
                    (n >= 5 && n <= 9) ||
                    (o >= 12 && o <= 14)
                  )
                    return 2;
                }
                return 3;
              }),
              g(["ar"], function (l) {
                if (l === 0) return 0;
                if (l === 1) return 1;
                if (l === 2) return 2;
                if (Number.isInteger(l)) {
                  const n = l % 100;
                  if (n >= 3 && n <= 10) return 3;
                  if (n >= 11 && n <= 99) return 4;
                }
                return 5;
              });
            const f = T[c(x.Z)];
            function s(l) {
              return T[l] || f;
            }
          },
          6327: (Se, W, a) => {
            "use strict";
            a.d(W, {
              $K: () => ye,
              JB: () => me,
              PI: () => O,
              RR: () => N,
              sH: () => pe,
            });
            var x = a(4444),
              T = a(6556),
              g = a(6630),
              c = a(3028),
              d = a(4094),
              h = a(4355);
            let f, s;
            const l = new T.A(),
              n = new T.A(),
              o = new c.z(),
              i = new c.z(),
              e = new c.z();
            (o.end = new T.A()), (i.end = new T.A()), (e.end = new T.A());
            const t = new T.A(),
              r = new T.A(),
              u = new T.A(),
              y = new T.A(),
              p = new T.A(),
              _ = new T.A(),
              m = new T.A(),
              E = new T.A(),
              v = new T.A(),
              P = new T.A(),
              I = new T.A(),
              A = new T.A(),
              B = new T.A(),
              C = new T.A(),
              w = new T.A(),
              k = new T.A(),
              K = new T.A(),
              te = new T.A(),
              X = new T.A(),
              $ = new T.A(),
              ne = new g.T();
            function Y(V, L, J) {
              return I.cross(V, L).dot(J);
            }
            function Z(V, L, J) {
              t.sub2(L, V),
                r.sub2(J[0], V),
                u.sub2(J[1], V),
                y.sub2(J[2], V),
                _.cross(y, t);
              let ae = r.dot(_),
                R,
                j;
              if (ae >= 0) {
                if (((R = -u.dot(_)), R < 0 || ((j = Y(t, u, r)), j < 0)))
                  return -1;
                const se = 1 / (R + ae + j);
                m.copy(J[0]).mulScalar(R * se),
                  E.copy(J[1]).mulScalar(ae * se),
                  v.copy(J[2]).mulScalar(j * se),
                  P.copy(m).add(E).add(v);
              } else {
                if (
                  (p.sub2(J[3], V),
                  (R = p.dot(_)),
                  R < 0 || ((j = Y(t, r, p)), j < 0))
                )
                  return -1;
                ae = -ae;
                const se = 1 / (R + ae + j);
                m.copy(J[0]).mulScalar(R * se),
                  E.copy(J[3]).mulScalar(ae * se),
                  v.copy(J[2]).mulScalar(j * se),
                  P.copy(m).add(E).add(v);
              }
              return t.sub2(J[0], J[2]).lengthSq() < 1e-8 ||
                t.sub2(J[1], J[3]).lengthSq() < 1e-8
                ? -1
                : P.sub(V).lengthSq();
            }
            class ye {
              constructor(L, J, ae) {
                (this.event = L),
                  (this.element = J),
                  (this.camera = ae),
                  (this._stopPropagation = !1);
              }
              stopPropagation() {
                (this._stopPropagation = !0),
                  this.event &&
                    (this.event.stopImmediatePropagation(),
                    this.event.stopPropagation());
              }
            }
            class pe extends ye {
              constructor(L, J, ae, R, j, se, ce) {
                super(L, J, ae),
                  (this.x = R),
                  (this.y = j),
                  (this.ctrlKey = L.ctrlKey || !1),
                  (this.altKey = L.altKey || !1),
                  (this.shiftKey = L.shiftKey || !1),
                  (this.metaKey = L.metaKey || !1),
                  (this.button = L.button),
                  d.T.isPointerLocked()
                    ? ((this.dx =
                        L.movementX ||
                        L.webkitMovementX ||
                        L.mozMovementX ||
                        0),
                      (this.dy =
                        L.movementY ||
                        L.webkitMovementY ||
                        L.mozMovementY ||
                        0))
                    : ((this.dx = R - se), (this.dy = j - ce)),
                  (this.wheelDelta = 0),
                  L.type === "wheel" &&
                    (L.deltaY > 0
                      ? (this.wheelDelta = 1)
                      : L.deltaY < 0 && (this.wheelDelta = -1));
              }
            }
            class O extends ye {
              constructor(L, J, ae, R, j, se) {
                super(L, J, ae),
                  (this.touches = L.touches),
                  (this.changedTouches = L.changedTouches),
                  (this.x = R),
                  (this.y = j),
                  (this.touch = se);
              }
            }
            class me extends ye {
              constructor(L, J, ae, R) {
                super(L, J, ae), (this.inputSource = R);
              }
            }
            class N {
              constructor(L, J) {
                (this._app = null),
                  (this._attached = !1),
                  (this._target = null),
                  (this._enabled = !0),
                  (this._lastX = 0),
                  (this._lastY = 0),
                  (this._upHandler = this._handleUp.bind(this)),
                  (this._downHandler = this._handleDown.bind(this)),
                  (this._moveHandler = this._handleMove.bind(this)),
                  (this._wheelHandler = this._handleWheel.bind(this)),
                  (this._touchstartHandler = this._handleTouchStart.bind(this)),
                  (this._touchendHandler = this._handleTouchEnd.bind(this)),
                  (this._touchcancelHandler = this._touchendHandler),
                  (this._touchmoveHandler = this._handleTouchMove.bind(this)),
                  (this._sortHandler = this._sortElements.bind(this)),
                  (this._elements = []),
                  (this._hoveredElement = null),
                  (this._pressedElement = null),
                  (this._touchedElements = {}),
                  (this._touchesForWhichTouchLeaveHasFired = {}),
                  (this._selectedElements = {}),
                  (this._selectedPressedElements = {}),
                  (this._useMouse = !J || J.useMouse !== !1),
                  (this._useTouch = !J || J.useTouch !== !1),
                  (this._useXr = !J || J.useXr !== !1),
                  (this._selectEventsAttached = !1),
                  x.J.touch && (this._clickedEntities = {}),
                  this.attach(L);
              }
              set enabled(L) {
                this._enabled = L;
              }
              get enabled() {
                return this._enabled;
              }
              set app(L) {
                this._app = L;
              }
              get app() {
                return this._app || (0, h.i)();
              }
              attach(L) {
                this._attached && ((this._attached = !1), this.detach()),
                  (this._target = L),
                  (this._attached = !0);
                const J = x.J.passiveEvents ? { passive: !0 } : !1;
                this._useMouse &&
                  (window.addEventListener("mouseup", this._upHandler, J),
                  window.addEventListener("mousedown", this._downHandler, J),
                  window.addEventListener("mousemove", this._moveHandler, J),
                  window.addEventListener("wheel", this._wheelHandler, J)),
                  this._useTouch &&
                    x.J.touch &&
                    (this._target.addEventListener(
                      "touchstart",
                      this._touchstartHandler,
                      J
                    ),
                    this._target.addEventListener(
                      "touchend",
                      this._touchendHandler,
                      !1
                    ),
                    this._target.addEventListener(
                      "touchmove",
                      this._touchmoveHandler,
                      !1
                    ),
                    this._target.addEventListener(
                      "touchcancel",
                      this._touchcancelHandler,
                      !1
                    )),
                  this.attachSelectEvents();
              }
              attachSelectEvents() {
                !this._selectEventsAttached &&
                  this._useXr &&
                  this.app &&
                  this.app.xr &&
                  this.app.xr.supported &&
                  (this._clickedEntities || (this._clickedEntities = {}),
                  (this._selectEventsAttached = !0),
                  this.app.xr.on("start", this._onXrStart, this));
              }
              detach() {
                if (!this._attached) return;
                this._attached = !1;
                const L = x.J.passiveEvents ? { passive: !0 } : !1;
                this._useMouse &&
                  (window.removeEventListener("mouseup", this._upHandler, L),
                  window.removeEventListener("mousedown", this._downHandler, L),
                  window.removeEventListener("mousemove", this._moveHandler, L),
                  window.removeEventListener("wheel", this._wheelHandler, L)),
                  this._useTouch &&
                    (this._target.removeEventListener(
                      "touchstart",
                      this._touchstartHandler,
                      L
                    ),
                    this._target.removeEventListener(
                      "touchend",
                      this._touchendHandler,
                      !1
                    ),
                    this._target.removeEventListener(
                      "touchmove",
                      this._touchmoveHandler,
                      !1
                    ),
                    this._target.removeEventListener(
                      "touchcancel",
                      this._touchcancelHandler,
                      !1
                    )),
                  this._selectEventsAttached &&
                    ((this._selectEventsAttached = !1),
                    this.app.xr.off("start", this._onXrStart, this),
                    this.app.xr.off("end", this._onXrEnd, this),
                    this.app.xr.off("update", this._onXrUpdate, this),
                    this.app.xr.input.off(
                      "selectstart",
                      this._onSelectStart,
                      this
                    ),
                    this.app.xr.input.off("selectend", this._onSelectEnd, this),
                    this.app.xr.input.off(
                      "remove",
                      this._onXrInputRemove,
                      this
                    )),
                  (this._target = null);
              }
              addElement(L) {
                this._elements.indexOf(L) === -1 && this._elements.push(L);
              }
              removeElement(L) {
                const J = this._elements.indexOf(L);
                J !== -1 && this._elements.splice(J, 1);
              }
              _handleUp(L) {
                this._enabled &&
                  (d.T.isPointerLocked() ||
                    (this._calcMouseCoords(L),
                    this._onElementMouseEvent("mouseup", L)));
              }
              _handleDown(L) {
                this._enabled &&
                  (d.T.isPointerLocked() ||
                    (this._calcMouseCoords(L),
                    this._onElementMouseEvent("mousedown", L)));
              }
              _handleMove(L) {
                this._enabled &&
                  (this._calcMouseCoords(L),
                  this._onElementMouseEvent("mousemove", L),
                  (this._lastX = f),
                  (this._lastY = s));
              }
              _handleWheel(L) {
                this._enabled &&
                  (this._calcMouseCoords(L),
                  this._onElementMouseEvent("mousewheel", L));
              }
              _determineTouchedElements(L) {
                const J = {},
                  ae = this.app.systems.camera.cameras;
                for (let R = ae.length - 1; R >= 0; R--) {
                  const j = ae[R];
                  let se = 0;
                  const ce = L.changedTouches.length;
                  for (let ie = 0; ie < ce; ie++) {
                    if (J[L.changedTouches[ie].identifier]) {
                      se++;
                      continue;
                    }
                    const b = this._calcTouchCoords(L.changedTouches[ie]),
                      M = this._getTargetElementByCoords(j, b.x, b.y);
                    M &&
                      (se++,
                      (J[L.changedTouches[ie].identifier] = {
                        element: M,
                        camera: j,
                        x: b.x,
                        y: b.y,
                      }));
                  }
                  if (se === ce) break;
                }
                return J;
              }
              _handleTouchStart(L) {
                if (!this._enabled) return;
                const J = this._determineTouchedElements(L);
                for (let ae = 0, R = L.changedTouches.length; ae < R; ae++) {
                  const j = L.changedTouches[ae],
                    se = J[j.identifier],
                    ce = this._touchedElements[j.identifier];
                  se &&
                    (!ce || se.element !== ce.element) &&
                    (this._fireEvent(
                      L.type,
                      new O(L, se.element, se.camera, se.x, se.y, j)
                    ),
                    (this._touchesForWhichTouchLeaveHasFired[j.identifier] =
                      !1));
                }
                for (const ae in J) this._touchedElements[ae] = J[ae];
              }
              _handleTouchEnd(L) {
                if (!this._enabled) return;
                const J = this.app.systems.camera.cameras;
                for (const ae in this._clickedEntities)
                  delete this._clickedEntities[ae];
                for (let ae = 0, R = L.changedTouches.length; ae < R; ae++) {
                  const j = L.changedTouches[ae],
                    se = this._touchedElements[j.identifier];
                  if (!se) continue;
                  const ce = se.element,
                    ie = se.camera,
                    b = se.x,
                    M = se.y;
                  delete this._touchedElements[j.identifier],
                    delete this._touchesForWhichTouchLeaveHasFired[
                      j.identifier
                    ],
                    this._fireEvent(L.type, new O(L, ce, ie, b, M, j));
                  const F = this._calcTouchCoords(j);
                  for (let z = J.length - 1; z >= 0; z--)
                    this._getTargetElementByCoords(J[z], F.x, F.y) === ce &&
                      (this._clickedEntities[ce.entity.getGuid()] ||
                        (this._fireEvent("click", new O(L, ce, ie, b, M, j)),
                        (this._clickedEntities[ce.entity.getGuid()] =
                          Date.now())));
                }
              }
              _handleTouchMove(L) {
                if ((L.preventDefault(), !this._enabled)) return;
                const J = this._determineTouchedElements(L);
                for (let ae = 0, R = L.changedTouches.length; ae < R; ae++) {
                  const j = L.changedTouches[ae],
                    se = J[j.identifier],
                    ce = this._touchedElements[j.identifier];
                  if (ce) {
                    const ie = this._calcTouchCoords(j);
                    (!se || se.element !== ce.element) &&
                      !this._touchesForWhichTouchLeaveHasFired[j.identifier] &&
                      (this._fireEvent(
                        "touchleave",
                        new O(L, ce.element, ce.camera, ie.x, ie.y, j)
                      ),
                      (this._touchesForWhichTouchLeaveHasFired[j.identifier] =
                        !0)),
                      this._fireEvent(
                        "touchmove",
                        new O(L, ce.element, ce.camera, ie.x, ie.y, j)
                      );
                  }
                }
              }
              _onElementMouseEvent(L, J) {
                let ae = null;
                const R = this._hoveredElement;
                this._hoveredElement = null;
                const j = this.app.systems.camera.cameras;
                let se;
                for (
                  let ce = j.length - 1;
                  ce >= 0 &&
                  ((se = j[ce]),
                  (ae = this._getTargetElementByCoords(se, f, s)),
                  !ae);
                  ce--
                );
                if (
                  ((this._hoveredElement = ae),
                  (L === "mousemove" || L === "mouseup") && this._pressedElement
                    ? this._fireEvent(
                        L,
                        new pe(
                          J,
                          this._pressedElement,
                          se,
                          f,
                          s,
                          this._lastX,
                          this._lastY
                        )
                      )
                    : ae &&
                      (this._fireEvent(
                        L,
                        new pe(J, ae, se, f, s, this._lastX, this._lastY)
                      ),
                      L === "mousedown" && (this._pressedElement = ae)),
                  R !== this._hoveredElement &&
                    (R &&
                      this._fireEvent(
                        "mouseleave",
                        new pe(J, R, se, f, s, this._lastX, this._lastY)
                      ),
                    this._hoveredElement &&
                      this._fireEvent(
                        "mouseenter",
                        new pe(
                          J,
                          this._hoveredElement,
                          se,
                          f,
                          s,
                          this._lastX,
                          this._lastY
                        )
                      )),
                  L === "mouseup" && this._pressedElement)
                ) {
                  if (this._pressedElement === this._hoveredElement) {
                    const ce = this._hoveredElement.entity.getGuid();
                    let ie = !this._clickedEntities;
                    if (this._clickedEntities) {
                      const b = this._clickedEntities[ce] || 0;
                      (ie = Date.now() - b > 300),
                        delete this._clickedEntities[ce];
                    }
                    ie &&
                      this._fireEvent(
                        "click",
                        new pe(
                          J,
                          this._hoveredElement,
                          se,
                          f,
                          s,
                          this._lastX,
                          this._lastY
                        )
                      );
                  }
                  this._pressedElement = null;
                }
              }
              _onXrStart() {
                this.app.xr.on("end", this._onXrEnd, this),
                  this.app.xr.on("update", this._onXrUpdate, this),
                  this.app.xr.input.on(
                    "selectstart",
                    this._onSelectStart,
                    this
                  ),
                  this.app.xr.input.on("selectend", this._onSelectEnd, this),
                  this.app.xr.input.on("remove", this._onXrInputRemove, this);
              }
              _onXrEnd() {
                this.app.xr.off("update", this._onXrUpdate, this),
                  this.app.xr.input.off(
                    "selectstart",
                    this._onSelectStart,
                    this
                  ),
                  this.app.xr.input.off("selectend", this._onSelectEnd, this),
                  this.app.xr.input.off("remove", this._onXrInputRemove, this);
              }
              _onXrUpdate() {
                if (!this._enabled) return;
                const L = this.app.xr.input.inputSources;
                for (let J = 0; J < L.length; J++)
                  this._onElementSelectEvent("selectmove", L[J], null);
              }
              _onXrInputRemove(L) {
                const J = this._selectedElements[L.id];
                J &&
                  ((L._elementEntity = null),
                  this._fireEvent("selectleave", new me(null, J, null, L))),
                  delete this._selectedElements[L.id],
                  delete this._selectedPressedElements[L.id];
              }
              _onSelectStart(L, J) {
                this._enabled &&
                  this._onElementSelectEvent("selectstart", L, J);
              }
              _onSelectEnd(L, J) {
                this._enabled && this._onElementSelectEvent("selectend", L, J);
              }
              _onElementSelectEvent(L, J, ae) {
                let R;
                const j = this._selectedElements[J.id];
                let se;
                const ce = this.app.systems.camera.cameras;
                let ie;
                if (J.elementInput) {
                  e.set(J.getOrigin(), J.getDirection());
                  for (
                    let M = ce.length - 1;
                    M >= 0 &&
                    ((ie = ce[M]),
                    (R = this._getTargetElementByRay(e, ie)),
                    !R);
                    M--
                  );
                }
                (J._elementEntity = R || null),
                  R
                    ? ((this._selectedElements[J.id] = R), (se = R))
                    : delete this._selectedElements[J.id],
                  j !== se &&
                    (j && this._fireEvent("selectleave", new me(ae, j, ie, J)),
                    se &&
                      this._fireEvent("selectenter", new me(ae, se, ie, J)));
                const b = this._selectedPressedElements[J.id];
                L === "selectmove" &&
                  b &&
                  this._fireEvent("selectmove", new me(ae, b, ie, J)),
                  L === "selectstart" &&
                    ((this._selectedPressedElements[J.id] = se),
                    se &&
                      this._fireEvent("selectstart", new me(ae, se, ie, J))),
                  !J.elementInput &&
                    b &&
                    (delete this._selectedPressedElements[J.id],
                    j && this._fireEvent("selectend", new me(ae, b, ie, J))),
                  L === "selectend" &&
                    J.elementInput &&
                    (delete this._selectedPressedElements[J.id],
                    b && this._fireEvent("selectend", new me(ae, b, ie, J)),
                    b &&
                      b === j &&
                      this._fireEvent("click", new me(ae, b, ie, J)));
              }
              _fireEvent(L, J) {
                let ae = J.element;
                for (
                  ;
                  ae.fire(L, J),
                    !(
                      J._stopPropagation ||
                      !ae.entity.parent ||
                      ((ae = ae.entity.parent.element), !ae)
                    );

                );
              }
              _calcMouseCoords(L) {
                const J = this._target.getBoundingClientRect(),
                  ae = Math.floor(J.left),
                  R = Math.floor(J.top);
                (f = L.clientX - ae), (s = L.clientY - R);
              }
              _calcTouchCoords(L) {
                let J = 0,
                  ae = 0,
                  R = L.target;
                for (; !(R instanceof HTMLElement); ) R = R.parentNode;
                let j = R;
                do
                  (J += j.offsetLeft - j.scrollLeft),
                    (ae += j.offsetTop - j.scrollTop),
                    (j = j.offsetParent);
                while (j);
                return { x: L.pageX - J, y: L.pageY - ae };
              }
              _sortElements(L, J) {
                const ae = this.app.scene.layers.sortTransparentLayers(
                  L.layers,
                  J.layers
                );
                return ae !== 0
                  ? ae
                  : L.screen && !J.screen
                  ? -1
                  : !L.screen && J.screen
                  ? 1
                  : !L.screen && !J.screen
                  ? 0
                  : L.screen.screen.screenSpace && !J.screen.screen.screenSpace
                  ? -1
                  : J.screen.screen.screenSpace && !L.screen.screen.screenSpace
                  ? 1
                  : J.drawOrder - L.drawOrder;
              }
              _getTargetElementByCoords(L, J, ae) {
                const R = this._calculateRayScreen(J, ae, L, o) ? o : null,
                  j = this._calculateRay3d(J, ae, L, i) ? i : null;
                return this._getTargetElement(L, R, j);
              }
              _getTargetElementByRay(L, J) {
                o.origin.copy(L.origin),
                  o.direction.copy(L.direction),
                  o.end
                    .copy(o.direction)
                    .mulScalar(J.farClip * 2)
                    .add(o.origin);
                const ae = o,
                  R = J.worldToScreen(ae.origin, l),
                  j = this._calculateRayScreen(R.x, R.y, J, i) ? i : null;
                return this._getTargetElement(J, j, ae);
              }
              _getTargetElement(L, J, ae) {
                let R = null,
                  j = 1 / 0;
                this._elements.sort(this._sortHandler);
                for (let se = 0, ce = this._elements.length; se < ce; se++) {
                  const ie = this._elements[se];
                  if (ie.layers.some((b) => L.layersSet.has(b)))
                    if (ie.screen && ie.screen.screen.screenSpace) {
                      if (!J) continue;
                      if (this._checkElement(J, ie, !0) >= 0) {
                        R = ie;
                        break;
                      }
                    } else {
                      if (!ae) continue;
                      const b = this._checkElement(ae, ie, !1);
                      if (b >= 0 && (b < j && ((R = ie), (j = b)), ie.screen)) {
                        R = ie;
                        break;
                      }
                    }
                }
                return R;
              }
              _calculateRayScreen(L, J, ae, R) {
                const j = this.app.graphicsDevice.width,
                  se = this.app.graphicsDevice.height,
                  ce = ae.rect.z * j,
                  ie = ae.rect.w * se,
                  b = ae.rect.x * j,
                  M = b + ce,
                  F = (1 - ae.rect.y) * se,
                  z = F - ie;
                let oe = (L * j) / this._target.clientWidth,
                  de = (J * se) / this._target.clientHeight;
                return oe >= b && oe <= M && de <= F && de >= z
                  ? ((oe = (j * (oe - b)) / ce),
                    (de = (se * (de - z)) / ie),
                    (de = se - de),
                    R.origin.set(oe, de, 1),
                    R.direction.set(0, 0, -1),
                    R.end.copy(R.direction).mulScalar(2).add(R.origin),
                    !0)
                  : !1;
              }
              _calculateRay3d(L, J, ae, R) {
                const j = this._target.clientWidth,
                  se = this._target.clientHeight,
                  ce = ae.rect.z * j,
                  ie = ae.rect.w * se,
                  b = ae.rect.x * j,
                  M = b + ce,
                  F = (1 - ae.rect.y) * se,
                  z = F - ie;
                let oe = L,
                  de = J;
                return L >= b && L <= M && J <= F && de >= z
                  ? ((oe = (j * (oe - b)) / ce),
                    (de = (se * (de - z)) / ie),
                    ae.screenToWorld(oe, de, ae.nearClip, l),
                    ae.screenToWorld(oe, de, ae.farClip, n),
                    R.origin.copy(l),
                    R.direction.set(0, 0, -1),
                    R.end.copy(n),
                    !0)
                  : !1;
              }
              _checkElement(L, J, ae) {
                if (
                  J.maskedBy &&
                  this._checkElement(L, J.maskedBy.element, ae) < 0
                )
                  return -1;
                let R;
                ae
                  ? (R = N.calculateScaleToScreen(J))
                  : (R = N.calculateScaleToWorld(J));
                const j = N.buildHitCorners(
                  J,
                  ae ? J.screenCorners : J.worldCorners,
                  R
                );
                return Z(L.origin, L.end, j);
              }
              static buildHitCorners(L, J, ae) {
                let R = J;
                if (L.entity && L.entity.button) {
                  const se = L.entity.button.hitPadding || ne;
                  B.copy(L.entity.up),
                    C.copy(B).mulScalar(-1),
                    k.copy(L.entity.right),
                    w.copy(k).mulScalar(-1),
                    B.mulScalar(se.w * ae.y),
                    C.mulScalar(se.y * ae.y),
                    k.mulScalar(se.z * ae.x),
                    w.mulScalar(se.x * ae.x),
                    K.copy(R[0]).add(C).add(w),
                    te.copy(R[1]).add(C).add(k),
                    X.copy(R[2]).add(B).add(k),
                    $.copy(R[3]).add(B).add(w),
                    (R = [K, te, X, $]);
                }
                if (ae.x < 0) {
                  const se = R[2].x,
                    ce = R[0].x;
                  (R[0].x = se), (R[1].x = ce), (R[2].x = ce), (R[3].x = se);
                }
                if (ae.y < 0) {
                  const se = R[2].y,
                    ce = R[0].y;
                  (R[0].y = se), (R[1].y = se), (R[2].y = ce), (R[3].y = ce);
                }
                if (ae.z < 0) {
                  const se = R[2].x,
                    ce = R[2].y,
                    ie = R[2].z;
                  (R[2].x = R[0].x),
                    (R[2].y = R[0].y),
                    (R[2].z = R[0].z),
                    (R[0].x = se),
                    (R[0].y = ce),
                    (R[0].z = ie);
                }
                return R;
              }
              static calculateScaleToScreen(L) {
                let J = L.entity;
                const ae = L.screen.screen.scale;
                for (A.set(ae, ae, ae); J && !J.screen; )
                  A.mul(J.getLocalScale()), (J = J.parent);
                return A;
              }
              static calculateScaleToWorld(L) {
                let J = L.entity;
                for (A.set(1, 1, 1); J; )
                  A.mul(J.getLocalScale()), (J = J.parent);
                return A;
              }
            }
          },
          6236: (Se, W, a) => {
            "use strict";
            a.d(W, { T: () => me });
            var x = a(3821),
              T = a(1367),
              g = a(4585),
              c = a(6556),
              d = a(3148),
              h = a(7921),
              f = a(3412),
              s = a(464),
              l = a(8869),
              n = a(8792),
              o = a(4641),
              i = a(349),
              e = a(3200),
              t = a(8372),
              r = a(3114),
              u = a(6165),
              y = a(7915),
              p = a(8944),
              _ = a(2978),
              m = a(14),
              E = a(4633);
            const v = new E.K();
            class P {
              constructor(V, L) {
                (this.scene = V),
                  (this.light = L),
                  this.store(),
                  (L.numCascades = 1),
                  L.type !== r.WQ &&
                    (L._node.getWorldTransform(),
                    L.getBoundingSphere(v),
                    (this.lightBounds = new d.k()),
                    this.lightBounds.center.copy(v.center),
                    this.lightBounds.halfExtents.set(
                      v.radius,
                      v.radius,
                      v.radius
                    ));
              }
              store() {
                (this.mask = this.light.mask),
                  (this.shadowUpdateMode = this.light.shadowUpdateMode),
                  (this.enabled = this.light.enabled),
                  (this.intensity = this.light.intensity),
                  (this.rotation = this.light._node.getLocalRotation().clone()),
                  (this.numCascades = this.light.numCascades);
              }
              restore() {
                const V = this.light;
                (V.mask = this.mask),
                  (V.shadowUpdateMode = this.shadowUpdateMode),
                  (V.enabled = this.enabled),
                  (V.intensity = this.intensity),
                  V._node.setLocalRotation(this.rotation),
                  (V.numCascades = this.numCascades);
              }
              startBake() {
                (this.light.enabled = !0),
                  this.light._destroyShadowMap(),
                  this.light.beginFrame();
              }
              endBake(V) {
                const L = this.light;
                (L.enabled = !1),
                  L.shadowMap &&
                    (L.shadowMap.cached && V.add(L, L.shadowMap),
                    (L.shadowMap = null));
              }
            }
            const I = new _.S();
            class A extends P {
              get numVirtualLights() {
                return this.light.type === r.WQ ? this.light.bakeNumSamples : 1;
              }
              prepareVirtualLight(V, L) {
                const J = this.light;
                if ((J._node.setLocalRotation(this.rotation), V > 0)) {
                  const j = J.bakeArea;
                  m.M.circlePointDeterministic(I, V, L),
                    I.mulScalar(j * 0.5),
                    J._node.rotateLocal(I.x, 0, I.y);
                }
                J._node.getWorldTransform();
                const ae = this.scene.gammaCorrection ? 2.2 : 1,
                  R = Math.pow(this.intensity, ae);
                J.intensity = Math.pow(R / L, 1 / ae);
              }
            }
            var B = a(258);
            const C = new c.A();
            class w extends P {
              constructor(V) {
                const L = new B.J("AmbientLight");
                L.addComponent("light", {
                  type: "directional",
                  affectDynamic: !0,
                  affectLightmapped: !1,
                  bake: !0,
                  bakeNumSamples: V.ambientBakeNumSamples,
                  castShadows: !0,
                  normalOffsetBias: 0.05,
                  shadowBias: 0.2,
                  shadowDistance: 1,
                  shadowResolution: 2048,
                  shadowType: r.iW,
                  color: T.I.WHITE,
                  intensity: 1,
                  bakeDir: !1,
                }),
                  super(V, L.light.light);
              }
              get numVirtualLights() {
                return this.light.bakeNumSamples;
              }
              prepareVirtualLight(V, L) {
                m.M.spherePointDeterministic(
                  C,
                  V,
                  L,
                  0,
                  this.scene.ambientBakeSpherePart
                ),
                  this.light._node.lookAt(C.mulScalar(-1)),
                  this.light._node.rotateLocal(90, 0, 0);
                const J = this.scene.gammaCorrection ? 2.2 : 1,
                  ae = 2 * Math.PI * this.scene.ambientBakeSpherePart,
                  R = Math.pow(ae, J);
                this.light.intensity = Math.pow(R / L, 1 / J);
              }
            }
            class k {
              constructor(V, L = null) {
                (this.node = V),
                  (this.component = V.render || V.model),
                  (L = L || this.component.meshInstances),
                  this.store(),
                  (this.meshInstances = L),
                  (this.bounds = null),
                  (this.renderTargets = []);
              }
              store() {
                this.castShadows = this.component.castShadows;
              }
              restore() {
                this.component.castShadows = this.castShadows;
              }
            }
            var K = a(963),
              te = a(9375);
            const X = 15;
            class $ {
              constructor(V) {
                (this.device = V),
                  (this.shaderDilate = (0, te.JM)(
                    V,
                    e.n.fullscreenQuadVS,
                    t.i.dilatePS,
                    "lmDilate"
                  )),
                  (this.constantTexSource = V.scope.resolve("source")),
                  (this.constantPixelOffset = V.scope.resolve("pixelOffset")),
                  (this.pixelOffset = new Float32Array(2)),
                  (this.shaderDenoise = null),
                  (this.sigmas = null),
                  (this.constantSigmas = null),
                  (this.kernel = null);
              }
              setSourceTexture(V) {
                this.constantTexSource.setValue(V);
              }
              prepare(V, L) {
                (this.pixelOffset[0] = 1 / V),
                  (this.pixelOffset[1] = 1 / L),
                  this.constantPixelOffset.setValue(this.pixelOffset);
              }
              prepareDenoise(V, L) {
                this.shaderDenoise ||
                  ((this.shaderDenoise = (0, te.JM)(
                    this.device,
                    e.n.fullscreenQuadVS,
                    t.i.bilateralDeNoisePS,
                    "lmBilateralDeNoise"
                  )),
                  (this.sigmas = new Float32Array(2)),
                  (this.constantSigmas = this.device.scope.resolve("sigmas")),
                  (this.constantKernel =
                    this.device.scope.resolve("kernel[0]")),
                  (this.bZnorm = this.device.scope.resolve("bZnorm"))),
                  (this.sigmas[0] = V),
                  (this.sigmas[1] = L),
                  this.constantSigmas.setValue(this.sigmas),
                  this.evaluateDenoiseUniforms(V, L);
              }
              evaluateDenoiseUniforms(V, L) {
                function J(se, ce) {
                  return (
                    (0.39894 * Math.exp((-0.5 * se * se) / (ce * ce))) / ce
                  );
                }
                this.kernel = this.kernel || new Float32Array(X);
                const ae = this.kernel,
                  R = Math.floor((X - 1) / 2);
                for (let se = 0; se <= R; ++se) {
                  const ce = J(se, V);
                  (ae[R + se] = ce), (ae[R - se] = ce);
                }
                this.constantKernel.setValue(this.kernel);
                const j = 1 / J(0, L);
                this.bZnorm.setValue(j);
              }
            }
            var ne = a(8277),
              Y = a(7013);
            const Z = 2048,
              ye = 0,
              pe = 1,
              O = new c.A();
            class me {
              constructor(V, L, J, ae, R) {
                (this.device = V),
                  (this.root = L),
                  (this.scene = J),
                  (this.renderer = ae),
                  (this.assets = R),
                  (this.shadowMapCache = ae.shadowMapCache),
                  (this._tempSet = new Set()),
                  (this._initCalled = !1),
                  (this.passMaterials = []),
                  (this.ambientAOMaterial = null),
                  (this.fog = ""),
                  (this.ambientLight = new T.I()),
                  (this.renderTargets = new Map()),
                  (this.stats = {
                    renderPasses: 0,
                    lightmapCount: 0,
                    totalRenderTime: 0,
                    forwardTime: 0,
                    fboTime: 0,
                    shadowMapTime: 0,
                    compileTime: 0,
                    shadersLinked: 0,
                  });
              }
              destroy() {
                K._.decRef(this.blackTex),
                  (this.blackTex = null),
                  K._.destroy(),
                  (this.device = null),
                  (this.root = null),
                  (this.scene = null),
                  (this.renderer = null),
                  (this.assets = null);
              }
              initBake(V) {
                if (!this._initCalled) {
                  (this._initCalled = !0),
                    (this.lightmapFilters = new $(V)),
                    (this.constantBakeDir = V.scope.resolve("bakeDir")),
                    (this.materials = []),
                    (this.blackTex = new l.x(this.device, {
                      width: 4,
                      height: 4,
                      format: h.jKI,
                      type: h.xIP,
                      name: "lightmapBlack",
                    })),
                    K._.incRef(this.blackTex);
                  const L = new u.V();
                  L.clearColor.set(0, 0, 0, 0),
                    (L.clearColorBuffer = !0),
                    (L.clearDepthBuffer = !1),
                    (L.clearStencilBuffer = !1),
                    (L.frustumCulling = !1),
                    (L.projection = r.Uc),
                    (L.aspectRatio = 1),
                    (L.node = new y.A()),
                    (this.camera = L);
                }
                if (this.scene.clusteredLightingEnabled) {
                  const L = new o.w(
                    V.supportsAreaLights,
                    V.maxTextureSize,
                    () => {}
                  );
                  this.lightingParams = L;
                  const J = this.scene.lighting;
                  (L.shadowsEnabled = J.shadowsEnabled),
                    (L.shadowAtlasResolution = J.shadowAtlasResolution),
                    (L.cookiesEnabled = J.cookiesEnabled),
                    (L.cookieAtlasResolution = J.cookieAtlasResolution),
                    (L.areaLightsEnabled = J.areaLightsEnabled),
                    (L.cells = new c.A(3, 3, 3)),
                    (L.maxLightsPerCell = 4),
                    (this.worldClusters = new i.P(V)),
                    (this.worldClusters.name = "ClusterLightmapper");
                }
              }
              finishBake(V) {
                this.materials = [];
                function L(J) {
                  K._.decRef(J.colorBuffer), J.destroy();
                }
                this.renderTargets.forEach((J) => {
                  L(J);
                }),
                  this.renderTargets.clear(),
                  V.forEach((J) => {
                    J.renderTargets.forEach((ae) => {
                      L(ae);
                    }),
                      (J.renderTargets.length = 0);
                  }),
                  (this.ambientAOMaterial = null),
                  this.worldClusters &&
                    (this.worldClusters.destroy(), (this.worldClusters = null));
              }
              createMaterialForPass(V, L, J, ae) {
                const R = new p.K();
                if (
                  ((R.name = `lmMaterial-pass:${J}-ambient:${ae}`),
                  (R.chunks.APIVersion = h.lmt),
                  (R.chunks.transformVS =
                    `#define UV1LAYOUT
` + e.n.transformVS),
                  J === ye)
                ) {
                  let j = t.i.bakeLmEndPS;
                  ae
                    ? (j =
                        `
										dDiffuseLight = ((dDiffuseLight - 0.5) * max(${L.ambientBakeOcclusionContrast.toFixed(
                      1
                    )} + 1.0, 0.0)) + 0.5;
										dDiffuseLight += vec3(${L.ambientBakeOcclusionBrightness.toFixed(1)});
										dDiffuseLight = saturate(dDiffuseLight);
										dDiffuseLight *= dAmbientLight;
								` + j)
                    : ((R.ambient = new T.I(0, 0, 0)), (R.ambientTint = !0)),
                    (R.chunks.basePS =
                      e.n.basePS +
                      (L.lightmapPixelFormat === h.jKI
                        ? `
#define LIGHTMAP_RGBM
`
                        : "")),
                    (R.chunks.endPS = j),
                    (R.lightMap = this.blackTex);
                } else
                  (R.chunks.basePS =
                    e.n.basePS +
                    `
uniform sampler2D texture_dirLightMap;
uniform float bakeDir;
`),
                    (R.chunks.endPS = t.i.bakeDirLmEndPS);
                return (
                  (R.chunks.outputAlphaPS = `
`),
                  (R.chunks.outputAlphaOpaquePS = `
`),
                  (R.chunks.outputAlphaPremulPS = `
`),
                  (R.cull = h.OL2),
                  (R.forceUv1 = !0),
                  R.update(),
                  R
                );
              }
              createMaterials(V, L, J) {
                for (let ae = 0; ae < J; ae++)
                  this.passMaterials[ae] ||
                    (this.passMaterials[ae] = this.createMaterialForPass(
                      V,
                      L,
                      ae,
                      !1
                    ));
                this.ambientAOMaterial ||
                  ((this.ambientAOMaterial = this.createMaterialForPass(
                    V,
                    L,
                    0,
                    !0
                  )),
                  (this.ambientAOMaterial.onUpdateShader = function (ae) {
                    return (
                      (ae.litOptions.lightMapWithoutAmbient = !0),
                      (ae.litOptions.separateAmbient = !0),
                      ae
                    );
                  }));
              }
              createTexture(V, L) {
                return new l.x(this.device, {
                  width: V,
                  height: V,
                  format: this.scene.lightmapPixelFormat,
                  mipmaps: !1,
                  type:
                    this.scene.lightmapPixelFormat === h.jKI ? h.xIP : h.zZc,
                  minFilter: h.yib,
                  magFilter: h.yib,
                  addressU: h.uFb,
                  addressV: h.uFb,
                  name: L,
                });
              }
              collectModels(V, L, J) {
                var ae, R, j;
                if (!V.enabled) return;
                let se;
                if (
                  ((ae = V.model) != null &&
                    ae.model &&
                    (R = V.model) != null &&
                    R.enabled &&
                    (J && J.push(new k(V)),
                    V.model.lightmapped &&
                      L &&
                      (se = V.model.model.meshInstances)),
                  (j = V.render) != null &&
                    j.enabled &&
                    (J && J.push(new k(V)),
                    V.render.lightmapped && L && (se = V.render.meshInstances)),
                  se)
                ) {
                  let ce = !0;
                  for (let ie = 0; ie < se.length; ie++)
                    if (!se[ie].mesh.vertexBuffer.format.hasUv1) {
                      ce = !1;
                      break;
                    }
                  if (ce) {
                    const ie = [];
                    for (let b = 0; b < se.length; b++) {
                      const M = se[b].mesh;
                      this._tempSet.has(M)
                        ? L.push(new k(V, [se[b]]))
                        : ie.push(se[b]),
                        this._tempSet.add(M);
                    }
                    this._tempSet.clear(),
                      ie.length > 0 && L.push(new k(V, ie));
                  }
                }
                for (let ce = 0; ce < V._children.length; ce++)
                  this.collectModels(V._children[ce], L, J);
              }
              prepareShadowCasters(V) {
                const L = [];
                for (let J = 0; J < V.length; J++) {
                  const ae = V[J].component;
                  if (
                    ((ae.castShadows = ae.castShadowsLightmap),
                    ae.castShadowsLightmap)
                  ) {
                    const R = V[J].meshInstances;
                    for (let j = 0; j < R.length; j++)
                      (R[j].visibleThisFrame = !0), L.push(R[j]);
                  }
                }
                return L;
              }
              updateTransforms(V) {
                for (let L = 0; L < V.length; L++) {
                  const J = V[L].meshInstances;
                  for (let ae = 0; ae < J.length; ae++)
                    J[ae].node.getWorldTransform();
                }
              }
              calculateLightmapSize(V) {
                let L;
                const J = this.scene.lightmapSizeMultiplier || 16,
                  ae = O;
                let R, j;
                V.model
                  ? ((j = V.model.lightmapSizeMultiplier),
                    V.model.asset
                      ? ((L = this.assets.get(V.model.asset).data),
                        L.area && (R = L.area))
                      : V.model._area &&
                        ((L = V.model), L._area && (R = L._area)))
                  : V.render &&
                    ((j = V.render.lightmapSizeMultiplier),
                    V.render.type !== "asset" &&
                      V.render._area &&
                      ((L = V.render), L._area && (R = L._area)));
                const se = { x: 1, y: 1, z: 1, uv: 1 };
                R && ((se.x = R.x), (se.y = R.y), (se.z = R.z), (se.uv = R.uv));
                const ce = j || 1;
                (se.x *= ce), (se.y *= ce), (se.z *= ce);
                const ie = V.render || V.model,
                  b = this.computeNodeBounds(ie.meshInstances);
                ae.copy(b.halfExtents);
                let M =
                  se.x * ae.y * ae.z + se.y * ae.x * ae.z + se.z * ae.x * ae.y;
                return (
                  (M /= se.uv),
                  (M = Math.sqrt(M)),
                  Math.min(
                    g.m.nextPowerOfTwo(M * J),
                    this.scene.lightmapMaxResolution || Z
                  )
                );
              }
              setLightmapping(V, L, J, ae) {
                for (let R = 0; R < V.length; R++) {
                  const j = V[R],
                    se = j.meshInstances;
                  for (let ce = 0; ce < se.length; ce++) {
                    const ie = se[ce];
                    if ((ie.setLightmapped(L), L)) {
                      ae && (ie._shaderDefs |= ae), (ie.mask = r.gN);
                      for (let b = 0; b < J; b++) {
                        const M = j.renderTargets[b].colorBuffer;
                        (M.minFilter = h.I5X),
                          (M.magFilter = h.I5X),
                          ie.setRealtimeLightmap(n.l.lightmapParamNames[b], M);
                      }
                    }
                  }
                }
              }
              bake(V, L = r.FB) {
                const J = this.device;
                if (J.isWebGPU) return;
                const ae = (0, x.z)();
                this.scene._updateSky(J),
                  (this.stats.renderPasses = 0),
                  (this.stats.shadowMapTime = 0),
                  (this.stats.forwardTime = 0);
                const R = J._shaderStats.linked,
                  j = J._renderTargetCreationTime,
                  se = J._shaderStats.compileTime,
                  ce = [],
                  ie = [];
                if (V) {
                  for (let M = 0; M < V.length; M++)
                    this.collectModels(V[M], ce, null);
                  this.collectModels(this.root, null, ie);
                } else this.collectModels(this.root, ce, ie);
                if (ce.length > 0) {
                  this.renderer.shadowRenderer.frameUpdate();
                  const M = L === r.FB ? 2 : 1;
                  this.setLightmapping(ce, !1, M),
                    this.initBake(J),
                    this.bakeInternal(M, ce, ie);
                  let F = r.b0;
                  L === r.FB && (F |= r.Bp),
                    this.scene.ambientBake && (F |= r.c8),
                    this.setLightmapping(ce, !0, M, F),
                    this.finishBake(ce);
                }
                const b = (0, x.z)();
                (this.stats.totalRenderTime = b - ae),
                  (this.stats.shadersLinked = J._shaderStats.linked - R),
                  (this.stats.compileTime = J._shaderStats.compileTime - se),
                  (this.stats.fboTime = J._renderTargetCreationTime - j),
                  (this.stats.lightmapCount = ce.length);
              }
              allocateTextures(V, L) {
                for (let J = 0; J < V.length; J++) {
                  const ae = V[J],
                    R = this.calculateLightmapSize(ae.node);
                  for (let j = 0; j < L; j++) {
                    const se = this.createTexture(
                      R,
                      "lightmapper_lightmap_" + J
                    );
                    K._.incRef(se),
                      (ae.renderTargets[j] = new f.A({
                        colorBuffer: se,
                        depth: !1,
                      }));
                  }
                  if (!this.renderTargets.has(R)) {
                    const j = this.createTexture(
                      R,
                      "lightmapper_temp_lightmap_" + R
                    );
                    K._.incRef(j),
                      this.renderTargets.set(
                        R,
                        new f.A({ colorBuffer: j, depth: !1 })
                      );
                  }
                }
              }
              prepareLightsToBake(V, L, J) {
                if (this.scene.ambientBake) {
                  const R = new w(this.scene);
                  J.push(R);
                }
                const ae = V._lights;
                for (let R = 0; R < ae.length; R++) {
                  const j = ae[R],
                    se = new A(this.scene, j);
                  L.push(se),
                    j.enabled &&
                      j.mask & r.ew &&
                      ((j.mask = 4294967295),
                      (j.shadowUpdateMode = j.type === r.WQ ? r.v5 : r.b1),
                      J.push(se));
                }
                J.sort();
              }
              restoreLights(V) {
                for (let L = 0; L < V.length; L++) V[L].restore();
              }
              setupScene() {
                (this.fog = this.scene.fog),
                  this.ambientLight.copy(this.scene.ambientLight),
                  (this.scene.fog = r.YV),
                  this.scene.ambientBake ||
                    this.scene.ambientLight.set(0, 0, 0),
                  this.renderer.setSceneConstants();
              }
              restoreScene() {
                (this.scene.fog = this.fog),
                  this.scene.ambientLight.copy(this.ambientLight);
              }
              computeNodeBounds(V) {
                const L = new d.k();
                if (V.length > 0) {
                  L.copy(V[0].aabb);
                  for (let J = 1; J < V.length; J++) L.add(V[J].aabb);
                }
                return L;
              }
              computeNodesBounds(V) {
                for (let L = 0; L < V.length; L++) {
                  const J = V[L].meshInstances;
                  V[L].bounds = this.computeNodeBounds(J);
                }
              }
              computeBounds(V) {
                const L = new d.k();
                for (let J = 0; J < V.length; J++) {
                  L.copy(V[0].aabb);
                  for (let ae = 1; ae < V.length; ae++) L.add(V[ae].aabb);
                }
                return L;
              }
              backupMaterials(V) {
                for (let L = 0; L < V.length; L++)
                  this.materials[L] = V[L].material;
              }
              restoreMaterials(V) {
                for (let L = 0; L < V.length; L++)
                  V[L].material = this.materials[L];
              }
              lightCameraPrepare(V, L) {
                const J = L.light;
                let ae;
                return (
                  J.type === r.z0 &&
                    ((ae = J.getRenderData(null, 0).shadowCamera),
                    ae._node.setPosition(J._node.getPosition()),
                    ae._node.setRotation(J._node.getRotation()),
                    ae._node.rotateLocal(-90, 0, 0),
                    (ae.projection = r.pm),
                    (ae.nearClip = J.attenuationEnd / 1e3),
                    (ae.farClip = J.attenuationEnd),
                    (ae.aspectRatio = 1),
                    (ae.fov = J._outerConeAngle * 2),
                    this.renderer.updateCameraFrustum(ae)),
                  ae
                );
              }
              lightCameraPrepareAndCull(V, L, J, ae) {
                const R = V.light;
                let j = !0;
                if (R.type === r.WQ) {
                  O.copy(ae.center),
                    (O.y += ae.halfExtents.y),
                    this.camera.node.setPosition(O),
                    this.camera.node.setEulerAngles(-90, 0, 0),
                    (this.camera.nearClip = 0),
                    (this.camera.farClip = ae.halfExtents.y * 2);
                  const se = Math.max(ae.halfExtents.x, ae.halfExtents.z);
                  this.camera.orthoHeight = se;
                } else V.lightBounds.intersects(L.bounds) || (j = !1);
                if (R.type === r.z0) {
                  let se = !1;
                  const ce = L.meshInstances;
                  for (let ie = 0; ie < ce.length; ie++)
                    if (ce[ie]._isVisible(J)) {
                      se = !0;
                      break;
                    }
                  se || (j = !1);
                }
                return j;
              }
              setupLightArray(V, L) {
                (V[r.WQ].length = 0),
                  (V[r.bA].length = 0),
                  (V[r.z0].length = 0),
                  (V[L.type][0] = L),
                  (L.visibleThisFrame = !0);
              }
              renderShadowMap(V, L, J) {
                const ae = J.light,
                  R = this.scene.clusteredLightingEnabled;
                if (!V && ae.castShadows) {
                  !ae.shadowMap &&
                    !R &&
                    (ae.shadowMap = this.shadowMapCache.get(this.device, ae)),
                    ae.type === r.WQ
                      ? this.renderer._shadowRendererDirectional.cull(
                          ae,
                          L,
                          this.camera
                        )
                      : this.renderer._shadowRendererLocal.cull(ae, L);
                  const j = !1;
                  this.renderer.shadowRenderer.render(ae, this.camera, j);
                }
                return !0;
              }
              postprocessTextures(V, L, J) {
                const R = this.lightmapFilters.shaderDilate,
                  j = this.scene.lightmapFilterEnabled;
                j &&
                  this.lightmapFilters.prepareDenoise(
                    this.scene.lightmapFilterRange,
                    this.scene.lightmapFilterSmoothness
                  ),
                  V.setBlendState(ne.a.NOBLEND),
                  V.setDepthState(Y.b.NODEPTH),
                  V.setStencilState(null, null);
                for (let se = 0; se < L.length; se++) {
                  const ce = L[se];
                  for (let ie = 0; ie < J; ie++) {
                    const b = ce.renderTargets[ie],
                      M = b.colorBuffer,
                      F = this.renderTargets.get(M.width),
                      z = F.colorBuffer;
                    this.lightmapFilters.prepare(M.width, M.height);
                    for (let oe = 0; oe < 1; oe++) {
                      this.lightmapFilters.setSourceTexture(M);
                      const de = j && ie === 0 && oe === 0;
                      (0, s.H)(
                        V,
                        F,
                        de ? this.lightmapFilters.shaderDenoise : R
                      ),
                        this.lightmapFilters.setSourceTexture(z),
                        (0, s.H)(V, b, R);
                    }
                  }
                }
              }
              bakeInternal(V, L, J) {
                const ae = this.scene,
                  R = this.device,
                  j = ae.clusteredLightingEnabled;
                this.createMaterials(R, ae, V),
                  this.setupScene(),
                  ae.layers._update(R, j),
                  this.computeNodesBounds(L),
                  this.allocateTextures(L, V);
                const se = [],
                  ce = [];
                this.prepareLightsToBake(ae.layers, se, ce),
                  this.updateTransforms(J);
                const ie = this.prepareShadowCasters(J);
                this.renderer.updateCpuSkinMatrices(ie),
                  this.renderer.gpuUpdate(ie);
                const b = this.computeBounds(ie);
                let M, F, z, oe;
                for (M = 0; M < L.length; M++)
                  for (z = L[M].meshInstances, F = 0; F < z.length; F++)
                    (oe = z[F]),
                      oe.setLightmapped(!1),
                      (oe.mask = r.ew),
                      oe.setRealtimeLightmap(
                        n.l.lightmapParamNames[0],
                        oe.material.lightMap
                          ? oe.material.lightMap
                          : this.blackTex
                      ),
                      oe.setRealtimeLightmap(
                        n.l.lightmapParamNames[1],
                        this.blackTex
                      );
                for (F = 0; F < ce.length; F++) ce[F].light.enabled = !1;
                const de = [[], [], []];
                let ge,
                  Re,
                  Te = !1;
                for (M = 0; M < ce.length; M++) {
                  const Ne = ce[M],
                    Le = Ne instanceof w;
                  let ke = Ne.numVirtualLights;
                  V > 1 && ke > 1 && Ne.light.bakeDir && (ke = 1);
                  for (let ht = 0; ht < ke; ht++) {
                    ke > 1 && Ne.prepareVirtualLight(ht, ke), Ne.startBake();
                    let _e = !1;
                    const U = this.lightCameraPrepare(R, Ne);
                    for (Re = 0; Re < L.length; Re++) {
                      const H = L[Re];
                      if (
                        ((z = H.meshInstances),
                        !!this.lightCameraPrepareAndCull(Ne, H, U, b))
                      ) {
                        if (
                          (this.setupLightArray(de, Ne.light),
                          j &&
                            this.renderer.lightTextureAtlas.update(
                              de[r.z0],
                              de[r.bA],
                              this.lightingParams
                            ),
                          (_e = this.renderShadowMap(_e, ie, Ne)),
                          j)
                        ) {
                          const G = de[r.z0].concat(de[r.bA]);
                          this.worldClusters.update(
                            G,
                            this.scene.gammaCorrection,
                            this.lightingParams
                          );
                        }
                        for (
                          this.backupMaterials(z), ge = 0;
                          ge < V && !((ge > 0 && ht > 0) || (Le && ge > 0));
                          ge++
                        ) {
                          const G = H.renderTargets[ge],
                            Q = H.renderTargets[ge].colorBuffer.width,
                            q = this.renderTargets.get(Q),
                            xe = q.colorBuffer;
                          ge === 0
                            ? (Te = ae.updateShaders)
                            : Te && (ae.updateShaders = !0);
                          let be = this.passMaterials[ge];
                          for (
                            Le &&
                              ht + 1 === ke &&
                              ge === 0 &&
                              (be = this.ambientAOMaterial),
                              F = 0;
                            F < z.length;
                            F++
                          )
                            z[F].material = be;
                          for (
                            this.renderer.updateShaders(z),
                              this.renderer.setCamera(this.camera, q, !0),
                              ge === pe &&
                                this.constantBakeDir.setValue(
                                  Ne.light.bakeDir ? 1 : 0
                                ),
                              j && this.worldClusters.activate(),
                              this.renderer._forwardTime = 0,
                              this.renderer._shadowMapTime = 0,
                              this.renderer.renderForward(
                                this.camera,
                                z,
                                z.length,
                                de,
                                r.zw
                              ),
                              R.updateEnd(),
                              H.renderTargets[ge] = q,
                              this.renderTargets.set(Q, G),
                              F = 0;
                            F < z.length;
                            F++
                          )
                            (oe = z[F]),
                              oe.setRealtimeLightmap(
                                n.l.lightmapParamNames[ge],
                                xe
                              ),
                              (oe._shaderDefs |= r.b0);
                        }
                        this.restoreMaterials(z);
                      }
                    }
                    Ne.endBake(this.shadowMapCache);
                  }
                }
                for (
                  this.postprocessTextures(R, L, V), Re = 0;
                  Re < J.length;
                  Re++
                )
                  J[Re].restore();
                this.restoreLights(se),
                  this.restoreScene(),
                  j || this.shadowMapCache.clear();
              }
            }
          },
          5067: (Se, W, a) => {
            "use strict";
            a.d(W, { J: () => e, t: () => i });
            var x = a(8391);
            function T(t, r) {
              let u;
              const _ = (C, w) => {
                  switch (w) {
                    case u.DT_INT8:
                      return new Int8Array(
                        C.buffer,
                        C.byteOffset,
                        C.byteLength
                      );
                    case u.DT_INT16:
                      return new Int16Array(
                        C.buffer,
                        C.byteOffset,
                        C.byteLength / 2
                      );
                    case u.DT_INT32:
                      return new Int32Array(
                        C.buffer,
                        C.byteOffset,
                        C.byteLength / 4
                      );
                    case u.DT_UINT8:
                      return new Uint8Array(
                        C.buffer,
                        C.byteOffset,
                        C.byteLength
                      );
                    case u.DT_UINT16:
                      return new Uint16Array(
                        C.buffer,
                        C.byteOffset,
                        C.byteLength / 2
                      );
                    case u.DT_UINT32:
                      return new Uint32Array(
                        C.buffer,
                        C.byteOffset,
                        C.byteLength / 4
                      );
                    case u.DT_FLOAT32:
                      return new Float32Array(
                        C.buffer,
                        C.byteOffset,
                        C.byteLength / 4
                      );
                  }
                  return null;
                },
                m = (C) => {
                  switch (C) {
                    case u.DT_INT8:
                      return 1;
                    case u.DT_INT16:
                      return 2;
                    case u.DT_INT32:
                      return 4;
                    case u.DT_UINT8:
                      return 1;
                    case u.DT_UINT16:
                      return 2;
                    case u.DT_UINT32:
                      return 4;
                    case u.DT_FLOAT32:
                      return 4;
                  }
                  return 1;
                },
                E = (C) => C.num_components() * m(C.data_type()),
                v = { 0: 0, 1: 1, 5: 2, 2: 3, 7: 4, 8: 5, 4: 6, 3: 7 },
                P = (C, w) => {
                  const k = (V, L, J) => {
                      (V[0] = L[0] - J[0]),
                        (V[1] = L[1] - J[1]),
                        (V[2] = L[2] - J[2]);
                    },
                    K = (V, L, J) => {
                      (V[0] = L[1] * J[2] - J[1] * L[2]),
                        (V[1] = L[2] * J[0] - J[2] * L[0]),
                        (V[2] = L[0] * J[1] - J[0] * L[1]);
                    },
                    te = (V, L) => {
                      const J = V[L + 0],
                        ae = V[L + 1],
                        R = V[L + 2],
                        j = 1 / Math.sqrt(J * J + ae * ae + R * R);
                      (V[L + 0] *= j), (V[L + 1] *= j), (V[L + 2] *= j);
                    },
                    X = (V, L, J) => {
                      for (let ae = 0; ae < 3; ++ae) V[ae] = L[J + ae];
                    },
                    $ = w.length / 3,
                    ne = C.length / 3,
                    Y = new Float32Array(C.length),
                    Z = [0, 0, 0],
                    ye = [0, 0, 0],
                    pe = [0, 0, 0],
                    O = [0, 0, 0],
                    me = [0, 0, 0],
                    N = [0, 0, 0];
                  for (let V = 0; V < $; ++V) {
                    const L = w[V * 3 + 0] * 3,
                      J = w[V * 3 + 1] * 3,
                      ae = w[V * 3 + 2] * 3;
                    X(Z, C, L),
                      X(ye, C, J),
                      X(pe, C, ae),
                      k(O, ye, Z),
                      k(me, pe, Z),
                      K(N, O, me),
                      te(N, 0);
                    for (let R = 0; R < 3; ++R)
                      (Y[L + R] += N[R]),
                        (Y[J + R] += N[R]),
                        (Y[ae + R] += N[R]);
                  }
                  for (let V = 0; V < ne; ++V) te(Y, V * 3);
                  return new Uint8Array(Y.buffer);
                },
                I = (C) => {
                  const w = {},
                    k = new u.DecoderBuffer();
                  k.Init(C, C.length);
                  const K = new u.Decoder();
                  if (K.GetEncodedGeometryType(k) !== u.TRIANGULAR_MESH)
                    return (
                      (w.error = "Failed to decode draco mesh: not a mesh"), w
                    );
                  const te = new u.Mesh(),
                    X = K.DecodeBufferToMesh(k, te);
                  if (!X || !X.ok() || te.ptr === 0)
                    return (w.error = "Failed to decode draco asset"), w;
                  const $ = te.num_faces() * 3,
                    ne = te.num_points() <= 65535,
                    Y = $ * (ne ? 2 : 4),
                    Z = u._malloc(Y);
                  ne
                    ? (K.GetTrianglesUInt16Array(te, Y, Z),
                      (w.indices = new Uint16Array(
                        u.HEAPU16.buffer,
                        Z,
                        $
                      ).slice().buffer))
                    : (K.GetTrianglesUInt32Array(te, Y, Z),
                      (w.indices = new Uint32Array(
                        u.HEAPU32.buffer,
                        Z,
                        $
                      ).slice().buffer)),
                    u._free(Z);
                  const ye = [];
                  for (let L = 0; L < te.num_attributes(); ++L)
                    ye.push(K.GetAttribute(te, L));
                  ye.sort((L, J) => {
                    var ae, R;
                    return (
                      ((ae = v[L.attribute_type()]) != null ? ae : v.length) -
                      ((R = v[J.attribute_type()]) != null ? R : v.length)
                    );
                  }),
                    (w.attributes = ye.map((L) => L.unique_id()));
                  let pe = 0;
                  const O = ye.map((L) => {
                      const J = pe;
                      return (pe += Math.ceil(E(L) / 4) * 4), J;
                    }),
                    me = ye.some((L) => L.attribute_type() === 1),
                    N = O[1];
                  if (!me) {
                    for (let L = 1; L < O.length; ++L) O[L] += 12;
                    pe += 12;
                  }
                  w.vertices = new ArrayBuffer(te.num_points() * pe);
                  const V = new Uint8Array(w.vertices);
                  for (let L = 0; L < te.num_attributes(); ++L) {
                    const J = ye[L],
                      ae = E(J),
                      R = te.num_points() * ae,
                      j = u._malloc(R);
                    K.GetAttributeDataArrayForAllPoints(
                      te,
                      J,
                      J.data_type(),
                      R,
                      j
                    );
                    const se = new Uint8Array(u.HEAPU8.buffer, j, R);
                    for (let ce = 0; ce < te.num_points(); ++ce)
                      for (let ie = 0; ie < ae; ++ie)
                        V[ce * pe + O[L] + ie] = se[ce * ae + ie];
                    if (!me && J.attribute_type() === 0) {
                      const ce = P(
                        _(se, J.data_type()),
                        ne
                          ? new Uint16Array(w.indices)
                          : new Uint32Array(w.indices)
                      );
                      for (let ie = 0; ie < te.num_points(); ++ie)
                        for (let b = 0; b < 12; ++b)
                          V[ie * pe + N + b] = ce[ie * 12 + b];
                    }
                    u._free(j);
                  }
                  return u.destroy(te), u.destroy(K), u.destroy(k), w;
                },
                A = (C) => {
                  const w = I(new Uint8Array(C.buffer));
                  self.postMessage(
                    {
                      jobId: C.jobId,
                      error: w.error,
                      indices: w.indices,
                      vertices: w.vertices,
                      attributes: w.attributes,
                    },
                    [w.indices, w.vertices].filter((k) => k != null)
                  );
                },
                B = [];
              self.onmessage = (C) => {
                const w = C.data;
                switch (w.type) {
                  case "init":
                    self
                      .DracoDecoderModule({
                        instantiateWasm: (k, K) => (
                          WebAssembly.instantiate(w.module, k)
                            .then((te) => K(te))
                            .catch((te) =>
                              console.error("instantiate failed + " + te)
                            ),
                          {}
                        ),
                      })
                      .then((k) => {
                        (u = k), B.forEach((K) => A(K));
                      });
                    break;
                  case "decodeMesh":
                    u ? A(w) : B.push(w);
                    break;
                }
              };
            }
            var g = a(1467);
            const c = 3;
            class d {
              constructor() {
                (this.workers = [[], [], []]),
                  (this.jobId = 0),
                  (this.jobQueue = []),
                  (this.jobCallbacks = new Map()),
                  (this.run = (r, u) => {
                    r.postMessage(
                      { type: "decodeMesh", jobId: u.jobId, buffer: u.buffer },
                      [u.buffer]
                    );
                  });
              }
              init(r) {
                for (
                  r.forEach((u) => {
                    u.addEventListener("message", (y) => {
                      const p = y.data,
                        _ = this.jobCallbacks.get(p.jobId);
                      if (
                        (_ &&
                          _(p.error, {
                            indices: p.indices,
                            vertices: p.vertices,
                            attributes: p.attributes,
                          }),
                        this.jobCallbacks.delete(p.jobId),
                        this.jobQueue.length > 0)
                      ) {
                        const m = this.jobQueue.shift();
                        this.run(u, m);
                      } else {
                        const m = this.workers[2].indexOf(u);
                        if (m !== -1)
                          this.workers[2].splice(m, 1), this.workers[1].push(u);
                        else {
                          const E = this.workers[1].indexOf(u);
                          E !== -1 &&
                            (this.workers[1].splice(E, 1),
                            this.workers[0].push(u));
                        }
                      }
                    });
                  }),
                    this.workers[0] = r;
                  this.jobQueue.length &&
                  (this.workers[0].length || this.workers[1].length);

                ) {
                  const u = this.jobQueue.shift();
                  if (this.workers[0].length > 0) {
                    const y = this.workers[0].shift();
                    this.workers[1].push(y), this.run(y, u);
                  } else {
                    const y = this.workers[1].shift();
                    this.workers[2].push(y), this.run(y, u);
                  }
                }
              }
              enqueueJob(r, u) {
                const y = { jobId: this.jobId++, buffer: r };
                if (
                  (this.jobCallbacks.set(y.jobId, u),
                  this.workers[0].length > 0)
                ) {
                  const p = this.workers[0].shift();
                  this.workers[1].push(p), this.run(p, y);
                } else if (this.workers[1].length > 0) {
                  const p = this.workers[1].shift();
                  this.workers[2].push(p), this.run(p, y);
                } else this.jobQueue.push(y);
              }
            }
            const h = (t) =>
                new Promise((r, u) => {
                  const y = {
                    cache: !0,
                    responseType: "text",
                    retry: c > 0,
                    maxRetries: c,
                  };
                  g.d.get(t, y, (p, _) => {
                    p ? u(p) : r(_);
                  });
                }),
              f = (t) => {
                const r = () =>
                    fetch(t)
                      .then((y) => y.arrayBuffer())
                      .then((y) => WebAssembly.compile(y)),
                  u = () =>
                    WebAssembly.compileStreaming(fetch(t)).catch((y) => r());
                return WebAssembly.compileStreaming ? u() : r();
              },
              s = 1;
            let l, n;
            const o = (t) => {
                if (l) return !0;
                if (!t)
                  if (n) t = n;
                  else {
                    const r = x.F.getConfig("DracoDecoderModule");
                    r
                      ? (t = {
                          jsUrl: r.glueUrl,
                          wasmUrl: r.wasmUrl,
                          numWorkers: r.numWorkers,
                        })
                      : (t = {
                          jsUrl: "draco.wasm.js",
                          wasmUrl: "draco.wasm.wasm",
                          numWorkers: s,
                        });
                  }
                return !t.jsUrl || !t.wasmUrl
                  ? !1
                  : ((l = new d()),
                    Promise.all([h(t.jsUrl), f(t.wasmUrl)]).then(([r, u]) => {
                      const y = [
                          "/* draco */",
                          r,
                          "/* worker */",
                          `(
${T.toString()}
)()

`,
                        ].join(`
`),
                        p = new Blob([y], { type: "application/javascript" }),
                        _ = URL.createObjectURL(p),
                        m = Math.max(1, Math.min(16, t.numWorkers || s)),
                        E = [];
                      for (let v = 0; v < m; ++v) {
                        const P = new Worker(_);
                        P.postMessage({ type: "init", module: u }), E.push(P);
                      }
                      l.init(E);
                    }),
                    !0);
              },
              i = (t) => {
                t != null && t.lazyInit ? (n = t) : o(t);
              },
              e = (t, r) => (o() ? (l.enqueueJob(t, r), !0) : !1);
          },
          1542: (Se, W, a) => {
            "use strict";
            a.d(W, { y: () => s });
            var x = a(8792),
              T = a(9915),
              g = a(1259),
              c = a(8691),
              d = a(5946),
              h = a(258),
              f = a(6204);
            class s {
              constructor(n, o, i, e) {
                const t = function (_, m, E) {
                    const v = s.createAsset(o.name, _, m, E);
                    return i.add(v), v;
                  },
                  r = [];
                for (let p = 0; p < n.renders.length; ++p)
                  r.push(t("render", n.renders[p], p));
                const u = [];
                for (let p = 0; p < n.materials.length; ++p)
                  u.push(t("material", n.materials[p], p));
                const y = [];
                for (let p = 0; p < n.animations.length; ++p)
                  y.push(t("animation", n.animations[p], p));
                (this.data = n),
                  (this._model = null),
                  (this._assetName = o.name),
                  (this._assets = i),
                  (this._defaultMaterial = e),
                  (this.renders = r),
                  (this.materials = u),
                  (this.textures = n.textures),
                  (this.animations = y);
              }
              get model() {
                if (!this._model) {
                  const n = s.createModel(this.data, this._defaultMaterial),
                    o = s.createAsset(this._assetName, "model", n, 0);
                  this._assets.add(o), (this._model = o);
                }
                return this._model;
              }
              static createAsset(n, o, i, e) {
                const t = new f.x(n + "/" + o + "/" + e, o, { url: "" });
                return (t.resource = i), (t.loaded = !0), t;
              }
              instantiateModelEntity(n) {
                const o = new h.J();
                return (
                  o.addComponent(
                    "model",
                    Object.assign({ type: "asset", asset: this.model }, n)
                  ),
                  o
                );
              }
              instantiateRenderEntity(n) {
                const o = this._defaultMaterial,
                  i = [],
                  e = function (y, p, _, m, E, v, P) {
                    const I = E[_.id],
                      A = I === void 0 ? o : m[I],
                      B = new x.l(_, A);
                    return (
                      _.morph && (B.morphInstance = new g.w(_.morph)),
                      P.hasOwnProperty("skin") &&
                        i.push({ meshInstance: B, rootBone: y, entity: p }),
                      B
                    );
                  },
                  t = (u, y, p) => {
                    const _ = new h.J();
                    y._cloneInternal(_), u || (u = _);
                    let m = null,
                      E = null;
                    for (let P = 0; P < p.nodes.length; P++)
                      if (p.nodes[P] === y) {
                        const A = p.gltf.nodes[P];
                        if (A.hasOwnProperty("mesh")) {
                          const B = p.renders[A.mesh].meshes;
                          E = this.renders[A.mesh];
                          for (let C = 0; C < B.length; C++) {
                            const w = B[C];
                            if (w) {
                              const k = e(
                                u,
                                _,
                                w,
                                p.materials,
                                p.meshDefaultMaterials,
                                p.skins,
                                A
                              );
                              m || (m = []), m.push(k);
                            }
                          }
                        }
                        if (p.lights) {
                          const B = p.lights.get(A);
                          B && _.addChild(B.clone());
                        }
                        if (p.cameras) {
                          const B = p.cameras.get(A);
                          B && B.camera.system.cloneComponent(B, _);
                        }
                      }
                    m &&
                      (_.addComponent(
                        "render",
                        Object.assign(
                          { type: "asset", meshInstances: m, rootBone: u },
                          n
                        )
                      ),
                      _.render.assignAsset(E));
                    const v = y.children;
                    for (let P = 0; P < v.length; P++) {
                      const I = t(u, v[P], p);
                      _.addChild(I);
                    }
                    return _;
                  },
                  r = [];
                for (const u of this.data.scenes) r.push(t(null, u, this.data));
                return (
                  i.forEach((u) => {
                    u.meshInstance.skinInstance = d.J.createCachedSkinInstance(
                      u.meshInstance.mesh.skin,
                      u.rootBone,
                      u.entity
                    );
                  }),
                  s.createSceneHierarchy(r, "Entity")
                );
              }
              getMaterialVariants() {
                return this.data.variants
                  ? Object.keys(this.data.variants)
                  : [];
              }
              applyMaterialVariant(n, o) {
                const i = o ? this.data.variants[o] : null;
                if (i === void 0) return;
                const e = n.findComponents("render");
                for (let t = 0; t < e.length; t++) {
                  const r = e[t];
                  this._applyMaterialVariant(i, r.meshInstances);
                }
              }
              applyMaterialVariantInstances(n, o) {
                const i = o ? this.data.variants[o] : null;
                i !== void 0 && this._applyMaterialVariant(i, n);
              }
              _applyMaterialVariant(n, o) {
                o.forEach((i) => {
                  if (n === null) i.material = this._defaultMaterial;
                  else {
                    const e = this.data.meshVariants[i.mesh.id];
                    e && (i.material = this.data.materials[e[n]]);
                  }
                });
              }
              static createSceneHierarchy(n, o) {
                let i = null;
                if (n.length === 1) i = n[0];
                else {
                  i = new o("SceneGroup");
                  for (const e of n) i.addChild(e);
                }
                return i;
              }
              static createModel(n, o) {
                const i = function (u, y, p, _, m, E, v) {
                    const P = n.meshDefaultMaterials[y.id],
                      I = P === void 0 ? o : m[P],
                      A = new x.l(y, I, E);
                    if (y.morph) {
                      const B = new g.w(y.morph);
                      (A.morphInstance = B), u.morphInstances.push(B);
                    }
                    if (v.hasOwnProperty("skin")) {
                      const B = v.skin,
                        C = p[B];
                      y.skin = C;
                      const w = _[B];
                      (A.skinInstance = w), u.skinInstances.push(w);
                    }
                    u.meshInstances.push(A);
                  },
                  e = new T.H(),
                  t = [];
                for (const r of n.skins) {
                  const u = new c.u(r);
                  (u.bones = r.bones), t.push(u);
                }
                e.graph = s.createSceneHierarchy(n.scenes, "GraphNode");
                for (let r = 0; r < n.nodes.length; r++) {
                  const u = n.nodes[r];
                  if (u.root === e.graph) {
                    const y = n.gltf.nodes[r];
                    if (y.hasOwnProperty("mesh")) {
                      const p = n.renders[y.mesh].meshes;
                      for (let _ = 0; _ < p.length; _++) {
                        const m = p[_];
                        m && i(e, m, n.skins, t, n.materials, u, y);
                      }
                    }
                  }
                }
                return e;
              }
              destroy() {
                const n = this._assets,
                  o = function (t) {
                    n.remove(t), t.unload();
                  },
                  i = function (t) {
                    t.forEach(function (r) {
                      o(r);
                    });
                  };
                this.animations &&
                  (i(this.animations), (this.animations = null)),
                  this.textures && (i(this.textures), (this.textures = null)),
                  this.materials &&
                    (i(this.materials), (this.materials = null)),
                  this.renders && (i(this.renders), (this.renders = null)),
                  this._model && (o(this._model), (this._model = null)),
                  (this.data = null),
                  (this.assets = null);
              }
            }
          },
          5768: (Se, W, a) => {
            "use strict";
            a.d(W, { Z: () => Pt });
            var x = a(9296),
              T = a(1367),
              g = a(9758),
              c = a(4585),
              d = a(2978),
              h = a(6556),
              f = a(3148),
              s = a(7921),
              l = a(9459),
              n = a(8869),
              o = a(6615),
              i = a(8385),
              e = a(1467),
              t = a(3114),
              r = a(7915),
              u = a(8632),
              y = a(7678),
              p = a(3823),
              _ = a(7551),
              m = a(4611),
              E = a(6598),
              v = a(4390),
              P = a(8944),
              I = a(258),
              A = a(3471),
              B = a(7061),
              C = a(3248),
              w = a(8949),
              k = a(6204),
              K = a(8462),
              te = a(5067);
            class X {
              constructor() {
                (this.gltf = void 0),
                  (this.nodes = void 0),
                  (this.scenes = void 0),
                  (this.animations = void 0),
                  (this.textures = void 0),
                  (this.materials = void 0),
                  (this.variants = void 0),
                  (this.meshVariants = void 0),
                  (this.meshDefaultMaterials = void 0),
                  (this.renders = void 0),
                  (this.skins = void 0),
                  (this.lights = void 0),
                  (this.cameras = void 0);
              }
              destroy() {
                this.renders &&
                  this.renders.forEach((fe) => {
                    fe.meshes = null;
                  });
              }
            }
            const $ = (he) => /^data:.*,.*$/i.test(he),
              ne = (he) => he.substring(he.indexOf(":") + 1, he.indexOf(";")),
              Y = (he) => {
                switch (he) {
                  case "SCALAR":
                    return 1;
                  case "VEC2":
                    return 2;
                  case "VEC3":
                    return 3;
                  case "VEC4":
                    return 4;
                  case "MAT2":
                    return 4;
                  case "MAT3":
                    return 9;
                  case "MAT4":
                    return 16;
                  default:
                    return 3;
                }
              },
              Z = (he) => {
                switch (he) {
                  case 5120:
                    return s.NPC;
                  case 5121:
                    return s.vyI;
                  case 5122:
                    return s.S81;
                  case 5123:
                    return s.Spw;
                  case 5124:
                    return s.$Rf;
                  case 5125:
                    return s.$GK;
                  case 5126:
                    return s.r8O;
                  default:
                    return 0;
                }
              },
              ye = (he) => {
                switch (he) {
                  case 5120:
                    return 1;
                  case 5121:
                    return 1;
                  case 5122:
                    return 2;
                  case 5123:
                    return 2;
                  case 5124:
                    return 4;
                  case 5125:
                    return 4;
                  case 5126:
                    return 4;
                  default:
                    return 0;
                }
              },
              pe = (he) => {
                switch (he) {
                  case 5120:
                    return Int8Array;
                  case 5121:
                    return Uint8Array;
                  case 5122:
                    return Int16Array;
                  case 5123:
                    return Uint16Array;
                  case 5124:
                    return Int32Array;
                  case 5125:
                    return Uint32Array;
                  case 5126:
                    return Float32Array;
                  default:
                    return null;
                }
              },
              O = {
                POSITION: s.Q5v,
                NORMAL: s.SA$,
                TANGENT: s.ipN,
                COLOR_0: s.wD$,
                JOINTS_0: s.MgX,
                WEIGHTS_0: s.d1j,
                TEXCOORD_0: s.$fY,
                TEXCOORD_1: s.Q0q,
                TEXCOORD_2: s.WtN,
                TEXCOORD_3: s.SSp,
                TEXCOORD_4: s.uOW,
                TEXCOORD_5: s.EKq,
                TEXCOORD_6: s.Vcj,
                TEXCOORD_7: s.$8O,
              },
              me = {
                [s.Q5v]: 0,
                [s.SA$]: 1,
                [s.ipN]: 2,
                [s.wD$]: 3,
                [s.MgX]: 4,
                [s.d1j]: 5,
                [s.$fY]: 6,
                [s.Q0q]: 7,
                [s.WtN]: 8,
                [s.SSp]: 9,
                [s.uOW]: 10,
                [s.EKq]: 11,
                [s.Vcj]: 12,
                [s.$8O]: 13,
              },
              N = (he) => {
                switch (he) {
                  case s.NPC:
                    return (fe) => Math.max(fe / 127, -1);
                  case s.vyI:
                    return (fe) => fe / 255;
                  case s.S81:
                    return (fe) => Math.max(fe / 32767, -1);
                  case s.Spw:
                    return (fe) => fe / 65535;
                  default:
                    return (fe) => fe;
                }
              },
              V = (he, fe, Ie) => {
                const ue = N(Ie),
                  De = fe.length;
                for (let et = 0; et < De; ++et) he[et] = ue(fe[et]);
                return he;
              },
              L = (he, fe, Ie = !1) => {
                const ue = Y(he.type),
                  De = pe(he.componentType);
                if (!De) return null;
                let et;
                if (he.sparse) {
                  const Ze = he.sparse,
                    Ve = { count: Ze.count, type: "SCALAR" },
                    tt = L(Object.assign(Ve, Ze.indices), fe, !0),
                    Be = {
                      count: Ze.count,
                      type: he.type,
                      componentType: he.componentType,
                    },
                    ot = L(Object.assign(Be, Ze.values), fe, !0);
                  if (he.hasOwnProperty("bufferView")) {
                    const Qe = {
                      bufferView: he.bufferView,
                      byteOffset: he.byteOffset,
                      componentType: he.componentType,
                      count: he.count,
                      type: he.type,
                    };
                    et = L(Qe, fe, !0).slice();
                  } else et = new De(he.count * ue);
                  for (let Qe = 0; Qe < Ze.count; ++Qe) {
                    const mt = tt[Qe];
                    for (let je = 0; je < ue; ++je)
                      et[mt * ue + je] = ot[Qe * ue + je];
                  }
                } else if (he.hasOwnProperty("bufferView")) {
                  const Ze = fe[he.bufferView];
                  if (Ie && Ze.hasOwnProperty("byteStride")) {
                    const Ve = ue * De.BYTES_PER_ELEMENT,
                      tt = new ArrayBuffer(he.count * Ve),
                      Be = new Uint8Array(tt);
                    let ot = 0;
                    for (let Qe = 0; Qe < he.count; ++Qe) {
                      let mt = (he.byteOffset || 0) + Qe * Ze.byteStride;
                      for (let je = 0; je < Ve; ++je) Be[ot++] = Ze[mt++];
                    }
                    et = new De(tt);
                  } else
                    et = new De(
                      Ze.buffer,
                      Ze.byteOffset + (he.byteOffset || 0),
                      he.count * ue
                    );
                } else et = new De(he.count * ue);
                return et;
              },
              J = (he, fe) => {
                const Ie = L(he, fe, !0);
                if (Ie instanceof Float32Array || !he.normalized) return Ie;
                const ue = new Float32Array(Ie.length);
                return V(ue, Ie, Z(he.componentType)), ue;
              },
              ae = (he) => {
                let fe = he.min,
                  Ie = he.max;
                if (!fe || !Ie) return null;
                if (he.normalized) {
                  const ue = Z(he.componentType);
                  (fe = V([], fe, ue)), (Ie = V([], Ie, ue));
                }
                return new f.k(
                  new h.A(
                    (Ie[0] + fe[0]) * 0.5,
                    (Ie[1] + fe[1]) * 0.5,
                    (Ie[2] + fe[2]) * 0.5
                  ),
                  new h.A(
                    (Ie[0] - fe[0]) * 0.5,
                    (Ie[1] - fe[1]) * 0.5,
                    (Ie[2] - fe[2]) * 0.5
                  )
                );
              },
              R = (he) => {
                if (!he.hasOwnProperty("mode")) return s.LAy;
                switch (he.mode) {
                  case 0:
                    return s.KtK;
                  case 1:
                    return s.Y7R;
                  case 2:
                    return s.QSU;
                  case 3:
                    return s.HWi;
                  case 4:
                    return s.LAy;
                  case 5:
                    return s.fmY;
                  case 6:
                    return s.x5Y;
                  default:
                    return s.LAy;
                }
              },
              j = (he) => {
                const fe = new Uint16Array(he);
                for (let Ie = 0; Ie < he; Ie++) fe[Ie] = Ie;
                return fe;
              },
              se = (he, fe) => {
                const Ie = he[s.Q5v];
                if (!Ie || Ie.components !== 3) return;
                let ue;
                if (Ie.size !== Ie.stride) {
                  const Ve = Ie.stride / s.MbK[Ie.type],
                    tt = new s.DIG[Ie.type](
                      Ie.buffer,
                      Ie.offset,
                      Ie.count * Ve
                    );
                  ue = new s.DIG[Ie.type](Ie.count * 3);
                  for (let Be = 0; Be < Ie.count; ++Be)
                    (ue[Be * 3 + 0] = tt[Be * Ve + 0]),
                      (ue[Be * 3 + 1] = tt[Be * Ve + 1]),
                      (ue[Be * 3 + 2] = tt[Be * Ve + 2]);
                } else
                  ue = new s.DIG[Ie.type](Ie.buffer, Ie.offset, Ie.count * 3);
                const De = Ie.count;
                fe || (fe = j(De));
                const et = (0, m.hu)(ue, fe),
                  Ze = new Float32Array(et.length);
                Ze.set(et),
                  (he[s.SA$] = {
                    buffer: Ze.buffer,
                    size: 12,
                    offset: 0,
                    stride: 12,
                    count: De,
                    components: 3,
                    type: s.r8O,
                  });
              },
              ce = (he) => {
                let fe, Ie;
                const ue = [],
                  De = [],
                  et = [];
                for (fe = 0; fe < he.format.elements.length; ++fe) {
                  const Ve = he.format.elements[fe];
                  if (Ve.name === s.$fY || Ve.name === s.Q0q)
                    switch (Ve.dataType) {
                      case s.r8O:
                        ue.push({
                          offset: Ve.offset / 4 + 1,
                          stride: Ve.stride / 4,
                        });
                        break;
                      case s.Spw:
                        De.push({
                          offset: Ve.offset / 2 + 1,
                          stride: Ve.stride / 2,
                        });
                        break;
                      case s.vyI:
                        et.push({ offset: Ve.offset + 1, stride: Ve.stride });
                        break;
                    }
                }
                const Ze = (Ve, tt, Be) => {
                  const ot = new tt(he.storage);
                  for (fe = 0; fe < Ve.length; ++fe) {
                    let Qe = Ve[fe].offset;
                    const mt = Ve[fe].stride;
                    for (Ie = 0; Ie < he.numVertices; ++Ie)
                      (ot[Qe] = Be - ot[Qe]), (Qe += mt);
                  }
                };
                ue.length > 0 && Ze(ue, Float32Array, 1),
                  De.length > 0 && Ze(De, Uint16Array, 65535),
                  et.length > 0 && Ze(et, Uint8Array, 255);
              },
              ie = (he) => {
                const fe = (ue) => {
                    const De = [];
                    for (let et = 0; et < ue._levels.length; ++et) {
                      let Ze = [];
                      if (ue.cubemap)
                        for (let Ve = 0; Ve < 6; ++Ve)
                          Ze.push(ue._levels[et][Ve]);
                      else Ze = ue._levels[et];
                      De.push(Ze);
                    }
                    return De;
                  },
                  Ie = new n.x(he.device, he);
                return (Ie._levels = fe(he)), Ie;
              },
              b = (he) => {
                const fe = new k.x(
                  he.name + "_clone",
                  he.type,
                  he.file,
                  he.data,
                  he.options
                );
                return (
                  (fe.loaded = !0),
                  (fe.resource = ie(he.resource)),
                  he.registry.add(fe),
                  fe
                );
              },
              M = (he, fe, Ie) => {
                const ue = fe[s.Q5v];
                if (!ue) return null;
                const De = ue.count,
                  et = [];
                for (const vt in fe)
                  fe.hasOwnProperty(vt) &&
                    et.push({
                      semantic: vt,
                      components: fe[vt].components,
                      type: fe[vt].type,
                      normalize: !!fe[vt].normalize,
                    });
                et.sort((vt, Fe) => me[vt.semantic] - me[Fe.semantic]);
                let Ze, Ve, tt, Be, ot, Qe;
                const mt = new i.g(he, et);
                let je = !0;
                for (Ze = 0; Ze < mt.elements.length; ++Ze)
                  if (
                    ((ot = mt.elements[Ze]),
                    (Be = fe[ot.name]),
                    (Qe = Be.offset - ue.offset),
                    Be.buffer !== ue.buffer ||
                      Be.stride !== ot.stride ||
                      Be.size !== ot.size ||
                      Qe !== ot.offset)
                  ) {
                    je = !1;
                    break;
                  }
                const lt = new o.o(he, mt, De, s.dxy),
                  Et = lt.lock(),
                  ct = new Uint32Array(Et);
                let pt;
                if (je)
                  (pt = new Uint32Array(
                    ue.buffer,
                    ue.offset,
                    (De * lt.format.size) / 4
                  )),
                    ct.set(pt);
                else {
                  let vt, Fe;
                  for (Ze = 0; Ze < lt.format.elements.length; ++Ze) {
                    (ot = lt.format.elements[Ze]),
                      (vt = ot.stride / 4),
                      (Be = fe[ot.name]),
                      (Fe = Be.stride / 4),
                      (pt = new Uint32Array(
                        Be.buffer,
                        Be.offset,
                        (Be.count - 1) * Fe + (Be.size + 3) / 4
                      ));
                    let Yt = 0,
                      Ot = ot.offset / 4;
                    const Rt = Math.floor((Be.size + 3) / 4);
                    for (Ve = 0; Ve < De; ++Ve) {
                      for (tt = 0; tt < Rt; ++tt) ct[Ot + tt] = pt[Yt + tt];
                      (Yt += Fe), (Ot += vt);
                    }
                  }
                }
                return Ie && ce(lt), lt.unlock(), lt;
              },
              F = (he, fe, Ie, ue, De, et, Ze) => {
                const Ve = {},
                  tt = [];
                for (const Qe in fe)
                  fe.hasOwnProperty(Qe) &&
                    O.hasOwnProperty(Qe) &&
                    ((Ve[Qe] = fe[Qe]), tt.push(Qe + ":" + fe[Qe]));
                tt.sort();
                const Be = tt.join();
                let ot = Ze[Be];
                if (!ot) {
                  const Qe = {};
                  for (const mt in Ve) {
                    const je = ue[fe[mt]],
                      lt = L(je, De),
                      Et = De[je.bufferView],
                      ct = O[mt],
                      pt = Y(je.type) * ye(je.componentType),
                      vt =
                        Et && Et.hasOwnProperty("byteStride")
                          ? Et.byteStride
                          : pt;
                    Qe[ct] = {
                      buffer: lt.buffer,
                      size: pt,
                      offset: lt.byteOffset,
                      stride: vt,
                      count: je.count,
                      components: Y(je.type),
                      type: Z(je.componentType),
                      normalize: je.normalized,
                    };
                  }
                  Qe.hasOwnProperty(s.SA$) || se(Qe, Ie),
                    (ot = M(he, Qe, et)),
                    (Ze[Be] = ot);
                }
                return ot;
              },
              z = (he, fe, Ie, ue, De, et) => {
                let Ze, Ve, tt;
                const Be = fe.joints,
                  ot = Be.length,
                  Qe = [];
                if (fe.hasOwnProperty("inverseBindMatrices")) {
                  const Et = fe.inverseBindMatrices,
                    ct = L(Ie[Et], ue, !0),
                    pt = [];
                  for (Ze = 0; Ze < ot; Ze++) {
                    for (Ve = 0; Ve < 16; Ve++) pt[Ve] = ct[Ze * 16 + Ve];
                    (tt = new g.y()), tt.set(pt), Qe.push(tt);
                  }
                } else
                  for (Ze = 0; Ze < ot; Ze++) (tt = new g.y()), Qe.push(tt);
                const mt = [];
                for (Ze = 0; Ze < ot; Ze++) mt[Ze] = De[Be[Ze]].name;
                const je = mt.join("#");
                let lt = et.get(je);
                return lt || ((lt = new v.Z(he, Qe, mt)), et.set(je, lt)), lt;
              },
              oe = (he, fe, Ie, ue, De, et, Ze) => {
                var Ve;
                const tt = new y.K(he);
                tt.aabb = ae(Ie[fe.attributes.POSITION]);
                const Be = [];
                for (const [Qe, mt] of Object.entries(fe.attributes)) {
                  var ot;
                  const je = Ie[mt],
                    lt = O[Qe],
                    Et = Z(je.componentType);
                  Be.push({
                    semantic: lt,
                    components: Y(je.type),
                    type: Et,
                    normalize:
                      (ot = je.normalized) != null
                        ? ot
                        : lt === s.wD$ && (Et === s.vyI || Et === s.Spw),
                  });
                }
                if (
                  (Ze.push(
                    new Promise((Qe, mt) => {
                      const je = fe.extensions.KHR_draco_mesh_compression;
                      (0, te.J)(ue[je.bufferView].slice().buffer, (lt, Et) => {
                        if (lt) console.log(lt), mt(lt);
                        else {
                          var ct;
                          const pt = {};
                          for (const [Lt, Ft] of Object.entries(je.attributes))
                            pt[O[Lt]] = Et.attributes.indexOf(Ft);
                          Be.sort(
                            (Lt, Ft) => pt[Lt.semantic] - pt[Ft.semantic]
                          ),
                            ((ct = fe.attributes) != null && ct.NORMAL) ||
                              Be.splice(1, 0, {
                                semantic: "NORMAL",
                                components: 3,
                                type: s.r8O,
                              });
                          const vt = new i.g(he, Be),
                            Fe = Et.vertices.byteLength / vt.size,
                            Yt = Fe <= 65535 ? s.q0F : s.qCh,
                            Ot = Et.indices.byteLength / (Fe <= 65535 ? 2 : 4),
                            Rt = new o.o(he, vt, Fe, s.dxy, Et.vertices),
                            Kt = new l.G(he, Yt, Ot, s.dxy, Et.indices);
                          (tt.vertexBuffer = Rt),
                            (tt.indexBuffer[0] = Kt),
                            (tt.primitive[0].type = R(fe)),
                            (tt.primitive[0].base = 0),
                            (tt.primitive[0].count = Kt ? Ot : Fe),
                            (tt.primitive[0].indexed = !!Kt),
                            Qe();
                        }
                      });
                    })
                  ),
                  fe != null &&
                    (Ve = fe.extensions) != null &&
                    Ve.KHR_materials_variants)
                ) {
                  const Qe = fe.extensions.KHR_materials_variants,
                    mt = {};
                  Qe.mappings.forEach((je) => {
                    je.variants.forEach((lt) => {
                      mt[lt] = je.material;
                    });
                  }),
                    (De[tt.id] = mt);
                }
                return (et[tt.id] = fe.material), tt;
              },
              de = (he, fe, Ie, ue, De, et, Ze, Ve, tt, Be) => {
                const ot = [];
                return (
                  fe.primitives.forEach((Qe) => {
                    var mt;
                    if (
                      (mt = Qe.extensions) != null &&
                      mt.KHR_draco_mesh_compression
                    )
                      ot.push(oe(he, Qe, Ie, ue, Ze, Ve, Be));
                    else {
                      let je = Qe.hasOwnProperty("indices")
                        ? L(Ie[Qe.indices], ue, !0)
                        : null;
                      const lt = F(he, Qe.attributes, je, Ie, ue, De, et),
                        Et = R(Qe),
                        ct = new y.K(he);
                      if (
                        ((ct.vertexBuffer = lt),
                        (ct.primitive[0].type = Et),
                        (ct.primitive[0].base = 0),
                        (ct.primitive[0].indexed = je !== null),
                        je !== null)
                      ) {
                        let vt;
                        je instanceof Uint8Array
                          ? (vt = s.fUD)
                          : je instanceof Uint16Array
                          ? (vt = s.q0F)
                          : (vt = s.qCh),
                          vt === s.qCh &&
                            !he.extUintElement &&
                            ((vt = s.q0F), (je = new Uint16Array(je))),
                          vt === s.fUD &&
                            he.isWebGPU &&
                            ((vt = s.q0F), (je = new Uint16Array(je)));
                        const Fe = new l.G(he, vt, je.length, s.dxy, je);
                        (ct.indexBuffer[0] = Fe),
                          (ct.primitive[0].count = je.length);
                      } else ct.primitive[0].count = lt.numVertices;
                      if (
                        Qe.hasOwnProperty("extensions") &&
                        Qe.extensions.hasOwnProperty("KHR_materials_variants")
                      ) {
                        const vt = Qe.extensions.KHR_materials_variants,
                          Fe = {};
                        vt.mappings.forEach((Yt) => {
                          Yt.variants.forEach((Ot) => {
                            Fe[Ot] = Yt.material;
                          });
                        }),
                          (Ze[ct.id] = Fe);
                      }
                      Ve[ct.id] = Qe.material;
                      let pt = Ie[Qe.attributes.POSITION];
                      if (((ct.aabb = ae(pt)), Qe.hasOwnProperty("targets"))) {
                        const vt = [];
                        Qe.targets.forEach((Fe, Yt) => {
                          const Ot = {};
                          Fe.hasOwnProperty("POSITION") &&
                            ((pt = Ie[Fe.POSITION]),
                            (Ot.deltaPositions = J(pt, ue)),
                            (Ot.deltaPositionsType = s.r8O),
                            (Ot.aabb = ae(pt))),
                            Fe.hasOwnProperty("NORMAL") &&
                              ((pt = Ie[Fe.NORMAL]),
                              (Ot.deltaNormals = J(pt, ue)),
                              (Ot.deltaNormalsType = s.r8O)),
                            fe.hasOwnProperty("extras") &&
                            fe.extras.hasOwnProperty("targetNames")
                              ? (Ot.name = fe.extras.targetNames[Yt])
                              : (Ot.name = Yt.toString(10)),
                            fe.hasOwnProperty("weights") &&
                              (Ot.defaultWeight = fe.weights[Yt]),
                            (Ot.preserveData = tt.morphPreserveData),
                            vt.push(new _.Y(Ot));
                        }),
                          (ct.morph = new p._(vt, he, {
                            preferHighPrecision: tt.morphPreferHighPrecision,
                          }));
                      }
                      ot.push(ct);
                    }
                  }),
                  ot
                );
              },
              ge = (he, fe, Ie) => {
                var ue;
                let De;
                const et = he.texCoord;
                if (et)
                  for (De = 0; De < Ie.length; ++De) fe[Ie[De] + "MapUv"] = et;
                const Ze = [0, 0],
                  Ve = [1, 1],
                  tt =
                    (ue = he.extensions) == null
                      ? void 0
                      : ue.KHR_texture_transform;
                if (tt) {
                  const Be = tt.offset || Ze,
                    ot = tt.scale || Ve,
                    Qe = tt.rotation ? -tt.rotation * c.m.RAD_TO_DEG : 0,
                    mt = new d.S(ot[0], ot[1]),
                    je = new d.S(Be[0], 1 - ot[1] - Be[1]);
                  for (De = 0; De < Ie.length; ++De)
                    (fe[`${Ie[De]}MapTiling`] = mt),
                      (fe[`${Ie[De]}MapOffset`] = je),
                      (fe[`${Ie[De]}MapRotation`] = Qe);
                }
              },
              Re = (he, fe, Ie) => {
                let ue, De;
                if (
                  (he.hasOwnProperty("diffuseFactor")
                    ? ((ue = he.diffuseFactor),
                      fe.diffuse.set(
                        Math.pow(ue[0], 1 / 2.2),
                        Math.pow(ue[1], 1 / 2.2),
                        Math.pow(ue[2], 1 / 2.2)
                      ),
                      (fe.opacity = ue[3]))
                    : (fe.diffuse.set(1, 1, 1), (fe.opacity = 1)),
                  he.hasOwnProperty("diffuseTexture"))
                ) {
                  const et = he.diffuseTexture;
                  (De = Ie[et.index]),
                    (fe.diffuseMap = De),
                    (fe.diffuseMapChannel = "rgb"),
                    (fe.opacityMap = De),
                    (fe.opacityMapChannel = "a"),
                    ge(et, fe, ["diffuse", "opacity"]);
                }
                if (
                  ((fe.useMetalness = !1),
                  he.hasOwnProperty("specularFactor")
                    ? ((ue = he.specularFactor),
                      fe.specular.set(
                        Math.pow(ue[0], 1 / 2.2),
                        Math.pow(ue[1], 1 / 2.2),
                        Math.pow(ue[2], 1 / 2.2)
                      ))
                    : fe.specular.set(1, 1, 1),
                  he.hasOwnProperty("glossinessFactor")
                    ? (fe.gloss = he.glossinessFactor)
                    : (fe.gloss = 1),
                  he.hasOwnProperty("specularGlossinessTexture"))
                ) {
                  const et = he.specularGlossinessTexture;
                  (fe.specularEncoding = "srgb"),
                    (fe.specularMap = fe.glossMap = Ie[et.index]),
                    (fe.specularMapChannel = "rgb"),
                    (fe.glossMapChannel = "a"),
                    ge(et, fe, ["gloss", "metalness"]);
                }
              },
              Te = (he, fe, Ie) => {
                if (
                  (he.hasOwnProperty("clearcoatFactor")
                    ? (fe.clearCoat = he.clearcoatFactor * 0.25)
                    : (fe.clearCoat = 0),
                  he.hasOwnProperty("clearcoatTexture"))
                ) {
                  const ue = he.clearcoatTexture;
                  (fe.clearCoatMap = Ie[ue.index]),
                    (fe.clearCoatMapChannel = "r"),
                    ge(ue, fe, ["clearCoat"]);
                }
                if (
                  (he.hasOwnProperty("clearcoatRoughnessFactor")
                    ? (fe.clearCoatGloss = he.clearcoatRoughnessFactor)
                    : (fe.clearCoatGloss = 0),
                  he.hasOwnProperty("clearcoatRoughnessTexture"))
                ) {
                  const ue = he.clearcoatRoughnessTexture;
                  (fe.clearCoatGlossMap = Ie[ue.index]),
                    (fe.clearCoatGlossMapChannel = "g"),
                    ge(ue, fe, ["clearCoatGloss"]);
                }
                if (he.hasOwnProperty("clearcoatNormalTexture")) {
                  const ue = he.clearcoatNormalTexture;
                  (fe.clearCoatNormalMap = Ie[ue.index]),
                    ge(ue, fe, ["clearCoatNormal"]),
                    ue.hasOwnProperty("scale") &&
                      (fe.clearCoatBumpiness = ue.scale);
                }
                fe.clearCoatGlossInvert = !0;
              },
              Ne = (he, fe, Ie) => {
                (fe.useLighting = !1),
                  fe.emissive.copy(fe.diffuse),
                  (fe.emissiveTint = fe.diffuseTint),
                  (fe.emissiveMap = fe.diffuseMap),
                  (fe.emissiveMapUv = fe.diffuseMapUv),
                  fe.emissiveMapTiling.copy(fe.diffuseMapTiling),
                  fe.emissiveMapOffset.copy(fe.diffuseMapOffset),
                  (fe.emissiveMapRotation = fe.diffuseMapRotation),
                  (fe.emissiveMapChannel = fe.diffuseMapChannel),
                  (fe.emissiveVertexColor = fe.diffuseVertexColor),
                  (fe.emissiveVertexColorChannel =
                    fe.diffuseVertexColorChannel),
                  (fe.useLighting = !1),
                  (fe.useSkybox = !1),
                  fe.diffuse.set(0, 0, 0),
                  (fe.diffuseTint = !1),
                  (fe.diffuseMap = null),
                  (fe.diffuseVertexColor = !1);
              },
              Le = (he, fe, Ie) => {
                if (
                  ((fe.useMetalnessSpecularColor = !0),
                  he.hasOwnProperty("specularColorTexture") &&
                    ((fe.specularEncoding = "srgb"),
                    (fe.specularMap = Ie[he.specularColorTexture.index]),
                    (fe.specularMapChannel = "rgb"),
                    ge(he.specularColorTexture, fe, ["specular"])),
                  he.hasOwnProperty("specularColorFactor"))
                ) {
                  const ue = he.specularColorFactor;
                  fe.specular.set(
                    Math.pow(ue[0], 1 / 2.2),
                    Math.pow(ue[1], 1 / 2.2),
                    Math.pow(ue[2], 1 / 2.2)
                  );
                } else fe.specular.set(1, 1, 1);
                he.hasOwnProperty("specularFactor")
                  ? (fe.specularityFactor = he.specularFactor)
                  : (fe.specularityFactor = 1),
                  he.hasOwnProperty("specularTexture") &&
                    ((fe.specularityFactorMapChannel = "a"),
                    (fe.specularityFactorMap = Ie[he.specularTexture.index]),
                    ge(he.specularTexture, fe, ["specularityFactor"]));
              },
              ke = (he, fe, Ie) => {
                he.hasOwnProperty("ior") && (fe.refractionIndex = 1 / he.ior);
              },
              ht = (he, fe, Ie) => {
                (fe.blendType = t.lA),
                  (fe.useDynamicRefraction = !0),
                  he.hasOwnProperty("transmissionFactor") &&
                    (fe.refraction = he.transmissionFactor),
                  he.hasOwnProperty("transmissionTexture") &&
                    ((fe.refractionMapChannel = "r"),
                    (fe.refractionMap = Ie[he.transmissionTexture.index]),
                    ge(he.transmissionTexture, fe, ["refraction"]));
              },
              _e = (he, fe, Ie) => {
                if (
                  ((fe.useSheen = !0), he.hasOwnProperty("sheenColorFactor"))
                ) {
                  const ue = he.sheenColorFactor;
                  fe.sheen.set(
                    Math.pow(ue[0], 1 / 2.2),
                    Math.pow(ue[1], 1 / 2.2),
                    Math.pow(ue[2], 1 / 2.2)
                  );
                } else fe.sheen.set(1, 1, 1);
                he.hasOwnProperty("sheenColorTexture") &&
                  ((fe.sheenMap = Ie[he.sheenColorTexture.index]),
                  (fe.sheenEncoding = "srgb"),
                  ge(he.sheenColorTexture, fe, ["sheen"])),
                  he.hasOwnProperty("sheenRoughnessFactor")
                    ? (fe.sheenGloss = he.sheenRoughnessFactor)
                    : (fe.sheenGloss = 0),
                  he.hasOwnProperty("sheenRoughnessTexture") &&
                    ((fe.sheenGlossMap = Ie[he.sheenRoughnessTexture.index]),
                    (fe.sheenGlossMapChannel = "a"),
                    ge(he.sheenRoughnessTexture, fe, ["sheenGloss"])),
                  (fe.sheenGlossInvert = !0);
              },
              U = (he, fe, Ie) => {
                if (
                  ((fe.blendType = t.lA),
                  (fe.useDynamicRefraction = !0),
                  he.hasOwnProperty("thicknessFactor") &&
                    (fe.thickness = he.thicknessFactor),
                  he.hasOwnProperty("thicknessTexture") &&
                    ((fe.thicknessMap = Ie[he.thicknessTexture.index]),
                    (fe.thicknessMapChannel = "g"),
                    ge(he.thicknessTexture, fe, ["thickness"])),
                  he.hasOwnProperty("attenuationDistance") &&
                    (fe.attenuationDistance = he.attenuationDistance),
                  he.hasOwnProperty("attenuationColor"))
                ) {
                  const ue = he.attenuationColor;
                  fe.attenuation.set(
                    Math.pow(ue[0], 1 / 2.2),
                    Math.pow(ue[1], 1 / 2.2),
                    Math.pow(ue[2], 1 / 2.2)
                  );
                }
              },
              H = (he, fe, Ie) => {
                he.hasOwnProperty("emissiveStrength") &&
                  (fe.emissiveIntensity = he.emissiveStrength);
              },
              Ee = (he, fe, Ie) => {
                (fe.useIridescence = !0),
                  he.hasOwnProperty("iridescenceFactor") &&
                    (fe.iridescence = he.iridescenceFactor),
                  he.hasOwnProperty("iridescenceTexture") &&
                    ((fe.iridescenceMapChannel = "r"),
                    (fe.iridescenceMap = Ie[he.iridescenceTexture.index]),
                    ge(he.iridescenceTexture, fe, ["iridescence"])),
                  he.hasOwnProperty("iridescenceIor") &&
                    (fe.iridescenceRefractionIndex = he.iridescenceIor),
                  he.hasOwnProperty("iridescenceThicknessMinimum") &&
                    (fe.iridescenceThicknessMin =
                      he.iridescenceThicknessMinimum),
                  he.hasOwnProperty("iridescenceThicknessMaximum") &&
                    (fe.iridescenceThicknessMax =
                      he.iridescenceThicknessMaximum),
                  he.hasOwnProperty("iridescenceThicknessTexture") &&
                    ((fe.iridescenceThicknessMapChannel = "g"),
                    (fe.iridescenceThicknessMap =
                      Ie[he.iridescenceThicknessTexture.index]),
                    ge(he.iridescenceThicknessTexture, fe, [
                      "iridescenceThickness",
                    ]));
              },
              G = (he, fe, Ie) => {
                const ue = new P.K();
                (ue.occludeSpecular = t._f),
                  (ue.diffuseTint = !0),
                  (ue.diffuseVertexColor = !0),
                  (ue.specularTint = !0),
                  (ue.specularVertexColor = !0),
                  he.hasOwnProperty("name") && (ue.name = he.name);
                let De, et;
                if (he.hasOwnProperty("pbrMetallicRoughness")) {
                  const Ve = he.pbrMetallicRoughness;
                  if (
                    (Ve.hasOwnProperty("baseColorFactor")
                      ? ((De = Ve.baseColorFactor),
                        ue.diffuse.set(
                          Math.pow(De[0], 1 / 2.2),
                          Math.pow(De[1], 1 / 2.2),
                          Math.pow(De[2], 1 / 2.2)
                        ),
                        (ue.opacity = De[3]))
                      : (ue.diffuse.set(1, 1, 1), (ue.opacity = 1)),
                    Ve.hasOwnProperty("baseColorTexture"))
                  ) {
                    const tt = Ve.baseColorTexture;
                    (et = fe[tt.index]),
                      (ue.diffuseMap = et),
                      (ue.diffuseMapChannel = "rgb"),
                      (ue.opacityMap = et),
                      (ue.opacityMapChannel = "a"),
                      ge(tt, ue, ["diffuse", "opacity"]);
                  }
                  if (
                    ((ue.useMetalness = !0),
                    ue.specular.set(1, 1, 1),
                    Ve.hasOwnProperty("metallicFactor")
                      ? (ue.metalness = Ve.metallicFactor)
                      : (ue.metalness = 1),
                    Ve.hasOwnProperty("roughnessFactor")
                      ? (ue.gloss = Ve.roughnessFactor)
                      : (ue.gloss = 1),
                    (ue.glossInvert = !0),
                    Ve.hasOwnProperty("metallicRoughnessTexture"))
                  ) {
                    const tt = Ve.metallicRoughnessTexture;
                    (ue.metalnessMap = ue.glossMap = fe[tt.index]),
                      (ue.metalnessMapChannel = "b"),
                      (ue.glossMapChannel = "g"),
                      ge(tt, ue, ["gloss", "metalness"]);
                  }
                }
                if (he.hasOwnProperty("normalTexture")) {
                  const Ve = he.normalTexture;
                  (ue.normalMap = fe[Ve.index]),
                    ge(Ve, ue, ["normal"]),
                    Ve.hasOwnProperty("scale") && (ue.bumpiness = Ve.scale);
                }
                if (he.hasOwnProperty("occlusionTexture")) {
                  const Ve = he.occlusionTexture;
                  (ue.aoMap = fe[Ve.index]),
                    (ue.aoMapChannel = "r"),
                    ge(Ve, ue, ["ao"]);
                }
                if (
                  (he.hasOwnProperty("emissiveFactor")
                    ? ((De = he.emissiveFactor),
                      ue.emissive.set(
                        Math.pow(De[0], 1 / 2.2),
                        Math.pow(De[1], 1 / 2.2),
                        Math.pow(De[2], 1 / 2.2)
                      ),
                      (ue.emissiveTint = !0))
                    : (ue.emissive.set(0, 0, 0), (ue.emissiveTint = !1)),
                  he.hasOwnProperty("emissiveTexture"))
                ) {
                  const Ve = he.emissiveTexture;
                  (ue.emissiveMap = fe[Ve.index]), ge(Ve, ue, ["emissive"]);
                }
                if (he.hasOwnProperty("alphaMode"))
                  switch (he.alphaMode) {
                    case "MASK":
                      (ue.blendType = t.He),
                        he.hasOwnProperty("alphaCutoff")
                          ? (ue.alphaTest = he.alphaCutoff)
                          : (ue.alphaTest = 0.5);
                      break;
                    case "BLEND":
                      (ue.blendType = t.lA), (ue.depthWrite = !1);
                      break;
                    default:
                    case "OPAQUE":
                      ue.blendType = t.He;
                      break;
                  }
                else ue.blendType = t.He;
                he.hasOwnProperty("doubleSided")
                  ? ((ue.twoSidedLighting = he.doubleSided),
                    (ue.cull = he.doubleSided ? s.OL2 : s.Ak1))
                  : ((ue.twoSidedLighting = !1), (ue.cull = s.Ak1));
                const Ze = {
                  KHR_materials_clearcoat: Te,
                  KHR_materials_emissive_strength: H,
                  KHR_materials_ior: ke,
                  KHR_materials_iridescence: Ee,
                  KHR_materials_pbrSpecularGlossiness: Re,
                  KHR_materials_sheen: _e,
                  KHR_materials_specular: Le,
                  KHR_materials_transmission: ht,
                  KHR_materials_unlit: Ne,
                  KHR_materials_volume: U,
                };
                if (he.hasOwnProperty("extensions"))
                  for (const Ve in he.extensions) {
                    const tt = Ze[Ve];
                    tt !== void 0 && tt(he.extensions[Ve], ue, fe);
                  }
                return ue.update(), ue;
              },
              Q = (he, fe, Ie, ue, De, et, Ze) => {
                const Ve = (Lt) => new C.X(Y(Lt.type), J(Lt, ue)),
                  tt = { STEP: A.B3, LINEAR: A.NW, CUBICSPLINE: A.Qf },
                  Be = {},
                  ot = {},
                  Qe = {};
                let mt = 1,
                  je;
                for (je = 0; je < he.samplers.length; ++je) {
                  const Lt = he.samplers[je];
                  Be.hasOwnProperty(Lt.input) ||
                    (Be[Lt.input] = Ve(Ie[Lt.input])),
                    ot.hasOwnProperty(Lt.output) ||
                      (ot[Lt.output] = Ve(Ie[Lt.output]));
                  const Ft =
                      Lt.hasOwnProperty("interpolation") &&
                      tt.hasOwnProperty(Lt.interpolation)
                        ? tt[Lt.interpolation]
                        : A.NW,
                    Jt = {
                      paths: [],
                      input: Lt.input,
                      output: Lt.output,
                      interpolation: Ft,
                    };
                  Qe[je] = Jt;
                }
                const lt = [],
                  Et = {
                    translation: "localPosition",
                    rotation: "localRotation",
                    scale: "localScale",
                  },
                  ct = (Lt) => {
                    const Ft = [];
                    for (; Lt; ) Ft.unshift(Lt.name), (Lt = Lt.parent);
                    return Ft;
                  },
                  pt = (Lt, Ft, Jt) => {
                    const zt = ot[Lt.output];
                    if (!zt) return;
                    let ss;
                    if (et && et[Ft.mesh]) {
                      const is = et[Ft.mesh];
                      is.hasOwnProperty("extras") &&
                        is.extras.hasOwnProperty("targetNames") &&
                        (ss = is.extras.targetNames);
                    }
                    const qt = zt.data,
                      fs = qt.length / Be[Lt.input].data.length,
                      ls = qt.length / fs,
                      Es = ls * 4,
                      Ke = new ArrayBuffer(Es * fs);
                    for (let is = 0; is < fs; is++) {
                      var hs;
                      const ys = new Float32Array(Ke, Es * is, ls);
                      for (let bs = 0; bs < ls; bs++) ys[bs] = qt[bs * fs + is];
                      const ps = new C.X(1, ys),
                        Ns =
                          (hs = ss) != null && hs[is] ? `name.${ss[is]}` : is;
                      ot[-mt] = ps;
                      const zs = {
                        paths: [
                          {
                            entityPath: Jt,
                            component: "graph",
                            propertyPath: [`weight.${Ns}`],
                          },
                        ],
                        input: Lt.input,
                        output: -mt,
                        interpolation: Lt.interpolation,
                      };
                      mt++, (Qe[`morphCurve-${je}-${is}`] = zs);
                    }
                  };
                for (je = 0; je < he.channels.length; ++je) {
                  const Lt = he.channels[je],
                    Ft = Lt.target,
                    Jt = Qe[Lt.sampler],
                    zt = De[Ft.node],
                    ss = Ze[Ft.node],
                    qt = ct(zt);
                  Ft.path.startsWith("weights")
                    ? (pt(Jt, ss, qt), (Qe[Lt.sampler].morphCurve = !0))
                    : Jt.paths.push({
                        entityPath: qt,
                        component: "graph",
                        propertyPath: [Et[Ft.path]],
                      });
                }
                const vt = [],
                  Fe = [],
                  Yt = [];
                for (const Lt in Be) vt.push(Be[Lt]), (Be[Lt] = vt.length - 1);
                for (const Lt in ot) Fe.push(ot[Lt]), (ot[Lt] = Fe.length - 1);
                for (const Lt in Qe) {
                  const Ft = Qe[Lt];
                  Ft.morphCurve ||
                    (Yt.push(
                      new B.c(
                        Ft.paths,
                        Be[Ft.input],
                        ot[Ft.output],
                        Ft.interpolation
                      )
                    ),
                    Ft.paths.length > 0 &&
                      Ft.paths[0].propertyPath[0] === "localRotation" &&
                      Ft.interpolation !== A.Qf &&
                      lt.push(Yt[Yt.length - 1].output));
                }
                lt.sort();
                let Ot = null,
                  Rt;
                for (je = 0; je < lt.length; ++je) {
                  const Lt = lt[je];
                  if (je === 0 || Lt !== Ot) {
                    if (((Rt = Fe[Lt]), Rt.components === 4)) {
                      const Ft = Rt.data,
                        Jt = Ft.length - 4;
                      for (let zt = 0; zt < Jt; zt += 4)
                        Ft[zt + 0] * Ft[zt + 4] +
                          Ft[zt + 1] * Ft[zt + 5] +
                          Ft[zt + 2] * Ft[zt + 6] +
                          Ft[zt + 3] * Ft[zt + 7] <
                          0 &&
                          ((Ft[zt + 4] *= -1),
                          (Ft[zt + 5] *= -1),
                          (Ft[zt + 6] *= -1),
                          (Ft[zt + 7] *= -1));
                    }
                    Ot = Lt;
                  }
                }
                let Kt = 0;
                for (je = 0; je < vt.length; je++)
                  (Rt = vt[je]._data),
                    (Kt = Math.max(
                      Kt,
                      Rt.length === 0 ? 0 : Rt[Rt.length - 1]
                    ));
                return new w.k(
                  he.hasOwnProperty("name") ? he.name : "animation_" + fe,
                  Kt,
                  vt,
                  Fe,
                  Yt
                );
              },
              q = new g.y(),
              xe = new h.A(),
              be = (he, fe) => {
                const Ie = new r.A();
                if (
                  (he.hasOwnProperty("name") && he.name.length > 0
                    ? (Ie.name = he.name)
                    : (Ie.name = "node_" + fe),
                  he.hasOwnProperty("matrix") &&
                    (q.data.set(he.matrix),
                    q.getTranslation(xe),
                    Ie.setLocalPosition(xe),
                    q.getEulerAngles(xe),
                    Ie.setLocalEulerAngles(xe),
                    q.getScale(xe),
                    Ie.setLocalScale(xe)),
                  he.hasOwnProperty("rotation"))
                ) {
                  const ue = he.rotation;
                  Ie.setLocalRotation(ue[0], ue[1], ue[2], ue[3]);
                }
                if (he.hasOwnProperty("translation")) {
                  const ue = he.translation;
                  Ie.setLocalPosition(ue[0], ue[1], ue[2]);
                }
                if (he.hasOwnProperty("scale")) {
                  const ue = he.scale;
                  Ie.setLocalScale(ue[0], ue[1], ue[2]);
                }
                return Ie;
              },
              Pe = (he, fe) => {
                const Ie = he.type === "orthographic" ? t.Uc : t.pm,
                  ue = Ie === t.Uc ? he.orthographic : he.perspective,
                  De = {
                    enabled: !1,
                    projection: Ie,
                    nearClip: ue.znear,
                    aspectRatioMode: t.HJ,
                  };
                ue.zfar && (De.farClip = ue.zfar),
                  Ie === t.Uc
                    ? ((De.orthoHeight = 0.5 * ue.ymag),
                      ue.ymag &&
                        ((De.aspectRatioMode = t.Gr),
                        (De.aspectRatio = ue.xmag / ue.ymag)))
                    : ((De.fov = ue.yfov * c.m.RAD_TO_DEG),
                      ue.aspectRatio &&
                        ((De.aspectRatioMode = t.Gr),
                        (De.aspectRatio = ue.aspectRatio)));
                const et = new I.J(he.name);
                return et.addComponent("camera", De), et;
              },
              we = (he, fe) => {
                const Ie = {
                  enabled: !1,
                  type: he.type === "point" ? "omni" : he.type,
                  color: he.hasOwnProperty("color")
                    ? new T.I(he.color)
                    : T.I.WHITE,
                  range: he.hasOwnProperty("range") ? he.range : 9999,
                  falloffMode: t.m8,
                  intensity: he.hasOwnProperty("intensity")
                    ? c.m.clamp(he.intensity, 0, 2)
                    : 1,
                };
                he.hasOwnProperty("spot") &&
                  ((Ie.innerConeAngle = he.spot.hasOwnProperty("innerConeAngle")
                    ? he.spot.innerConeAngle * c.m.RAD_TO_DEG
                    : 0),
                  (Ie.outerConeAngle = he.spot.hasOwnProperty("outerConeAngle")
                    ? he.spot.outerConeAngle * c.m.RAD_TO_DEG
                    : Math.PI / 4)),
                  he.hasOwnProperty("intensity") &&
                    (Ie.luminance =
                      he.intensity *
                      u._.getLightUnitConversion(
                        u.J[Ie.type],
                        Ie.outerConeAngle,
                        Ie.innerConeAngle
                      ));
                const ue = new I.J(fe.name);
                return (
                  ue.rotateLocal(90, 0, 0), ue.addComponent("light", Ie), ue
                );
              },
              Oe = (he, fe, Ie, ue) => {
                if (!fe.hasOwnProperty("skins") || fe.skins.length === 0)
                  return [];
                const De = new Map();
                return fe.skins.map((et) =>
                  z(he, et, fe.accessors, ue, Ie, De)
                );
              },
              $e = (he, fe, Ie, ue, De) => {
                var et, Ze, Ve;
                const tt = {},
                  Be = {},
                  ot = {},
                  Qe = [];
                return {
                  meshes:
                    !De.skipMeshes &&
                    (fe == null || (et = fe.meshes) == null
                      ? void 0
                      : et.length) &&
                    (fe == null || (Ze = fe.accessors) == null
                      ? void 0
                      : Ze.length) &&
                    (fe == null || (Ve = fe.bufferViews) == null
                      ? void 0
                      : Ve.length)
                      ? fe.meshes.map((lt) =>
                          de(he, lt, fe.accessors, Ie, ue, tt, Be, ot, De, Qe)
                        )
                      : [],
                  meshVariants: Be,
                  meshDefaultMaterials: ot,
                  promises: Qe,
                };
              },
              gt = (he, fe, Ie, ue) => {
                var De, et, Ze, Ve;
                if (
                  !he.hasOwnProperty("materials") ||
                  he.materials.length === 0
                )
                  return [];
                const tt =
                    Ie == null || (De = Ie.material) == null
                      ? void 0
                      : De.preprocess,
                  Be =
                    (et =
                      Ie == null || (Ze = Ie.material) == null
                        ? void 0
                        : Ze.process) != null
                      ? et
                      : G,
                  ot =
                    Ie == null || (Ve = Ie.material) == null
                      ? void 0
                      : Ve.postprocess;
                return he.materials.map((Qe) => {
                  tt && tt(Qe);
                  const mt = Be(Qe, fe, ue);
                  return ot && ot(Qe, mt), mt;
                });
              },
              qe = (he) => {
                if (
                  !he.hasOwnProperty("extensions") ||
                  !he.extensions.hasOwnProperty("KHR_materials_variants")
                )
                  return null;
                const fe = he.extensions.KHR_materials_variants.variants,
                  Ie = {};
                for (let ue = 0; ue < fe.length; ue++) Ie[fe[ue].name] = ue;
                return Ie;
              },
              Tt = (he, fe, Ie, ue) => {
                var De, et;
                if (
                  !he.hasOwnProperty("animations") ||
                  he.animations.length === 0
                )
                  return [];
                const Ze =
                    ue == null || (De = ue.animation) == null
                      ? void 0
                      : De.preprocess,
                  Ve =
                    ue == null || (et = ue.animation) == null
                      ? void 0
                      : et.postprocess;
                return he.animations.map((tt, Be) => {
                  Ze && Ze(tt);
                  const ot = Q(
                    tt,
                    Be,
                    he.accessors,
                    Ie,
                    fe,
                    he.meshes,
                    he.nodes
                  );
                  return Ve && Ve(tt, ot), ot;
                });
              },
              Mt = (he, fe) => {
                var Ie, ue, De, et;
                if (!he.hasOwnProperty("nodes") || he.nodes.length === 0)
                  return [];
                const Ze =
                    fe == null || (Ie = fe.node) == null
                      ? void 0
                      : Ie.preprocess,
                  Ve =
                    (ue =
                      fe == null || (De = fe.node) == null
                        ? void 0
                        : De.process) != null
                      ? ue
                      : be,
                  tt =
                    fe == null || (et = fe.node) == null
                      ? void 0
                      : et.postprocess,
                  Be = he.nodes.map((ot, Qe) => {
                    Ze && Ze(ot);
                    const mt = Ve(ot, Qe);
                    return tt && tt(ot, mt), mt;
                  });
                for (let ot = 0; ot < he.nodes.length; ++ot) {
                  const Qe = he.nodes[ot];
                  if (Qe.hasOwnProperty("children")) {
                    const mt = Be[ot],
                      je = {};
                    for (let lt = 0; lt < Qe.children.length; ++lt) {
                      const Et = Be[Qe.children[lt]];
                      Et.parent ||
                        (je.hasOwnProperty(Et.name)
                          ? (Et.name += je[Et.name]++)
                          : (je[Et.name] = 1),
                        mt.addChild(Et));
                    }
                  }
                }
                return Be;
              },
              Dt = (he, fe) => {
                var Ie;
                const ue = [],
                  De = he.scenes.length;
                if (
                  De === 1 &&
                  ((Ie = he.scenes[0].nodes) == null ? void 0 : Ie.length) === 1
                ) {
                  const et = he.scenes[0].nodes[0];
                  ue.push(fe[et]);
                } else
                  for (let et = 0; et < De; et++) {
                    const Ze = he.scenes[et];
                    if (Ze.nodes) {
                      const Ve = new r.A(Ze.name);
                      for (let tt = 0; tt < Ze.nodes.length; tt++) {
                        const Be = fe[Ze.nodes[tt]];
                        Ve.addChild(Be);
                      }
                      ue.push(Ve);
                    }
                  }
                return ue;
              },
              ut = (he, fe, Ie) => {
                let ue = null;
                if (
                  he.hasOwnProperty("nodes") &&
                  he.hasOwnProperty("cameras") &&
                  he.cameras.length > 0
                ) {
                  var De, et, Ze, Ve;
                  const tt =
                      Ie == null || (De = Ie.camera) == null
                        ? void 0
                        : De.preprocess,
                    Be =
                      (et =
                        Ie == null || (Ze = Ie.camera) == null
                          ? void 0
                          : Ze.process) != null
                        ? et
                        : Pe,
                    ot =
                      Ie == null || (Ve = Ie.camera) == null
                        ? void 0
                        : Ve.postprocess;
                  he.nodes.forEach((Qe, mt) => {
                    if (Qe.hasOwnProperty("camera")) {
                      const je = he.cameras[Qe.camera];
                      if (je) {
                        tt && tt(je);
                        const lt = Be(je, fe[mt]);
                        ot && ot(je, lt),
                          lt && (ue || (ue = new Map()), ue.set(Qe, lt));
                      }
                    }
                  });
                }
                return ue;
              },
              At = (he, fe, Ie) => {
                let ue = null;
                if (
                  he.hasOwnProperty("nodes") &&
                  he.hasOwnProperty("extensions") &&
                  he.extensions.hasOwnProperty("KHR_lights_punctual") &&
                  he.extensions.KHR_lights_punctual.hasOwnProperty("lights")
                ) {
                  const tt = he.extensions.KHR_lights_punctual.lights;
                  if (tt.length) {
                    var De, et, Ze, Ve;
                    const Be =
                        Ie == null || (De = Ie.light) == null
                          ? void 0
                          : De.preprocess,
                      ot =
                        (et =
                          Ie == null || (Ze = Ie.light) == null
                            ? void 0
                            : Ze.process) != null
                          ? et
                          : we,
                      Qe =
                        Ie == null || (Ve = Ie.light) == null
                          ? void 0
                          : Ve.postprocess;
                    he.nodes.forEach((mt, je) => {
                      if (
                        mt.hasOwnProperty("extensions") &&
                        mt.extensions.hasOwnProperty("KHR_lights_punctual") &&
                        mt.extensions.KHR_lights_punctual.hasOwnProperty(
                          "light"
                        )
                      ) {
                        const lt = mt.extensions.KHR_lights_punctual.light,
                          Et = tt[lt];
                        if (Et) {
                          Be && Be(Et);
                          const ct = ot(Et, fe[je]);
                          Qe && Qe(Et, ct),
                            ct && (ue || (ue = new Map()), ue.set(mt, ct));
                        }
                      }
                    });
                  }
                }
                return ue;
              },
              xt = (he, fe, Ie) => {
                he.nodes.forEach((ue) => {
                  ue.hasOwnProperty("mesh") &&
                    ue.hasOwnProperty("skin") &&
                    fe[ue.mesh].meshes.forEach((et) => {
                      et.skin = Ie[ue.skin];
                    });
                });
              },
              jt = (he, fe, Ie, ue, De) =>
                pn($n, null, function* () {
                  var et, Ze;
                  const Ve =
                      De == null || (et = De.global) == null
                        ? void 0
                        : et.preprocess,
                    tt =
                      De == null || (Ze = De.global) == null
                        ? void 0
                        : Ze.postprocess;
                  Ve && Ve(fe);
                  const Be = fe.asset && fe.asset.generator === "PlayCanvas",
                    ot = Mt(fe, De),
                    Qe = Dt(fe, ot),
                    mt = At(fe, ot, De),
                    je = ut(fe, ot, De),
                    lt = qe(fe),
                    Et = yield Promise.all(Ie),
                    {
                      meshes: ct,
                      meshVariants: pt,
                      meshDefaultMaterials: vt,
                      promises: Fe,
                    } = $e(he, fe, Et, Be, De),
                    Yt = Tt(fe, ot, Et, De),
                    Ot = yield Promise.all(ue),
                    Rt = Ot.map((zt) => zt.resource),
                    Kt = gt(fe, Rt, De, Be),
                    Lt = Oe(he, fe, ot, Et),
                    Ft = [];
                  for (let zt = 0; zt < ct.length; zt++)
                    (Ft[zt] = new E.H()), (Ft[zt].meshes = ct[zt]);
                  xt(fe, Ft, Lt);
                  const Jt = new X();
                  return (
                    (Jt.gltf = fe),
                    (Jt.nodes = ot),
                    (Jt.scenes = Qe),
                    (Jt.animations = Yt),
                    (Jt.textures = Ot),
                    (Jt.materials = Kt),
                    (Jt.variants = lt),
                    (Jt.meshVariants = pt),
                    (Jt.meshDefaultMaterials = vt),
                    (Jt.renders = Ft),
                    (Jt.skins = Lt),
                    (Jt.lights = mt),
                    (Jt.cameras = je),
                    tt && tt(fe, Jt),
                    yield Promise.all(Fe),
                    Jt
                  );
                }),
              Gt = (he, fe) => {
                const Ie = (et, Ze) => {
                    switch (et) {
                      case 9728:
                        return s.yib;
                      case 9729:
                        return s.I5X;
                      case 9984:
                        return s.Aap;
                      case 9985:
                        return s.feq;
                      case 9986:
                        return s.$_P;
                      case 9987:
                        return s.Snx;
                      default:
                        return Ze;
                    }
                  },
                  ue = (et, Ze) => {
                    switch (et) {
                      case 33071:
                        return s.uFb;
                      case 33648:
                        return s.nVg;
                      case 10497:
                        return s.SuC;
                      default:
                        return Ze;
                    }
                  };
                if (he) {
                  var De;
                  (fe = (De = fe) != null ? De : {}),
                    (he.minFilter = Ie(fe.minFilter, s.Snx)),
                    (he.magFilter = Ie(fe.magFilter, s.I5X)),
                    (he.addressU = ue(fe.wrapS, s.SuC)),
                    (he.addressV = ue(fe.wrapT, s.SuC));
                }
              };
            let yt = 0;
            const Ae = (he, fe, Ie, ue, De) => {
                var et, Ze, Ve;
                if (!he.images || he.images.length === 0) return [];
                const tt =
                    De == null || (et = De.image) == null
                      ? void 0
                      : et.preprocess,
                  Be =
                    De == null || (Ze = De.image) == null
                      ? void 0
                      : Ze.processAsync,
                  ot =
                    De == null || (Ve = De.image) == null
                      ? void 0
                      : Ve.postprocess,
                  Qe = {
                    "image/png": "png",
                    "image/jpeg": "jpg",
                    "image/basis": "basis",
                    "image/ktx": "ktx",
                    "image/ktx2": "ktx2",
                    "image/vnd-ms.dds": "dds",
                  },
                  mt = (je, lt, Et, ct, pt) =>
                    new Promise((vt, Fe) => {
                      const Yt = (Ot) => {
                        const Rt = (je.name || "gltf-texture") + "-" + yt++,
                          Kt = { url: lt || Rt };
                        if ((Ot && (Kt.contents = Ot.slice(0).buffer), ct)) {
                          const Ft = Qe[ct];
                          Ft && (Kt.filename = Kt.url + "." + Ft);
                        }
                        const Lt = new k.x(Rt, "texture", Kt, null, pt);
                        Lt.on("load", (Ft) => vt(Ft)),
                          Lt.on("error", (Ft) => Fe(Ft)),
                          ue.add(Lt),
                          ue.load(Lt);
                      };
                      Et ? Et.then((Ot) => Yt(Ot)) : Yt(null);
                    });
                return he.images.map((je, lt) => {
                  tt && tt(je);
                  let Et;
                  return (
                    Be
                      ? (Et = new Promise((ct, pt) => {
                          Be(je, (vt, Fe) => {
                            vt ? pt(vt) : ct(Fe);
                          });
                        }))
                      : (Et = new Promise((ct) => {
                          ct(null);
                        })),
                    (Et = Et.then(
                      (ct) =>
                        ct ||
                        (je.hasOwnProperty("uri")
                          ? $(je.uri)
                            ? mt(je, je.uri, null, ne(je.uri), null)
                            : mt(
                                je,
                                K.P1.test(je.uri)
                                  ? je.uri
                                  : x.E.join(Ie, je.uri),
                                null,
                                null,
                                { crossOrigin: "anonymous" }
                              )
                          : je.hasOwnProperty("bufferView") &&
                            je.hasOwnProperty("mimeType")
                          ? mt(je, null, fe[je.bufferView], je.mimeType, null)
                          : Promise.reject(
                              new Error(
                                `Invalid image found in gltf (neither uri or bufferView found). index=${lt}`
                              )
                            ))
                    )),
                    ot && (Et = Et.then((ct) => (ot(je, ct), ct))),
                    Et
                  );
                });
              },
              Xe = (he, fe, Ie) => {
                var ue, De, et, Ze, Ve;
                if (
                  !(he != null && (ue = he.images) != null && ue.length) ||
                  !(he != null && (De = he.textures) != null && De.length)
                )
                  return [];
                const tt =
                    Ie == null || (et = Ie.texture) == null
                      ? void 0
                      : et.preprocess,
                  Be =
                    Ie == null || (Ze = Ie.texture) == null
                      ? void 0
                      : Ze.processAsync,
                  ot =
                    Ie == null || (Ve = Ie.texture) == null
                      ? void 0
                      : Ve.postprocess,
                  Qe = new Set();
                return he.textures.map((mt) => {
                  tt && tt(mt);
                  let je;
                  return (
                    Be
                      ? (je = new Promise((lt, Et) => {
                          Be(mt, he.images, (ct, pt) => {
                            ct ? Et(ct) : lt(pt);
                          });
                        }))
                      : (je = new Promise((lt) => {
                          lt(null);
                        })),
                    (je = je.then((lt) => {
                      var Et, ct, pt, vt, Fe;
                      lt =
                        (Et =
                          (ct =
                            (pt = lt) != null
                              ? pt
                              : mt == null ||
                                (vt = mt.extensions) == null ||
                                (vt = vt.KHR_texture_basisu) == null
                              ? void 0
                              : vt.source) != null
                            ? ct
                            : mt == null ||
                              (Fe = mt.extensions) == null ||
                              (Fe = Fe.EXT_texture_webp) == null
                            ? void 0
                            : Fe.source) != null
                          ? Et
                          : mt.source;
                      const Yt = Qe.has(lt);
                      return (
                        Qe.add(lt),
                        fe[lt].then((Ot) => {
                          var Rt;
                          const Kt = Yt ? b(Ot) : Ot;
                          return (
                            Gt(
                              Kt.resource,
                              ((Rt = he.samplers) != null ? Rt : [])[mt.sampler]
                            ),
                            Kt
                          );
                        })
                      );
                    })),
                    ot && (je = je.then((lt) => (ot(mt, lt), lt))),
                    je
                  );
                });
              },
              Ye = (he, fe, Ie, ue) => {
                var De, et, Ze;
                if (!he.buffers || he.buffers.length === 0) return [];
                const Ve =
                    ue == null || (De = ue.buffer) == null
                      ? void 0
                      : De.preprocess,
                  tt =
                    ue == null || (et = ue.buffer) == null
                      ? void 0
                      : et.processAsync,
                  Be =
                    ue == null || (Ze = ue.buffer) == null
                      ? void 0
                      : Ze.postprocess;
                return he.buffers.map((ot, Qe) => {
                  Ve && Ve(ot);
                  let mt;
                  return (
                    tt
                      ? (mt = new Promise((je, lt) => {
                          tt(ot, (Et, ct) => {
                            Et ? lt(Et) : je(ct);
                          });
                        }))
                      : (mt = new Promise((je) => {
                          je(null);
                        })),
                    (mt = mt.then((je) => {
                      if (je) return je;
                      if (ot.hasOwnProperty("uri")) {
                        if ($(ot.uri)) {
                          const lt = atob(ot.uri.split(",")[1]),
                            Et = new Uint8Array(lt.length);
                          for (let ct = 0; ct < lt.length; ct++)
                            Et[ct] = lt.charCodeAt(ct);
                          return Et;
                        }
                        return new Promise((lt, Et) => {
                          e.d.get(
                            K.P1.test(ot.uri) ? ot.uri : x.E.join(Ie, ot.uri),
                            {
                              cache: !0,
                              responseType: "arraybuffer",
                              retry: !1,
                            },
                            (ct, pt) => {
                              ct ? Et(ct) : lt(new Uint8Array(pt));
                            }
                          );
                        });
                      }
                      return fe;
                    })),
                    Be && (mt = mt.then((je) => (Be(he.buffers[Qe], je), je))),
                    mt
                  );
                });
              },
              it = (he, fe) => {
                const ue = JSON.parse(
                  ((De) => {
                    if (typeof TextDecoder != "undefined")
                      return new TextDecoder().decode(De);
                    let et = "";
                    for (let Ze = 0; Ze < De.length; Ze++)
                      et += String.fromCharCode(De[Ze]);
                    return decodeURIComponent(escape(et));
                  })(he)
                );
                if (
                  ue.asset &&
                  ue.asset.version &&
                  parseFloat(ue.asset.version) < 2
                ) {
                  fe(
                    `Invalid gltf version. Expected version 2.0 or above but found version '${ue.asset.version}'.`
                  );
                  return;
                }
                fe(null, ue);
              },
              st = (he, fe) => {
                const Ie =
                    he instanceof ArrayBuffer
                      ? new DataView(he)
                      : new DataView(he.buffer, he.byteOffset, he.byteLength),
                  ue = Ie.getUint32(0, !0),
                  De = Ie.getUint32(4, !0),
                  et = Ie.getUint32(8, !0);
                if (ue !== 1179937895) {
                  fe(
                    "Invalid magic number found in glb header. Expected 0x46546C67, found 0x" +
                      ue.toString(16)
                  );
                  return;
                }
                if (De !== 2) {
                  fe(
                    "Invalid version number found in glb header. Expected 2, found " +
                      De
                  );
                  return;
                }
                if (et <= 0 || et > Ie.byteLength) {
                  fe("Invalid length found in glb header. Found " + et);
                  return;
                }
                const Ze = [];
                let Ve = 12;
                for (; Ve < et; ) {
                  const tt = Ie.getUint32(Ve, !0);
                  Ve + tt + 8 > Ie.byteLength &&
                    fe(`Invalid chunk length found in glb. Found ${tt}`);
                  const Be = Ie.getUint32(Ve + 4, !0),
                    ot = new Uint8Array(Ie.buffer, Ie.byteOffset + Ve + 8, tt);
                  Ze.push({ length: tt, type: Be, data: ot }), (Ve += tt + 8);
                }
                if (Ze.length !== 1 && Ze.length !== 2) {
                  fe("Invalid number of chunks found in glb file.");
                  return;
                }
                if (Ze[0].type !== 1313821514) {
                  fe(
                    `Invalid chunk type found in glb file. Expected 0x4E4F534A, found 0x${Ze[0].type.toString(
                      16
                    )}`
                  );
                  return;
                }
                if (Ze.length > 1 && Ze[1].type !== 5130562) {
                  fe(
                    `Invalid chunk type found in glb file. Expected 0x004E4942, found 0x${Ze[1].type.toString(
                      16
                    )}`
                  );
                  return;
                }
                fe(null, {
                  gltfChunk: Ze[0].data,
                  binaryChunk: Ze.length === 2 ? Ze[1].data : null,
                });
              },
              He = (he, fe, Ie) => {
                const ue = () => {
                  const De = new Uint8Array(fe);
                  return (
                    De[0] === 103 &&
                    De[1] === 108 &&
                    De[2] === 84 &&
                    De[3] === 70
                  );
                };
                (he && he.toLowerCase().endsWith(".glb")) || ue()
                  ? st(fe, Ie)
                  : Ie(null, { gltfChunk: fe, binaryChunk: null });
              },
              at = (he, fe, Ie) => {
                var ue, De, et, Ze;
                const Ve = [],
                  tt =
                    Ie == null || (ue = Ie.bufferView) == null
                      ? void 0
                      : ue.preprocess,
                  Be =
                    Ie == null || (De = Ie.bufferView) == null
                      ? void 0
                      : De.processAsync,
                  ot =
                    Ie == null || (et = Ie.bufferView) == null
                      ? void 0
                      : et.postprocess;
                if (!((Ze = he.bufferViews) != null && Ze.length)) return Ve;
                for (let Qe = 0; Qe < he.bufferViews.length; ++Qe) {
                  const mt = he.bufferViews[Qe];
                  tt && tt(mt);
                  let je;
                  Be
                    ? (je = new Promise((lt, Et) => {
                        Be(mt, fe, (ct, pt) => {
                          ct ? Et(ct) : lt(pt);
                        });
                      }))
                    : (je = new Promise((lt) => {
                        lt(null);
                      })),
                    (je = je.then(
                      (lt) =>
                        lt ||
                        fe[mt.buffer].then(
                          (Et) =>
                            new Uint8Array(
                              Et.buffer,
                              Et.byteOffset + (mt.byteOffset || 0),
                              mt.byteLength
                            )
                        )
                    )),
                    mt.hasOwnProperty("byteStride") &&
                      (je = je.then(
                        (lt) => ((lt.byteStride = mt.byteStride), lt)
                      )),
                    ot && (je = je.then((lt) => (ot(mt, lt), lt))),
                    Ve.push(je);
                }
                return Ve;
              };
            class Pt {
              static parse(fe, Ie, ue, De, et, Ze, Ve) {
                He(fe, ue, (tt, Be) => {
                  if (tt) {
                    Ve(tt);
                    return;
                  }
                  it(Be.gltfChunk, (ot, Qe) => {
                    if (ot) {
                      Ve(ot);
                      return;
                    }
                    const mt = Ye(Qe, Be.binaryChunk, Ie, Ze),
                      je = at(Qe, mt, Ze),
                      lt = Ae(Qe, je, Ie, et, Ze),
                      Et = Xe(Qe, lt, Ze);
                    jt(De, Qe, je, Et, Ze)
                      .then((ct) => Ve(null, ct))
                      .catch((ct) => Ve(ct));
                  });
                });
              }
              static createDefaultMaterial() {
                return G({ name: "defaultGlbMaterial" }, []);
              }
            }
          },
          2710: (Se, W, a) => {
            "use strict";
            a.d(W, { r: () => i });
            var x = a(9078),
              T = a(1367),
              g = a(2978),
              c = a(6556),
              d = a(8869),
              h = a(3148),
              f = a(3114),
              s = a(8944),
              l = a(7921),
              n = a(6672);
            class o {
              constructor() {
                (this.removeInvalid = !0),
                  (this.valid = !0),
                  (this.enumValidators = {
                    occludeSpecular: this._createEnumValidator([
                      f.wk,
                      f._f,
                      f.X8,
                    ]),
                    cull: this._createEnumValidator([
                      l.OL2,
                      l.Ak1,
                      l.TWf,
                      l.QKK,
                    ]),
                    blendType: this._createEnumValidator([
                      f.C1,
                      f.$U,
                      f.lA,
                      f.He,
                      f.yp,
                      f.ch,
                      f.Yk,
                      f.oF,
                      f.Sh,
                      f.yl,
                      f.rR,
                    ]),
                    depthFunc: this._createEnumValidator([
                      l._3e,
                      l.n9,
                      l._v4,
                      l.u9l,
                      l.Lp7,
                      l.qVn,
                      l.ZIZ,
                      l.g8z,
                    ]),
                    shadingModel: this._createEnumValidator([f.yd, f.qT]),
                  });
              }
              setInvalid(t, r) {
                (this.valid = !1), this.removeInvalid && delete r[t];
              }
              validate(t) {
                const r = n.Ru,
                  u = n.v$,
                  y = t.mappingFormat === "path";
                for (const p in t) {
                  const _ = r[p];
                  if (!_) {
                    u[p] ? delete t[p] : (this.valid = !1);
                    continue;
                  }
                  if (_.startsWith("enum")) {
                    const m = _.split(":")[1];
                    this.enumValidators[m] &&
                      (this.enumValidators[m](t[p]) || this.setInvalid(p, t));
                  } else if (_ === "number")
                    typeof t[p] != "number" && this.setInvalid(p, t);
                  else if (_ === "boolean")
                    typeof t[p] != "boolean" && this.setInvalid(p, t);
                  else if (_ === "string")
                    typeof t[p] != "string" && this.setInvalid(p, t);
                  else if (_ === "vec2")
                    (t[p] instanceof Array && t[p].length === 2) ||
                      this.setInvalid(p, t);
                  else if (_ === "rgb")
                    (t[p] instanceof Array && t[p].length === 3) ||
                      this.setInvalid(p, t);
                  else if (_ === "texture")
                    y
                      ? typeof t[p] == "string" ||
                        t[p] === null ||
                        t[p] instanceof d.x ||
                        this.setInvalid(p, t)
                      : typeof t[p] == "number" ||
                        t[p] === null ||
                        t[p] instanceof d.x ||
                        this.setInvalid(p, t);
                  else if (_ === "boundingbox")
                    (t[p].center &&
                      t[p].center instanceof Array &&
                      t[p].center.length === 3) ||
                      this.setInvalid(p, t),
                      (t[p].halfExtents &&
                        t[p].halfExtents instanceof Array &&
                        t[p].halfExtents.length === 3) ||
                        this.setInvalid(p, t);
                  else if (_ === "cubemap")
                    typeof t[p] == "number" ||
                      t[p] === null ||
                      t[p] === void 0 ||
                      (t[p] instanceof d.x && t[p].cubemap) ||
                      this.setInvalid(p, t);
                  else if (_ === "chunks") {
                    const m = Object.keys(t[p]);
                    for (let E = 0; E < m.length; E++)
                      typeof t[p][m[E]] != "string" &&
                        this.setInvalid(m[E], t[p]);
                  } else console.error("Unknown material type: " + _);
                }
                return (t.validated = !0), this.valid;
              }
              _createEnumValidator(t) {
                return function (r) {
                  return t.indexOf(r) >= 0;
                };
              }
            }
            class i {
              constructor() {
                this._validator = null;
              }
              parse(t) {
                const r = this.migrate(t),
                  u = this._validate(r),
                  y = new s.K();
                return this.initialize(y, u), y;
              }
              initialize(t, r) {
                r.validated || (r = this._validate(r)),
                  r.chunks && (t.chunks = (0, x.g)({}, r.chunks));
                for (const u in r) {
                  const y = n.Ru[u],
                    p = r[u];
                  if (y === "vec2") t[u] = new g.S(p[0], p[1]);
                  else if (y === "rgb") t[u] = new T.I(p[0], p[1], p[2]);
                  else if (y === "texture")
                    p instanceof d.x
                      ? (t[u] = p)
                      : (t[u] instanceof d.x &&
                          typeof p == "number" &&
                          p > 0) ||
                        (t[u] = null);
                  else if (y === "cubemap")
                    p instanceof d.x
                      ? (t[u] = p)
                      : (t[u] instanceof d.x &&
                          typeof p == "number" &&
                          p > 0) ||
                        (t[u] = null),
                      u === "cubeMap" && !p && (t.prefilteredCubemaps = null);
                  else if (y === "boundingbox") {
                    const _ = new c.A(p.center[0], p.center[1], p.center[2]),
                      m = new c.A(
                        p.halfExtents[0],
                        p.halfExtents[1],
                        p.halfExtents[2]
                      );
                    t[u] = new h.k(_, m);
                  } else t[u] = r[u];
                }
                t.update();
              }
              migrate(t) {
                t.shadingModel === void 0 &&
                  (t.shader === "blinn"
                    ? (t.shadingModel = f.qT)
                    : (t.shadingModel = f.yd)),
                  t.shader && delete t.shader,
                  t.mapping_format &&
                    ((t.mappingFormat = t.mapping_format),
                    delete t.mapping_format);
                let r;
                const u = [
                  ["bumpMapFactor", "bumpiness"],
                  ["aoUvSet", "aoMapUv"],
                  ["aoMapVertexColor", "aoVertexColor"],
                  ["diffuseMapVertexColor", "diffuseVertexColor"],
                  ["emissiveMapVertexColor", "emissiveVertexColor"],
                  ["specularMapVertexColor", "specularVertexColor"],
                  ["metalnessMapVertexColor", "metalnessVertexColor"],
                  ["opacityMapVertexColor", "opacityVertexColor"],
                  ["glossMapVertexColor", "glossVertexColor"],
                  ["lightMapVertexColor", "lightVertexColor"],
                  ["diffuseMapTint", "diffuseTint"],
                  ["specularMapTint", "specularTint"],
                  ["emissiveMapTint", "emissiveTint"],
                  ["metalnessMapTint", "metalnessTint"],
                  ["clearCoatGlossiness", "clearCoatGloss"],
                ];
                for (r = 0; r < u.length; r++) {
                  const p = u[r][0],
                    _ = u[r][1];
                  t[p] !== void 0 &&
                    (t[_] === void 0 && (t[_] = t[p]), delete t[p]);
                }
                const y = ["fresnelFactor", "shadowSampleType"];
                for (r = 0; r < y.length; r++) {
                  const p = y[r];
                  t.hasOwnProperty(p) && delete t[p];
                }
                return t;
              }
              _validate(t) {
                return (
                  t.validated ||
                    (this._validator || (this._validator = new o()),
                    this._validator.validate(t)),
                  t
                );
              }
            }
          },
          544: (Se, W, a) => {
            "use strict";
            a.d(W, { n: () => c });
            var x = a(258);
            const T = {
              setCompressedPRS: function (d, h, f) {
                const s = f.singleVecs;
                let l, n;
                const o = h.___1;
                o || ((l = f.tripleVecs), (n = h.___2));
                let i = o ? o[0] : l[n];
                d.setLocalPosition(s[i], s[i + 1], s[i + 2]),
                  (i = o ? o[1] : l[n + 1]),
                  d.setLocalEulerAngles(s[i], s[i + 1], s[i + 2]),
                  (i = o ? o[2] : l[n + 2]),
                  d.setLocalScale(s[i], s[i + 1], s[i + 2]);
              },
              oneCharToKey: function (d, h) {
                const f = d.charCodeAt(0) - h.fieldFirstCode;
                return h.fieldArray[f];
              },
              multCharToKey: function (d, h) {
                let f = 0;
                for (let s = 0; s < d.length; s++)
                  f = f * h.fieldCodeBase + d.charCodeAt(s) - h.fieldFirstCode;
                return h.fieldArray[f];
              },
            };
            class g {
              constructor(h, f) {
                (this._node = h), (this._data = f);
              }
              run() {
                const h = Object.prototype.toString.call(this._node);
                return (
                  h === "[object Object]"
                    ? this._handleMap()
                    : h === "[object Array]"
                    ? this._handleArray()
                    : (this._result = this._node),
                  this._result
                );
              }
              _handleMap() {
                (this._result = {}),
                  Object.keys(this._node).forEach(this._handleKey, this);
              }
              _handleKey(h) {
                let f = h;
                const s = h.length;
                s === 1
                  ? (f = T.oneCharToKey(h, this._data))
                  : s === 2 && (f = T.multCharToKey(h, this._data)),
                  (this._result[f] = new g(this._node[h], this._data).run());
              }
              _handleArray() {
                (this._result = []),
                  this._node.forEach(this._handleArElt, this);
              }
              _handleArElt(h) {
                const f = new g(h, this._data).run();
                this._result.push(f);
              }
            }
            class c {
              constructor(h, f) {
                (this._app = h), (this._isTemplate = f);
              }
              parse(h) {
                const f = {};
                let s = null;
                const l = h.compressedFormat;
                l &&
                  !h.entDecompressed &&
                  ((h.entDecompressed = !0),
                  (h.entities = new g(h.entities, l).run()));
                for (const n in h.entities) {
                  const o = h.entities[n],
                    i = this._createEntity(o, l);
                  (f[n] = i), o.parent === null && (s = i);
                }
                for (const n in h.entities) {
                  const o = f[n],
                    i = h.entities[n].children,
                    e = i.length;
                  for (let t = 0; t < e; t++) {
                    const r = f[i[t]];
                    r && o.addChild(r);
                  }
                }
                return this._openComponentData(s, h.entities), s;
              }
              _createEntity(h, f) {
                var s;
                const l = new x.J(h.name, this._app);
                if (
                  (l.setGuid(h.resource_id),
                  this._setPosRotScale(l, h, f),
                  (l._enabled = (s = h.enabled) != null ? s : !0),
                  this._isTemplate
                    ? (l._template = !0)
                    : (l._enabledInHierarchy = l._enabled),
                  (l.template = h.template),
                  h.tags)
                )
                  for (let n = 0; n < h.tags.length; n++) l.tags.add(h.tags[n]);
                return (
                  h.labels &&
                    h.labels.forEach(function (n) {
                      l.addLabel(n);
                    }),
                  l
                );
              }
              _setPosRotScale(h, f, s) {
                if (s) T.setCompressedPRS(h, f, s);
                else {
                  const l = f.position,
                    n = f.rotation,
                    o = f.scale;
                  h.setLocalPosition(l[0], l[1], l[2]),
                    h.setLocalEulerAngles(n[0], n[1], n[2]),
                    h.setLocalScale(o[0], o[1], o[2]);
                }
              }
              _openComponentData(h, f) {
                const s = this._app.systems.list;
                let l = s.length;
                const n = f[h.getGuid()];
                for (let i = 0; i < l; i++) {
                  const e = s[i],
                    t = n.components[e.id];
                  t && e.addComponent(h, t);
                }
                l = n.children.length;
                const o = h._children;
                for (let i = 0; i < l; i++)
                  o[i] && (o[i] = this._openComponentData(o[i], f));
                return h;
              }
            }
          },
          2329: (Se, W, a) => {
            "use strict";
            a.d(W, { W: () => x });
            class x {
              constructor(g, c) {
                (this.name = void 0),
                  (this.url = void 0),
                  (this.data = null),
                  (this._loading = !1),
                  (this._onLoadedCallbacks = []),
                  (this.name = g),
                  (this.url = c);
              }
              get loaded() {
                return !!this.data;
              }
              get loading() {
                return this._loading;
              }
            }
          },
          590: (Se, W, a) => {
            "use strict";
            a.d(W, { H: () => c });
            var x = a(9296),
              T = a(8462),
              g = a(2329);
            class c {
              constructor(h) {
                (this._app = void 0),
                  (this._list = []),
                  (this._index = {}),
                  (this._urlIndex = {}),
                  (this._app = h);
              }
              destroy() {
                this._app = null;
              }
              list() {
                return this._list;
              }
              add(h, f) {
                if (this._index.hasOwnProperty(h)) return !1;
                const s = new g.W(h, f),
                  l = this._list.push(s);
                return (
                  (this._index[s.name] = l - 1),
                  (this._urlIndex[s.url] = l - 1),
                  !0
                );
              }
              find(h) {
                return this._index.hasOwnProperty(h)
                  ? this._list[this._index[h]]
                  : null;
              }
              findByUrl(h) {
                return this._urlIndex.hasOwnProperty(h)
                  ? this._list[this._urlIndex[h]]
                  : null;
              }
              remove(h) {
                if (this._index.hasOwnProperty(h)) {
                  const f = this._index[h];
                  let s = this._list[f];
                  delete this._urlIndex[s.url],
                    delete this._index[h],
                    this._list.splice(f, 1);
                  for (let l = 0; l < this._list.length; l++)
                    (s = this._list[l]),
                      (this._index[s.name] = l),
                      (this._urlIndex[s.url] = l);
                }
              }
              _loadSceneData(h, f, s) {
                const l = this._app;
                let n = h;
                if (
                  (typeof h == "string" &&
                    (h =
                      this.findByUrl(n) ||
                      this.find(n) ||
                      new g.W("Untitled", n)),
                  (n = h.url),
                  !n)
                ) {
                  s("Cannot find scene to load");
                  return;
                }
                if (h.loaded) {
                  s(null, h);
                  return;
                }
                l.assets &&
                  l.assets.prefix &&
                  !T.P1.test(n) &&
                  (n = x.E.join(l.assets.prefix, n)),
                  h._onLoadedCallbacks.push(s),
                  h._loading ||
                    l.loader.getHandler("hierarchy").load(n, (i, e) => {
                      (h.data = e), (h._loading = !1);
                      for (let t = 0; t < h._onLoadedCallbacks.length; t++)
                        h._onLoadedCallbacks[t](i, h);
                      f || (h.data = null), (h._onLoadedCallbacks.length = 0);
                    }),
                  (h._loading = !0);
              }
              loadSceneData(h, f) {
                this._loadSceneData(h, !0, f);
              }
              unloadSceneData(h) {
                typeof h == "string" && (h = this.findByUrl(h)),
                  h && (h.data = null);
              }
              _loadSceneHierarchy(h, f, s) {
                this._loadSceneData(h, !1, (l, n) => {
                  if (l) {
                    s && s(l);
                    return;
                  }
                  f && f(n);
                  const o = this._app,
                    i = () => {
                      const e = o.loader.getHandler("hierarchy");
                      o.systems.script.preloading = !0;
                      const t = e.open(n.url, n.data);
                      (o.systems.script.preloading = !1),
                        o.loader.clearCache(n.url, "hierarchy"),
                        o.root.addChild(t),
                        o.systems.fire("initialize", t),
                        o.systems.fire("postInitialize", t),
                        o.systems.fire("postPostInitialize", t),
                        s && s(null, t);
                    };
                  o._preloadScripts(n.data, i);
                });
              }
              loadSceneHierarchy(h, f) {
                this._loadSceneHierarchy(h, null, f);
              }
              loadSceneSettings(h, f) {
                this._loadSceneData(h, !1, (s, l) => {
                  s
                    ? f && f(s)
                    : (this._app.applySceneSettings(l.data.settings),
                      f && f(null));
                });
              }
              changeScene(h, f) {
                const s = this._app,
                  l = (n) => {
                    const { children: o } = s.root;
                    for (; o.length; ) o[0].destroy();
                    s.applySceneSettings(n.data.settings);
                  };
                this._loadSceneHierarchy(h, l, f);
              }
              loadScene(h, f) {
                const s = this._app,
                  l = s.loader.getHandler("scene");
                s.assets &&
                  s.assets.prefix &&
                  !T.P1.test(h) &&
                  (h = x.E.join(s.assets.prefix, h)),
                  l.load(h, (n, o) => {
                    if (n) f && f(n);
                    else {
                      const i = () => {
                        s.systems.script.preloading = !0;
                        const e = l.open(h, o),
                          t = this.findByUrl(h);
                        t && !t.loaded && (t.data = o),
                          (s.systems.script.preloading = !1),
                          s.loader.clearCache(h, "scene"),
                          s.loader.patch(
                            { resource: e, type: "scene" },
                            s.assets
                          ),
                          s.root.addChild(e.root),
                          s.systems.rigidbody &&
                            typeof Ammo != "undefined" &&
                            s.systems.rigidbody.gravity.set(
                              e._gravity.x,
                              e._gravity.y,
                              e._gravity.z
                            ),
                          f && f(null, e);
                      };
                      s._preloadScripts(o, i);
                    }
                  });
              }
            }
          },
          5751: (Se, W, a) => {
            "use strict";
            a.d(W, { _: () => h });
            var x = a(5843),
              T = a(4355),
              g = a(8615);
            let c = !1,
              d = !1;
            const h = {
              app: null,
              create: function (f, s) {
                if (!c) return;
                const l = s(h.app);
                (l._pcScriptName = f),
                  g.t.push(l, c),
                  this.fire("created", f, s);
              },
              attribute: function (f, s, l, n) {},
              createLoadingScreen: function (f) {
                if (d) return;
                d = !0;
                const s = (0, T.i)();
                f(s);
              },
            };
            Object.defineProperty(h, "legacy", {
              get: function () {
                return c;
              },
              set: function (f) {
                c = f;
              },
            }),
              x.U.attach(h);
          },
          1118: (Se, W, a) => {
            "use strict";
            a.d(W, {
              Bg: () => x,
              Ms: () => c,
              k2: () => g,
              qM: () => d,
              wJ: () => T,
            });
            const x = "initialize",
              T = "postInitialize",
              g = "update",
              c = "postUpdate",
              d = "swap";
          },
          36: (Se, W, a) => {
            "use strict";
            a.d(W, { s: () => i });
            var x = a(1367),
              T = a(429),
              g = a(1239),
              c = a(2978),
              d = a(6556),
              h = a(6630),
              f = a(7915),
              s = a(6204);
            const l = ["x", "y", "z", "w"],
              n = [void 0, void 0, c.S, d.A, h.T];
            function o(e, t, r, u) {
              switch (t.type) {
                case "boolean":
                  return !!r;
                case "number":
                  if (typeof r == "number") return r;
                  if (typeof r == "string") {
                    const y = parseInt(r, 10);
                    return isNaN(y) ? null : y;
                  } else if (typeof r == "boolean") return 0 + r;
                  return null;
                case "json": {
                  const y = {};
                  if (Array.isArray(t.schema)) {
                    (!r || typeof r != "object") && (r = {});
                    for (let p = 0; p < t.schema.length; p++) {
                      const _ = t.schema[p];
                      if (_.name)
                        if (_.array) {
                          y[_.name] = [];
                          const m = Array.isArray(r[_.name]) ? r[_.name] : [];
                          for (let E = 0; E < m.length; E++)
                            y[_.name].push(o(e, _, m[E]));
                        } else {
                          const m = r.hasOwnProperty(_.name)
                            ? r[_.name]
                            : _.default;
                          y[_.name] = o(e, _, m);
                        }
                    }
                  }
                  return y;
                }
                case "asset":
                  return r instanceof s.x
                    ? r
                    : typeof r == "number"
                    ? e.assets.get(r) || null
                    : (typeof r == "string" && e.assets.get(parseInt(r, 10))) ||
                      null;
                case "entity":
                  return r instanceof f.A
                    ? r
                    : typeof r == "string"
                    ? e.getEntityFromIndex(r)
                    : null;
                case "rgb":
                case "rgba":
                  if (r instanceof x.I)
                    return u instanceof x.I ? (u.copy(r), u) : r.clone();
                  if (r instanceof Array && r.length >= 3 && r.length <= 4) {
                    for (let y = 0; y < r.length; y++)
                      if (typeof r[y] != "number") return null;
                    return (
                      u || (u = new x.I()),
                      (u.r = r[0]),
                      (u.g = r[1]),
                      (u.b = r[2]),
                      (u.a = r.length === 3 ? 1 : r[3]),
                      u
                    );
                  } else if (
                    typeof r == "string" &&
                    /#([0-9abcdef]{2}){3,4}/i.test(r)
                  )
                    return u || (u = new x.I()), u.fromString(r), u;
                  return null;
                case "vec2":
                case "vec3":
                case "vec4": {
                  const y = parseInt(t.type.slice(3), 10),
                    p = n[y];
                  if (r instanceof p)
                    return u instanceof p ? (u.copy(r), u) : r.clone();
                  if (r instanceof Array && r.length === y) {
                    for (let _ = 0; _ < r.length; _++)
                      if (typeof r[_] != "number") return null;
                    u || (u = new p());
                    for (let _ = 0; _ < y; _++) u[l[_]] = r[_];
                    return u;
                  }
                  return null;
                }
                case "curve":
                  if (r) {
                    let y;
                    if (r instanceof T.H || r instanceof g.e) y = r.clone();
                    else {
                      const p = r.keys[0] instanceof Array ? g.e : T.H;
                      (y = new p(r.keys)), (y.type = r.type);
                    }
                    return y;
                  }
                  break;
              }
              return r;
            }
            class i {
              constructor(t) {
                (this.scriptType = t), (this.index = {});
              }
              add(t, r) {
                this.index[t] ||
                  i.reservedNames.has(t) ||
                  ((this.index[t] = r),
                  Object.defineProperty(this.scriptType.prototype, t, {
                    get: function () {
                      return this.__attributes[t];
                    },
                    set: function (u) {
                      const y = "attr",
                        p = "attr:" + t,
                        _ = this.__attributes[t];
                      let m = _;
                      if (
                        (_ &&
                          r.type !== "json" &&
                          r.type !== "entity" &&
                          _.clone &&
                          (this.hasEvent(y) || this.hasEvent(p)) &&
                          (m = _.clone()),
                        r.array)
                      ) {
                        if (((this.__attributes[t] = []), u))
                          for (let E = 0, v = u.length; E < v; E++)
                            this.__attributes[t].push(
                              o(this.app, r, u[E], _ ? _[E] : null)
                            );
                      } else this.__attributes[t] = o(this.app, r, u, _);
                      this.fire(y, t, this.__attributes[t], m),
                        this.fire(p, this.__attributes[t], m);
                    },
                  }));
              }
              remove(t) {
                return this.index[t]
                  ? (delete this.index[t],
                    delete this.scriptType.prototype[t],
                    !0)
                  : !1;
              }
              has(t) {
                return !!this.index[t];
              }
              get(t) {
                return this.index[t] || null;
              }
            }
            i.reservedNames = new Set([
              "app",
              "entity",
              "enabled",
              "_enabled",
              "_enabledOld",
              "_destroyed",
              "__attributes",
              "__attributesRaw",
              "__scriptType",
              "__executionOrder",
              "_callbacks",
              "_callbackActive",
              "has",
              "get",
              "on",
              "off",
              "fire",
              "once",
              "hasEvent",
            ]);
          },
          4759: (Se, W, a) => {
            "use strict";
            a.d(W, { l: () => T });
            var x = a(5338);
            class T extends x.b {
              constructor(c) {
                super(),
                  (this.app = c),
                  (this._scripts = {}),
                  (this._list = []);
              }
              destroy() {
                (this.app = null), this.off();
              }
              add(c) {
                const d = c.__name;
                return this._scripts.hasOwnProperty(d)
                  ? (setTimeout(() => {
                      if (c.prototype.swap) {
                        const h = this._scripts[d],
                          f = this._list.indexOf(h);
                        (this._list[f] = c),
                          (this._scripts[d] = c),
                          this.fire("swap", d, c),
                          this.fire("swap:" + d, c);
                      } else
                        console.warn(
                          `script registry already has '${d}' script, define 'swap' method for new script type to enable code hot swapping`
                        );
                    }),
                    !1)
                  : ((this._scripts[d] = c),
                    this._list.push(c),
                    this.fire("add", d, c),
                    this.fire("add:" + d, c),
                    setTimeout(() => {
                      if (
                        !this._scripts.hasOwnProperty(d) ||
                        !this.app ||
                        !this.app.systems ||
                        !this.app.systems.script
                      )
                        return;
                      const h = this.app.systems.script._components;
                      let f;
                      const s = [],
                        l = [];
                      for (
                        h.loopIndex = 0;
                        h.loopIndex < h.length;
                        h.loopIndex++
                      ) {
                        const n = h.items[h.loopIndex];
                        if (n._scriptsIndex[d] && n._scriptsIndex[d].awaiting) {
                          n._scriptsData &&
                            n._scriptsData[d] &&
                            (f = n._scriptsData[d].attributes);
                          const o = n.create(d, {
                            preloading: !0,
                            ind: n._scriptsIndex[d].ind,
                            attributes: f,
                          });
                          o && s.push(o);
                        }
                      }
                      for (let n = 0; n < s.length; n++)
                        s[n].__initializeAttributes();
                      for (let n = 0; n < s.length; n++)
                        s[n].enabled &&
                          ((s[n]._initialized = !0),
                          l.push(s[n]),
                          s[n].initialize && s[n].initialize());
                      for (let n = 0; n < l.length; n++)
                        !l[n].enabled ||
                          l[n]._postInitialized ||
                          ((l[n]._postInitialized = !0),
                          l[n].postInitialize && l[n].postInitialize());
                    }),
                    !0);
              }
              remove(c) {
                let d = c,
                  h = c;
                if (
                  (typeof h != "string" ? (h = d.__name) : (d = this.get(h)),
                  this.get(h) !== d)
                )
                  return !1;
                delete this._scripts[h];
                const f = this._list.indexOf(d);
                return (
                  this._list.splice(f, 1),
                  this.fire("remove", h, d),
                  this.fire("remove:" + h, d),
                  !0
                );
              }
              get(c) {
                return this._scripts[c] || null;
              }
              has(c) {
                if (typeof c == "string")
                  return this._scripts.hasOwnProperty(c);
                if (!c) return !1;
                const d = c.__name;
                return this._scripts[d] === c;
              }
              list() {
                return this._list;
              }
            }
          },
          3428: (Se, W, a) => {
            "use strict";
            a.d(W, { e: () => d });
            var x = a(5338),
              T = a(1118),
              g = a(36);
            const c = new RegExp(
              "^\\s*function(?:\\s|\\s*\\/\\*.*\\*\\/\\s*)+([^\\(\\s\\/]*)\\s*"
            );
            class d extends x.b {
              constructor(f) {
                super(),
                  (this.app = void 0),
                  (this.entity = void 0),
                  (this._enabled = void 0),
                  (this._enabledOld = void 0),
                  (this._initialized = void 0),
                  (this._postInitialized = void 0),
                  (this.__destroyed = void 0),
                  (this.__attributes = void 0),
                  (this.__attributesRaw = void 0),
                  (this.__scriptType = void 0),
                  (this.__executionOrder = void 0),
                  this.initScriptType(f);
              }
              set enabled(f) {
                (this._enabled = !!f),
                  this.enabled !== this._enabledOld &&
                    ((this._enabledOld = this.enabled),
                    this.fire(this.enabled ? "enable" : "disable"),
                    this.fire("state", this.enabled),
                    !this._initialized &&
                      this.enabled &&
                      ((this._initialized = !0),
                      this.__initializeAttributes(!0),
                      this.initialize &&
                        this.entity.script._scriptMethod(this, T.Bg)),
                    this._initialized &&
                      !this._postInitialized &&
                      this.enabled &&
                      !this.entity.script._beingEnabled &&
                      ((this._postInitialized = !0),
                      this.postInitialize &&
                        this.entity.script._scriptMethod(this, T.wJ)));
              }
              get enabled() {
                return (
                  this._enabled &&
                  !this._destroyed &&
                  this.entity.script.enabled &&
                  this.entity.enabled
                );
              }
              initScriptType(f) {
                const s = this.constructor;
                (this.app = f.app),
                  (this.entity = f.entity),
                  (this._enabled =
                    typeof f.enabled == "boolean" ? f.enabled : !0),
                  (this._enabledOld = this.enabled),
                  (this.__destroyed = !1),
                  (this.__attributes = {}),
                  (this.__attributesRaw = f.attributes || {}),
                  (this.__scriptType = s),
                  (this.__executionOrder = -1);
              }
              static __getScriptName(f) {
                if (typeof f != "function") return;
                if ("name" in Function.prototype) return f.name;
                if (f === Function || f === Function.prototype.constructor)
                  return "Function";
                const s = ("" + f).match(c);
                return s ? s[1] : void 0;
              }
              static get scriptName() {
                return this.__name;
              }
              static get attributes() {
                return (
                  this.hasOwnProperty("__attributes") ||
                    (this.__attributes = new g.s(this)),
                  this.__attributes
                );
              }
              __initializeAttributes(f) {
                if (!(!f && !this.__attributesRaw)) {
                  for (const s in this.__scriptType.attributes.index)
                    this.__attributesRaw &&
                    this.__attributesRaw.hasOwnProperty(s)
                      ? (this[s] = this.__attributesRaw[s])
                      : this.__attributes.hasOwnProperty(s) ||
                        (this.__scriptType.attributes.index[s].hasOwnProperty(
                          "default"
                        )
                          ? (this[s] =
                              this.__scriptType.attributes.index[s].default)
                          : (this[s] = null));
                  this.__attributesRaw = null;
                }
              }
              static extend(f) {
                for (const s in f)
                  f.hasOwnProperty(s) && (this.prototype[s] = f[s]);
              }
            }
            d.__name = null;
          },
          8615: (Se, W, a) => {
            "use strict";
            a.d(W, { t: () => x });
            class x {
              static push(g, c) {
                c && x._types.length > 0
                  ? console.assert(
                      "Script Ordering Error. Contact support@playcanvas.com"
                    )
                  : x._types.push(g);
              }
            }
            x._types = [];
          },
          9124: (Se, W, a) => {
            "use strict";
            a.d(W, { A8: () => o, H8: () => s, hT: () => l });
            var x = a(5338),
              T = a(5751),
              g = a(2816),
              c = a(36),
              d = a(3428),
              h = a(8615);
            const f = new Set([
              "system",
              "entity",
              "create",
              "destroy",
              "swap",
              "move",
              "data",
              "scripts",
              "_scripts",
              "_scriptsIndex",
              "_scriptsData",
              "enabled",
              "_oldState",
              "onEnable",
              "onDisable",
              "onPostStateChange",
              "_onSetEnabled",
              "_checkState",
              "_onBeforeRemove",
              "_onInitializeAttributes",
              "_onInitialize",
              "_onPostInitialize",
              "_onUpdate",
              "_onPostUpdate",
              "_callbacks",
              "_callbackActive",
              "has",
              "get",
              "on",
              "off",
              "fire",
              "once",
              "hasEvent",
            ]);
            function s() {
              return f;
            }
            function l(i, e) {
              if (T._.legacy) return null;
              if (f.has(i))
                throw new Error(
                  `Script name '${i}' is reserved, please rename the script`
                );
              const t = function (u) {
                x.b.prototype.initEventHandler.call(this),
                  d.e.prototype.initScriptType.call(this, u);
              };
              return (
                (t.prototype = Object.create(d.e.prototype)),
                (t.prototype.constructor = t),
                (t.extend = d.e.extend),
                (t.attributes = new c.s(t)),
                o(t, i, e),
                t
              );
            }
            const n = {};
            c.s.reservedNames.forEach((i, e, t) => {
              n[i] = 1;
            }),
              (l.reservedAttributes = n);
            function o(i, e, t) {
              if (i.legacy) return;
              if (typeof i != "function")
                throw new Error(
                  `script class: '${i}' must be a constructor function (i.e. class).`
                );
              if (!(i.prototype instanceof d.e))
                throw new Error(
                  `script class: '${d.e.__getScriptName(
                    i
                  )}' does not extend pc.ScriptType.`
                );
              if (((e = e || i.__name || d.e.__getScriptName(i)), f.has(e)))
                throw new Error(
                  `script name: '${e}' is reserved, please change script name`
                );
              (i.__name = e),
                (t ? t.scripts : g.k.getApplication().scripts).add(i),
                h.t.push(i, i.legacy);
            }
          },
          7088: (Se, W, a) => {
            "use strict";
            a.d(W, { Y: () => T });
            var x = a(544);
            class T {
              constructor(c, d) {
                (this._app = void 0),
                  (this._data = void 0),
                  (this._templateRoot = null),
                  (this._app = c),
                  (this._data = d);
              }
              instantiate() {
                return (
                  this._templateRoot || this._parseTemplate(),
                  this._templateRoot.clone()
                );
              }
              _parseTemplate() {
                const c = new x.n(this._app, !0);
                this._templateRoot = c.parse(this._data);
              }
            }
          },
          5004: (Se, W, a) => {
            "use strict";
            a.d(W, { e: () => c });
            var x = a(8620),
              T = a(258),
              g = a(5338);
            class c extends g.b {
              constructor(h, f, s) {
                if ((super(), !h || !(h instanceof x.w)))
                  throw new Error(
                    "The parentComponent argument is required and must be a Component"
                  );
                if (!f || typeof f != "string")
                  throw new Error(
                    "The propertyName argument is required and must be a string"
                  );
                if (s && typeof s != "object")
                  throw new Error(
                    "If provided, the eventConfig argument must be an object"
                  );
                (this._parentComponent = h),
                  (this._entityPropertyName = f),
                  (this._entity = null),
                  (this._app = h.system.app),
                  this._configureEventListeners(s || {}, {
                    "entity#destroy": this._onEntityDestroy,
                  }),
                  this._toggleLifecycleListeners("on");
              }
              _configureEventListeners(h, f) {
                const s = this._parseEventListenerConfig(
                    h,
                    "external",
                    this._parentComponent
                  ),
                  l = this._parseEventListenerConfig(f, "internal", this);
                (this._eventListenerConfigs = s.concat(l)),
                  (this._listenerStatusFlags = {}),
                  (this._gainListeners = {}),
                  (this._loseListeners = {});
              }
              _parseEventListenerConfig(h, f, s) {
                return Object.keys(h).map(function (l, n) {
                  const o = l.split("#"),
                    i = o[0],
                    e = o[1],
                    t = h[l];
                  if (
                    o.length !== 2 ||
                    typeof i != "string" ||
                    i.length === 0 ||
                    typeof e != "string" ||
                    e.length === 0
                  )
                    throw new Error(
                      "Invalid event listener description: `" + l + "`"
                    );
                  if (typeof t != "function")
                    throw new Error(
                      "Invalid or missing callback for event listener `" +
                        l +
                        "`"
                    );
                  return {
                    id: f + "_" + n + "_" + l,
                    sourceName: i,
                    eventName: e,
                    callback: t,
                    scope: s,
                  };
                }, this);
              }
              _toggleLifecycleListeners(h) {
                this._parentComponent[h](
                  "set_" + this._entityPropertyName,
                  this._onSetEntity,
                  this
                ),
                  this._parentComponent.system[h](
                    "beforeremove",
                    this._onParentComponentRemove,
                    this
                  ),
                  this._app.systems[h](
                    "postPostInitialize",
                    this._updateEntityReference,
                    this
                  ),
                  this._app[h]("tools:sceneloaded", this._onSceneLoaded, this);
                const f = [];
                for (let s = 0; s < this._eventListenerConfigs.length; ++s) {
                  const l = this._eventListenerConfigs[s],
                    n = this._app.systems[l.sourceName];
                  n &&
                    (f.indexOf(n) === -1 && f.push(n),
                    n &&
                      l.eventName === "gain" &&
                      (this._gainListeners[l.sourceName] = l),
                    n &&
                      l.eventName === "lose" &&
                      (this._loseListeners[l.sourceName] = l));
                }
                for (let s = 0; s < f.length; ++s)
                  f[s][h]("add", this._onComponentAdd, this),
                    f[s][h]("beforeremove", this._onComponentRemove, this);
              }
              _onSetEntity(h, f, s) {
                if (s instanceof T.J) this._updateEntityReference();
                else {
                  if (s != null && typeof s != "string") {
                    console.warn(
                      "Entity field `" +
                        this._entityPropertyName +
                        "` was set to unexpected type '" +
                        typeof s +
                        "'"
                    );
                    return;
                  }
                  f !== s && this._updateEntityReference();
                }
              }
              onParentComponentEnable() {
                this._entity || this._updateEntityReference();
              }
              _onSceneLoaded() {
                this._updateEntityReference();
              }
              _updateEntityReference() {
                let h = this._parentComponent.data[this._entityPropertyName],
                  f;
                if (h instanceof T.J)
                  (f = h),
                    (h = f.getGuid()),
                    (this._parentComponent.data[this._entityPropertyName] = h);
                else {
                  const l = this._parentComponent.system.app.root;
                  f =
                    this._parentComponent.entity.isDescendantOf(l) && h
                      ? l.findByGuid(h)
                      : null;
                }
                this._entity !== f &&
                  (this._entity && this._onBeforeEntityChange(),
                  (this._entity = f),
                  this._entity && this._onAfterEntityChange(),
                  this.fire("set:entity", this._entity));
              }
              _onBeforeEntityChange() {
                this._toggleEntityListeners("off"),
                  this._callAllGainOrLoseListeners(this._loseListeners);
              }
              _onAfterEntityChange() {
                this._toggleEntityListeners("on"),
                  this._callAllGainOrLoseListeners(this._gainListeners);
              }
              _onComponentAdd(h, f) {
                const s = f.system.id;
                h === this._entity &&
                  (this._callGainOrLoseListener(s, this._gainListeners),
                  this._toggleComponentListeners("on", s));
              }
              _onComponentRemove(h, f) {
                const s = f.system.id;
                h === this._entity &&
                  (this._callGainOrLoseListener(s, this._loseListeners),
                  this._toggleComponentListeners("off", s, !0));
              }
              _callAllGainOrLoseListeners(h) {
                for (const f in this._entity.c)
                  this._callGainOrLoseListener(f, h);
              }
              _callGainOrLoseListener(h, f) {
                if (this._entity.c.hasOwnProperty(h) && f[h]) {
                  const s = f[h];
                  s.callback.call(s.scope);
                }
              }
              _toggleEntityListeners(h, f) {
                if (this._entity)
                  for (let s = 0; s < this._eventListenerConfigs.length; ++s)
                    this._safeToggleListener(
                      h,
                      this._eventListenerConfigs[s],
                      f
                    );
              }
              _toggleComponentListeners(h, f, s) {
                for (let l = 0; l < this._eventListenerConfigs.length; ++l) {
                  const n = this._eventListenerConfigs[l];
                  n.sourceName === f && this._safeToggleListener(h, n, s);
                }
              }
              _safeToggleListener(h, f, s) {
                const l = h === "on";
                if (l && this._listenerStatusFlags[f.id]) return;
                const n = this._getEventSource(f.sourceName, s);
                n &&
                  (n[h](f.eventName, f.callback, f.scope),
                  (this._listenerStatusFlags[f.id] = l));
              }
              _getEventSource(h, f) {
                if (h === "entity") return this._entity;
                const s = this._entity[h];
                return (
                  s ||
                  (f || console.warn("Entity has no component with name " + h),
                  null)
                );
              }
              _onEntityDestroy(h) {
                this._entity === h &&
                  (this._toggleEntityListeners("off", !0),
                  (this._entity = null));
              }
              _onParentComponentRemove(h, f) {
                f === this._parentComponent &&
                  (this._toggleLifecycleListeners("off"),
                  this._toggleEntityListeners("off", !0));
              }
              hasComponent(h) {
                return this._entity && this._entity.c
                  ? !!this._entity.c[h]
                  : !1;
              }
              get entity() {
                return this._entity;
              }
            }
          },
          2872: (Se, W, a) => {
            "use strict";
            a.d(W, {
              AD: () => t,
              Dd: () => T,
              ED: () => f,
              FO: () => y,
              Gu: () => m,
              OB: () => n,
              Qi: () => o,
              RF: () => i,
              UG: () => g,
              Y$: () => u,
              YW: () => x,
              ZY: () => r,
              _B: () => E,
              eF: () => d,
              fK: () => c,
              fO: () => h,
              fh: () => _,
              iq: () => l,
              l2: () => s,
              qr: () => p,
              u5: () => e,
            });
            const x = "inline",
              T = "immersive-vr",
              g = "immersive-ar",
              c = "viewer",
              d = "local",
              h = "local-floor",
              f = "bounded-floor",
              s = "unbounded",
              l = "gaze",
              n = "screen",
              o = "tracked-pointer",
              i = "none",
              e = "left",
              t = "right",
              r = "point",
              u = "plane",
              y = "mesh",
              p = "cpu-optimized",
              _ = "gpu-optimized",
              m = "luminance-alpha",
              E = "float32";
          },
          8657: (Se, W, a) => {
            "use strict";
            a.d(W, { e: () => f });
            var x = a(5338),
              T = a(4444),
              g = a(9758),
              c = a(7921),
              d = a(8869),
              h = a(2872);
            class f extends x.b {
              constructor(l) {
                super(),
                  (this._manager = void 0),
                  (this._available = !1),
                  (this._depthInfoCpu = null),
                  (this._depthInfoGpu = null),
                  (this._usage = null),
                  (this._dataFormat = null),
                  (this._matrixDirty = !1),
                  (this._matrix = new g.y()),
                  (this._emptyBuffer = new Uint8Array(32)),
                  (this._depthBuffer = null),
                  (this._texture = void 0),
                  (this._manager = l),
                  (this._texture = new d.x(this._manager.app.graphicsDevice, {
                    format: c.$Op,
                    mipmaps: !1,
                    addressU: c.uFb,
                    addressV: c.uFb,
                    minFilter: c.I5X,
                    magFilter: c.I5X,
                    name: "XRDepthSensing",
                  })),
                  this.supported &&
                    (this._manager.on("start", this._onSessionStart, this),
                    this._manager.on("end", this._onSessionEnd, this));
              }
              destroy() {
                this._texture.destroy(), (this._texture = null);
              }
              _onSessionStart() {
                const l = this._manager.session;
                try {
                  (this._usage = l.depthUsage),
                    (this._dataFormat = l.depthDataFormat);
                } catch (n) {
                  (this._usage = null),
                    (this._dataFormat = null),
                    (this._available = !1),
                    this.fire("error", n);
                }
              }
              _onSessionEnd() {
                (this._depthInfoCpu = null),
                  (this._depthInfoGpu = null),
                  (this._usage = null),
                  (this._dataFormat = null),
                  this._available &&
                    ((this._available = !1), this.fire("unavailable")),
                  (this._depthBuffer = null),
                  (this._texture._width = 4),
                  (this._texture._height = 4),
                  (this._texture._levels[0] = this._emptyBuffer),
                  this._texture.upload();
              }
              _updateTexture() {
                const l = this._depthInfoCpu || this._depthInfoGpu;
                if (l) {
                  let n = !1;
                  if (
                    ((l.width !== this._texture.width ||
                      l.height !== this._texture.height) &&
                      ((this._texture._width = l.width),
                      (this._texture._height = l.height),
                      (this._matrixDirty = !0),
                      (n = !0)),
                    this._depthInfoCpu)
                  ) {
                    const o = this._depthInfoCpu.data;
                    (this._depthBuffer = new Uint8Array(o)),
                      (this._texture._levels[0] = this._depthBuffer),
                      this._texture.upload();
                  } else
                    this._depthInfoGpu &&
                      ((this._texture._levels[0] = this._depthInfoGpu.texture),
                      this._texture.upload());
                  n && this.fire("resize", l.width, l.height);
                } else
                  this._depthBuffer &&
                    ((this._depthBuffer = null),
                    (this._texture._width = 4),
                    (this._texture._height = 4),
                    (this._texture._levels[0] = this._emptyBuffer),
                    this._texture.upload());
              }
              update(l, n) {
                if (!this._usage) return;
                let o = null,
                  i = null;
                if (
                  (this._usage === h.qr && n
                    ? (o = l.getDepthInformation(n))
                    : this._usage === h.fh &&
                      n &&
                      (i = l.getDepthInformation(n)),
                  ((this._depthInfoCpu && !o) ||
                    (!this._depthInfoCpu && o) ||
                    (this.depthInfoGpu && !i) ||
                    (!this._depthInfoGpu && i)) &&
                    (this._matrixDirty = !0),
                  (this._depthInfoCpu = o),
                  (this._depthInfoGpu = i),
                  this._updateTexture(),
                  this._matrixDirty)
                ) {
                  this._matrixDirty = !1;
                  const e = this._depthInfoCpu || this._depthInfoGpu;
                  e
                    ? this._matrix.data.set(
                        e.normDepthBufferFromNormView.matrix
                      )
                    : this._matrix.setIdentity();
                }
                (this._depthInfoCpu || this._depthInfoGpu) && !this._available
                  ? ((this._available = !0), this.fire("available"))
                  : !this._depthInfoCpu &&
                    !this._depthInfoGpu &&
                    this._available &&
                    ((this._available = !1), this.fire("unavailable"));
              }
              getDepth(l, n) {
                return this._depthInfoCpu
                  ? this._depthInfoCpu.getDepthInMeters(l, n)
                  : null;
              }
              get supported() {
                return T.J.browser && !!window.XRDepthInformation;
              }
              get available() {
                return this._available;
              }
              get usage() {
                return this._usage;
              }
              get dataFormat() {
                return this._dataFormat;
              }
              get width() {
                const l = this._depthInfoCpu || this._depthInfoGpu;
                return (l && l.width) || 0;
              }
              get height() {
                const l = this._depthInfoCpu || this._depthInfoGpu;
                return (l && l.height) || 0;
              }
              get texture() {
                return this._texture;
              }
              get uvMatrix() {
                return this._matrix;
              }
              get rawValueToMeters() {
                const l = this._depthInfoCpu || this._depthInfoGpu;
                return (l && l.rawValueToMeters) || 0;
              }
            }
          },
          100: (Se, W, a) => {
            "use strict";
            a.d(W, { q: () => T });
            var x = a(4444);
            class T {
              constructor(c) {
                (this._manager = void 0),
                  (this._supported = x.J.browser && !!window.XRDOMOverlayState),
                  (this._root = null),
                  (this._manager = c);
              }
              get supported() {
                return this._supported;
              }
              get available() {
                return (
                  this._supported &&
                  this._manager.active &&
                  this._manager._session.domOverlayState !== null
                );
              }
              get state() {
                return !this._supported ||
                  !this._manager.active ||
                  !this._manager._session.domOverlayState
                  ? null
                  : this._manager._session.domOverlayState.type;
              }
              set root(c) {
                !this._supported || this._manager.active || (this._root = c);
              }
              get root() {
                return this._root;
              }
            }
          },
          8878: (Se, W, a) => {
            "use strict";
            a.d(W, { j: () => h });
            var x = a(5338),
              T = a(6847),
              g = a(6556);
            const c = [],
              d = [];
            class h extends x.b {
              constructor(s, l, n) {
                super(),
                  (this.manager = void 0),
                  (this._xrHitTestSource = void 0),
                  (this._transient = void 0),
                  (this.manager = s),
                  (this._xrHitTestSource = l),
                  (this._transient = n);
              }
              remove() {
                if (!this._xrHitTestSource) return;
                const s = this.manager.hitTest.sources,
                  l = s.indexOf(this);
                l !== -1 && s.splice(l, 1), this.onStop();
              }
              onStop() {
                this._xrHitTestSource.cancel(),
                  (this._xrHitTestSource = null),
                  this.fire("remove"),
                  this.manager.hitTest.fire("remove", this);
              }
              update(s) {
                if (this._transient) {
                  const l = s.getHitTestResultsForTransientInput(
                    this._xrHitTestSource
                  );
                  for (let n = 0; n < l.length; n++) {
                    const o = l[n];
                    let i;
                    o.inputSource &&
                      (i = this.manager.input._getByInputSource(o.inputSource)),
                      this.updateHitResults(o.results, i);
                  }
                } else
                  this.updateHitResults(
                    s.getHitTestResults(this._xrHitTestSource)
                  );
              }
              updateHitResults(s, l) {
                for (let n = 0; n < s.length; n++) {
                  const o = s[n].getPose(this.manager._referenceSpace);
                  let i = c.pop();
                  i || (i = new g.A()), i.copy(o.transform.position);
                  let e = d.pop();
                  e || (e = new T.D()),
                    e.copy(o.transform.orientation),
                    this.fire("result", i, e, l),
                    this.manager.hitTest.fire("result", this, i, e, l),
                    c.push(i),
                    d.push(e);
                }
              }
            }
          },
          1376: (Se, W, a) => {
            "use strict";
            a.d(W, { S: () => d });
            var x = a(4444),
              T = a(5338),
              g = a(2872),
              c = a(8878);
            class d extends T.b {
              constructor(f) {
                super(),
                  (this.manager = void 0),
                  (this._supported =
                    x.J.browser &&
                    !!(
                      window.XRSession &&
                      window.XRSession.prototype.requestHitTestSource
                    )),
                  (this._session = null),
                  (this.sources = []),
                  (this.manager = f),
                  this._supported &&
                    (this.manager.on("start", this._onSessionStart, this),
                    this.manager.on("end", this._onSessionEnd, this));
              }
              _onSessionStart() {
                this.manager.type === g.UG &&
                  (this._session = this.manager.session);
              }
              _onSessionEnd() {
                if (this._session) {
                  this._session = null;
                  for (let f = 0; f < this.sources.length; f++)
                    this.sources[f].onStop();
                  this.sources = [];
                }
              }
              isAvailable(f, s) {
                let l;
                return (
                  this._supported ||
                    (l = new Error("XR HitTest is not supported")),
                  this._session ||
                    (l = new Error("XR Session is not started (1)")),
                  this.manager.type !== g.UG &&
                    (l = new Error("XR HitTest is available only for AR")),
                  l ? (f && f(l), s && s.fire("error", l), !1) : !0
                );
              }
              start(f = {}) {
                if (!this.isAvailable(f.callback, this)) return;
                !f.profile && !f.spaceType && (f.spaceType = g.fK);
                let s;
                const l = f.offsetRay;
                if (l) {
                  const o = new DOMPoint(l.origin.x, l.origin.y, l.origin.z, 1),
                    i = new DOMPoint(
                      l.direction.x,
                      l.direction.y,
                      l.direction.z,
                      0
                    );
                  s = new XRRay(o, i);
                }
                const n = f.callback;
                f.spaceType
                  ? this._session
                      .requestReferenceSpace(f.spaceType)
                      .then((o) => {
                        if (!this._session) {
                          const i = new Error("XR Session is not started (2)");
                          n && n(i), this.fire("error", i);
                          return;
                        }
                        this._session
                          .requestHitTestSource({
                            space: o,
                            entityTypes: f.entityTypes || void 0,
                            offsetRay: s,
                          })
                          .then((i) => {
                            this._onHitTestSource(i, !1, n);
                          })
                          .catch((i) => {
                            n && n(i), this.fire("error", i);
                          });
                      })
                      .catch((o) => {
                        n && n(o), this.fire("error", o);
                      })
                  : this._session
                      .requestHitTestSourceForTransientInput({
                        profile: f.profile,
                        entityTypes: f.entityTypes || void 0,
                        offsetRay: s,
                      })
                      .then((o) => {
                        this._onHitTestSource(o, !0, n);
                      })
                      .catch((o) => {
                        n && n(o), this.fire("error", o);
                      });
              }
              _onHitTestSource(f, s, l) {
                if (!this._session) {
                  f.cancel();
                  const o = new Error("XR Session is not started (3)");
                  l && l(o), this.fire("error", o);
                  return;
                }
                const n = new c.j(this.manager, f, s);
                this.sources.push(n), l && l(null, n), this.fire("add", n);
              }
              update(f) {
                for (let s = 0; s < this.sources.length; s++)
                  this.sources[s].update(f);
              }
              get supported() {
                return this._supported;
              }
            }
          },
          5571: (Se, W, a) => {
            "use strict";
            a.d(W, { s: () => c });
            var x = a(5338),
              T = a(4444),
              g = a(6337);
            class c extends x.b {
              constructor(h) {
                super(),
                  (this._manager = void 0),
                  (this._supported =
                    T.J.browser && !!window.XRImageTrackingResult),
                  (this._available = !1),
                  (this._images = []),
                  (this._manager = h),
                  this._supported &&
                    (this._manager.on("start", this._onSessionStart, this),
                    this._manager.on("end", this._onSessionEnd, this));
              }
              add(h, f) {
                if (!this._supported || this._manager.active) return null;
                const s = new g.J(h, f);
                return this._images.push(s), s;
              }
              remove(h) {
                if (this._manager.active) return;
                const f = this._images.indexOf(h);
                f !== -1 && (h.destroy(), this._images.splice(f, 1));
              }
              _onSessionStart() {
                this._manager.session
                  .getTrackedImageScores()
                  .then((h) => {
                    this._available = !0;
                    for (let f = 0; f < h.length; f++)
                      this._images[f]._trackable = h[f] === "trackable";
                  })
                  .catch((h) => {
                    (this._available = !1), this.fire("error", h);
                  });
              }
              _onSessionEnd() {
                this._available = !1;
                for (let h = 0; h < this._images.length; h++) {
                  const f = this._images[h];
                  (f._pose = null),
                    (f._measuredWidth = 0),
                    f._tracking && ((f._tracking = !1), f.fire("untracked"));
                }
              }
              prepareImages(h) {
                this._images.length
                  ? Promise.all(
                      this._images.map(function (f) {
                        return f.prepare();
                      })
                    )
                      .then(function (f) {
                        h(null, f);
                      })
                      .catch(function (f) {
                        h(f, null);
                      })
                  : h(null, null);
              }
              update(h) {
                if (!this._available) return;
                const f = h.getImageTrackingResults(),
                  s = {};
                for (let l = 0; l < f.length; l++) {
                  s[f[l].index] = f[l];
                  const n = this._images[f[l].index];
                  (n._emulated = f[l].trackingState === "emulated"),
                    (n._measuredWidth = f[l].measuredWidthInMeters),
                    (n._pose = h.getPose(
                      f[l].imageSpace,
                      this._manager._referenceSpace
                    ));
                }
                for (let l = 0; l < this._images.length; l++)
                  this._images[l]._tracking && !s[l]
                    ? ((this._images[l]._tracking = !1),
                      this._images[l].fire("untracked"))
                    : !this._images[l]._tracking &&
                      s[l] &&
                      ((this._images[l]._tracking = !0),
                      this._images[l].fire("tracked"));
              }
              get supported() {
                return this._supported;
              }
              get available() {
                return this._available;
              }
              get images() {
                return this._images;
              }
            }
          },
          5541: (Se, W, a) => {
            "use strict";
            a.d(W, { g: () => _ });
            var x = a(5338),
              T = a(9758),
              g = a(6847),
              c = a(6556),
              d = a(3028),
              h = a(4444),
              f = a(2872);
            class s {
              constructor(E, v) {
                (this._index = void 0),
                  (this._hand = void 0),
                  (this._joints = []),
                  (this._tip = null),
                  (this._index = E),
                  (this._hand = v),
                  this._hand._fingers.push(this);
              }
              get index() {
                return this._index;
              }
              get hand() {
                return this._hand;
              }
              get joints() {
                return this._joints;
              }
              get tip() {
                return this._tip;
              }
            }
            const l =
                h.J.browser && window.XRHand
                  ? [
                      "thumb-tip",
                      "index-finger-tip",
                      "middle-finger-tip",
                      "ring-finger-tip",
                      "pinky-finger-tip",
                    ]
                  : [],
              n = {};
            for (let m = 0; m < l.length; m++) n[l[m]] = !0;
            class o {
              constructor(E, v, P, I = null) {
                (this._index = void 0),
                  (this._id = void 0),
                  (this._hand = void 0),
                  (this._finger = void 0),
                  (this._wrist = void 0),
                  (this._tip = void 0),
                  (this._radius = null),
                  (this._localTransform = new T.y()),
                  (this._worldTransform = new T.y()),
                  (this._localPosition = new c.A()),
                  (this._localRotation = new g.D()),
                  (this._position = new c.A()),
                  (this._rotation = new g.D()),
                  (this._dirtyLocal = !0),
                  (this._index = E),
                  (this._id = v),
                  (this._hand = P),
                  (this._finger = I),
                  (this._wrist = v === "wrist"),
                  (this._tip = this._finger && !!n[v]);
              }
              update(E) {
                (this._dirtyLocal = !0),
                  (this._radius = E.radius),
                  this._localPosition.copy(E.transform.position),
                  this._localRotation.copy(E.transform.orientation);
              }
              _updateTransforms() {
                this._dirtyLocal &&
                  ((this._dirtyLocal = !1),
                  this._localTransform.setTRS(
                    this._localPosition,
                    this._localRotation,
                    c.A.ONE
                  ));
                const v = this._hand._manager.camera.parent;
                v
                  ? this._worldTransform.mul2(
                      v.getWorldTransform(),
                      this._localTransform
                    )
                  : this._worldTransform.copy(this._localTransform);
              }
              getPosition() {
                return (
                  this._updateTransforms(),
                  this._worldTransform.getTranslation(this._position),
                  this._position
                );
              }
              getRotation() {
                return (
                  this._updateTransforms(),
                  this._rotation.setFromMat4(this._worldTransform),
                  this._rotation
                );
              }
              get index() {
                return this._index;
              }
              get hand() {
                return this._hand;
              }
              get finger() {
                return this._finger;
              }
              get wrist() {
                return this._wrist;
              }
              get tip() {
                return this._tip;
              }
              get radius() {
                return this._radius || 0.005;
              }
            }
            let i = [];
            const e = new c.A(),
              t = new c.A(),
              r = new c.A();
            h.J.browser &&
              window.XRHand &&
              (i = [
                [
                  "thumb-metacarpal",
                  "thumb-phalanx-proximal",
                  "thumb-phalanx-distal",
                  "thumb-tip",
                ],
                [
                  "index-finger-metacarpal",
                  "index-finger-phalanx-proximal",
                  "index-finger-phalanx-intermediate",
                  "index-finger-phalanx-distal",
                  "index-finger-tip",
                ],
                [
                  "middle-finger-metacarpal",
                  "middle-finger-phalanx-proximal",
                  "middle-finger-phalanx-intermediate",
                  "middle-finger-phalanx-distal",
                  "middle-finger-tip",
                ],
                [
                  "ring-finger-metacarpal",
                  "ring-finger-phalanx-proximal",
                  "ring-finger-phalanx-intermediate",
                  "ring-finger-phalanx-distal",
                  "ring-finger-tip",
                ],
                [
                  "pinky-finger-metacarpal",
                  "pinky-finger-phalanx-proximal",
                  "pinky-finger-phalanx-intermediate",
                  "pinky-finger-phalanx-distal",
                  "pinky-finger-tip",
                ],
              ]);
            class u extends x.b {
              constructor(E) {
                super(),
                  (this._manager = void 0),
                  (this._inputSource = void 0),
                  (this._tracking = !1),
                  (this._fingers = []),
                  (this._joints = []),
                  (this._jointsById = {}),
                  (this._tips = []),
                  (this._wrist = null);
                const v = E._xrInputSource.hand;
                if (
                  ((this._manager = E._manager),
                  (this._inputSource = E),
                  v.get("wrist"))
                ) {
                  const P = new o(0, "wrist", this, null);
                  (this._wrist = P),
                    this._joints.push(P),
                    (this._jointsById.wrist = P);
                }
                for (let P = 0; P < i.length; P++) {
                  const I = new s(P, this);
                  for (let A = 0; A < i[P].length; A++) {
                    const B = i[P][A];
                    if (!v.get(B)) continue;
                    const C = new o(A, B, this, I);
                    this._joints.push(C),
                      (this._jointsById[B] = C),
                      C.tip && (this._tips.push(C), (I._tip = C)),
                      I._joints.push(C);
                  }
                }
              }
              update(E) {
                const v = this._inputSource._xrInputSource;
                for (let K = 0; K < this._joints.length; K++) {
                  const te = this._joints[K],
                    X = v.hand.get(te._id);
                  if (X) {
                    let $;
                    if (
                      (E.session.visibilityState !== "hidden" &&
                        ($ = E.getJointPose(X, this._manager._referenceSpace)),
                      $)
                    )
                      te.update($),
                        te.wrist &&
                          !this._tracking &&
                          ((this._tracking = !0), this.fire("tracking"));
                    else if (te.wrist) {
                      this._tracking &&
                        ((this._tracking = !1), this.fire("trackinglost"));
                      break;
                    }
                  }
                }
                const P = this._jointsById["thumb-metacarpal"],
                  I = this._jointsById["thumb-tip"],
                  A = this._jointsById["index-finger-phalanx-proximal"],
                  B = this._jointsById["index-finger-tip"],
                  C = this._jointsById["ring-finger-phalanx-proximal"],
                  w = this._jointsById["pinky-finger-phalanx-proximal"];
                if (P && I && A && B && C && w) {
                  (this._inputSource._dirtyRay = !0),
                    this._inputSource._rayLocal.origin.lerp(
                      I._localPosition,
                      B._localPosition,
                      0.5
                    );
                  let K = P,
                    te = w;
                  if (this._inputSource.handedness === f.u5) {
                    const X = K;
                    (K = te), (te = X);
                  }
                  e.sub2(K._localPosition, this._wrist._localPosition),
                    t.sub2(te._localPosition, this._wrist._localPosition),
                    r.cross(e, t).normalize(),
                    e.lerp(A._localPosition, C._localPosition, 0.5),
                    e.sub(this._wrist._localPosition).normalize(),
                    this._inputSource._rayLocal.direction
                      .lerp(r, e, 0.5)
                      .normalize();
                }
                this._fingerIsClosed(1) &&
                this._fingerIsClosed(2) &&
                this._fingerIsClosed(3) &&
                this._fingerIsClosed(4)
                  ? this._inputSource._squeezing ||
                    ((this._inputSource._squeezing = !0),
                    this._inputSource.fire("squeezestart"),
                    this._manager.input.fire("squeezestart", this._inputSource))
                  : this._inputSource._squeezing &&
                    ((this._inputSource._squeezing = !1),
                    this._inputSource.fire("squeeze"),
                    this._manager.input.fire("squeeze", this._inputSource),
                    this._inputSource.fire("squeezeend"),
                    this._manager.input.fire("squeezeend", this._inputSource));
              }
              _fingerIsClosed(E) {
                const v = this._fingers[E];
                return (
                  e
                    .sub2(
                      v.joints[0]._localPosition,
                      v.joints[1]._localPosition
                    )
                    .normalize(),
                  t
                    .sub2(
                      v.joints[2]._localPosition,
                      v.joints[3]._localPosition
                    )
                    .normalize(),
                  e.dot(t) < -0.8
                );
              }
              getJointById(E) {
                return this._jointsById[E] || null;
              }
              get fingers() {
                return this._fingers;
              }
              get joints() {
                return this._joints;
              }
              get tips() {
                return this._tips;
              }
              get wrist() {
                return this._wrist;
              }
              get tracking() {
                return this._tracking;
              }
            }
            const y = new g.D();
            let p = 0;
            class _ extends x.b {
              constructor(E, v) {
                super(),
                  (this._id = void 0),
                  (this._manager = void 0),
                  (this._xrInputSource = void 0),
                  (this._ray = new d.z()),
                  (this._rayLocal = new d.z()),
                  (this._grip = !1),
                  (this._hand = null),
                  (this._localTransform = null),
                  (this._worldTransform = null),
                  (this._position = new c.A()),
                  (this._rotation = new g.D()),
                  (this._localPosition = null),
                  (this._localRotation = null),
                  (this._dirtyLocal = !0),
                  (this._dirtyRay = !1),
                  (this._selecting = !1),
                  (this._squeezing = !1),
                  (this._elementInput = !0),
                  (this._elementEntity = null),
                  (this._hitTestSources = []),
                  (this._id = ++p),
                  (this._manager = E),
                  (this._xrInputSource = v),
                  v.hand && (this._hand = new u(this));
              }
              get id() {
                return this._id;
              }
              get inputSource() {
                return this._xrInputSource;
              }
              get targetRayMode() {
                return this._xrInputSource.targetRayMode;
              }
              get handedness() {
                return this._xrInputSource.handedness;
              }
              get profiles() {
                return this._xrInputSource.profiles;
              }
              get grip() {
                return this._grip;
              }
              get hand() {
                return this._hand;
              }
              get gamepad() {
                return this._xrInputSource.gamepad || null;
              }
              get selecting() {
                return this._selecting;
              }
              get squeezing() {
                return this._squeezing;
              }
              set elementInput(E) {
                this._elementInput !== E &&
                  ((this._elementInput = E),
                  this._elementInput || (this._elementEntity = null));
              }
              get elementInput() {
                return this._elementInput;
              }
              get elementEntity() {
                return this._elementEntity;
              }
              get hitTestSources() {
                return this._hitTestSources;
              }
              update(E) {
                if (this._hand) this._hand.update(E);
                else {
                  if (this._xrInputSource.gripSpace) {
                    const P = E.getPose(
                      this._xrInputSource.gripSpace,
                      this._manager._referenceSpace
                    );
                    P &&
                      (this._grip ||
                        ((this._grip = !0),
                        (this._localTransform = new T.y()),
                        (this._worldTransform = new T.y()),
                        (this._localPosition = new c.A()),
                        (this._localRotation = new g.D())),
                      (this._dirtyLocal = !0),
                      this._localPosition.copy(P.transform.position),
                      this._localRotation.copy(P.transform.orientation));
                  }
                  const v = E.getPose(
                    this._xrInputSource.targetRaySpace,
                    this._manager._referenceSpace
                  );
                  v &&
                    ((this._dirtyRay = !0),
                    this._rayLocal.origin.copy(v.transform.position),
                    this._rayLocal.direction.set(0, 0, -1),
                    y.copy(v.transform.orientation),
                    y.transformVector(
                      this._rayLocal.direction,
                      this._rayLocal.direction
                    ));
                }
              }
              _updateTransforms() {
                this._dirtyLocal &&
                  ((this._dirtyLocal = !1),
                  this._localTransform.setTRS(
                    this._localPosition,
                    this._localRotation,
                    c.A.ONE
                  ));
                const E = this._manager.camera.parent;
                E
                  ? this._worldTransform.mul2(
                      E.getWorldTransform(),
                      this._localTransform
                    )
                  : this._worldTransform.copy(this._localTransform);
              }
              _updateRayTransforms() {
                const E = this._dirtyRay;
                if (((this._dirtyRay = !1), this._manager.camera.parent)) {
                  const P = this._manager.camera.parent.getWorldTransform();
                  P.getTranslation(this._position),
                    this._rotation.setFromMat4(P),
                    this._rotation.transformVector(
                      this._rayLocal.origin,
                      this._ray.origin
                    ),
                    this._ray.origin.add(this._position),
                    this._rotation.transformVector(
                      this._rayLocal.direction,
                      this._ray.direction
                    );
                } else
                  E &&
                    (this._ray.origin.copy(this._rayLocal.origin),
                    this._ray.direction.copy(this._rayLocal.direction));
              }
              getPosition() {
                return this._position
                  ? (this._updateTransforms(),
                    this._worldTransform.getTranslation(this._position),
                    this._position)
                  : null;
              }
              getLocalPosition() {
                return this._localPosition;
              }
              getRotation() {
                return this._rotation
                  ? (this._updateTransforms(),
                    this._rotation.setFromMat4(this._worldTransform),
                    this._rotation)
                  : null;
              }
              getLocalRotation() {
                return this._localRotation;
              }
              getOrigin() {
                return this._updateRayTransforms(), this._ray.origin;
              }
              getDirection() {
                return this._updateRayTransforms(), this._ray.direction;
              }
              hitTestStart(E = {}) {
                E.profile = this._xrInputSource.profiles[0];
                const v = E.callback;
                (E.callback = (P, I) => {
                  I && this.onHitTestSourceAdd(I), v && v(P, I);
                }),
                  this._manager.hitTest.start(E);
              }
              onHitTestSourceAdd(E) {
                this._hitTestSources.push(E),
                  this.fire("hittest:add", E),
                  E.on(
                    "result",
                    function (v, P, I) {
                      I === this && this.fire("hittest:result", E, v, P);
                    },
                    this
                  ),
                  E.once(
                    "remove",
                    function () {
                      this.onHitTestSourceRemove(E),
                        this.fire("hittest:remove", E);
                    },
                    this
                  );
              }
              onHitTestSourceRemove(E) {
                const v = this._hitTestSources.indexOf(E);
                v !== -1 && this._hitTestSources.splice(v, 1);
              }
            }
          },
          7649: (Se, W, a) => {
            "use strict";
            a.d(W, { r: () => g });
            var x = a(5338),
              T = a(5541);
            class g extends x.b {
              constructor(d) {
                super(),
                  (this.manager = void 0),
                  (this._inputSources = []),
                  (this._onInputSourcesChangeEvt = void 0),
                  (this.manager = d),
                  (this._onInputSourcesChangeEvt = (h) => {
                    this._onInputSourcesChange(h);
                  }),
                  this.manager.on("start", this._onSessionStart, this),
                  this.manager.on("end", this._onSessionEnd, this);
              }
              _onSessionStart() {
                const d = this.manager.session;
                d.addEventListener(
                  "inputsourceschange",
                  this._onInputSourcesChangeEvt
                ),
                  d.addEventListener("select", (f) => {
                    const s = this._getByInputSource(f.inputSource);
                    s.update(f.frame),
                      s.fire("select", f),
                      this.fire("select", s, f);
                  }),
                  d.addEventListener("selectstart", (f) => {
                    const s = this._getByInputSource(f.inputSource);
                    s.update(f.frame),
                      (s._selecting = !0),
                      s.fire("selectstart", f),
                      this.fire("selectstart", s, f);
                  }),
                  d.addEventListener("selectend", (f) => {
                    const s = this._getByInputSource(f.inputSource);
                    s.update(f.frame),
                      (s._selecting = !1),
                      s.fire("selectend", f),
                      this.fire("selectend", s, f);
                  }),
                  d.addEventListener("squeeze", (f) => {
                    const s = this._getByInputSource(f.inputSource);
                    s.update(f.frame),
                      s.fire("squeeze", f),
                      this.fire("squeeze", s, f);
                  }),
                  d.addEventListener("squeezestart", (f) => {
                    const s = this._getByInputSource(f.inputSource);
                    s.update(f.frame),
                      (s._squeezing = !0),
                      s.fire("squeezestart", f),
                      this.fire("squeezestart", s, f);
                  }),
                  d.addEventListener("squeezeend", (f) => {
                    const s = this._getByInputSource(f.inputSource);
                    s.update(f.frame),
                      (s._squeezing = !1),
                      s.fire("squeezeend", f),
                      this.fire("squeezeend", s, f);
                  });
                const h = d.inputSources;
                for (let f = 0; f < h.length; f++) this._addInputSource(h[f]);
              }
              _onSessionEnd() {
                let d = this._inputSources.length;
                for (; d--; ) {
                  const f = this._inputSources[d];
                  this._inputSources.splice(d, 1),
                    f.fire("remove"),
                    this.fire("remove", f);
                }
                this.manager.session.removeEventListener(
                  "inputsourceschange",
                  this._onInputSourcesChangeEvt
                );
              }
              _onInputSourcesChange(d) {
                for (let h = 0; h < d.removed.length; h++)
                  this._removeInputSource(d.removed[h]);
                for (let h = 0; h < d.added.length; h++)
                  this._addInputSource(d.added[h]);
              }
              _getByInputSource(d) {
                for (let h = 0; h < this._inputSources.length; h++)
                  if (this._inputSources[h].inputSource === d)
                    return this._inputSources[h];
                return null;
              }
              _addInputSource(d) {
                if (this._getByInputSource(d)) return;
                const h = new T.g(this.manager, d);
                this._inputSources.push(h), this.fire("add", h);
              }
              _removeInputSource(d) {
                for (let h = 0; h < this._inputSources.length; h++) {
                  if (this._inputSources[h].inputSource !== d) continue;
                  const f = this._inputSources[h];
                  this._inputSources.splice(h, 1);
                  let s = f.hitTestSources.length;
                  for (; s--; ) f.hitTestSources[s].remove();
                  f.fire("remove"), this.fire("remove", f);
                  return;
                }
              }
              update(d) {
                for (let h = 0; h < this._inputSources.length; h++)
                  this._inputSources[h].update(d);
              }
              get inputSources() {
                return this._inputSources;
              }
            }
          },
          5268: (Se, W, a) => {
            "use strict";
            a.d(W, { z: () => o });
            var x = a(5338),
              T = a(1367),
              g = a(9758),
              c = a(6847),
              d = a(6556),
              h = a(2872);
            const f = new d.A(),
              s = new d.A(),
              l = new g.y(),
              n = new g.y();
            class o extends x.b {
              constructor(e) {
                super(),
                  (this._manager = void 0),
                  (this._supported = !1),
                  (this._available = !1),
                  (this._lightProbeRequested = !1),
                  (this._lightProbe = null),
                  (this._intensity = 0),
                  (this._rotation = new c.D()),
                  (this._color = new T.I()),
                  (this._sphericalHarmonics = new Float32Array(27)),
                  (this._manager = e),
                  this._manager.on("start", this._onSessionStart, this),
                  this._manager.on("end", this._onSessionEnd, this);
              }
              _onSessionStart() {
                this._manager.session.requestLightProbe &&
                  (this._supported = !0);
              }
              _onSessionEnd() {
                (this._supported = !1),
                  (this._available = !1),
                  (this._lightProbeRequested = !1),
                  (this._lightProbe = null);
              }
              start() {
                let e;
                if (
                  (this._manager.session ||
                    (e = new Error("XR session is not running")),
                  !e &&
                    this._manager.type !== h.UG &&
                    (e = new Error("XR session type is not AR")),
                  !e &&
                    !this._supported &&
                    (e = new Error("light-estimation is not supported")),
                  ((!e && this._lightProbe) || this._lightProbeRequested) &&
                    (e = new Error("light estimation is already requested")),
                  e)
                ) {
                  this.fire("error", e);
                  return;
                }
                (this._lightProbeRequested = !0),
                  this._manager.session
                    .requestLightProbe()
                    .then((t) => {
                      const r = this._lightProbeRequested;
                      (this._lightProbeRequested = !1),
                        this._manager.active
                          ? r && (this._lightProbe = t)
                          : this.fire(
                              "error",
                              new Error("XR session is not active")
                            );
                    })
                    .catch((t) => {
                      (this._lightProbeRequested = !1), this.fire("error", t);
                    });
              }
              end() {
                (this._lightProbeRequested = !1),
                  (this._lightProbe = null),
                  (this._available = !1);
              }
              update(e) {
                if (!this._lightProbe) return;
                const t = e.getLightEstimate(this._lightProbe);
                if (!t) return;
                this._available ||
                  ((this._available = !0), this.fire("available"));
                const r = t.primaryLightIntensity;
                (this._intensity = Math.max(
                  1,
                  Math.max(r.x, Math.max(r.y, r.z))
                )),
                  f.copy(r).mulScalar(1 / this._intensity),
                  this._color.set(f.x, f.y, f.z),
                  f.set(0, 0, 0),
                  s.copy(t.primaryLightDirection),
                  l.setLookAt(s, f, d.A.UP),
                  n.setFromAxisAngle(d.A.RIGHT, 90),
                  l.mul(n),
                  this._rotation.setFromMat4(l),
                  this._sphericalHarmonics.set(
                    t.sphericalHarmonicsCoefficients
                  );
              }
              get supported() {
                return this._supported;
              }
              get available() {
                return this._available;
              }
              get intensity() {
                return this._available ? this._intensity : null;
              }
              get color() {
                return this._available ? this._color : null;
              }
              get rotation() {
                return this._available ? this._rotation : null;
              }
              get sphericalHarmonics() {
                return this._available ? this._sphericalHarmonics : null;
              }
            }
          },
          1502: (Se, W, a) => {
            "use strict";
            a.d(W, { V: () => u });
            var x = a(5338),
              T = a(4444),
              g = a(4486),
              c = a(9758),
              d = a(6847),
              h = a(6556),
              f = a(6630),
              s = a(2872),
              l = a(8657),
              n = a(100),
              o = a(1376),
              i = a(5571),
              e = a(7649),
              t = a(5268),
              r = a(2953);
            class u extends x.b {
              constructor(p) {
                super(),
                  (this.app = void 0),
                  (this._supported = T.J.browser && !!navigator.xr),
                  (this._available = {}),
                  (this._type = null),
                  (this._spaceType = null),
                  (this._session = null),
                  (this._baseLayer = null),
                  (this._referenceSpace = null),
                  (this.depthSensing = void 0),
                  (this.domOverlay = void 0),
                  (this.hitTest = void 0),
                  (this.imageTracking = void 0),
                  (this.planeDetection = void 0),
                  (this.input = void 0),
                  (this.lightEstimation = void 0),
                  (this._camera = null),
                  (this.views = []),
                  (this.viewsPool = []),
                  (this._localPosition = new h.A()),
                  (this._localRotation = new d.D()),
                  (this._depthNear = 0.1),
                  (this._depthFar = 1e3),
                  (this._width = 0),
                  (this._height = 0),
                  (this.app = p),
                  (this._available[s.YW] = !1),
                  (this._available[s.Dd] = !1),
                  (this._available[s.UG] = !1),
                  (this.depthSensing = new l.e(this)),
                  (this.domOverlay = new n.q(this)),
                  (this.hitTest = new o.S(this)),
                  (this.imageTracking = new i.s(this)),
                  (this.planeDetection = new r.r(this)),
                  (this.input = new e.r(this)),
                  (this.lightEstimation = new t.z(this)),
                  this._supported &&
                    (navigator.xr.addEventListener("devicechange", () => {
                      this._deviceAvailabilityCheck();
                    }),
                    this._deviceAvailabilityCheck());
              }
              destroy() {
                this.depthSensing.destroy(), (this.depthSensing = null);
              }
              start(p, _, m, E) {
                let v = E;
                if (
                  (typeof E == "object" && (v = E.callback),
                  !this._available[_])
                ) {
                  v && v(new Error("XR is not available"));
                  return;
                }
                if (this._session) {
                  v && v(new Error("XR session is already started"));
                  return;
                }
                (this._camera = p),
                  (this._camera.camera.xr = this),
                  (this._type = _),
                  (this._spaceType = m),
                  this._setClipPlanes(p.nearClip, p.farClip);
                const P = { requiredFeatures: [m], optionalFeatures: [] };
                if (_ === s.UG) {
                  if (
                    (P.optionalFeatures.push("light-estimation"),
                    P.optionalFeatures.push("hit-test"),
                    E &&
                      (E.imageTracking &&
                        this.imageTracking.supported &&
                        P.optionalFeatures.push("image-tracking"),
                      E.planeDetection &&
                        P.optionalFeatures.push("plane-detection")),
                    this.domOverlay.supported &&
                      this.domOverlay.root &&
                      (P.optionalFeatures.push("dom-overlay"),
                      (P.domOverlay = { root: this.domOverlay.root })),
                    E && E.depthSensing && this.depthSensing.supported)
                  ) {
                    P.optionalFeatures.push("depth-sensing");
                    const I = [s.qr],
                      A = [s.Gu];
                    if (E.depthSensing.usagePreference) {
                      const B = I.indexOf(E.depthSensing.usagePreference);
                      B !== -1 && I.splice(B, 1),
                        I.unshift(E.depthSensing.usagePreference);
                    }
                    if (E.depthSensing.dataFormatPreference) {
                      const B = A.indexOf(E.depthSensing.dataFormatPreference);
                      B !== -1 && A.splice(B, 1),
                        A.unshift(E.depthSensing.dataFormatPreference);
                    }
                    P.depthSensing = {
                      usagePreference: I,
                      dataFormatPreference: A,
                    };
                  }
                } else _ === s.Dd && P.optionalFeatures.push("hand-tracking");
                E &&
                  E.optionalFeatures &&
                  (P.optionalFeatures = P.optionalFeatures.concat(
                    E.optionalFeatures
                  )),
                  this.imageTracking.supported &&
                  this.imageTracking.images.length
                    ? this.imageTracking.prepareImages((I, A) => {
                        if (I) {
                          v && v(I), this.fire("error", I);
                          return;
                        }
                        A !== null && (P.trackedImages = A),
                          this._onStartOptionsReady(_, m, P, v);
                      })
                    : this._onStartOptionsReady(_, m, P, v);
              }
              _onStartOptionsReady(p, _, m, E) {
                navigator.xr
                  .requestSession(p, m)
                  .then((v) => {
                    this._onSessionStart(v, _, E);
                  })
                  .catch((v) => {
                    (this._camera.camera.xr = null),
                      (this._camera = null),
                      (this._type = null),
                      (this._spaceType = null),
                      E && E(v),
                      this.fire("error", v);
                  });
              }
              end(p) {
                if (!this._session) {
                  p && p(new Error("XR Session is not initialized"));
                  return;
                }
                p && this.once("end", p), this._session.end();
              }
              isAvailable(p) {
                return this._available[p];
              }
              _deviceAvailabilityCheck() {
                for (const p in this._available) this._sessionSupportCheck(p);
              }
              _sessionSupportCheck(p) {
                navigator.xr
                  .isSessionSupported(p)
                  .then((_) => {
                    this._available[p] !== _ &&
                      ((this._available[p] = _),
                      this.fire("available", p, _),
                      this.fire("available:" + p, _));
                  })
                  .catch((_) => {
                    this.fire("error", _);
                  });
              }
              _onSessionStart(p, _, m) {
                let E = !1;
                this._session = p;
                const v = () => {
                    this.fire("visibility:change", p.visibilityState);
                  },
                  P = () => {
                    this._setClipPlanes(
                      this._camera.nearClip,
                      this._camera.farClip
                    );
                  },
                  I = () => {
                    this._camera &&
                      (this._camera.off("set_nearClip", P),
                      this._camera.off("set_farClip", P),
                      (this._camera.camera.xr = null),
                      (this._camera = null)),
                      p.removeEventListener("end", I),
                      p.removeEventListener("visibilitychange", v),
                      E || this.fire("end"),
                      (this._session = null),
                      (this._referenceSpace = null),
                      (this.views = []),
                      (this._width = 0),
                      (this._height = 0),
                      (this._type = null),
                      (this._spaceType = null),
                      this.app.tick();
                  };
                p.addEventListener("end", I),
                  p.addEventListener("visibilitychange", v),
                  this._camera.on("set_nearClip", P),
                  this._camera.on("set_farClip", P);
                const A =
                  this.app.graphicsDevice.maxPixelRatio /
                  window.devicePixelRatio;
                (this._baseLayer = new XRWebGLLayer(
                  p,
                  this.app.graphicsDevice.gl,
                  {
                    alpha: !0,
                    depth: !0,
                    stencil: !0,
                    framebufferScaleFactor: A,
                  }
                )),
                  p.updateRenderState({
                    baseLayer: this._baseLayer,
                    depthNear: this._depthNear,
                    depthFar: this._depthFar,
                  }),
                  p
                    .requestReferenceSpace(_)
                    .then((B) => {
                      (this._referenceSpace = B),
                        this.app.tick(),
                        m && m(null),
                        this.fire("start");
                    })
                    .catch((B) => {
                      (E = !0), p.end(), m && m(B), this.fire("error", B);
                    });
              }
              _setClipPlanes(p, _) {
                (this._depthNear === p && this._depthFar === _) ||
                  ((this._depthNear = p),
                  (this._depthFar = _),
                  this._session &&
                    this._session.updateRenderState({
                      depthNear: this._depthNear,
                      depthFar: this._depthFar,
                    }));
              }
              update(p) {
                if (!this._session) return !1;
                const _ = p.session.renderState.baseLayer.framebufferWidth,
                  m = p.session.renderState.baseLayer.framebufferHeight;
                (this._width !== _ || this._height !== m) &&
                  ((this._width = _),
                  (this._height = m),
                  this.app.graphicsDevice.setResolution(_, m));
                const E = p.getViewerPose(this._referenceSpace);
                if (!E) return !1;
                const v = this.views.length,
                  P = E.views.length;
                for (; P > this.views.length; ) {
                  let C = this.viewsPool.pop();
                  C ||
                    (C = {
                      viewport: new f.T(),
                      projMat: new c.y(),
                      viewMat: new c.y(),
                      viewOffMat: new c.y(),
                      viewInvMat: new c.y(),
                      viewInvOffMat: new c.y(),
                      projViewOffMat: new c.y(),
                      viewMat3: new g.T(),
                      position: new Float32Array(3),
                      rotation: new d.D(),
                    }),
                    this.views.push(C);
                }
                for (; P < this.views.length; )
                  this.viewsPool.push(this.views.pop());
                const I = E.transform.position,
                  A = E.transform.orientation;
                this._localPosition.set(I.x, I.y, I.z),
                  this._localRotation.set(A.x, A.y, A.z, A.w);
                const B = p.session.renderState.baseLayer;
                for (let C = 0; C < E.views.length; C++) {
                  const w = E.views[C],
                    k = this.views[C],
                    K = B.getViewport(w);
                  (k.viewport.x = K.x),
                    (k.viewport.y = K.y),
                    (k.viewport.z = K.width),
                    (k.viewport.w = K.height),
                    k.projMat.set(w.projectionMatrix),
                    k.viewMat.set(w.transform.inverse.matrix),
                    k.viewInvMat.set(w.transform.matrix);
                }
                if (v === 0 && this.views.length > 0) {
                  const C = new c.y(),
                    w = this.views[0];
                  C.copy(w.projMat);
                  const k = C.data,
                    K = (2 * Math.atan(1 / k[5]) * 180) / Math.PI,
                    te = k[5] / k[0],
                    X = k[14] / (k[10] + 1),
                    $ = k[14] / (k[10] - 1),
                    ne = !1;
                  this._camera.camera.setXrProperties({
                    aspectRatio: te,
                    farClip: X,
                    fov: K,
                    horizontalFov: ne,
                    nearClip: $,
                  });
                }
                return (
                  this._camera.camera._node.setLocalPosition(
                    this._localPosition
                  ),
                  this._camera.camera._node.setLocalRotation(
                    this._localRotation
                  ),
                  this.input.update(p),
                  this._type === s.UG &&
                    (this.hitTest.supported && this.hitTest.update(p),
                    this.lightEstimation.supported &&
                      this.lightEstimation.update(p),
                    this.depthSensing.supported &&
                      this.depthSensing.update(p, E && E.views[0]),
                    this.imageTracking.supported &&
                      this.imageTracking.update(p),
                    this.planeDetection.supported &&
                      this.planeDetection.update(p)),
                  this.fire("update", p),
                  !0
                );
              }
              get supported() {
                return this._supported;
              }
              get active() {
                return !!this._session;
              }
              get type() {
                return this._type;
              }
              get spaceType() {
                return this._spaceType;
              }
              get session() {
                return this._session;
              }
              get camera() {
                return this._camera ? this._camera.entity : null;
              }
              get visibilityState() {
                return this._session ? this._session.visibilityState : null;
              }
            }
          },
          2953: (Se, W, a) => {
            "use strict";
            a.d(W, { r: () => c });
            var x = a(4444),
              T = a(5338),
              g = a(8010);
            class c extends T.b {
              constructor(h) {
                super(),
                  (this._manager = void 0),
                  (this._supported = x.J.browser && !!window.XRPlane),
                  (this._available = !1),
                  (this._planesIndex = new Map()),
                  (this._planes = null),
                  (this._manager = h),
                  this._supported &&
                    this._manager.on("end", this._onSessionEnd, this);
              }
              _onSessionEnd() {
                if (this._planes)
                  for (let h = 0; h < this._planes.length; h++)
                    this._planes[h].destroy();
                this._planesIndex.clear(),
                  (this._planes = null),
                  this._available &&
                    ((this._available = !1), this.fire("unavailable"));
              }
              update(h) {
                let f;
                if (this._available) f = h.detectedPlanes;
                else
                  try {
                    (f = h.detectedPlanes),
                      (this._planes = []),
                      (this._available = !0),
                      this.fire("available");
                  } catch (s) {
                    return;
                  }
                for (const [s, l] of this._planesIndex)
                  f.has(s) ||
                    (this._planesIndex.delete(s),
                    this._planes.splice(this._planes.indexOf(l), 1),
                    l.destroy(),
                    this.fire("remove", l));
                for (const s of f) {
                  let l = this._planesIndex.get(s);
                  l
                    ? l.update(h)
                    : ((l = new g.c(this, s)),
                      this._planesIndex.set(s, l),
                      this._planes.push(l),
                      l.update(h),
                      this.fire("add", l));
                }
              }
              get supported() {
                return this._supported;
              }
              get available() {
                return this._available;
              }
              get planes() {
                return this._planes;
              }
            }
          },
          8010: (Se, W, a) => {
            "use strict";
            a.d(W, { c: () => d });
            var x = a(5338),
              T = a(6847),
              g = a(6556);
            let c = 0;
            class d extends x.b {
              constructor(f, s) {
                super(),
                  (this._id = void 0),
                  (this._planeDetection = void 0),
                  (this._xrPlane = void 0),
                  (this._lastChangedTime = void 0),
                  (this._orientation = void 0),
                  (this._position = new g.A()),
                  (this._rotation = new T.D()),
                  (this._id = ++c),
                  (this._planeDetection = f),
                  (this._xrPlane = s),
                  (this._lastChangedTime = s.lastChangedTime),
                  (this._orientation = s.orientation);
              }
              destroy() {
                this.fire("remove");
              }
              update(f) {
                const s = this._planeDetection._manager,
                  l = f.getPose(this._xrPlane.planeSpace, s._referenceSpace);
                l &&
                  (this._position.copy(l.transform.position),
                  this._rotation.copy(l.transform.orientation)),
                  this._lastChangedTime !== this._xrPlane.lastChangedTime &&
                    ((this._lastChangedTime = this._xrPlane.lastChangedTime),
                    this.fire("change"));
              }
              getPosition() {
                return this._position;
              }
              getRotation() {
                return this._rotation;
              }
              get id() {
                return this._id;
              }
              get orientation() {
                return this._orientation;
              }
              get points() {
                return this._xrPlane.polygon;
              }
            }
          },
          6337: (Se, W, a) => {
            "use strict";
            a.d(W, { J: () => c });
            var x = a(5338),
              T = a(6556),
              g = a(6847);
            class c extends x.b {
              constructor(h, f) {
                super(),
                  (this._image = void 0),
                  (this._width = void 0),
                  (this._bitmap = null),
                  (this._measuredWidth = 0),
                  (this._trackable = !1),
                  (this._tracking = !1),
                  (this._emulated = !1),
                  (this._pose = null),
                  (this._position = new T.A()),
                  (this._rotation = new g.D()),
                  (this._image = h),
                  (this._width = f);
              }
              get image() {
                return this._image;
              }
              set width(h) {
                this._width = h;
              }
              get width() {
                return this._width;
              }
              get trackable() {
                return this._trackable;
              }
              get tracking() {
                return this._tracking;
              }
              get emulated() {
                return this._emulated;
              }
              prepare() {
                return this._bitmap
                  ? { image: this._bitmap, widthInMeters: this._width }
                  : createImageBitmap(this._image).then(
                      (h) => (
                        (this._bitmap = h),
                        { image: this._bitmap, widthInMeters: this._width }
                      )
                    );
              }
              destroy() {
                (this._image = null),
                  (this._pose = null),
                  this._bitmap && (this._bitmap.close(), (this._bitmap = null));
              }
              getPosition() {
                return (
                  this._pose &&
                    this._position.copy(this._pose.transform.position),
                  this._position
                );
              }
              getRotation() {
                return (
                  this._pose &&
                    this._rotation.copy(this._pose.transform.orientation),
                  this._rotation
                );
              }
            }
          },
          3620: (Se, W, a) => {
            "use strict";
            a.r(W),
              a.d(W, {
                ABSOLUTE_URL: () => Fs.P1,
                ACTION_GAMEPAD: () => Fe.FV,
                ACTION_KEYBOARD: () => Fe.Jx,
                ACTION_MOUSE: () => Fe.C0,
                ADDRESS_CLAMP_TO_EDGE: () => O.uFb,
                ADDRESS_MIRRORED_REPEAT: () => O.nVg,
                ADDRESS_REPEAT: () => O.SuC,
                ANIM_BLEND_1D: () => cs.YB,
                ANIM_BLEND_2D_CARTESIAN: () => cs.Ju,
                ANIM_BLEND_2D_DIRECTIONAL: () => cs.cV,
                ANIM_BLEND_DIRECT: () => cs.Pp,
                ANIM_CONTROL_STATES: () => cs.Fw,
                ANIM_EQUAL_TO: () => cs.j6,
                ANIM_GREATER_THAN: () => cs.t1,
                ANIM_GREATER_THAN_EQUAL_TO: () => cs.ju,
                ANIM_INTERRUPTION_NEXT: () => cs.Qn,
                ANIM_INTERRUPTION_NEXT_PREV: () => cs.lV,
                ANIM_INTERRUPTION_NONE: () => cs.s6,
                ANIM_INTERRUPTION_PREV: () => cs.IF,
                ANIM_INTERRUPTION_PREV_NEXT: () => cs.hq,
                ANIM_LAYER_ADDITIVE: () => cs.v1,
                ANIM_LAYER_OVERWRITE: () => cs.xU,
                ANIM_LESS_THAN: () => cs.RZ,
                ANIM_LESS_THAN_EQUAL_TO: () => cs.gk,
                ANIM_NOT_EQUAL_TO: () => cs.vT,
                ANIM_PARAMETER_BOOLEAN: () => cs.p2,
                ANIM_PARAMETER_FLOAT: () => cs.yg,
                ANIM_PARAMETER_INTEGER: () => cs.qR,
                ANIM_PARAMETER_TRIGGER: () => cs.S5,
                ANIM_STATE_ANY: () => cs.i_,
                ANIM_STATE_END: () => cs.JK,
                ANIM_STATE_START: () => cs.So,
                ASPECT_AUTO: () => Ke.HJ,
                ASPECT_MANUAL: () => Ke.Gr,
                ASSET_ANIMATION: () => Fs.ql,
                ASSET_AUDIO: () => Fs.V7,
                ASSET_CONTAINER: () => Fs.mu,
                ASSET_CSS: () => Fs.pU,
                ASSET_CUBEMAP: () => Fs.Ex,
                ASSET_HTML: () => Fs.IS,
                ASSET_IMAGE: () => Fs.CZ,
                ASSET_JSON: () => Fs.Zf,
                ASSET_MATERIAL: () => Fs.g9,
                ASSET_MODEL: () => Fs.SV,
                ASSET_SCRIPT: () => Fs.MH,
                ASSET_SHADER: () => Fs.I0,
                ASSET_TEXT: () => Fs.bB,
                ASSET_TEXTURE: () => Fs.Ve,
                ASSET_TEXTUREATLAS: () => Fs.GY,
                AXIS_KEY: () => Fe.vA,
                AXIS_MOUSE_X: () => Fe.h1,
                AXIS_MOUSE_Y: () => Fe.cJ,
                AXIS_PAD_L_X: () => Fe.JX,
                AXIS_PAD_L_Y: () => Fe.xY,
                AXIS_PAD_R_X: () => Fe.vN,
                AXIS_PAD_R_Y: () => Fe.dL,
                AnimBinder: () => ar.S,
                AnimClip: () => or.L,
                AnimClipHandler: () => wr.m,
                AnimComponent: () => Vi.l,
                AnimComponentLayer: () => Gi._,
                AnimComponentSystem: () => an.R,
                AnimController: () => mr.o,
                AnimCurve: () => lr.c,
                AnimData: () => hr.X,
                AnimEvaluator: () => cr.g,
                AnimEvents: () => fr.D,
                AnimSnapshot: () => dr.e,
                AnimStateGraph: () => gr.Z,
                AnimStateGraphHandler: () => Ir.O,
                AnimTarget: () => ur.e,
                AnimTrack: () => pr.k,
                Animation: () => Pi.fw,
                AnimationComponent: () => ki.c,
                AnimationComponentSystem: () => rn._,
                AnimationHandler: () => Rr.n,
                AppBase: () => Wi.k,
                AppOptions: () => sn.U,
                Application: () => nn.M,
                Asset: () => jn.x,
                AssetListLoader: () => yr,
                AssetReference: () => vr.M,
                AssetRegistry: () => Er.o,
                AudioHandler: () => Dr.Z,
                AudioListenerComponent: () => on.r,
                AudioListenerComponentSystem: () => oi.n,
                AudioSourceComponent: () => ii.Q,
                AudioSourceComponentSystem: () => ln.D,
                BAKE_COLOR: () => Ke.Au,
                BAKE_COLORDIR: () => Ke.FB,
                BINDGROUP_MESH: () => O.Ak$,
                BINDGROUP_VIEW: () => O.Qqf,
                BLENDEQUATION_ADD: () => O.cn$,
                BLENDEQUATION_MAX: () => O.uAW,
                BLENDEQUATION_MIN: () => O.xJm,
                BLENDEQUATION_REVERSE_SUBTRACT: () => O.b4e,
                BLENDEQUATION_SUBTRACT: () => O.NFS,
                BLENDMODE_CONSTANT: () => O.Q8W,
                BLENDMODE_CONSTANT_ALPHA: () => Xt.Js,
                BLENDMODE_CONSTANT_COLOR: () => Xt.CF,
                BLENDMODE_DST_ALPHA: () => O.liJ,
                BLENDMODE_DST_COLOR: () => O.CZC,
                BLENDMODE_ONE: () => O.NdT,
                BLENDMODE_ONE_MINUS_CONSTANT: () => O.Ax$,
                BLENDMODE_ONE_MINUS_CONSTANT_ALPHA: () => Xt.yC,
                BLENDMODE_ONE_MINUS_CONSTANT_COLOR: () => Xt.nl,
                BLENDMODE_ONE_MINUS_DST_ALPHA: () => O.hJD,
                BLENDMODE_ONE_MINUS_DST_COLOR: () => O.PDh,
                BLENDMODE_ONE_MINUS_SRC_ALPHA: () => O.Hiv,
                BLENDMODE_ONE_MINUS_SRC_COLOR: () => O.gXY,
                BLENDMODE_SRC_ALPHA: () => O._HM,
                BLENDMODE_SRC_ALPHA_SATURATE: () => O.OVG,
                BLENDMODE_SRC_COLOR: () => O.RR1,
                BLENDMODE_ZERO: () => O.rqb,
                BLEND_ADDITIVE: () => Ke.$U,
                BLEND_ADDITIVEALPHA: () => Ke.Yk,
                BLEND_MAX: () => Ke.rR,
                BLEND_MIN: () => Ke.yl,
                BLEND_MULTIPLICATIVE: () => Ke.ch,
                BLEND_MULTIPLICATIVE2X: () => Ke.oF,
                BLEND_NONE: () => Ke.He,
                BLEND_NORMAL: () => Ke.lA,
                BLEND_PREMULTIPLIED: () => Ke.yp,
                BLEND_SCREEN: () => Ke.Sh,
                BLEND_SUBTRACTIVE: () => Ke.C1,
                BLUR_BOX: () => Ke.M,
                BLUR_GAUSSIAN: () => Ke.J2,
                BODYFLAG_KINEMATIC_OBJECT: () => es.tU,
                BODYFLAG_NORESPONSE_OBJECT: () => es.ge,
                BODYFLAG_STATIC_OBJECT: () => es.zG,
                BODYGROUP_DEFAULT: () => es.vp,
                BODYGROUP_DYNAMIC: () => es.hQ,
                BODYGROUP_ENGINE_1: () => es.pM,
                BODYGROUP_ENGINE_2: () => es.A4,
                BODYGROUP_ENGINE_3: () => es.RH,
                BODYGROUP_KINEMATIC: () => es.o9,
                BODYGROUP_NONE: () => es.n2,
                BODYGROUP_STATIC: () => es.F8,
                BODYGROUP_TRIGGER: () => es.Im,
                BODYGROUP_USER_1: () => es.jy,
                BODYGROUP_USER_2: () => es.NF,
                BODYGROUP_USER_3: () => es.Es,
                BODYGROUP_USER_4: () => es.Kl,
                BODYGROUP_USER_5: () => es.$4,
                BODYGROUP_USER_6: () => es.ct,
                BODYGROUP_USER_7: () => es.KM,
                BODYGROUP_USER_8: () => es.VG,
                BODYMASK_ALL: () => es.jh,
                BODYMASK_NONE: () => es.q9,
                BODYMASK_NOT_STATIC: () => es.wn,
                BODYMASK_NOT_STATIC_KINEMATIC: () => es.Kf,
                BODYMASK_STATIC: () => es._V,
                BODYSTATE_ACTIVE_TAG: () => es.sc,
                BODYSTATE_DISABLE_DEACTIVATION: () => es.Ln,
                BODYSTATE_DISABLE_SIMULATION: () => es.AE,
                BODYSTATE_ISLAND_SLEEPING: () => es.qi,
                BODYSTATE_WANTS_DEACTIVATION: () => es.SN,
                BODYTYPE_DYNAMIC: () => es.YZ,
                BODYTYPE_KINEMATIC: () => es.oV,
                BODYTYPE_STATIC: () => es.eg,
                BUFFER_DYNAMIC: () => O.AHc,
                BUFFER_GPUDYNAMIC: () => O.Tfk,
                BUFFER_STATIC: () => O.dxy,
                BUFFER_STREAM: () => O.oWk,
                BUTTON_TRANSITION_MODE_SPRITE_CHANGE: () => li.v,
                BUTTON_TRANSITION_MODE_TINT: () => li.C,
                BasicMaterial: () => ys.K,
                Batch: () => ps.E,
                BatchGroup: () => Ns.y,
                BatchManager: () => bs.D,
                BinaryHandler: () => Or.o,
                BlendState: () => Ae.a,
                BoundingBox: () => w.k,
                BoundingSphere: () => k.K,
                Bundle: () => Ar.b,
                BundleHandler: () => Lr.p,
                BundleRegistry: () => Cr.X,
                ButtonComponent: () => hn.r,
                ButtonComponentSystem: () => cn.n,
                CHUNKAPI_1_51: () => O.gJK,
                CHUNKAPI_1_55: () => O.aA6,
                CHUNKAPI_1_56: () => O.KZS,
                CHUNKAPI_1_57: () => O.dKq,
                CHUNKAPI_1_58: () => O._wK,
                CHUNKAPI_1_60: () => O.R0Y,
                CHUNKAPI_1_62: () => O.vec,
                CHUNKAPI_1_65: () => O.lmt,
                CLEARFLAG_COLOR: () => O.Zzy,
                CLEARFLAG_DEPTH: () => O.zk9,
                CLEARFLAG_STENCIL: () => O.$tA,
                COMPUPDATED_BLEND: () => Ke.Ei,
                COMPUPDATED_CAMERAS: () => Ke.w7,
                COMPUPDATED_INSTANCES: () => Ke.GI,
                COMPUPDATED_LIGHTS: () => Ke.S9,
                CUBEFACE_NEGX: () => O.cAh,
                CUBEFACE_NEGY: () => O.hw4,
                CUBEFACE_NEGZ: () => O.piJ,
                CUBEFACE_POSX: () => O.UD6,
                CUBEFACE_POSY: () => O.$E,
                CUBEFACE_POSZ: () => O.$B1,
                CUBEPROJ_BOX: () => Ke.jJ,
                CUBEPROJ_NONE: () => Ke.AM,
                CULLFACE_BACK: () => O.Ak1,
                CULLFACE_FRONT: () => O.TWf,
                CULLFACE_FRONTANDBACK: () => O.QKK,
                CULLFACE_NONE: () => O.OL2,
                CURVE_CARDINAL: () => y.C0,
                CURVE_CATMULL: () => y.X3,
                CURVE_LINEAR: () => y.Tr,
                CURVE_SMOOTHSTEP: () => y.xS,
                CURVE_SPLINE: () => y.pj,
                CURVE_STEP: () => y.ZP,
                Camera: () => Ws.V,
                CameraComponent: () => Ls.M,
                CameraComponentSystem: () => xn.r,
                CanvasFont: () => xr,
                ChunkBuilder: () => We.R,
                CollisionComponent: () => wi.k,
                CollisionComponentSystem: () => An._,
                Color: () => _.I,
                Command: () => Is.m,
                Component: () => _n.w,
                ComponentSystem: () => Cn.Q,
                ComponentSystemRegistry: () => mn.s,
                ContactPoint: () => un.SQ,
                ContactResult: () => un.sT,
                ContainerHandler: () => Zn.F,
                ContainerResource: () => Zn.T,
                ContextCreationError: () => Xt._A,
                Controller: () => Yt.Q,
                CssHandler: () => Br.s,
                CubemapHandler: () => Fr.o,
                Curve: () => m.H,
                CurveSet: () => E.e,
                DETAILMODE_ADD: () => Ke.Ar,
                DETAILMODE_MAX: () => Ke.PH,
                DETAILMODE_MIN: () => Ke.Vy,
                DETAILMODE_MUL: () => Ke.pk,
                DETAILMODE_OVERLAY: () => Ke.Vf,
                DETAILMODE_SCREEN: () => Ke._u,
                DEVICETYPE_WEBGL1: () => O.qYt,
                DEVICETYPE_WEBGL2: () => O.agD,
                DEVICETYPE_WEBGPU: () => O.dJb,
                DISTANCE_EXPONENTIAL: () => pe.r1,
                DISTANCE_INVERSE: () => pe.mU,
                DISTANCE_LINEAR: () => pe.WY,
                DefaultAnimBinder: () => _r.o,
                DepthState: () => st.b,
                ELEMENTTYPE_FLOAT32: () => Xt.$s,
                ELEMENTTYPE_GROUP: () => gi.Kv,
                ELEMENTTYPE_IMAGE: () => gi.rf,
                ELEMENTTYPE_INT16: () => Xt.zx,
                ELEMENTTYPE_INT32: () => Xt.H3,
                ELEMENTTYPE_INT8: () => Xt.f6,
                ELEMENTTYPE_TEXT: () => gi.l2,
                ELEMENTTYPE_UINT16: () => Xt.Ki,
                ELEMENTTYPE_UINT32: () => Xt.Zz,
                ELEMENTTYPE_UINT8: () => Xt.Xw,
                EMITTERSHAPE_BOX: () => Ke.EB,
                EMITTERSHAPE_SPHERE: () => Ke.mx,
                EVENT_GAMEPADCONNECTED: () => Fe.kg,
                EVENT_GAMEPADDISCONNECTED: () => Fe.Uq,
                EVENT_KEYDOWN: () => Fe.QB,
                EVENT_KEYUP: () => Fe.O,
                EVENT_MOUSEDOWN: () => Fe.tw,
                EVENT_MOUSEMOVE: () => Fe.qq,
                EVENT_MOUSEUP: () => Fe.L_,
                EVENT_MOUSEWHEEL: () => Fe.SN,
                EVENT_SELECT: () => Fe.NM,
                EVENT_SELECTEND: () => Fe.EI,
                EVENT_SELECTSTART: () => Fe.KV,
                EVENT_TOUCHCANCEL: () => Fe.Rm,
                EVENT_TOUCHEND: () => Fe.Lx,
                EVENT_TOUCHMOVE: () => Fe.Nj,
                EVENT_TOUCHSTART: () => Fe.V,
                ElementComponent: () => Pn.o,
                ElementComponentSystem: () => $t.h,
                ElementDragHelper: () => gn.d,
                ElementInput: () => bn.RR,
                ElementInputEvent: () => bn.$K,
                ElementMouseEvent: () => bn.sH,
                ElementSelectEvent: () => bn.JB,
                ElementTouchEvent: () => bn.PI,
                Entity: () => ee.J,
                EntityReference: () => S.e,
                EnvLighting: () => Ji.C,
                EventHandler: () => s.b,
                FILLMODE_FILL_WINDOW: () => mi.Qb,
                FILLMODE_KEEP_ASPECT: () => mi.Wx,
                FILLMODE_NONE: () => mi.DP,
                FILTER_LINEAR: () => O.I5X,
                FILTER_LINEAR_MIPMAP_LINEAR: () => O.Snx,
                FILTER_LINEAR_MIPMAP_NEAREST: () => O.feq,
                FILTER_NEAREST: () => O.yib,
                FILTER_NEAREST_MIPMAP_LINEAR: () => O.$_P,
                FILTER_NEAREST_MIPMAP_NEAREST: () => O.Aap,
                FITMODE_CONTAIN: () => gi.fM,
                FITMODE_COVER: () => gi.cm,
                FITMODE_STRETCH: () => gi.gc,
                FITTING_BOTH: () => Bt.F9,
                FITTING_NONE: () => Bt.hz,
                FITTING_SHRINK: () => Bt.zL,
                FITTING_STRETCH: () => Bt.az,
                FOG_EXP: () => Ke.KE,
                FOG_EXP2: () => Ke.En,
                FOG_LINEAR: () => Ke.ce,
                FOG_NONE: () => Ke.YV,
                FONT_BITMAP: () => Yn.M,
                FONT_MSDF: () => Yn.E,
                FRESNEL_NONE: () => Ke.SD,
                FRESNEL_SCHLICK: () => Ke.Rx,
                FUNC_ALWAYS: () => O.g8z,
                FUNC_EQUAL: () => O._v4,
                FUNC_GREATER: () => O.Lp7,
                FUNC_GREATEREQUAL: () => O.ZIZ,
                FUNC_LESS: () => O.n9,
                FUNC_LESSEQUAL: () => O.u9l,
                FUNC_NEVER: () => O._3e,
                FUNC_NOTEQUAL: () => O.qVn,
                FolderHandler: () => Ur.s,
                Font: () => Tr.Z,
                FontHandler: () => Nr.G,
                ForwardRenderer: () => ei.g,
                Frustum: () => K.i,
                GAMMA_NONE: () => Ke.Ie,
                GAMMA_SRGB: () => Ke.DZ,
                GAMMA_SRGBFAST: () => Ke.O1,
                GAMMA_SRGBHDR: () => Ke.CH,
                GamePads: () => Ot.pF,
                GraphNode: () => Js.A,
                GraphicsDevice: () => me.$,
                HierarchyHandler: () => zr.c,
                HtmlHandler: () => Wr.x,
                Http: () => ss.e,
                I18n: () => aa.o,
                INDEXFORMAT_UINT16: () => O.q0F,
                INDEXFORMAT_UINT32: () => O.qCh,
                INDEXFORMAT_UINT8: () => O.fUD,
                INTERPOLATION_CUBIC: () => kn.Qf,
                INTERPOLATION_LINEAR: () => kn.NW,
                INTERPOLATION_STEP: () => kn.B3,
                ImageElement: () => D.K,
                IndexBuffer: () => ot.G,
                IndexedList: () => l._,
                JointComponent: () => Ce.T,
                JointComponentSystem: () => Ue.m,
                JsonHandler: () => kr.G,
                JsonStandardMaterialParser: () => sa.r,
                KEY_0: () => Fe.Fi,
                KEY_1: () => Fe.Ec,
                KEY_2: () => Fe.IZ,
                KEY_3: () => Fe.Vy,
                KEY_4: () => Fe.K3,
                KEY_5: () => Fe.Ww,
                KEY_6: () => Fe.K5,
                KEY_7: () => Fe.dy,
                KEY_8: () => Fe.ci,
                KEY_9: () => Fe.II,
                KEY_A: () => Fe.Kx,
                KEY_ADD: () => Fe.D5,
                KEY_ALT: () => Fe.cm,
                KEY_B: () => Fe.OE,
                KEY_BACKSPACE: () => Fe.j,
                KEY_BACK_SLASH: () => Fe.pp,
                KEY_C: () => Fe.Hx,
                KEY_CAPS_LOCK: () => Fe.dv,
                KEY_CLOSE_BRACKET: () => Fe.b8,
                KEY_COMMA: () => Fe.sY,
                KEY_CONTEXT_MENU: () => Fe.dz,
                KEY_CONTROL: () => Fe.YE,
                KEY_D: () => Fe.WR,
                KEY_DECIMAL: () => Fe.X2,
                KEY_DELETE: () => Fe.Ze,
                KEY_DIVIDE: () => Fe.ck,
                KEY_DOWN: () => Fe.Hb,
                KEY_E: () => Fe.OY,
                KEY_END: () => Fe.yM,
                KEY_ENTER: () => Fe.tt,
                KEY_EQUAL: () => Fe.w9,
                KEY_ESCAPE: () => Fe.KW,
                KEY_F: () => Fe.As,
                KEY_F1: () => Fe.Bo,
                KEY_F10: () => Fe.R5,
                KEY_F11: () => Fe.Ii,
                KEY_F12: () => Fe._m,
                KEY_F2: () => Fe.uk,
                KEY_F3: () => Fe.m9,
                KEY_F4: () => Fe.uV,
                KEY_F5: () => Fe.mY,
                KEY_F6: () => Fe.Yv,
                KEY_F7: () => Fe.XI,
                KEY_F8: () => Fe.pU,
                KEY_F9: () => Fe.we,
                KEY_G: () => Fe.G9,
                KEY_H: () => Fe.Dg,
                KEY_HOME: () => Fe.hv,
                KEY_I: () => Fe.wE,
                KEY_INSERT: () => Fe.bG,
                KEY_J: () => Fe.CA,
                KEY_K: () => Fe.$K,
                KEY_L: () => Fe.iG,
                KEY_LEFT: () => Fe.ob,
                KEY_M: () => Fe.GB,
                KEY_META: () => Fe.UK,
                KEY_MULTIPLY: () => Fe.Bq,
                KEY_N: () => Fe.j6,
                KEY_NUMPAD_0: () => Fe.iH,
                KEY_NUMPAD_1: () => Fe.Cz,
                KEY_NUMPAD_2: () => Fe.E3,
                KEY_NUMPAD_3: () => Fe.EQ,
                KEY_NUMPAD_4: () => Fe.wJ,
                KEY_NUMPAD_5: () => Fe.aK,
                KEY_NUMPAD_6: () => Fe.y1,
                KEY_NUMPAD_7: () => Fe.PD,
                KEY_NUMPAD_8: () => Fe.$W,
                KEY_NUMPAD_9: () => Fe.bC,
                KEY_O: () => Fe.tm,
                KEY_OPEN_BRACKET: () => Fe.IJ,
                KEY_P: () => Fe.R9,
                KEY_PAGE_DOWN: () => Fe.Qk,
                KEY_PAGE_UP: () => Fe.rU,
                KEY_PAUSE: () => Fe.zS,
                KEY_PERIOD: () => Fe.Ct,
                KEY_PRINT_SCREEN: () => Fe.T,
                KEY_Q: () => Fe.GJ,
                KEY_R: () => Fe.Qh,
                KEY_RETURN: () => Fe.AC,
                KEY_RIGHT: () => Fe.iB,
                KEY_S: () => Fe.RI,
                KEY_SEMICOLON: () => Fe.B9,
                KEY_SEPARATOR: () => Fe.oZ,
                KEY_SHIFT: () => Fe.pN,
                KEY_SLASH: () => Fe.qV,
                KEY_SPACE: () => Fe.PC,
                KEY_SUBTRACT: () => Fe.dR,
                KEY_T: () => Fe.wW,
                KEY_TAB: () => Fe.HF,
                KEY_U: () => Fe.Ax,
                KEY_UP: () => Fe.R4,
                KEY_V: () => Fe.O7,
                KEY_W: () => Fe.fQ,
                KEY_WINDOWS: () => Fe.MR,
                KEY_X: () => Fe.GU,
                KEY_Y: () => Fe.sI,
                KEY_Z: () => Fe.au,
                Key: () => Pi.sr,
                Keyboard: () => Rt.N,
                KeyboardEvent: () => Kt._,
                LAYERID_DEPTH: () => Ke.Pp,
                LAYERID_IMMEDIATE: () => Ke.vt,
                LAYERID_SKYBOX: () => Ke.Fk,
                LAYERID_UI: () => Ke.Q7,
                LAYERID_WORLD: () => Ke.kY,
                LAYER_FX: () => Ke.ly,
                LAYER_GIZMO: () => Ke.yk,
                LAYER_HUD: () => Ke._3,
                LAYER_WORLD: () => Ke.G,
                LIGHTFALLOFF_INVERSESQUARED: () => Ke.m8,
                LIGHTFALLOFF_LINEAR: () => Ke.MU,
                LIGHTSHAPE_DISK: () => Ke.Lf,
                LIGHTSHAPE_PUNCTUAL: () => Ke.pI,
                LIGHTSHAPE_RECT: () => Ke.XD,
                LIGHTSHAPE_SPHERE: () => Ke.zy,
                LIGHTTYPE_COUNT: () => Ke.$i,
                LIGHTTYPE_DIRECTIONAL: () => Ke.WQ,
                LIGHTTYPE_OMNI: () => Ke.bA,
                LIGHTTYPE_POINT: () => Ke.lR,
                LIGHTTYPE_SPOT: () => Ke.z0,
                LINEBATCH_GIZMO: () => Ke.j9,
                LINEBATCH_OVERLAY: () => Ke.Pk,
                LINEBATCH_WORLD: () => Ke.Jq,
                Layer: () => ti.m,
                LayerComposition: () => Bs.d,
                LayoutCalculator: () => rt.S,
                LayoutChildComponent: () => Je.v,
                LayoutChildComponentSystem: () => St.G,
                LayoutGroupComponent: () => Nt.k,
                LayoutGroupComponentSystem: () => Ht.T,
                Light: () => si._,
                LightComponent: () => ns.r0,
                LightComponentSystem: () => xs.i,
                LightingParams: () => Ti.w,
                Lightmapper: () => _s.T,
                LitMaterial: () => Ps,
                LitOptions: () => Xt.ZI,
                LitShaderOptions: () => ks.F,
                LocalizedAsset: () => Sr.E,
                MASK_AFFECT_DYNAMIC: () => Ke.BN,
                MASK_AFFECT_LIGHTMAPPED: () => Ke.gN,
                MASK_BAKE: () => Ke.ew,
                MOTION_FREE: () => le.Pk,
                MOTION_LIMITED: () => le.q8,
                MOTION_LOCKED: () => le.wg,
                MOUSEBUTTON_LEFT: () => Fe.kj,
                MOUSEBUTTON_MIDDLE: () => Fe.v_,
                MOUSEBUTTON_NONE: () => Fe.mf,
                MOUSEBUTTON_RIGHT: () => Fe.bT,
                Mat3: () => v.T,
                Mat4: () => P.y,
                Material: () => ws.F,
                MaterialHandler: () => Vr.r,
                Mesh: () => xi.K,
                MeshInstance: () => Is.l,
                Model: () => ai.H,
                ModelComponent: () => Rs.v,
                ModelComponentSystem: () => ms.w,
                ModelHandler: () => Gr.U,
                Morph: () => Qs._,
                MorphInstance: () => ji.w,
                MorphTarget: () => Di.Y,
                Mouse: () => Lt.T,
                MouseEvent: () => Ft.T,
                Node: () => Pi.NB,
                ORIENTATION_HORIZONTAL: () => Ke.gC,
                ORIENTATION_VERTICAL: () => Ke.Gh,
                OrientedBox: () => Z,
                PAD_1: () => Fe.QA,
                PAD_2: () => Fe.sT,
                PAD_3: () => Fe.MH,
                PAD_4: () => Fe.j9,
                PAD_DOWN: () => Fe.VF,
                PAD_FACE_1: () => Fe.IU,
                PAD_FACE_2: () => Fe.R7,
                PAD_FACE_3: () => Fe.vi,
                PAD_FACE_4: () => Fe.JD,
                PAD_LEFT: () => Fe.nr,
                PAD_L_SHOULDER_1: () => Fe._l,
                PAD_L_SHOULDER_2: () => Fe.Eq,
                PAD_L_STICK_BUTTON: () => Fe._Q,
                PAD_L_STICK_X: () => Fe.an,
                PAD_L_STICK_Y: () => Fe.zL,
                PAD_RIGHT: () => Fe.Ly,
                PAD_R_SHOULDER_1: () => Fe.cM,
                PAD_R_SHOULDER_2: () => Fe.PI,
                PAD_R_STICK_BUTTON: () => Fe.HY,
                PAD_R_STICK_X: () => Fe.Bx,
                PAD_R_STICK_Y: () => Fe.en,
                PAD_SELECT: () => Fe.mB,
                PAD_START: () => Fe.lL,
                PAD_UP: () => Fe.Fe,
                PAD_VENDOR: () => Fe.Tt,
                PARTICLEMODE_CPU: () => Ke.rX,
                PARTICLEMODE_GPU: () => Ke.Fg,
                PARTICLEORIENTATION_EMITTER: () => Ke.uk,
                PARTICLEORIENTATION_SCREEN: () => Ke.d3,
                PARTICLEORIENTATION_WORLD: () => Ke.GS,
                PARTICLESORT_DISTANCE: () => Ke.Ug,
                PARTICLESORT_NEWER_FIRST: () => Ke.i,
                PARTICLESORT_NONE: () => Ke.XV,
                PARTICLESORT_OLDER_FIRST: () => Ke.JF,
                PIXELFORMAT_111110F: () => O.kYl,
                PIXELFORMAT_A8: () => O.fGB,
                PIXELFORMAT_ASTC_4x4: () => O.JOC,
                PIXELFORMAT_ATC_RGB: () => O.$4V,
                PIXELFORMAT_ATC_RGBA: () => O.iJ1,
                PIXELFORMAT_BGRA8: () => O.ka9,
                PIXELFORMAT_DEPTH: () => O.EFh,
                PIXELFORMAT_DEPTHSTENCIL: () => O.sUt,
                PIXELFORMAT_DXT1: () => O.TES,
                PIXELFORMAT_DXT3: () => O.UPc,
                PIXELFORMAT_DXT5: () => O.ZtC,
                PIXELFORMAT_ETC1: () => O.IAT,
                PIXELFORMAT_ETC2_RGB: () => O.krP,
                PIXELFORMAT_ETC2_RGBA: () => O.MwV,
                PIXELFORMAT_L8: () => O.peA,
                PIXELFORMAT_L8_A8: () => Xt.qx,
                PIXELFORMAT_LA8: () => O.$Op,
                PIXELFORMAT_PVRTC_2BPP_RGBA_1: () => O.g0o,
                PIXELFORMAT_PVRTC_2BPP_RGB_1: () => O.eV7,
                PIXELFORMAT_PVRTC_4BPP_RGBA_1: () => O._t$,
                PIXELFORMAT_PVRTC_4BPP_RGB_1: () => O.NeV,
                PIXELFORMAT_R32F: () => O.DYM,
                PIXELFORMAT_R4_G4_B4_A4: () => Xt.mF,
                PIXELFORMAT_R5_G5_B5_A1: () => Xt.Ie,
                PIXELFORMAT_R5_G6_B5: () => Xt.Yt,
                PIXELFORMAT_R8_G8_B8: () => Xt.W0,
                PIXELFORMAT_R8_G8_B8_A8: () => Xt.MI,
                PIXELFORMAT_RGB16F: () => O.q_o,
                PIXELFORMAT_RGB32F: () => O.lN5,
                PIXELFORMAT_RGB565: () => O.Rbg,
                PIXELFORMAT_RGB8: () => O.Hsr,
                PIXELFORMAT_RGBA16F: () => O.a7f,
                PIXELFORMAT_RGBA32F: () => O.uC3,
                PIXELFORMAT_RGBA4: () => O.UUS,
                PIXELFORMAT_RGBA5551: () => O.BmF,
                PIXELFORMAT_RGBA8: () => O.jKI,
                PIXELFORMAT_SRGB: () => O.wNl,
                PIXELFORMAT_SRGBA: () => O.X8g,
                PRIMITIVE_LINELOOP: () => O.QSU,
                PRIMITIVE_LINES: () => O.Y7R,
                PRIMITIVE_LINESTRIP: () => O.HWi,
                PRIMITIVE_POINTS: () => O.KtK,
                PRIMITIVE_TRIANGLES: () => O.LAy,
                PRIMITIVE_TRIFAN: () => O.x5Y,
                PRIMITIVE_TRISTRIP: () => O.fmY,
                PROJECTION_ORTHOGRAPHIC: () => Ke.Uc,
                PROJECTION_PERSPECTIVE: () => Ke.pm,
                ParticleEmitter: () => Yi.V,
                ParticleSystemComponent: () => Vs.i,
                ParticleSystemComponentSystem: () => hi._,
                PhongMaterial: () => Xt.JF,
                Picker: () => Pr.c,
                Plane: () => ye.J,
                PostEffect: () => Ni.c,
                PostEffectQueue: () => yn.G,
                ProgramLibrary: () => en._,
                QuadRender: () => Ai._,
                Quat: () => I.D,
                RENDERSTYLE_POINTS: () => Ke.mZ,
                RENDERSTYLE_SOLID: () => Ke.pr,
                RENDERSTYLE_WIREFRAME: () => Ke.b5,
                RESOLUTION_AUTO: () => mi.Qd,
                RESOLUTION_FIXED: () => mi.Qx,
                RIGIDBODY_ACTIVE_TAG: () => Xt.aZ,
                RIGIDBODY_CF_KINEMATIC_OBJECT: () => Xt.yb,
                RIGIDBODY_CF_NORESPONSE_OBJECT: () => Xt.q7,
                RIGIDBODY_CF_STATIC_OBJECT: () => Xt.rF,
                RIGIDBODY_DISABLE_DEACTIVATION: () => Xt.Gn,
                RIGIDBODY_DISABLE_SIMULATION: () => Xt.xN,
                RIGIDBODY_ISLAND_SLEEPING: () => Xt.RF,
                RIGIDBODY_TYPE_DYNAMIC: () => Xt.g2,
                RIGIDBODY_TYPE_KINEMATIC: () => Xt.qe,
                RIGIDBODY_TYPE_STATIC: () => Xt.IL,
                RIGIDBODY_WANTS_DEACTIVATION: () => Xt.qJ,
                Ray: () => te.z,
                RaycastResult: () => un.Fv,
                ReadStream: () => o.H,
                RenderComponent: () => dn.V,
                RenderComponentSystem: () => Un.r,
                RenderHandler: () => Hr.c,
                RenderTarget: () => N.A,
                ResourceHandler: () => Kr,
                ResourceLoader: () => jr.h,
                RigidBodyComponent: () => Nn.D,
                RigidBodyComponentSystem: () => un.Lz,
                SAMPLETYPE_DEPTH: () => O.g98,
                SAMPLETYPE_FLOAT: () => O.qUb,
                SAMPLETYPE_UNFILTERABLE_FLOAT: () => O.rT2,
                SCALEMODE_BLEND: () => In.A,
                SCALEMODE_NONE: () => In.f,
                SCROLLBAR_VISIBILITY_SHOW_ALWAYS: () => vs.Cz,
                SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED: () => vs.ek,
                SCROLL_MODE_BOUNCE: () => vs.V6,
                SCROLL_MODE_CLAMP: () => vs.Wb,
                SCROLL_MODE_INFINITE: () => vs.q2,
                SEMANTIC_ATTR: () => O.$eZ,
                SEMANTIC_ATTR0: () => O.CNh,
                SEMANTIC_ATTR1: () => O.x5T,
                SEMANTIC_ATTR10: () => O.JxJ,
                SEMANTIC_ATTR11: () => O.Az9,
                SEMANTIC_ATTR12: () => O.gLS,
                SEMANTIC_ATTR13: () => O.OrD,
                SEMANTIC_ATTR14: () => O.nKe,
                SEMANTIC_ATTR15: () => O.s36,
                SEMANTIC_ATTR2: () => O.PBu,
                SEMANTIC_ATTR3: () => O.PFm,
                SEMANTIC_ATTR4: () => O.LFx,
                SEMANTIC_ATTR5: () => O.qFC,
                SEMANTIC_ATTR6: () => O.PcA,
                SEMANTIC_ATTR7: () => O.jYq,
                SEMANTIC_ATTR8: () => O.syi,
                SEMANTIC_ATTR9: () => O.ScY,
                SEMANTIC_BLENDINDICES: () => O.MgX,
                SEMANTIC_BLENDWEIGHT: () => O.d1j,
                SEMANTIC_COLOR: () => O.wD$,
                SEMANTIC_NORMAL: () => O.SA$,
                SEMANTIC_POSITION: () => O.Q5v,
                SEMANTIC_TANGENT: () => O.ipN,
                SEMANTIC_TEXCOORD: () => O.Pd9,
                SEMANTIC_TEXCOORD0: () => O.$fY,
                SEMANTIC_TEXCOORD1: () => O.Q0q,
                SEMANTIC_TEXCOORD2: () => O.WtN,
                SEMANTIC_TEXCOORD3: () => O.SSp,
                SEMANTIC_TEXCOORD4: () => O.uOW,
                SEMANTIC_TEXCOORD5: () => O.EKq,
                SEMANTIC_TEXCOORD6: () => O.Vcj,
                SEMANTIC_TEXCOORD7: () => O.$8O,
                SHADERDEF_DIRLM: () => Ke.Bp,
                SHADERDEF_INSTANCING: () => Ke.Is,
                SHADERDEF_LM: () => Ke.b0,
                SHADERDEF_LMAMBIENT: () => Ke.c8,
                SHADERDEF_MORPH_NORMAL: () => Ke.$I,
                SHADERDEF_MORPH_POSITION: () => Ke.q4,
                SHADERDEF_MORPH_TEXTURE_BASED: () => Ke.jx,
                SHADERDEF_NOSHADOW: () => Ke.BP,
                SHADERDEF_SCREENSPACE: () => Ke.hz,
                SHADERDEF_SKIN: () => Ke.e8,
                SHADERDEF_TANGENTS: () => Ke.tX,
                SHADERDEF_UV0: () => Ke.KV,
                SHADERDEF_UV1: () => Ke.Sm,
                SHADERDEF_VCOLOR: () => Ke.HI,
                SHADERLANGUAGE_GLSL: () => O.yP3,
                SHADERLANGUAGE_WGSL: () => O.uN2,
                SHADERPASS_ALBEDO: () => Ke.Og,
                SHADERPASS_AO: () => Ke.yC,
                SHADERPASS_EMISSION: () => Ke.pT,
                SHADERPASS_FORWARD: () => Ke.OL,
                SHADERPASS_GLOSS: () => Ke.Yi,
                SHADERPASS_LIGHTING: () => Ke.ON,
                SHADERPASS_METALNESS: () => Ke.MV,
                SHADERPASS_OPACITY: () => Ke.nE,
                SHADERPASS_SPECULARITY: () => Ke.Mk,
                SHADERPASS_UV0: () => Ke.OE,
                SHADERPASS_WORLDNORMAL: () => Ke.Qr,
                SHADERSTAGE_COMPUTE: () => O.Pgy,
                SHADERSTAGE_FRAGMENT: () => O.sxQ,
                SHADERSTAGE_VERTEX: () => O.y4i,
                SHADERTAG_MATERIAL: () => O.pS1,
                SHADER_DEPTH: () => Ke.Jb,
                SHADER_FORWARD: () => Ke.lW,
                SHADER_FORWARDHDR: () => Ke.zw,
                SHADER_PICK: () => Ke.WW,
                SHADER_SHADOW: () => Ke.w1,
                SHADOWUPDATE_NONE: () => Ke.yo,
                SHADOWUPDATE_REALTIME: () => Ke.v5,
                SHADOWUPDATE_THISFRAME: () => Ke.b1,
                SHADOW_DEPTH: () => Ke.xW,
                SHADOW_PCF1: () => Ke.sH,
                SHADOW_PCF3: () => Ke.iW,
                SHADOW_PCF5: () => Ke.sz,
                SHADOW_PCSS: () => Ke.b3,
                SHADOW_VSM16: () => Ke.J7,
                SHADOW_VSM32: () => Ke.oK,
                SHADOW_VSM8: () => Ke.JN,
                SORTKEY_DEPTH: () => Ke.UG,
                SORTKEY_FORWARD: () => Ke.Uo,
                SORTMODE_BACK2FRONT: () => Ke.oJ,
                SORTMODE_CUSTOM: () => Ke.T4,
                SORTMODE_FRONT2BACK: () => Ke.SG,
                SORTMODE_MANUAL: () => Ke.Us,
                SORTMODE_MATERIALMESH: () => Ke.lI,
                SORTMODE_NONE: () => Ke.sB,
                SPECOCC_AO: () => Ke._f,
                SPECOCC_GLOSSDEPENDENT: () => Ke.X8,
                SPECOCC_NONE: () => Ke.wk,
                SPECULAR_BLINN: () => Ke.qT,
                SPECULAR_PHONG: () => Ke.yd,
                SPRITETYPE_ANIMATED: () => Kn.C,
                SPRITETYPE_SIMPLE: () => Kn.V,
                SPRITE_RENDERMODE_SIMPLE: () => Ke._r,
                SPRITE_RENDERMODE_SLICED: () => Ke.ei,
                SPRITE_RENDERMODE_TILED: () => Ke.DD,
                STENCILOP_DECREMENT: () => O.A8C,
                STENCILOP_DECREMENTWRAP: () => O.vcW,
                STENCILOP_INCREMENT: () => O.ROU,
                STENCILOP_INCREMENTWRAP: () => O.KnZ,
                STENCILOP_INVERT: () => O.T4M,
                STENCILOP_KEEP: () => O.gKr,
                STENCILOP_REPLACE: () => O.P3e,
                STENCILOP_ZERO: () => O.Mc_,
                Scene: () => Oi.x,
                SceneHandler: () => Xr.d,
                SceneRegistry: () => zn.H,
                SceneRegistryItem: () => wn.W,
                SceneSettingsHandler: () => Jr,
                ScopeId: () => Qe.q,
                ScopeSpace: () => mt.X,
                ScreenComponent: () => Wn.k,
                ScreenComponentSystem: () => Mn.P,
                ScriptAttributes: () => ia.s,
                ScriptComponent: () => Rn.Z,
                ScriptComponentSystem: () => Ds.q,
                ScriptHandler: () => Yr.z,
                ScriptLegacyComponent: () => vn.w,
                ScriptLegacyComponentSystem: () => Dn.I,
                ScriptRegistry: () => na.l,
                ScriptType: () => ra.e,
                ScrollViewComponent: () => Hi.W,
                ScrollViewComponentSystem: () => ci.c,
                ScrollbarComponent: () => Ii.x,
                ScrollbarComponentSystem: () => yi.$,
                Shader: () => Xe.e,
                ShaderHandler: () => Qr.C,
                ShaderPass: () => Ci.T,
                SingleContactResult: () => un.u6,
                Skeleton: () => Zi.O,
                Skin: () => Li.Z,
                SkinBatchInstance: () => zs.H,
                SkinInstance: () => Bi.u,
                SortedLoopArray: () => i._,
                Sound: () => fs.$,
                SoundComponent: () => On.x,
                SoundComponentSystem: () => Ln.T,
                SoundInstance: () => ls.J,
                SoundInstance3d: () => Es.b,
                SoundManager: () => qt.P,
                SoundSlot: () => fn.Y,
                Sprite: () => Fi.j,
                SpriteAnimationClip: () => qn.p,
                SpriteComponent: () => er.i,
                SpriteComponentSystem: () => tr.P,
                SpriteHandler: () => $r.B,
                StandardMaterial: () => Ui.K,
                StandardMaterialOptions: () => pi.J,
                StencilParameters: () => V.p,
                TEXHINT_ASSET: () => O.P4A,
                TEXHINT_LIGHTMAP: () => O.SK8,
                TEXHINT_NONE: () => O.yc,
                TEXHINT_SHADOWMAP: () => O.rWR,
                TEXTUREDIMENSION_1D: () => O.Y1U,
                TEXTUREDIMENSION_2D: () => O.He_,
                TEXTUREDIMENSION_2D_ARRAY: () => O.AZ8,
                TEXTUREDIMENSION_3D: () => O.lTf,
                TEXTUREDIMENSION_CUBE: () => O.Hfq,
                TEXTUREDIMENSION_CUBE_ARRAY: () => O.weO,
                TEXTURELOCK_READ: () => O.Huo,
                TEXTURELOCK_WRITE: () => O.NTX,
                TEXTUREPROJECTION_CUBE: () => O.BuW,
                TEXTUREPROJECTION_EQUIRECT: () => O.wfm,
                TEXTUREPROJECTION_NONE: () => O.O$k,
                TEXTUREPROJECTION_OCTAHEDRAL: () => O.to1,
                TEXTURETYPE_DEFAULT: () => O.zZc,
                TEXTURETYPE_RGBE: () => O.puI,
                TEXTURETYPE_RGBM: () => O.xIP,
                TEXTURETYPE_RGBP: () => O.kVJ,
                TEXTURETYPE_SWIZZLEGGGR: () => O.anS,
                TONEMAP_ACES: () => Ke.pF,
                TONEMAP_ACES2: () => Ke.iC,
                TONEMAP_FILMIC: () => Ke.XT,
                TONEMAP_HEJL: () => Ke.X1,
                TONEMAP_LINEAR: () => Ke.Fz,
                TRACEID_BINDGROUPFORMAT_ALLOC: () => x.Jg,
                TRACEID_BINDGROUP_ALLOC: () => x.Rv,
                TRACEID_GPU_TIMINGS: () => x.wf,
                TRACEID_PIPELINELAYOUT_ALLOC: () => x.M0,
                TRACEID_RENDERPIPELINE_ALLOC: () => x.Mm,
                TRACEID_RENDER_ACTION: () => x.e9,
                TRACEID_RENDER_FRAME: () => x.Bw,
                TRACEID_RENDER_FRAME_TIME: () => x.gs,
                TRACEID_RENDER_PASS: () => x.W1,
                TRACEID_RENDER_PASS_DETAIL: () => x.OJ,
                TRACEID_RENDER_QUEUE: () => x.AB,
                TRACEID_RENDER_TARGET_ALLOC: () => x.P2,
                TRACEID_SHADER_ALLOC: () => x.io,
                TRACEID_SHADER_COMPILE: () => x.$T,
                TRACEID_TEXTURES: () => x.WS,
                TRACEID_TEXTURE_ALLOC: () => x.OR,
                TRACEID_VRAM_IB: () => x.hB,
                TRACEID_VRAM_TEXTURE: () => x.YH,
                TRACEID_VRAM_VB: () => x.Se,
                TRACE_ID_ELEMENT: () => x.Rd,
                TYPE_FLOAT32: () => O.r8O,
                TYPE_INT16: () => O.S81,
                TYPE_INT32: () => O.$Rf,
                TYPE_INT8: () => O.NPC,
                TYPE_UINT16: () => O.Spw,
                TYPE_UINT32: () => O.$GK,
                TYPE_UINT8: () => O.vyI,
                Tags: () => e.$,
                Template: () => sr.Y,
                TemplateHandler: () => qr.V,
                TextElement: () => ir.G,
                TextHandler: () => ea.q,
                Texture: () => je.x,
                TextureAtlas: () => Xi.Y,
                TextureAtlasHandler: () => ta.d,
                TextureHandler: () => Jn.A,
                TextureParser: () => Jn._,
                TextureUtils: () => Dt.O,
                Touch: () => zt.Xh,
                TouchDevice: () => Jt.S,
                TouchEvent: () => zt.Wb,
                Tracing: () => u.$,
                TransformFeedback: () => ct,
                UNIFORMTYPE_BOOL: () => O.lRO,
                UNIFORMTYPE_BVEC2: () => O.U$,
                UNIFORMTYPE_BVEC3: () => O.AMs,
                UNIFORMTYPE_BVEC4: () => O.fmW,
                UNIFORMTYPE_FLOAT: () => O.Cdl,
                UNIFORMTYPE_FLOATARRAY: () => O.mQ2,
                UNIFORMTYPE_INT: () => O.cNy,
                UNIFORMTYPE_IVEC2: () => O.YsN,
                UNIFORMTYPE_IVEC3: () => O.D35,
                UNIFORMTYPE_IVEC4: () => O.JT4,
                UNIFORMTYPE_MAT2: () => O.R4W,
                UNIFORMTYPE_MAT3: () => O.Si0,
                UNIFORMTYPE_MAT4: () => O.EA4,
                UNIFORMTYPE_MAT4ARRAY: () => O.mK,
                UNIFORMTYPE_TEXTURE2D: () => O.qTk,
                UNIFORMTYPE_TEXTURE2D_SHADOW: () => O.Sdj,
                UNIFORMTYPE_TEXTURE3D: () => O.cgc,
                UNIFORMTYPE_TEXTURECUBE: () => O.pwe,
                UNIFORMTYPE_TEXTURECUBE_SHADOW: () => O.vW_,
                UNIFORMTYPE_VEC2: () => O.d_l,
                UNIFORMTYPE_VEC2ARRAY: () => O.KdK,
                UNIFORMTYPE_VEC3: () => O.T73,
                UNIFORMTYPE_VEC3ARRAY: () => O.m4F,
                UNIFORMTYPE_VEC4: () => O.nZ6,
                UNIFORMTYPE_VEC4ARRAY: () => O.QQe,
                UNIFORM_BUFFER_DEFAULT_SLOT_NAME: () => O.ASF,
                URI: () => r.o,
                UnsupportedBrowserError: () => Xt.VZ,
                VIEW_CENTER: () => Ke.Hc,
                VIEW_LEFT: () => Ke.wJ,
                VIEW_RIGHT: () => Ke.U2,
                Vec2: () => A.S,
                Vec3: () => B.A,
                Vec4: () => C.T,
                VertexBuffer: () => lt.o,
                VertexFormat: () => pt.g,
                VertexIterator: () => vt.O,
                WasmModule: () => n.F,
                WebglGraphicsDevice: () => tt.S,
                WebgpuGraphicsDevice: () => Ve,
                WorldClusters: () => Ts.P,
                XRDEPTHSENSINGFORMAT_F32: () => As._B,
                XRDEPTHSENSINGFORMAT_L8A8: () => As.Gu,
                XRDEPTHSENSINGUSAGE_CPU: () => As.qr,
                XRDEPTHSENSINGUSAGE_GPU: () => As.fh,
                XRHAND_LEFT: () => As.u5,
                XRHAND_NONE: () => As.RF,
                XRHAND_RIGHT: () => As.AD,
                XRPAD_A: () => Fe.pT,
                XRPAD_B: () => Fe.gv,
                XRPAD_SQUEEZE: () => Fe.NB,
                XRPAD_STICK_BUTTON: () => Fe.aF,
                XRPAD_STICK_X: () => Fe.kU,
                XRPAD_STICK_Y: () => Fe.hk,
                XRPAD_TOUCHPAD_BUTTON: () => Fe.JQ,
                XRPAD_TOUCHPAD_X: () => Fe.FY,
                XRPAD_TOUCHPAD_Y: () => Fe.d7,
                XRPAD_TRIGGER: () => Fe.mu,
                XRSPACE_BOUNDEDFLOOR: () => As.ED,
                XRSPACE_LOCAL: () => As.eF,
                XRSPACE_LOCALFLOOR: () => As.fO,
                XRSPACE_UNBOUNDED: () => As.l2,
                XRSPACE_VIEWER: () => As.fK,
                XRTARGETRAY_GAZE: () => As.iq,
                XRTARGETRAY_POINTER: () => As.Qi,
                XRTARGETRAY_SCREEN: () => As.OB,
                XRTRACKABLE_MESH: () => As.FO,
                XRTRACKABLE_PLANE: () => As.Y$,
                XRTRACKABLE_POINT: () => As.ZY,
                XRTYPE_AR: () => As.UG,
                XRTYPE_INLINE: () => As.YW,
                XRTYPE_VR: () => As.Dd,
                XrDepthSensing: () => ca.e,
                XrDomOverlay: () => ma.q,
                XrHitTest: () => ua.S,
                XrHitTestSource: () => fa.j,
                XrImageTracking: () => pa.s,
                XrInput: () => oa.r,
                XrInputSource: () => la.g,
                XrLightEstimation: () => ha.z,
                XrManager: () => da.V,
                XrPlane: () => ya.c,
                XrPlaneDetection: () => ga.r,
                XrTrackedImage: () => _a.J,
                ZoneComponent: () => nr.k,
                ZoneComponentSystem: () => rr.x,
                anim: () => Xt.if,
                app: () => Wi.l,
                apps: () => T.hO,
                asset: () => Xt.pt,
                audio: () => Xt.n0,
                basisInitialize: () => Mr.h,
                basisSetDownloadConfig: () => Xt.op,
                bindGroupNames: () => O.BzP,
                calculateNormals: () => hs.hu,
                calculateTangents: () => hs.bF,
                common: () => T.y0,
                config: () => T.vc,
                createBox: () => hs.dO,
                createCapsule: () => hs.JL,
                createCone: () => hs.VD,
                createCylinder: () => hs.Y,
                createGraphicsDevice: () => Be,
                createMesh: () => hs.Ns,
                createPlane: () => hs.j6,
                createScript: () => Vn.hT,
                createShader: () => Mi.ef,
                createShaderFromCode: () => Mi.JM,
                createSphere: () => hs.$R,
                createStyle: () => Xt.wj,
                createTorus: () => hs.$w,
                createURI: () => r.Q,
                data: () => T.aT,
                dracoInitialize: () => br.t,
                drawFullscreenQuad: () => Xt.mS,
                drawQuadWithShader: () => is.H,
                drawTexture: () => is.d,
                events: () => g.U,
                extend: () => T.l7,
                getPixelFormatArrayType: () => O.QUn,
                getReservedScriptNames: () => Vn.H8,
                getTouchTargetCoords: () => zt.kX,
                gfx: () => Xt.Um,
                guid: () => c.M,
                http: () => ss.d,
                inherits: () => Xt.XW,
                input: () => Xt.qH,
                isCompressedPixelFormat: () => O.stI,
                log: () => Xt.cM,
                makeArray: () => Xt.VL,
                math: () => p.m,
                now: () => t.z,
                path: () => d.E,
                pixelFormatInfo: () => O.qBv,
                platform: () => h.J,
                posteffect: () => Xt.se,
                prefilterCubemap: () => Xt.Ri,
                programlib: () => Xt.HR,
                registerScript: () => Vn.A8,
                reprojectTexture: () => qi.Y,
                revision: () => T.LB,
                scene: () => Xt.Ah,
                script: () => tn._,
                semanticToLocation: () => O.Lb6,
                shFromCubemap: () => $i,
                shaderChunks: () => bi.n,
                shaderChunksLightmapper: () => zi.i,
                shadowTypeToString: () => Ke.LH,
                shape: () => Xt.mC,
                string: () => f.Z,
                time: () => Xt.XV,
                type: () => T.dt,
                typedArrayIndexFormats: () => O.kRF,
                typedArrayIndexFormatsByteSize: () => O.jJZ,
                typedArrayToType: () => O.gXw,
                typedArrayTypes: () => O.DIG,
                typedArrayTypesByteSize: () => O.MbK,
                uniformTypeToName: () => O.HBB,
                version: () => T.i8,
                vertexTypesNames: () => O.PdC,
              });
            var x = a(2200),
              T = a(9795),
              g = a(5843),
              c = a(6724),
              d = a(9296),
              h = a(4444),
              f = a(9351),
              s = a(5338),
              l = a(743),
              n = a(8391),
              o = a(6458),
              i = a(9595),
              e = a(6660),
              t = a(3821),
              r = a(959),
              u = a(3226),
              y = a(3996),
              p = a(4585),
              _ = a(1367),
              m = a(429),
              E = a(1239),
              v = a(4486),
              P = a(9758),
              I = a(6847),
              A = a(2978),
              B = a(6556),
              C = a(6630),
              w = a(3148),
              k = a(4633),
              K = a(5230),
              te = a(3028);
            const X = new te.z(),
              $ = new B.A(),
              ne = new k.K(),
              Y = new P.y();
            class Z {
              constructor(re = new P.y(), ve = new B.A(0.5, 0.5, 0.5)) {
                (this.halfExtents = void 0),
                  (this._modelTransform = void 0),
                  (this._worldTransform = void 0),
                  (this._aabb = void 0),
                  (this.halfExtents = ve),
                  (this._modelTransform = re.clone().invert()),
                  (this._worldTransform = re.clone()),
                  (this._aabb = new w.k(new B.A(), this.halfExtents));
              }
              set worldTransform(re) {
                this._worldTransform.copy(re),
                  this._modelTransform.copy(re).invert();
              }
              get worldTransform() {
                return this._worldTransform;
              }
              intersectsRay(re, ve) {
                if (
                  (this._modelTransform.transformPoint(re.origin, X.origin),
                  this._modelTransform.transformVector(
                    re.direction,
                    X.direction
                  ),
                  ve)
                ) {
                  const Me = this._aabb._intersectsRay(X, ve);
                  return (
                    Y.copy(this._modelTransform)
                      .invert()
                      .transformPoint(ve, ve),
                    Me
                  );
                }
                return this._aabb._fastIntersectsRay(X);
              }
              containsPoint(re) {
                return (
                  this._modelTransform.transformPoint(re, $),
                  this._aabb.containsPoint($)
                );
              }
              intersectsBoundingSphere(re) {
                return (
                  this._modelTransform.transformPoint(re.center, ne.center),
                  (ne.radius = re.radius),
                  !!this._aabb.intersectsBoundingSphere(ne)
                );
              }
            }
            var ye = a(6251),
              pe = a(1304),
              O = a(7921),
              me = a(4738),
              N = a(3412),
              V = a(30);
            class L {
              constructor() {
                this.bindGroup = void 0;
              }
              update(re) {
                this.destroy();
                const ve = re.device,
                  Me = this.createDescriptor(ve, re);
                this.bindGroup = ve.wgpu.createBindGroup(Me);
              }
              destroy() {
                this.bindGroup = null;
              }
              createDescriptor(re, ve) {
                const Me = [],
                  ze = ve.format;
                let Ge = 0;
                return (
                  ve.uniformBuffers.forEach((dt) => {
                    const _t = dt.persistent
                      ? dt.impl.buffer
                      : dt.allocation.gpuBuffer.buffer;
                    Me.push({
                      binding: Ge++,
                      resource: {
                        buffer: _t,
                        offset: 0,
                        size: dt.format.byteSize,
                      },
                    });
                  }),
                  ve.textures.forEach((dt, _t) => {
                    const Ct = dt.impl,
                      wt = ze.textureFormats[_t],
                      It = Ct.getView(re);
                    Me.push({ binding: Ge++, resource: It });
                    const Vt = Ct.getSampler(re, wt.sampleType);
                    Me.push({ binding: Ge++, resource: Vt });
                  }),
                  { layout: ve.format.impl.bindGroupLayout, entries: Me }
                );
              }
            }
            var J = a(576);
            class ae {
              static shaderStage(re) {
                let ve = 0;
                return (
                  re & O.y4i && (ve |= GPUShaderStage.VERTEX),
                  re & O.sxQ && (ve |= GPUShaderStage.FRAGMENT),
                  re & O.Pgy && (ve |= GPUShaderStage.COMPUTE),
                  ve
                );
              }
            }
            const R = [];
            (R[O.qUb] = "filtering"),
              (R[O.rT2] = "non-filtering"),
              (R[O.g98] = "comparison");
            const j = [];
            (j[O.qUb] = "float"),
              (j[O.rT2] = "unfilterable-float"),
              (j[O.g98] = "depth");
            const se = new J.X();
            class ce {
              constructor(re) {
                const ve = re.device,
                  { key: Me, descr: ze } = this.createDescriptor(re);
                (this.key = se.get(Me)),
                  (this.bindGroupLayout = ve.wgpu.createBindGroupLayout(ze));
              }
              destroy() {
                this.bindGroupLayout = null;
              }
              loseContext() {}
              getTextureSlot(re, ve) {
                return re.bufferFormats.length + ve * 2;
              }
              createDescriptor(re) {
                const ve = [];
                let Me = "",
                  ze = 0;
                return (
                  re.bufferFormats.forEach((nt) => {
                    const dt = ae.shaderStage(nt.visibility);
                    (Me += `#${ze}U:${dt}`),
                      ve.push({
                        binding: ze++,
                        visibility: dt,
                        buffer: { type: "uniform", hasDynamicOffset: !0 },
                      });
                  }),
                  re.textureFormats.forEach((nt) => {
                    const dt = ae.shaderStage(nt.visibility),
                      _t = nt.sampleType,
                      Ct = nt.textureDimension,
                      wt = !1,
                      It = j[_t];
                    (Me += `#${ze}T:${dt}-${It}-${Ct}-${wt}`),
                      ve.push({
                        binding: ze++,
                        visibility: dt,
                        texture: {
                          sampleType: It,
                          viewDimension: Ct,
                          multisampled: wt,
                        },
                      });
                    const Vt = R[_t];
                    (Me += `#${ze}S:${dt}-${Vt}`),
                      ve.push({
                        binding: ze++,
                        visibility: dt,
                        sampler: { type: Vt },
                      });
                  }),
                  { key: Me, descr: { entries: ve } }
                );
              }
            }
            class ie {
              constructor() {
                this.buffer = null;
              }
              destroy(re) {
                this.buffer && (this.buffer.destroy(), (this.buffer = null));
              }
              get initialized() {
                return !!this.buffer;
              }
              loseContext() {}
              unlock(re, ve, Me, ze) {
                var Ge, nt;
                const dt = re.wgpu;
                if (!this.buffer) {
                  const It = (ze.byteLength + 3) & -4;
                  this.buffer = re.wgpu.createBuffer({
                    size: It,
                    usage: Me | GPUBufferUsage.COPY_DST,
                  });
                }
                const _t = (Ge = ze.byteOffset) != null ? Ge : 0,
                  Ct = new Uint8Array(
                    (nt = ze.buffer) != null ? nt : ze,
                    _t,
                    ze.byteLength
                  ),
                  wt = new Uint8Array(this.buffer.size);
                wt.set(Ct),
                  dt.queue.writeBuffer(this.buffer, 0, wt, 0, wt.length);
              }
            }
            class b extends ie {
              constructor(re) {
                super(),
                  (this.format = null),
                  (this.format = re.format === O.q0F ? "uint16" : "uint32");
              }
              unlock(re) {
                const ve = re.device;
                super.unlock(ve, re.usage, GPUBufferUsage.INDEX, re.storage);
              }
            }
            var M = a(2752);
            const F = {
                equals: function (Ut, re) {
                  if (Ut.size !== re.size) return !1;
                  for (let ve = 0; ve < Ut.length; ve++)
                    if (Ut[ve] !== re[ve]) return !1;
                  return !0;
                },
              },
              z = [];
            (z[O.NPC] = "sint8"),
              (z[O.vyI] = "uint8"),
              (z[O.S81] = "sint16"),
              (z[O.Spw] = "uint16"),
              (z[O.$Rf] = "sint32"),
              (z[O.$GK] = "uint32"),
              (z[O.r8O] = "float32");
            const oe = [];
            (oe[O.NPC] = "snorm8"),
              (oe[O.vyI] = "unorm8"),
              (oe[O.S81] = "snorm16"),
              (oe[O.Spw] = "unorm16"),
              (oe[O.$Rf] = "sint32"),
              (oe[O.$GK] = "uint32"),
              (oe[O.r8O] = "float32");
            class de {
              constructor() {
                this.cache = new Map();
              }
              get(re, ve = null) {
                const Me = this.getKey(re, ve);
                let ze = this.cache.get(Me);
                return (
                  ze || ((ze = this.create(re, ve)), this.cache.set(Me, ze)), ze
                );
              }
              getKey(re, ve = null) {
                return `${re == null ? void 0 : re.renderingHashString}-${
                  ve == null ? void 0 : ve.renderingHashString
                }`;
              }
              create(re, ve) {
                const Me = [],
                  ze = (Ge) => {
                    const nt = Ge.interleaved,
                      dt = Ge.instancing ? "instance" : "vertex";
                    let _t = [];
                    const Ct = Ge.elements.length;
                    for (let wt = 0; wt < Ct; wt++) {
                      const It = Ge.elements[wt],
                        Vt = O.Lb6[It.name],
                        Wt = It.normalize ? oe : z;
                      _t.push({
                        shaderLocation: Vt,
                        offset: nt ? It.offset : 0,
                        format: `${Wt[It.dataType]}${
                          It.numComponents > 1 ? "x" + It.numComponents : ""
                        }`,
                      }),
                        (!nt || wt === Ct - 1) &&
                          (Me.push({
                            attributes: _t,
                            arrayStride: It.stride,
                            stepMode: dt,
                          }),
                          (_t = []));
                    }
                  };
                return re && ze(re), ve && ze(ve), Me;
              }
            }
            const ge = [
                "point-list",
                "line-list",
                void 0,
                "line-strip",
                "triangle-list",
                "triangle-strip",
                void 0,
              ],
              Re = ["add", "subtract", "reverse-subtract", "min", "max"],
              Te = [
                "zero",
                "one",
                "src",
                "one-minus-src",
                "dst",
                "one-minus-dst",
                "src-alpha",
                "src-alpha-saturated",
                "one-minus-src-alpha",
                "dst-alpha",
                "one-minus-dst-alpha",
                "constant",
                "one-minus-constant",
              ],
              Ne = [
                "never",
                "less",
                "equal",
                "less-equal",
                "greater",
                "not-equal",
                "greater-equal",
                "always",
              ],
              Le = ["none", "back", "front"],
              ke = [
                "keep",
                "zero",
                "replace",
                "increment-clamp",
                "increment-wrap",
                "decrement-clamp",
                "decrement-wrap",
                "invert",
              ],
              ht = [];
            class _e {
              constructor() {
                (this.pipeline = void 0), (this.hashes = void 0);
              }
            }
            class U {
              constructor(re) {
                (this.lookupHashes = new Uint32Array(13)),
                  (this.device = re),
                  (this.vertexBufferLayout = new de()),
                  (this.cache = new Map());
              }
              get(re, ve, Me, ze, Ge, nt, dt, _t, Ct, wt, It, Vt) {
                var Wt, Zt, ds, Gs, Us, $s, vi, En;
                const us = this.lookupHashes;
                (us[0] = re.type),
                  (us[1] = ze.id),
                  (us[2] = Ct),
                  (us[3] = _t.key),
                  (us[4] = dt.key),
                  (us[5] =
                    (Wt = ve == null ? void 0 : ve.renderingHash) != null
                      ? Wt
                      : 0),
                  (us[6] =
                    (Zt = Me == null ? void 0 : Me.renderingHash) != null
                      ? Zt
                      : 0),
                  (us[7] = Ge.impl.key),
                  (us[8] =
                    (ds = (Gs = nt[0]) == null ? void 0 : Gs.key) != null
                      ? ds
                      : 0),
                  (us[9] =
                    (Us = ($s = nt[1]) == null ? void 0 : $s.key) != null
                      ? Us
                      : 0),
                  (us[10] =
                    (vi = (En = nt[2]) == null ? void 0 : En.key) != null
                      ? vi
                      : 0),
                  (us[11] = wt ? It.key : 0),
                  (us[12] = wt ? Vt.key : 0);
                const os = (0, M.A)(us);
                let as = this.cache.get(os);
                if (as)
                  for (let ni = 0; ni < as.length; ni++) {
                    const Ks = as[ni];
                    if (F.equals(Ks.hashes, us)) return Ks.pipeline;
                  }
                const gs = ge[re.type],
                  di = this.getPipelineLayout(nt),
                  Ms = this.vertexBufferLayout.get(ve, Me),
                  Hs = new _e();
                return (
                  (Hs.hashes = new Uint32Array(us)),
                  (Hs.pipeline = this.create(
                    gs,
                    ze,
                    Ge,
                    di,
                    dt,
                    _t,
                    Ms,
                    Ct,
                    wt,
                    It,
                    Vt
                  )),
                  as ? as.push(Hs) : (as = [Hs]),
                  this.cache.set(os, as),
                  Hs.pipeline
                );
              }
              getPipelineLayout(re) {
                re.forEach((ze) => {
                  ht.push(ze.bindGroupLayout);
                });
                const ve = { bindGroupLayouts: ht },
                  Me = this.device.wgpu.createPipelineLayout(ve);
                return (ht.length = 0), Me;
              }
              getBlend(re) {
                let ve;
                return (
                  re.blend &&
                    (ve = {
                      color: {
                        operation: Re[re.colorOp],
                        srcFactor: Te[re.colorSrcFactor],
                        dstFactor: Te[re.colorDstFactor],
                      },
                      alpha: {
                        operation: Re[re.alphaOp],
                        srcFactor: Te[re.alphaSrcFactor],
                        dstFactor: Te[re.alphaDstFactor],
                      },
                    }),
                  ve
                );
              }
              getDepthStencil(re, ve, Me, ze, Ge) {
                let nt;
                const { depth: dt, stencil: _t } = ve;
                return (
                  (dt || _t) &&
                    ((nt = { format: ve.impl.depthFormat }),
                    dt
                      ? ((nt.depthWriteEnabled = re.write),
                        (nt.depthCompare = Ne[re.func]))
                      : ((nt.depthWriteEnabled = !1),
                        (nt.depthCompare = "always")),
                    _t &&
                      Me &&
                      ((nt.stencilReadMas = ze.readMask),
                      (nt.stencilWriteMask = ze.writeMask),
                      (nt.stencilFront = {
                        compare: Ne[ze.func],
                        failOp: ke[ze.fail],
                        passOp: ke[ze.zpass],
                        depthFailOp: ke[ze.zfail],
                      }),
                      (nt.stencilBack = {
                        compare: Ne[Ge.func],
                        failOp: ke[Ge.fail],
                        passOp: ke[Ge.zpass],
                        depthFailOp: ke[Ge.zfail],
                      }))),
                  nt
                );
              }
              create(re, ve, Me, ze, Ge, nt, dt, _t, Ct, wt, It) {
                const Vt = this.device.wgpu,
                  Wt = ve.impl,
                  Zt = {
                    vertex: {
                      module: Wt.getVertexShaderModule(),
                      entryPoint: Wt.vertexEntryPoint,
                      buffers: dt,
                    },
                    fragment: {
                      module: Wt.getFragmentShaderModule(),
                      entryPoint: Wt.fragmentEntryPoint,
                      targets: [],
                    },
                    primitive: {
                      topology: re,
                      frontFace: "ccw",
                      cullMode: Le[_t],
                    },
                    depthStencil: this.getDepthStencil(nt, Me, Ct, wt, It),
                    multisample: { count: Me.samples },
                    layout: ze,
                  },
                  ds = Me.impl.colorAttachments;
                if (ds.length > 0) {
                  let Us = 0;
                  Ge.redWrite && (Us |= GPUColorWrite.RED),
                    Ge.greenWrite && (Us |= GPUColorWrite.GREEN),
                    Ge.blueWrite && (Us |= GPUColorWrite.BLUE),
                    Ge.alphaWrite && (Us |= GPUColorWrite.ALPHA);
                  const $s = this.getBlend(Ge);
                  ds.forEach((vi) => {
                    Zt.fragment.targets.push({
                      format: vi.format,
                      writeMask: Us,
                      blend: $s,
                    });
                  });
                }
                return Vt.createRenderPipeline(Zt);
              }
            }
            const H = new J.X();
            class Ee {
              constructor() {
                (this.format = void 0), (this.multisampledBuffer = void 0);
              }
              destroy() {
                var re;
                (re = this.multisampledBuffer) == null || re.destroy(),
                  (this.multisampledBuffer = null);
              }
            }
            class G {
              constructor(re) {
                (this.initialized = !1),
                  (this.key = void 0),
                  (this.colorAttachments = []),
                  (this.depthFormat = void 0),
                  (this.hasStencil = void 0),
                  (this.depthTexture = null),
                  (this.depthTextureInternal = !1),
                  (this.assignedColorTexture = null),
                  (this.renderPassDescriptor = {}),
                  (this.renderTarget = re),
                  re._colorBuffers &&
                    re._colorBuffers.forEach((ve, Me) => {
                      this.setColorAttachment(Me, void 0, ve.impl.format);
                    }),
                  this.updateKey();
              }
              destroy(re) {
                if (((this.initialized = !1), this.depthTextureInternal)) {
                  var ve;
                  (ve = this.depthTexture) == null || ve.destroy(),
                    (this.depthTexture = null);
                }
                (this.assignedColorTexture = null),
                  this.colorAttachments.forEach((Me) => {
                    Me.destroy();
                  }),
                  (this.colorAttachments.length = 0);
              }
              updateKey() {
                const re = this.renderTarget;
                let ve = `${re.samples}:${
                  re.depth ? this.depthFormat : "nodepth"
                }`;
                this.colorAttachments.forEach((Me) => {
                  ve += `:${Me.format}`;
                }),
                  (this.key = H.get(ve));
              }
              setDepthFormat(re) {
                (this.depthFormat = re),
                  (this.hasStencil = re === "depth24plus-stencil8");
              }
              assignColorTexture(re) {
                this.assignedColorTexture = re;
                const ve = re.createView(),
                  Me = this.renderPassDescriptor.colorAttachments[0];
                this.renderTarget.samples > 1
                  ? (Me.resolveTarget = ve)
                  : (Me.view = ve),
                  this.setColorAttachment(0, void 0, re.format),
                  this.updateKey();
              }
              setColorAttachment(re, ve, Me) {
                this.colorAttachments[re] ||
                  (this.colorAttachments[re] = new Ee()),
                  ve && (this.colorAttachments[re].multisampledBuffer = ve),
                  Me && (this.colorAttachments[re].format = Me);
              }
              init(re, ve) {
                var Me, ze;
                const Ge = re.wgpu;
                this.initDepthStencil(Ge, ve),
                  (this.renderPassDescriptor.colorAttachments = []);
                const nt =
                  (Me = (ze = ve._colorBuffers) == null ? void 0 : ze.length) !=
                  null
                    ? Me
                    : 1;
                for (let _t = 0; _t < nt; ++_t) {
                  var dt;
                  const Ct = this.initColor(Ge, ve, _t),
                    wt =
                      _t === 0 &&
                      ((dt = this.colorAttachments[0]) == null
                        ? void 0
                        : dt.format);
                  (Ct.view || wt) &&
                    this.renderPassDescriptor.colorAttachments.push(Ct);
                }
                this.initialized = !0;
              }
              initDepthStencil(re, ve) {
                const {
                  samples: Me,
                  width: ze,
                  height: Ge,
                  depth: nt,
                  depthBuffer: dt,
                } = ve;
                if (nt || dt) {
                  if (dt)
                    (this.depthTexture = dt.impl.gpuTexture),
                      this.setDepthFormat(dt.impl.format);
                  else {
                    this.setDepthFormat("depth24plus-stencil8");
                    const _t = {
                      size: [ze, Ge, 1],
                      dimension: "2d",
                      sampleCount: Me,
                      format: this.depthFormat,
                      usage: GPUTextureUsage.RENDER_ATTACHMENT,
                    };
                    Me > 1
                      ? (_t.usage |= GPUTextureUsage.TEXTURE_BINDING)
                      : (_t.usage |= GPUTextureUsage.COPY_SRC),
                      (this.depthTexture = re.createTexture(_t)),
                      (this.depthTextureInternal = !0);
                  }
                  this.renderPassDescriptor.depthStencilAttachment = {
                    view: this.depthTexture.createView(),
                  };
                }
              }
              initColor(re, ve, Me) {
                const ze = {},
                  { samples: Ge, width: nt, height: dt } = ve,
                  _t = ve.getColorBuffer(Me);
                let Ct = null;
                if (
                  (_t &&
                    (_t.cubemap
                      ? (Ct = _t.impl.createView({
                          dimension: "2d",
                          baseArrayLayer: ve.face,
                          arrayLayerCount: 1,
                          mipLevelCount: 1,
                        }))
                      : (Ct = _t.impl.createView({ mipLevelCount: 1 }))),
                  Ge > 1)
                ) {
                  var wt, It;
                  const Vt = {
                      size: [nt, dt, 1],
                      dimension: "2d",
                      sampleCount: Ge,
                      format:
                        (wt =
                          (It = this.colorAttachments[Me]) == null
                            ? void 0
                            : It.format) != null
                          ? wt
                          : _t.impl.format,
                      usage: GPUTextureUsage.RENDER_ATTACHMENT,
                    },
                    Wt = re.createTexture(Vt);
                  this.setColorAttachment(Me, Wt),
                    (ze.view = Wt.createView()),
                    (ze.resolveTarget = Ct);
                } else ze.view = Ct;
                return ze;
              }
              setupForRenderPass(re) {
                var ve, Me;
                const ze =
                  (ve =
                    (Me = this.renderPassDescriptor.colorAttachments) == null
                      ? void 0
                      : Me.length) != null
                    ? ve
                    : 0;
                for (let nt = 0; nt < ze; ++nt) {
                  const dt = this.renderPassDescriptor.colorAttachments[nt],
                    _t = re.colorArrayOps[nt];
                  (dt.clearValue = _t.clearValue),
                    (dt.loadOp = _t.clear ? "clear" : "load"),
                    (dt.storeOp = _t.store ? "store" : "discard");
                }
                const Ge = this.renderPassDescriptor.depthStencilAttachment;
                Ge &&
                  ((Ge.depthClearValue = re.depthStencilOps.clearDepthValue),
                  (Ge.depthLoadOp = re.depthStencilOps.clearDepth
                    ? "clear"
                    : "load"),
                  (Ge.depthStoreOp = re.depthStencilOps.storeDepth
                    ? "store"
                    : "discard"),
                  (Ge.depthReadOnly = !1),
                  this.hasStencil &&
                    ((Ge.stencilClearValue =
                      re.depthStencilOps.clearStencilValue),
                    (Ge.stencilLoadOp = re.depthStencilOps.clearStencil
                      ? "clear"
                      : "load"),
                    (Ge.stencilStoreOp = re.depthStencilOps.storeStencil
                      ? "store"
                      : "discard"),
                    (Ge.stencilReadOnly = !1)));
              }
              loseContext() {
                this.initialized = !1;
              }
              resolve(re, ve, Me, ze) {}
            }
            var Q = a(289),
              q = a(2158);
            const xe = /[ \t]*(\battribute\b|\bvarying\b|\buniform\b)/g,
              be =
                /(\battribute\b|\bvarying\b|\bout\b|\buniform\b)[ \t]*([^;]+)([;]+)/g,
              Pe = "@@@",
              we = /([\w-]+)\[(.*?)\]/,
              Oe = new Set(["highp", "mediump", "lowp"]),
              $e = new Set(["sampler2DShadow", "samplerCubeShadow"]),
              gt = {
                sampler2D: O.He_,
                sampler3D: O.lTf,
                samplerCube: O.Hfq,
                samplerCubeShadow: O.Hfq,
                sampler2DShadow: O.He_,
                sampler2DArray: O.AZ8,
                sampler2DArrayShadow: O.AZ8,
              };
            class qe {
              constructor(re, ve) {
                this.line = re;
                const Me = re.trim().split(/\s+/);
                if (
                  (Oe.has(Me[0]) && (this.precision = Me.shift()),
                  (this.type = Me.shift()),
                  re.includes(","),
                  re.includes("["))
                ) {
                  const ze = Me.join(" "),
                    Ge = we.exec(ze);
                  (this.name = Ge[1]),
                    (this.arraySize = Number(Ge[2])),
                    isNaN(this.arraySize) && (ve.failed = !0);
                } else (this.name = Me.shift()), (this.arraySize = 0);
                this.isSampler = this.type.indexOf("sampler") !== -1;
              }
            }
            class Tt {
              static run(re, ve, Me) {
                const ze = new Map(),
                  Ge = Tt.extract(ve.vshader),
                  nt = Tt.extract(ve.fshader),
                  dt = Tt.processAttributes(
                    Ge.attributes,
                    ve.attributes,
                    ve.processingOptions
                  ),
                  _t = Tt.processVaryings(Ge.varyings, ze, !0),
                  Ct = Tt.processVaryings(nt.varyings, ze, !1),
                  wt = Tt.processOuts(nt.outs),
                  It = Ge.uniforms.concat(nt.uniforms),
                  Wt = Array.from(new Set(It)).map((vi) => new qe(vi, Me)),
                  Zt = Tt.processUniforms(re, Wt, ve.processingOptions, Me),
                  ds =
                    dt +
                    `
` +
                    _t +
                    `
` +
                    Zt.code,
                  Gs = Ge.src.replace(Pe, ds),
                  Us =
                    Ct +
                    `
` +
                    wt +
                    `
` +
                    Zt.code,
                  $s = nt.src.replace(Pe, Us);
                return {
                  vshader: Gs,
                  fshader: $s,
                  meshUniformBufferFormat: Zt.meshUniformBufferFormat,
                  meshBindGroupFormat: Zt.meshBindGroupFormat,
                };
              }
              static extract(re) {
                const ve = [],
                  Me = [],
                  ze = [],
                  Ge = [];
                let nt = `${Pe}
`,
                  dt;
                for (; (dt = xe.exec(re)) !== null; ) {
                  const _t = dt[1];
                  switch (_t) {
                    case "attribute":
                    case "varying":
                    case "uniform":
                    case "out": {
                      be.lastIndex = dt.index;
                      const Ct = be.exec(re);
                      _t === "attribute"
                        ? ve.push(Ct[2])
                        : _t === "varying"
                        ? Me.push(Ct[2])
                        : _t === "out"
                        ? ze.push(Ct[2])
                        : _t === "uniform" && Ge.push(Ct[2]),
                        (re = Tt.cutOut(re, dt.index, be.lastIndex, nt)),
                        (xe.lastIndex = dt.index + nt.length),
                        (nt = "");
                      break;
                    }
                  }
                }
                return {
                  src: re,
                  attributes: ve,
                  varyings: Me,
                  outs: ze,
                  uniforms: Ge,
                };
              }
              static processUniforms(re, ve, Me, ze) {
                const Ge = [],
                  nt = [];
                ve.forEach((Wt) => {
                  Wt.isSampler ? Ge.push(Wt) : nt.push(Wt);
                });
                const dt = [];
                nt.forEach((Wt) => {
                  if (!Me.hasUniform(Wt.name)) {
                    const Zt = O.HBB.indexOf(Wt.type),
                      ds = new Q.M(Wt.name, Zt, Wt.arraySize);
                    dt.push(ds);
                  }
                });
                const _t = dt.length ? new Q.f(re, dt) : null,
                  Ct = [];
                _t && Ct.push(new q.Q1(O.ASF, O.y4i | O.sxQ));
                const wt = [];
                Ge.forEach((Wt) => {
                  if (!Me.hasTexture(Wt.name)) {
                    let Zt = O.qUb;
                    Wt.precision === "highp" && (Zt = O.rT2),
                      $e.has(Wt.type) && (Zt = O.g98);
                    const ds = gt[Wt.type];
                    wt.push(new q.sT(Wt.name, O.y4i | O.sxQ, ds, Zt));
                  }
                });
                const It = new q.WM(re, Ct, wt);
                let Vt = "";
                return (
                  Me.uniformFormats.forEach((Wt, Zt) => {
                    Wt && (Vt += Wt.getShaderDeclaration(Zt, 0));
                  }),
                  _t && (Vt += _t.getShaderDeclaration(O.Ak$, 0)),
                  Me.bindGroupFormats.forEach((Wt, Zt) => {
                    Wt && (Vt += Wt.getShaderDeclarationTextures(Zt));
                  }),
                  (Vt += It.getShaderDeclarationTextures(O.Ak$)),
                  {
                    code: Vt,
                    meshUniformBufferFormat: _t,
                    meshBindGroupFormat: It,
                  }
                );
              }
              static processVaryings(re, ve, Me) {
                let ze = "";
                const Ge = Me ? "out" : "in";
                return (
                  re.forEach((nt, dt) => {
                    const _t = Tt.splitToWords(nt),
                      Ct = _t[0],
                      wt = _t[1];
                    Me ? ve.set(wt, dt) : (dt = ve.get(wt)),
                      (ze += `layout(location = ${dt}) ${Ge} ${Ct} ${wt};
`);
                  }),
                  ze
                );
              }
              static processOuts(re) {
                let ve = "";
                return (
                  re.forEach((Me, ze) => {
                    ve += `layout(location = ${ze}) out ${Me};
`;
                  }),
                  ve
                );
              }
              static getTypeCount(re) {
                const ve = re.substring(re.length - 1),
                  Me = parseInt(ve, 10);
                return isNaN(Me) ? 1 : Me;
              }
              static processAttributes(re, ve, Me) {
                let ze = "";
                return (
                  re.forEach((Ge) => {
                    const nt = Tt.splitToWords(Ge);
                    let dt = nt[0],
                      _t = nt[1];
                    if (ve.hasOwnProperty(_t)) {
                      const Ct = ve[_t],
                        wt = O.Lb6[Ct];
                      let It;
                      const Vt = Me.getVertexElement(Ct);
                      if (Vt) {
                        const Wt = Vt.dataType;
                        if (Wt !== O.r8O && !Vt.normalize) {
                          const Zt = Tt.getTypeCount(dt),
                            ds = `_private_${_t}`;
                          (It = `vec${Zt} ${_t} = vec${Zt}(${ds});
`),
                            (_t = ds);
                          const Gs =
                            Wt === O.NPC || Wt === O.S81 || Wt === O.$Rf;
                          Zt === 1
                            ? (dt = Gs ? "int" : "uint")
                            : (dt = Gs ? `ivec${Zt}` : `uvec${Zt}`);
                        }
                      }
                      (ze += `layout(location = ${wt}) in ${dt} ${_t};
`),
                        It && (ze += It);
                    }
                  }),
                  ze
                );
              }
              static splitToWords(re) {
                return (re = re.replace(/\s+/g, " ").trim()), re.split(" ");
              }
              static cutOut(re, ve, Me, ze) {
                return re.substring(0, ve) + ze + re.substring(Me);
              }
            }
            class Mt {
              constructor(re) {
                (this._vertexCode = void 0),
                  (this._fragmentCode = void 0),
                  (this.vertexEntryPoint = "main"),
                  (this.fragmentEntryPoint = "main"),
                  (this.shader = re);
                const ve = re.definition;
                ve.shaderLanguage === O.uN2
                  ? ((this._vertexCode = ve.vshader),
                    (this._fragmentCode = ve.fshader),
                    (this.vertexEntryPoint = "vertexMain"),
                    (this.fragmentEntryPoint = "fragmentMain"),
                    (re.ready = !0))
                  : ve.processingOptions && this.process();
              }
              destroy(re) {
                (this._vertexCode = null), (this._fragmentCode = null);
              }
              createShaderModule(re, ve) {
                return this.shader.device.wgpu.createShaderModule({ code: re });
              }
              getVertexShaderModule() {
                return this.createShaderModule(this._vertexCode, "Vertex");
              }
              getFragmentShaderModule() {
                return this.createShaderModule(this._fragmentCode, "Fragment");
              }
              process() {
                const re = this.shader,
                  ve = Tt.run(re.device, re.definition, re);
                (this._vertexCode = this.transpile(
                  ve.vshader,
                  "vertex",
                  re.definition.vshader
                )),
                  (this._fragmentCode = this.transpile(
                    ve.fshader,
                    "fragment",
                    re.definition.fshader
                  )),
                  this._vertexCode && this._fragmentCode
                    ? (re.ready = !0)
                    : (re.failed = !0),
                  (re.meshUniformBufferFormat = ve.meshUniformBufferFormat),
                  (re.meshBindGroupFormat = ve.meshBindGroupFormat);
              }
              transpile(re, ve, Me) {
                try {
                  const ze = this.shader.device.glslang.compileGLSL(re, ve);
                  return this.shader.device.twgsl.convertSpirV2WGSL(ze);
                } catch (ze) {
                  console.error(
                    `Failed to transpile webgl ${ve} shader [${this.shader.label}] to WebGPU: [${ze.message}]`,
                    { processed: re, original: Me, shader: this.shader }
                  );
                }
              }
              get vertexCode() {
                return this._vertexCode;
              }
              get fragmentCode() {
                return this._fragmentCode;
              }
              loseContext() {}
              restoreContext(re, ve) {}
            }
            var Dt = a(5432);
            const ut = [];
            (ut[O.fGB] = ""),
              (ut[O.peA] = "r8unorm"),
              (ut[O.$Op] = "rg8unorm"),
              (ut[O.Rbg] = ""),
              (ut[O.BmF] = ""),
              (ut[O.UUS] = ""),
              (ut[O.Hsr] = "rgba8unorm"),
              (ut[O.jKI] = "rgba8unorm"),
              (ut[O.TES] = "bc1-rgba-unorm"),
              (ut[O.UPc] = "bc2-rgba-unorm"),
              (ut[O.ZtC] = "bc3-rgba-unorm"),
              (ut[O.q_o] = ""),
              (ut[O.a7f] = "rgba16float"),
              (ut[O.lN5] = ""),
              (ut[O.uC3] = "rgba32float"),
              (ut[O.DYM] = "r32float"),
              (ut[O.EFh] = "depth32float"),
              (ut[O.sUt] = "depth24plus-stencil8"),
              (ut[O.kYl] = "rg11b10ufloat"),
              (ut[O.wNl] = ""),
              (ut[O.X8g] = ""),
              (ut[O.IAT] = ""),
              (ut[O.krP] = "etc2-rgb8unorm"),
              (ut[O.MwV] = "etc2-rgba8unorm"),
              (ut[O.eV7] = ""),
              (ut[O.g0o] = ""),
              (ut[O.NeV] = ""),
              (ut[O._t$] = ""),
              (ut[O.JOC] = "astc-4x4-unorm"),
              (ut[O.$4V] = ""),
              (ut[O.iJ1] = ""),
              (ut[O.ka9] = "bgra8unorm");
            const At = [];
            (At[O.SuC] = "repeat"),
              (At[O.uFb] = "clamp-to-edge"),
              (At[O.nVg] = "mirror-repeat");
            const xt = [];
            (xt[O.yib] = { level: "nearest", mip: "nearest" }),
              (xt[O.I5X] = { level: "linear", mip: "nearest" }),
              (xt[O.Aap] = { level: "nearest", mip: "nearest" }),
              (xt[O.$_P] = { level: "nearest", mip: "linear" }),
              (xt[O.feq] = { level: "linear", mip: "nearest" }),
              (xt[O.Snx] = { level: "linear", mip: "linear" });
            class jt {
              constructor(re) {
                (this.gpuTexture = void 0),
                  (this.view = void 0),
                  (this.samplers = []),
                  (this.descr = void 0),
                  (this.format = void 0),
                  (this.texture = re),
                  (this.format = ut[re.format]),
                  this.create(re.device);
              }
              create(re) {
                const ve = this.texture,
                  Me = re.wgpu,
                  ze = ve.requiredMipLevels;
                (this.descr = {
                  size: {
                    width: ve.width,
                    height: ve.height,
                    depthOrArrayLayers: ve.cubemap ? 6 : 1,
                  },
                  format: this.format,
                  mipLevelCount: ze,
                  sampleCount: 1,
                  dimension: ve.volume ? "3d" : "2d",
                  usage:
                    GPUTextureUsage.TEXTURE_BINDING |
                    GPUTextureUsage.COPY_DST |
                    GPUTextureUsage.RENDER_ATTACHMENT |
                    GPUTextureUsage.COPY_SRC,
                }),
                  (this.gpuTexture = Me.createTexture(this.descr));
                let Ge;
                this.texture.format === O.sUt &&
                  (Ge = { format: "depth24plus", aspect: "depth-only" }),
                  (this.view = this.createView(Ge));
              }
              destroy(re) {}
              propertyChanged(re) {
                this.samplers.length = 0;
              }
              getView(re) {
                return this.uploadImmediate(re, this.texture), this.view;
              }
              createView(re) {
                var ve, Me, ze, Ge, nt, dt, _t;
                const Ct = re != null ? re : {},
                  wt = this.descr,
                  It = this.texture,
                  Vt = () => (It.cubemap ? "cube" : It.volume ? "3d" : "2d"),
                  Wt = {
                    format: (ve = Ct.format) != null ? ve : wt.format,
                    dimension: (Me = Ct.dimension) != null ? Me : Vt(),
                    aspect: (ze = Ct.aspect) != null ? ze : "all",
                    baseMipLevel: (Ge = Ct.baseMipLevel) != null ? Ge : 0,
                    mipLevelCount:
                      (nt = Ct.mipLevelCount) != null ? nt : wt.mipLevelCount,
                    baseArrayLayer: (dt = Ct.baseArrayLayer) != null ? dt : 0,
                    arrayLayerCount:
                      (_t = Ct.arrayLayerCount) != null
                        ? _t
                        : wt.depthOrArrayLayers,
                  };
                return this.gpuTexture.createView(Wt);
              }
              getSampler(re, ve) {
                let Me = this.samplers[ve];
                if (!Me) {
                  const ze = this.texture,
                    Ge = {
                      addressModeU: At[ze.addressU],
                      addressModeV: At[ze.addressV],
                      addressModeW: At[ze.addressW],
                      maxAnisotropy: p.m.clamp(
                        Math.round(ze._anisotropy),
                        1,
                        re.maxTextureAnisotropy
                      ),
                    };
                  !ve && ze.compareOnRead && (ve = O.g98),
                    ve === O.g98
                      ? ((Ge.compare = "less"),
                        (Ge.magFilter = "linear"),
                        (Ge.minFilter = "linear"))
                      : ve === O.rT2 ||
                        this.texture.format === O.uC3 ||
                        this.texture.format === O.sUt ||
                        this.texture.format === O.a7f
                      ? ((Ge.magFilter = "nearest"),
                        (Ge.minFilter = "nearest"),
                        (Ge.mipmapFilter = "nearest"))
                      : ((Ge.magFilter = xt[ze.magFilter].level),
                        (Ge.minFilter = xt[ze.minFilter].level),
                        (Ge.mipmapFilter = xt[ze.minFilter].mip)),
                    (Me = re.wgpu.createSampler(Ge)),
                    (this.samplers[ve] = Me);
                }
                return Me;
              }
              loseContext() {}
              uploadImmediate(re, ve) {
                (ve._needsUpload || ve._needsMipmapsUpload) &&
                  (this.uploadData(re),
                  (ve._needsUpload = !1),
                  (ve._needsMipmapsUpload = !1));
              }
              uploadData(re) {
                const ve = this.texture;
                if (ve._levels) {
                  let Me = !1;
                  const ze = ve.requiredMipLevels;
                  for (let Ge = 0; Ge < ze; Ge++) {
                    const nt = ve._levels[Ge];
                    if (nt)
                      if (ve.cubemap)
                        for (let dt = 0; dt < 6; dt++) {
                          const _t = nt[dt];
                          _t &&
                            (this.isExternalImage(_t)
                              ? (this.uploadExternalImage(re, _t, Ge, dt),
                                (Me = !0))
                              : ArrayBuffer.isView(_t) &&
                                (this.uploadTypedArrayData(re, _t, Ge, dt),
                                (Me = !0)));
                        }
                      else
                        ve._volume ||
                          (this.isExternalImage(nt)
                            ? (this.uploadExternalImage(re, nt, Ge, 0),
                              (Me = !0))
                            : ArrayBuffer.isView(nt) &&
                              (this.uploadTypedArrayData(re, nt, Ge, 0),
                              (Me = !0)));
                  }
                  Me && ve.mipmaps && re.mipmapRenderer.generate(this);
                }
              }
              isExternalImage(re) {
                return (
                  re instanceof ImageBitmap ||
                  re instanceof HTMLVideoElement ||
                  re instanceof HTMLCanvasElement ||
                  re instanceof OffscreenCanvas
                );
              }
              uploadExternalImage(re, ve, Me, ze) {
                const Ge = { source: ve, origin: [0, 0], flipY: !1 },
                  nt = {
                    texture: this.gpuTexture,
                    mipLevel: Me,
                    origin: [0, 0, ze],
                    aspect: "all",
                  },
                  dt = {
                    width: this.descr.size.width,
                    height: this.descr.size.height,
                    depthOrArrayLayers: 1,
                  };
                re.submit(),
                  re.wgpu.queue.copyExternalImageToTexture(Ge, nt, dt);
              }
              uploadTypedArrayData(re, ve, Me, ze) {
                var Ge;
                const nt = this.texture,
                  dt = re.wgpu,
                  _t = {
                    texture: this.gpuTexture,
                    origin: [0, 0, ze],
                    mipLevel: Me,
                  },
                  Ct = Dt.O.calcLevelDimension(nt.width, Me),
                  wt = Dt.O.calcLevelDimension(nt.height, Me);
                Dt.O.calcLevelGpuSize(Ct, wt, 1, nt.format);
                const Zt = {
                    offset: 0,
                    bytesPerRow:
                      ((Ge = O.qBv.get(nt.format).size) != null ? Ge : 0) * Ct,
                    rowsPerImage: wt,
                  },
                  ds = { width: Ct, height: wt, depthOrArrayLayers: 1 };
                re.submit(), dt.queue.writeTexture(_t, ve, Zt, ds);
              }
            }
            class Gt extends ie {
              constructor(re) {
                super();
              }
              destroy(re) {
                super.destroy(re);
              }
              unlock(re) {
                const ve = re.device;
                super.unlock(ve, void 0, GPUBufferUsage.UNIFORM, re.storage);
              }
            }
            class yt extends ie {
              constructor(re, ve) {
                super();
              }
              destroy(re) {
                super.destroy(re);
              }
              unlock(re) {
                const ve = re.device;
                super.unlock(ve, re.usage, GPUBufferUsage.VERTEX, re.storage);
              }
            }
            var Ae = a(8277),
              Xe = a(6977),
              Ye = a(7008),
              it = a(4051),
              st = a(7013);
            const He = { type: O.fmY, base: 0, count: 4, indexed: !1 };
            class at {
              constructor(re) {
                const ve = `

						struct ub_mesh {
								color : vec4f,
								depth: f32
						}

						@group(0) @binding(0) var<uniform> ubMesh : ub_mesh;

						var<private> pos : array<vec2f, 4> = array<vec2f, 4>(
								vec2(-1.0, 1.0), vec2(1.0, 1.0),
								vec2(-1.0, -1.0), vec2(1.0, -1.0)
						);

						struct VertexOutput {
								@builtin(position) position : vec4f
						}

						@vertex
						fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
								var output : VertexOutput;
								output.position = vec4(pos[vertexIndex], ubMesh.depth, 1.0);
								return output;
						}

						@fragment
						fn fragmentMain() -> @location(0) vec4f {
								return ubMesh.color;
						}
				`;
                (this.shader = new Xe.e(re, {
                  name: "WebGPUClearRendererShader",
                  shaderLanguage: O.uN2,
                  vshader: ve,
                  fshader: ve,
                })),
                  (this.uniformBuffer = new it.M(
                    re,
                    new Q.f(re, [
                      new Q.M("color", O.nZ6),
                      new Q.M("depth", O.Cdl),
                    ]),
                    !1
                  ));
                const Me = new q.WM(re, [new q.Q1(O.ASF, O.y4i | O.sxQ)]);
                (this.bindGroup = new Ye.v(re, Me, this.uniformBuffer)),
                  (this.colorData = new Float32Array(4)),
                  (this.colorId = re.scope.resolve("color")),
                  (this.depthId = re.scope.resolve("depth"));
              }
              destroy() {
                this.shader.destroy(),
                  (this.shader = null),
                  this.uniformBuffer.destroy(),
                  (this.uniformBuffer = null),
                  this.bindGroup.destroy(),
                  (this.bindGroup = null);
              }
              clear(re, ve, Me, ze) {
                var Ge;
                Me = Me || ze;
                const nt = (Ge = Me.flags) != null ? Ge : ze.flags;
                if (nt !== 0) {
                  if (nt & O.Zzy && ve.colorBuffer) {
                    var dt;
                    const wt = (dt = Me.color) != null ? dt : ze.color;
                    this.colorData.set(wt), re.setBlendState(Ae.a.NOBLEND);
                  } else re.setBlendState(Ae.a.NOWRITE);
                  if (
                    (this.colorId.setValue(this.colorData),
                    nt & O.zk9 && ve.depth)
                  ) {
                    var _t;
                    const wt = (_t = Me.depth) != null ? _t : ze.depth;
                    this.depthId.setValue(wt),
                      re.setDepthState(st.b.WRITEDEPTH);
                  } else
                    this.depthId.setValue(1), re.setDepthState(st.b.NODEPTH);
                  nt & O.$tA && ve.stencil,
                    re.setCullMode(O.OL2),
                    re.setShader(this.shader);
                  const Ct = this.bindGroup;
                  Ct.defaultUniformBuffer.update(),
                    Ct.update(),
                    re.setBindGroup(O.Ak$, Ct),
                    re.draw(He);
                }
              }
            }
            class Pt {
              constructor(re) {
                (this.device = void 0), (this.device = re);
                const ve = `
 
						var<private> pos : array<vec2f, 4> = array<vec2f, 4>(
								vec2(-1.0, 1.0), vec2(1.0, 1.0),
								vec2(-1.0, -1.0), vec2(1.0, -1.0)
						);

						struct VertexOutput {
								@builtin(position) position : vec4f,
								@location(0) texCoord : vec2f
						};

						@vertex
						fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
							var output : VertexOutput;
							output.texCoord = pos[vertexIndex] * vec2f(0.5, -0.5) + vec2f(0.5);
							output.position = vec4f(pos[vertexIndex], 0, 1);
							return output;
						}

						@group(0) @binding(0) var imgSampler : sampler;
						@group(0) @binding(1) var img : texture_2d<f32>;

						@fragment
						fn fragmentMain(@location(0) texCoord : vec2f) -> @location(0) vec4f {
							return textureSample(img, imgSampler, texCoord);
						}
				`;
                (this.shader = new Xe.e(re, {
                  name: "WebGPUMipmapRendererShader",
                  shaderLanguage: O.uN2,
                  vshader: ve,
                  fshader: ve,
                })),
                  (this.minSampler = re.wgpu.createSampler({
                    minFilter: "linear",
                  }));
              }
              destroy() {
                this.shader.destroy(), (this.shader = null);
              }
              generate(re) {
                var ve;
                const Me = re.descr;
                if (Me.mipLevelCount <= 1 || re.texture.volume) return;
                const ze = this.device,
                  Ge = ze.wgpu,
                  nt = this.shader.impl,
                  dt = Ge.createRenderPipeline({
                    layout: "auto",
                    vertex: {
                      module: nt.getVertexShaderModule(),
                      entryPoint: nt.vertexEntryPoint,
                    },
                    fragment: {
                      module: nt.getFragmentShaderModule(),
                      entryPoint: nt.fragmentEntryPoint,
                      targets: [{ format: Me.format }],
                    },
                    primitive: { topology: "triangle-strip" },
                  }),
                  _t = re.texture.cubemap ? 6 : 1,
                  Ct = [];
                for (let It = 0; It < _t; It++)
                  Ct.push(
                    re.createView({
                      dimension: "2d",
                      baseMipLevel: 0,
                      mipLevelCount: 1,
                      baseArrayLayer: It,
                    })
                  );
                const wt =
                  (ve = ze.commandEncoder) != null
                    ? ve
                    : Ge.createCommandEncoder();
                for (let It = 1; It < Me.mipLevelCount; It++)
                  for (let Vt = 0; Vt < _t; Vt++) {
                    const Wt = re.createView({
                        dimension: "2d",
                        baseMipLevel: It,
                        mipLevelCount: 1,
                        baseArrayLayer: Vt,
                      }),
                      Zt = wt.beginRenderPass({
                        colorAttachments: [
                          { view: Wt, loadOp: "clear", storeOp: "store" },
                        ],
                      }),
                      ds = Ge.createBindGroup({
                        layout: dt.getBindGroupLayout(0),
                        entries: [
                          { binding: 0, resource: this.minSampler },
                          { binding: 1, resource: Ct[Vt] },
                        ],
                      });
                    Zt.setPipeline(dt),
                      Zt.setBindGroup(0, ds),
                      Zt.draw(4),
                      Zt.end(),
                      (Ct[Vt] = Wt);
                  }
                if (!ze.commandEncoder) {
                  const It = wt.finish();
                  ze.addCommandBuffer(It);
                }
                ze.pipeline = null;
              }
            }
            var he = a(9227);
            class fe extends he.fd {
              constructor(re, ve, Me) {
                super(re),
                  (this.buffer = null),
                  (this.mappedRange = null),
                  (this.buffer = re.wgpu.createBuffer({
                    size: ve,
                    usage: Me
                      ? GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC
                      : GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
                    mappedAtCreation: Me,
                  })),
                  Me && this.onAvailable(),
                  (re._vram.ub += ve);
              }
              destroy(re) {
                (re._vram.ub -= this.buffer.size),
                  this.buffer.destroy(),
                  (this.buffer = null);
              }
              onAvailable() {
                this.mappedRange = this.buffer.getMappedRange();
              }
              alloc(re, ve) {
                return new Int32Array(this.mappedRange, re, ve / 4);
              }
            }
            class Ie extends he.Ns {
              constructor(...re) {
                super(...re), (this.pendingStagingBuffers = []);
              }
              createBuffer(re, ve, Me) {
                return new fe(re, ve, Me);
              }
              submit() {
                super.submit();
                const re = this.usedBuffers.length;
                if (re) {
                  const ve = this.device,
                    Me = this.gpuBuffers,
                    ze = ve.wgpu.createCommandEncoder();
                  for (let nt = re - 1; nt >= 0; nt--) {
                    const dt = this.usedBuffers[nt],
                      {
                        stagingBuffer: _t,
                        gpuBuffer: Ct,
                        offset: wt,
                        size: It,
                      } = dt,
                      Vt = _t.buffer;
                    Vt.unmap(),
                      ze.copyBufferToBuffer(Vt, wt, Ct.buffer, wt, It),
                      Me.push(Ct);
                  }
                  const Ge = ze.finish();
                  ve.addCommandBuffer(Ge, !0);
                  for (let nt = 0; nt < re; nt++) {
                    const dt = this.usedBuffers[nt].stagingBuffer;
                    this.pendingStagingBuffers.push(dt);
                  }
                  this.usedBuffers.length = 0;
                }
              }
              onCommandBuffersSubmitted() {
                const re = this.pendingStagingBuffers.length;
                if (re) {
                  for (let ve = 0; ve < re; ve++) {
                    const Me = this.pendingStagingBuffers[ve];
                    Me.buffer.mapAsync(GPUMapMode.WRITE).then(() => {
                      Me.onAvailable(), this.stagingBuffers.push(Me);
                    });
                  }
                  this.pendingStagingBuffers.length = 0;
                }
              }
            }
            var ue = a(3998);
            class De {
              constructor(re, ve, Me) {
                (this.querySet = void 0),
                  (this.stagingBuffers = []),
                  (this.activeStagingBuffer = null),
                  (this.bytesPerSlot = void 0),
                  (this.device = re),
                  (this.capacity = Me),
                  (this.bytesPerSlot = ve ? 8 : 4);
                const ze = re.wgpu;
                (this.querySet = ze.createQuerySet({
                  type: ve ? "timestamp" : "occlusion",
                  count: Me,
                })),
                  (this.queryBuffer = ze.createBuffer({
                    size: this.bytesPerSlot * Me,
                    usage:
                      GPUBufferUsage.QUERY_RESOLVE |
                      GPUBufferUsage.STORAGE |
                      GPUBufferUsage.COPY_SRC |
                      GPUBufferUsage.COPY_DST,
                  }));
              }
              destroy() {
                var re, ve;
                (re = this.querySet) == null || re.destroy(),
                  (this.querySet = null),
                  (ve = this.queryBuffer) == null || ve.destroy(),
                  (this.queryBuffer = null),
                  (this.activeStagingBuffer = null),
                  this.stagingBuffers.forEach((Me) => {
                    Me.destroy();
                  }),
                  (this.stagingBuffers = null);
              }
              getStagingBuffer() {
                let re = this.stagingBuffers.pop();
                return (
                  re ||
                    (re = this.device.wgpu.createBuffer({
                      size: this.queryBuffer.size,
                      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
                    })),
                  re
                );
              }
              resolve(re) {
                const ve = this.device,
                  Me = ve.wgpu.createCommandEncoder();
                Me.resolveQuerySet(this.querySet, 0, re, this.queryBuffer, 0);
                const ze = this.getStagingBuffer();
                (this.activeStagingBuffer = ze),
                  Me.copyBufferToBuffer(
                    this.queryBuffer,
                    0,
                    ze,
                    0,
                    this.bytesPerSlot * re
                  );
                const Ge = Me.finish();
                ve.addCommandBuffer(Ge);
              }
              request(re, ve) {
                const Me = this.activeStagingBuffer;
                return (
                  (this.activeStagingBuffer = null),
                  Me.mapAsync(GPUMapMode.READ).then(() => {
                    const ze = new BigInt64Array(Me.getMappedRange()),
                      Ge = [];
                    for (let nt = 0; nt < re; nt++)
                      Ge.push(Number(ze[nt * 2 + 1] - ze[nt * 2]) * 1e-6);
                    return (
                      Me.unmap(),
                      this.stagingBuffers.push(Me),
                      { renderVersion: ve, timings: Ge }
                    );
                  })
                );
              }
            }
            class et extends ue.l {
              constructor(re) {
                super(),
                  (this.device = void 0),
                  (this.frameGPUMarkerSlot = void 0),
                  (this.device = re),
                  (this.timestampQueriesSet = re.supportsTimestampQuery
                    ? new De(re, !0, 512)
                    : null);
              }
              destroy() {
                var re;
                (re = this.timestampQueriesSet) == null || re.destroy(),
                  (this.timestampQueriesSet = null);
              }
              frameMarker(re) {
                if (this.timestampQueriesSet) {
                  const ve = this.device.wgpu.createCommandEncoder();
                  (this.frameGPUMarkerSlot = re
                    ? this.getSlot("GpuFrame")
                    : this.frameGPUMarkerSlot),
                    ve.writeTimestamp(
                      this.timestampQueriesSet.querySet,
                      this.frameGPUMarkerSlot * 2 + (re ? 0 : 1)
                    );
                  const Me = ve.finish();
                  this.device.addCommandBuffer(Me, re);
                }
              }
              frameStart() {
                this.processEnableRequest(),
                  this._enabled && this.frameMarker(!0);
              }
              frameEnd() {
                if (this._enabled) {
                  var re;
                  this.frameMarker(!1),
                    (re = this.timestampQueriesSet) == null ||
                      re.resolve(this.slotCount * 2);
                }
              }
              request() {
                if (this._enabled) {
                  var re;
                  const ve = this.device.renderVersion;
                  (re = this.timestampQueriesSet) == null ||
                    re.request(this.slotCount, ve).then((Me) => {
                      this.report(Me.renderVersion, Me.timings);
                    }),
                    super.request(ve);
                }
              }
            }
            class Ze {
              constructor(re) {
                (this.device = void 0),
                  (this.pipelineCache = new Map()),
                  (this.device = re);
                const ve = `
 
						var<private> pos : array<vec2f, 4> = array<vec2f, 4>(
								vec2(-1.0, 1.0), vec2(1.0, 1.0), vec2(-1.0, -1.0), vec2(1.0, -1.0)
						);

						struct VertexOutput {
								@builtin(position) position : vec4f,
						};

						@vertex
						fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
							var output : VertexOutput;
							output.position = vec4f(pos[vertexIndex], 0, 1);
							return output;
						}

						@group(0) @binding(0) var img : texture_depth_multisampled_2d;

						@fragment
						fn fragmentMain(@builtin(position) fragColor: vec4f) -> @location(0) vec4f {
								// load th depth value from sample index 0
								var depth = textureLoad(img, vec2i(fragColor.xy), 0u);
								return vec4<f32>(depth, 0.0, 0.0, 0.0);
						}
				`;
                this.shader = new Xe.e(re, {
                  name: "WebGPUResolverDepthShader",
                  shaderLanguage: O.uN2,
                  vshader: ve,
                  fshader: ve,
                });
              }
              destroy() {
                this.shader.destroy(),
                  (this.shader = null),
                  (this.pipelineCache = null);
              }
              getPipeline(re) {
                let ve = this.pipelineCache.get(re);
                return (
                  ve ||
                    ((ve = this.createPipeline(re)),
                    this.pipelineCache.set(re, ve)),
                  ve
                );
              }
              createPipeline(re) {
                const ve = this.shader.impl;
                return this.device.wgpu.createRenderPipeline({
                  layout: "auto",
                  vertex: {
                    module: ve.getVertexShaderModule(),
                    entryPoint: ve.vertexEntryPoint,
                  },
                  fragment: {
                    module: ve.getFragmentShaderModule(),
                    entryPoint: ve.fragmentEntryPoint,
                    targets: [{ format: re }],
                  },
                  primitive: { topology: "triangle-strip" },
                });
              }
              resolveDepth(re, ve, Me) {
                const ze = this.device,
                  Ge = ze.wgpu,
                  nt = this.getPipeline(Me.format),
                  dt = ve.depthOrArrayLayers;
                for (let _t = 0; _t < dt; _t++) {
                  const Ct = ve.createView({
                      dimension: "2d",
                      aspect: "depth-only",
                      baseMipLevel: 0,
                      mipLevelCount: 1,
                      baseArrayLayer: _t,
                    }),
                    wt = Me.createView({
                      dimension: "2d",
                      baseMipLevel: 0,
                      mipLevelCount: 1,
                      baseArrayLayer: _t,
                    }),
                    It = re.beginRenderPass({
                      colorAttachments: [
                        { view: wt, loadOp: "clear", storeOp: "store" },
                      ],
                    }),
                    Vt = Ge.createBindGroup({
                      layout: nt.getBindGroupLayout(0),
                      entries: [{ binding: 0, resource: Ct }],
                    });
                  It.setPipeline(nt),
                    It.setBindGroup(0, Vt),
                    It.draw(4),
                    It.end();
                }
                ze.pipeline = null;
              }
            }
            class Ve extends me.$ {
              constructor(re, ve = {}) {
                super(re, ve),
                  (this.frameBuffer = void 0),
                  (this.renderPipeline = new U(this)),
                  (this.clearRenderer = void 0),
                  (this.mipmapRenderer = void 0),
                  (this.pipeline = void 0),
                  (this.bindGroupFormats = []),
                  (this.commandEncoder = void 0),
                  (this.commandBuffers = []),
                  (this.limits = void 0),
                  (ve = this.initOptions),
                  (this.isWebGPU = !0),
                  (this._deviceType = O.dJb),
                  (this.samples = ve.antialias ? 4 : 1),
                  this.setupPassEncoderDefaults();
              }
              destroy() {
                this.clearRenderer.destroy(),
                  (this.clearRenderer = null),
                  this.mipmapRenderer.destroy(),
                  (this.mipmapRenderer = null),
                  this.resolver.destroy(),
                  (this.resolver = null),
                  super.destroy();
              }
              initDeviceCaps() {
                this.disableParticleSystem = !0;
                const re = this.gpuAdapter.limits;
                (this.limits = re),
                  (this.precision = "highp"),
                  (this.maxPrecision = "highp"),
                  (this.maxSamples = 4),
                  (this.maxTextures = 16),
                  (this.maxTextureSize = re.maxTextureDimension2D),
                  (this.maxCubeMapSize = re.maxTextureDimension2D),
                  (this.maxVolumeSize = re.maxTextureDimension3D),
                  (this.maxColorAttachments = re.maxColorAttachments),
                  (this.maxPixelRatio = 1),
                  (this.maxAnisotropy = 16),
                  (this.supportsInstancing = !0),
                  (this.supportsUniformBuffers = !0),
                  (this.supportsVolumeTextures = !0),
                  (this.supportsBoneTextures = !0),
                  (this.supportsMorphTargetTexturesCore = !0),
                  (this.supportsAreaLights = !0),
                  (this.supportsDepthShadow = !0),
                  (this.supportsGpuParticles = !1),
                  (this.supportsMrt = !0),
                  (this.extUintElement = !0),
                  (this.extTextureFloat = !0),
                  (this.textureFloatRenderable = !0),
                  (this.extTextureHalfFloat = !0),
                  (this.textureHalfFloatRenderable = !0),
                  (this.textureHalfFloatUpdatable = !0),
                  (this.boneLimit = 1024),
                  (this.supportsImageBitmap = !0),
                  (this.extStandardDerivatives = !0),
                  (this.extBlendMinmax = !0),
                  (this.areaLightLutFormat = this.floatFilterable
                    ? O.uC3
                    : O.jKI),
                  (this.supportsTextureFetch = !0);
              }
              initWebGpu(re, ve) {
                return pn(this, null, function* () {
                  if (!window.navigator.gpu)
                    throw new Error(
                      "Unable to retrieve GPU. Ensure you are using a browser that supports WebGPU rendering."
                    );
                  const Me = (wt) =>
                    new Promise(function (It, Vt) {
                      const Wt = document.createElement("script");
                      (Wt.src = wt),
                        (Wt.async = !1),
                        (Wt.onload = function () {
                          It(wt);
                        }),
                        (Wt.onerror = function () {
                          Vt(new Error(`Failed to download script ${wt}`));
                        }),
                        document.body.appendChild(Wt);
                    });
                  yield Me(re), yield Me(ve), (this.glslang = yield glslang());
                  const ze = ve.replace(".js", ".wasm");
                  this.twgsl = yield twgsl(ze);
                  const Ge = {
                    powerPreference:
                      this.initOptions.powerPreference !== "default"
                        ? this.initOptions.powerPreference
                        : void 0,
                  };
                  this.gpuAdapter = yield window.navigator.gpu.requestAdapter(
                    Ge
                  );
                  const nt = [],
                    dt = (wt) => {
                      const It = this.gpuAdapter.features.has(wt);
                      return It && nt.push(wt), It;
                    };
                  (this.floatFilterable = dt("float32-filterable")),
                    (this.extCompressedTextureS3TC = dt(
                      "texture-compression-bc"
                    )),
                    (this.extCompressedTextureETC = dt(
                      "texture-compression-etc2"
                    )),
                    (this.extCompressedTextureASTC = dt(
                      "texture-compression-astc"
                    )),
                    (this.supportsTimestampQuery = dt("timestamp-query"));
                  const _t = {
                    requiredFeatures: nt,
                    requiredLimits: {},
                    defaultQueue: { label: "Default Queue" },
                  };
                  (this.wgpu = yield this.gpuAdapter.requestDevice(_t)),
                    this.initDeviceCaps(),
                    this.setResolution(window.innerWidth, window.innerHeight),
                    (this.gpuContext = this.canvas.getContext("webgpu"));
                  const Ct = navigator.gpu.getPreferredCanvasFormat();
                  return (
                    (this.framebufferFormat =
                      Ct === "rgba8unorm" ? O.jKI : O.ka9),
                    (this.canvasConfig = {
                      device: this.wgpu,
                      colorSpace: "srgb",
                      alphaMode: "opaque",
                      format: Ct,
                      usage:
                        GPUTextureUsage.RENDER_ATTACHMENT |
                        GPUTextureUsage.COPY_SRC |
                        GPUTextureUsage.COPY_DST,
                      viewFormats: [],
                    }),
                    this.gpuContext.configure(this.canvasConfig),
                    this.createFramebuffer(),
                    (this.clearRenderer = new at(this)),
                    (this.mipmapRenderer = new Pt(this)),
                    (this.resolver = new Ze(this)),
                    this.postInit(),
                    this
                  );
                });
              }
              postInit() {
                super.postInit(),
                  (this.gpuProfiler = new et(this)),
                  (this.dynamicBuffers = new Ie(
                    this,
                    1048576,
                    this.limits.minUniformBufferOffsetAlignment
                  ));
              }
              createFramebuffer() {
                (this.supportsStencil = this.initOptions.stencil),
                  (this.frameBufferDimensions = new A.S()),
                  (this.frameBuffer = new N.A({
                    name: "WebgpuFramebuffer",
                    graphicsDevice: this,
                    depth: this.initOptions.depth,
                    stencil: this.supportsStencil,
                    samples: this.samples,
                  }));
              }
              resizeCanvas(re, ve) {
                (this._width = re),
                  (this._height = ve),
                  (this.canvas.width !== re || this.canvas.height !== ve) &&
                    ((this.canvas.width = re),
                    (this.canvas.height = ve),
                    this.fire(me.$.EVENT_RESIZE, re, ve));
              }
              frameStart() {
                super.frameStart(),
                  this.gpuProfiler.frameStart(),
                  this.submit();
                const re = this.gpuContext.getCurrentTexture();
                (this.frameBufferDimensions.x !== re.width ||
                  this.frameBufferDimensions.y !== re.height) &&
                  (this.frameBufferDimensions.set(re.width, re.height),
                  this.frameBuffer.destroy(),
                  (this.frameBuffer = null),
                  this.createFramebuffer());
                const ve = this.frameBuffer,
                  Me = ve.impl;
                Me.setColorAttachment(0, void 0, re.format),
                  this.initRenderTarget(ve),
                  Me.assignColorTexture(re);
              }
              frameEnd() {
                super.frameEnd(),
                  this.gpuProfiler.frameEnd(),
                  this.submit(),
                  this.gpuProfiler.request();
              }
              createUniformBufferImpl(re) {
                return new Gt(re);
              }
              createVertexBufferImpl(re, ve) {
                return new yt(re, ve);
              }
              createIndexBufferImpl(re) {
                return new b(re);
              }
              createShaderImpl(re) {
                return new Mt(re);
              }
              createTextureImpl(re) {
                return new jt(re);
              }
              createRenderTargetImpl(re) {
                return new G(re);
              }
              createBindGroupFormatImpl(re) {
                return new ce(re);
              }
              createBindGroupImpl(re) {
                return new L();
              }
              setBindGroup(re, ve) {
                this.passEncoder &&
                  (this.passEncoder.setBindGroup(
                    re,
                    ve.impl.bindGroup,
                    ve.uniformBufferOffsets
                  ),
                  (this.bindGroupFormats[re] = ve.format.impl));
              }
              submitVertexBuffer(re, ve) {
                const Me = re.format.elements,
                  ze = Me.length,
                  Ge = re.impl.buffer;
                for (let nt = 0; nt < ze; nt++)
                  this.passEncoder.setVertexBuffer(ve + nt, Ge, Me[nt].offset);
                return ze;
              }
              draw(re, ve = 1, Me) {
                if (this.shader.ready && !this.shader.failed) {
                  const ze = this.passEncoder,
                    Ge = this.vertexBuffers[0],
                    nt = this.vertexBuffers[1];
                  if (((this.vertexBuffers.length = 0), Ge)) {
                    const Ct = this.submitVertexBuffer(Ge, 0);
                    nt && this.submitVertexBuffer(nt, Ct);
                  }
                  const dt = this.renderPipeline.get(
                    re,
                    Ge == null ? void 0 : Ge.format,
                    nt == null ? void 0 : nt.format,
                    this.shader,
                    this.renderTarget,
                    this.bindGroupFormats,
                    this.blendState,
                    this.depthState,
                    this.cullMode,
                    this.stencilEnabled,
                    this.stencilFront,
                    this.stencilBack
                  );
                  this.pipeline !== dt &&
                    ((this.pipeline = dt), ze.setPipeline(dt));
                  const _t = this.indexBuffer;
                  _t
                    ? ((this.indexBuffer = null),
                      ze.setIndexBuffer(_t.impl.buffer, _t.impl.format),
                      ze.drawIndexed(re.count, ve, 0, 0, 0))
                    : ze.draw(re.count, ve, 0, 0);
                }
              }
              setShader(re) {
                return (this.shader = re), !0;
              }
              setBlendState(re) {
                this.blendState.copy(re);
              }
              setDepthState(re) {
                this.depthState.copy(re);
              }
              setStencilState(re, ve) {
                if (re || ve) {
                  (this.stencilEnabled = !0),
                    this.stencilFront.copy(re != null ? re : V.p.DEFAULT),
                    this.stencilBack.copy(ve != null ? ve : V.p.DEFAULT);
                  const Me = this.stencilFront.ref;
                  this.stencilRef !== Me &&
                    ((this.stencilRef = Me),
                    this.passEncoder.setStencilReference(Me));
                } else this.stencilEnabled = !1;
              }
              setBlendColor(re, ve, Me, ze) {}
              setCullMode(re) {
                this.cullMode = re;
              }
              setAlphaToCoverage(re) {}
              initializeContextCaches() {
                super.initializeContextCaches();
              }
              setupPassEncoderDefaults() {
                this.stencilRef = 0;
              }
              startPass(re) {
                const ve = re.renderTarget || this.frameBuffer;
                this.renderTarget = ve;
                const Me = ve.impl;
                (this.commandEncoder = this.wgpu.createCommandEncoder()),
                  ve !== this.frameBuffer && this.initRenderTarget(ve),
                  Me.setupForRenderPass(re),
                  (this.pipeline = null);
                const ze = Me.renderPassDescriptor;
                if (
                  this.gpuProfiler._enabled &&
                  this.gpuProfiler.timestampQueriesSet
                ) {
                  const dt = this.gpuProfiler.getSlot(re.name);
                  ze.timestampWrites = {
                    querySet: this.gpuProfiler.timestampQueriesSet.querySet,
                    beginningOfPassWriteIndex: dt * 2,
                    endOfPassWriteIndex: dt * 2 + 1,
                  };
                }
                (this.passEncoder = this.commandEncoder.beginRenderPass(ze)),
                  this.setupPassEncoderDefaults();
                const { width: Ge, height: nt } = ve;
                this.setViewport(0, 0, Ge, nt),
                  this.setScissor(0, 0, Ge, nt),
                  (this.insideRenderPass = !0);
              }
              endPass(re) {
                this.passEncoder.end(),
                  (this.passEncoder = null),
                  (this.insideRenderPass = !1),
                  (this.bindGroupFormats.length = 0);
                for (let Me = 0; Me < re.colorArrayOps.length; Me++)
                  re.colorArrayOps[Me].mipmaps &&
                    this.mipmapRenderer.generate(
                      re.renderTarget._colorBuffers[Me].impl
                    );
                const ve = this.commandEncoder.finish();
                this.addCommandBuffer(ve), (this.commandEncoder = null);
              }
              addCommandBuffer(re, ve = !1) {
                ve
                  ? this.commandBuffers.unshift(re)
                  : this.commandBuffers.push(re);
              }
              submit() {
                this.commandBuffers.length > 0 &&
                  (this.dynamicBuffers.submit(),
                  this.wgpu.queue.submit(this.commandBuffers),
                  (this.commandBuffers.length = 0),
                  this.dynamicBuffers.onCommandBuffersSubmitted());
              }
              clear(re) {
                re.flags &&
                  this.clearRenderer.clear(
                    this,
                    this.renderTarget,
                    re,
                    this.defaultClearOptions
                  );
              }
              get width() {
                return this._width;
              }
              get height() {
                return this._height;
              }
              setDepthBias(re) {}
              setDepthBiasValues(re, ve) {}
              setViewport(re, ve, Me, ze) {
                this.passEncoder &&
                  (this.renderTarget.flipY ||
                    (ve = this.renderTarget.height - ve - ze),
                  (this.vx = re),
                  (this.vy = ve),
                  (this.vw = Me),
                  (this.vh = ze),
                  this.passEncoder.setViewport(re, ve, Me, ze, 0, 1));
              }
              setScissor(re, ve, Me, ze) {
                this.passEncoder &&
                  (this.renderTarget.flipY ||
                    (ve = this.renderTarget.height - ve - ze),
                  (this.sx = re),
                  (this.sy = ve),
                  (this.sw = Me),
                  (this.sh = ze),
                  this.passEncoder.setScissorRect(re, ve, Me, ze));
              }
              copyRenderTarget(re, ve, Me, ze) {
                var Ge;
                const nt = {
                    width: re ? re.width : ve.width,
                    height: re ? re.height : ve.height,
                    depthOrArrayLayers: 1,
                  },
                  dt =
                    (Ge = this.commandEncoder) != null
                      ? Ge
                      : this.wgpu.createCommandEncoder();
                if (Me) {
                  const _t = {
                      texture: re
                        ? re.colorBuffer.impl.gpuTexture
                        : this.renderTarget.impl.assignedColorTexture,
                      mipLevel: 0,
                    },
                    Ct = {
                      texture: ve
                        ? ve.colorBuffer.impl.gpuTexture
                        : this.renderTarget.impl.assignedColorTexture,
                      mipLevel: 0,
                    };
                  dt.copyTextureToTexture(_t, Ct, nt);
                }
                if (ze) {
                  const Ct = (re || this.renderTarget).impl.depthTexture;
                  if (re.samples > 1) {
                    const wt = ve.colorBuffer.impl.gpuTexture;
                    this.resolver.resolveDepth(dt, Ct, wt);
                  } else {
                    const wt = ve
                        ? ve.depthBuffer.impl.gpuTexture
                        : this.renderTarget.impl.depthTexture,
                      It = { texture: Ct, mipLevel: 0 },
                      Vt = { texture: wt, mipLevel: 0 };
                    dt.copyTextureToTexture(It, Vt, nt);
                  }
                }
                if (!this.commandEncoder) {
                  const _t = dt.finish();
                  this.addCommandBuffer(_t);
                }
                return !0;
              }
            }
            var tt = a(9207);
            function Be(Ut, re = {}) {
              var ve;
              const Me = (ve = re.deviceTypes) != null ? ve : [];
              if (
                (Me.includes(O.agD) || Me.push(O.agD),
                Me.includes(O.qYt) || Me.push(O.qYt),
                h.J.browser && navigator.xr)
              ) {
                var ze;
                (ze = re.xrCompatible) != null || (re.xrCompatible = !0);
              }
              let Ge;
              for (let dt = 0; dt < Me.length; dt++) {
                var nt;
                const _t = Me[dt];
                if (
                  _t === O.dJb &&
                  (nt = window) != null &&
                  (nt = nt.navigator) != null &&
                  nt.gpu
                )
                  return (
                    (Ge = new Ve(Ut, re)),
                    Ge.initWebGpu(re.glslangUrl, re.twgslUrl)
                  );
                if (_t !== O.dJb)
                  return (
                    (re.preferWebGl2 = _t === O.agD),
                    (Ge = new tt.S(Ut, re)),
                    Promise.resolve(Ge)
                  );
              }
              return Promise.reject(
                new Error("Failed to allocate graphics device")
              );
            }
            var ot = a(9459),
              Qe = a(8298),
              mt = a(6132),
              je = a(8869),
              lt = a(6615),
              Et = a(3862);
            class ct {
              constructor(re, ve = O.Tfk) {
                this.device = re.device;
                const Me = this.device.gl;
                (this._inputBuffer = re),
                  ve === O.Tfk &&
                    re.usage !== ve &&
                    (Me.bindBuffer(Me.ARRAY_BUFFER, re.impl.bufferId),
                    Me.bufferData(
                      Me.ARRAY_BUFFER,
                      re.storage,
                      Me.DYNAMIC_COPY
                    )),
                  (this._outputBuffer = new lt.o(
                    re.device,
                    re.format,
                    re.numVertices,
                    ve,
                    re.storage
                  ));
              }
              static createShader(re, ve, Me) {
                return new Xe.e(
                  re,
                  Et.x.createDefinition(re, {
                    name: Me,
                    vertexCode: ve,
                    useTransformFeedback: !0,
                  })
                );
              }
              destroy() {
                this._outputBuffer.destroy();
              }
              process(re, ve = !0) {
                const Me = this.device,
                  ze = Me.getRenderTarget();
                if (
                  (Me.setRenderTarget(null),
                  Me.updateBegin(),
                  Me.setVertexBuffer(this._inputBuffer, 0),
                  Me.setRaster(!1),
                  Me.setTransformFeedbackBuffer(this._outputBuffer),
                  Me.setShader(re),
                  Me.draw({
                    type: O.KtK,
                    base: 0,
                    count: this._inputBuffer.numVertices,
                    indexed: !1,
                  }),
                  Me.setTransformFeedbackBuffer(null),
                  Me.setRaster(!0),
                  Me.updateEnd(),
                  Me.setRenderTarget(ze),
                  ve)
                ) {
                  let Ge = this._inputBuffer.impl.bufferId;
                  (this._inputBuffer.impl.bufferId =
                    this._outputBuffer.impl.bufferId),
                    (this._outputBuffer.impl.bufferId = Ge),
                    (Ge = this._inputBuffer.impl.vao),
                    (this._inputBuffer.impl.vao = this._outputBuffer.impl.vao),
                    (this._outputBuffer.impl.vao = Ge);
                }
              }
              get inputBuffer() {
                return this._inputBuffer;
              }
              get outputBuffer() {
                return this._outputBuffer;
              }
            }
            var pt = a(8385),
              vt = a(6938),
              Fe = a(5675),
              Yt = a(9212),
              Ot = a(3176),
              Rt = a(6848),
              Kt = a(9818),
              Lt = a(4094),
              Ft = a(6135),
              Jt = a(5593),
              zt = a(4946),
              ss = a(1467),
              qt = a(5491),
              fs = a(9095),
              ls = a(3467),
              Es = a(7302),
              Ke = a(3114),
              hs = a(4611),
              is = a(464),
              ys = a(5752),
              ps = a(3894),
              Ns = a(3240),
              zs = a(1034),
              bs = a(793),
              Ws = a(6165),
              Ss = a(1071),
              ws = a(2737),
              ks = a(3054);
            class Ys {
              constructor() {
                (this.usedUvs = void 0),
                  (this.shaderChunk = void 0),
                  (this.litOptions = new ks.F());
              }
            }
            var Xs = a(5928),
              Zs = a(192),
              We = a(7790),
              ft = a(1475),
              bt = a(4976);
            const ts = [0, 1, 2, 3, 4, 5, 6, 7],
              Qt = {
                generateKey: function (Ut) {
                  return (
                    "lit" +
                    ts.map((ve, Me) => (Ut.usedUvs[Me] ? "1" : "0")).join("") +
                    Ut.shaderChunk +
                    bt.W.generateKey(Ut.litOptions)
                  );
                },
                createShaderDefinition: function (Ut, re) {
                  const ve = new ft.i(Ut, re.litOptions),
                    Me = new We.R(),
                    ze = new We.R(),
                    Ge = new We.R();
                  Me.append("uniform float textureBias;"),
                    Me.append(ve.chunks.litShaderArgsPS),
                    ze.append(re.shaderChunk),
                    (Ge.code = "evaluateFrontend();"),
                    (Ge.code = `
${Ge.code
  .split(
    `
`
  )
  .map((_t) => `    ${_t}`).join(`
`)}

`);
                  const nt = re.usedUvs || [!0],
                    dt = [];
                  return (
                    ve.generateVertexShader(nt, nt, dt),
                    ve.generateFragmentShader(
                      Me.code,
                      ze.code,
                      Ge.code,
                      "vUv0"
                    ),
                    ve.getDefinition()
                  );
                },
              },
              rs = new Ys();
            class Ps extends ws.F {
              constructor(...re) {
                super(...re),
                  (this.usedUvs = [!0]),
                  (this.shaderChunk = `void evaluateFrontend() {}
`),
                  (this.chunks = null),
                  (this.useLighting = !0),
                  (this.useFog = !0),
                  (this.useGammaTonemap = !0),
                  (this.useSkybox = !0),
                  (this.shadingModel = Ke.qT),
                  (this.ambientSH = null),
                  (this.pixelSnap = !1),
                  (this.nineSlicedMode = null),
                  (this.fastTbn = !1),
                  (this.twoSidedLighting = !1),
                  (this.occludeDirect = !1),
                  (this.occludeSpecular = Ke._f),
                  (this.occludeSpecularIntensity = 1),
                  (this.opacityFadesSpecular = !0),
                  (this.conserveEnergy = !0),
                  (this.ggxSpecular = !1),
                  (this.fresnelModel = Ke.Rx),
                  (this.dynamicRefraction = !1),
                  (this.hasAo = !1),
                  (this.hasSpecular = !1),
                  (this.hasSpecularityFactor = !1),
                  (this.hasLighting = !1),
                  (this.hasHeights = !1),
                  (this.hasNormals = !1),
                  (this.hasSheen = !1),
                  (this.hasRefraction = !1),
                  (this.hasIrridescence = !1),
                  (this.hasMetalness = !1),
                  (this.hasClearCoat = !1),
                  (this.hasClearCoatNormals = !1);
              }
              getShaderVariant(re, ve, Me, ze, Ge, nt, dt, _t, Ct) {
                (rs.usedUvs = this.usedUvs.slice()),
                  (rs.shaderChunk = this.shaderChunk),
                  Xs.Q.update(rs.litOptions, this, ve, Me, Ge, nt);
                const wt = new Ss.C(dt, _t, Ct),
                  It = (0, Zs.N)(re);
                return (
                  It.register("lit", Qt),
                  It.getProgram("lit", rs, wt, this.userId)
                );
              }
            }
            var Ts = a(349),
              ei = a(4210),
              Js = a(7915),
              ti = a(7934),
              Bs = a(6462),
              si = a(8632),
              Ti = a(4641),
              xi = a(7678),
              Is = a(8792),
              ai = a(9915),
              Qs = a(3823),
              ji = a(1259),
              Di = a(7551),
              Yi = a(3241),
              Ai = a(4354),
              Oi = a(7224),
              Ci = a(1585),
              Li = a(4390),
              Bi = a(8691),
              Fi = a(9432),
              Ui = a(8944),
              pi = a(7474),
              Xi = a(6567),
              Pi = a(8451),
              Zi = a(242),
              Ji = a(340),
              Ni = a(1741),
              Mi = a(9375),
              bi = a(3200);
            function _i(Ut, re) {
              return Math.atan2(Ut * re, Math.sqrt(Ut * Ut + re * re + 1));
            }
            function Qi(Ut, re, ve) {
              let Me = (2 * (Ut + 0.5)) / ve - 1,
                ze = (2 * (re + 0.5)) / ve - 1;
              (Me *= 1 - 1 / ve), (ze *= 1 - 1 / ve);
              const Ge = 1 / ve,
                nt = Me - Ge,
                dt = ze - Ge,
                _t = Me + Ge,
                Ct = ze + Ge;
              let wt = _i(nt, dt) - _i(nt, Ct) - _i(_t, dt) + _i(_t, Ct);
              return (
                (Ut === 0 && re === 0) ||
                (Ut === ve - 1 && re === 0) ||
                (Ut === 0 && re === ve - 1) ||
                (Ut === ve - 1 && re === ve - 1)
                  ? (wt /= 3)
                  : (Ut === 0 || re === 0 || Ut === ve - 1 || re === ve - 1) &&
                    (wt *= 0.5),
                wt
              );
            }
            function $i(Ut, re, ve) {
              if (re.format !== O.jKI || !re._levels[0] || !re._levels[0][0])
                return null;
              const Me = re.width;
              if (!re._levels[0][0].length)
                if (re._levels[0][0] instanceof HTMLImageElement) {
                  const os = (0, Mi.JM)(
                      Ut,
                      bi.n.fullscreenQuadVS,
                      bi.n.fullscreenQuadPS,
                      "fsQuadSimple"
                    ),
                    as = Ut.scope.resolve("source");
                  for (let gs = 0; gs < 6; gs++) {
                    const di = re._levels[0][gs],
                      Ms = new je.x(Ut, {
                        name: "prefiltered-cube",
                        cubemap: !1,
                        type: O.zZc,
                        format: re.format,
                        width: Me,
                        height: Me,
                        mipmaps: !1,
                      });
                    (Ms._levels[0] = di), Ms.upload();
                    const Hs = new je.x(Ut, {
                        name: "prefiltered-cube",
                        cubemap: !1,
                        type: O.zZc,
                        format: re.format,
                        width: Me,
                        height: Me,
                        mipmaps: !1,
                      }),
                      ni = new N.A({ colorBuffer: Hs, depth: !1 });
                    as.setValue(Ms),
                      Ut.setBlendState(Ae.a.NOBLEND),
                      (0, is.H)(Ut, ni, os);
                    const Ks = Ut.gl;
                    Ks.bindFramebuffer(Ks.FRAMEBUFFER, ni.impl._glFrameBuffer);
                    const Sn = new Uint8Array(Me * Me * 4);
                    Ks.readPixels(
                      0,
                      0,
                      Ms.width,
                      Ms.height,
                      Ks.RGBA,
                      Ks.UNSIGNED_BYTE,
                      Sn
                    ),
                      (re._levels[0][gs] = Sn);
                  }
                } else return null;
              const ze = [];
              for (let os = 0; os < Me; os++)
                for (let as = 0; as < Me; as++) {
                  const gs = (as / (Me - 1)) * 2 - 1,
                    di = (os / (Me - 1)) * 2 - 1;
                  ze[os * Me + as] = new B.A(gs, di, 1).normalize();
                }
              const Ge = new Float32Array(9 * 3),
                nt = 0,
                dt = 1 * 3,
                _t = 2 * 3,
                Ct = 3 * 3,
                wt = 4 * 3,
                It = 5 * 3,
                Vt = 6 * 3,
                Wt = 7 * 3,
                Zt = 8 * 3,
                ds = 0,
                Gs = 1,
                Us = 2,
                $s = 3,
                vi = 4,
                En = 5;
              let us = 0;
              for (let os = 0; os < 6; os++)
                for (let as = 0; as < Me; as++)
                  for (let gs = 0; gs < Me; gs++) {
                    const di = as * Me + gs,
                      Ms = Qi(gs, as, Me),
                      Hs = (Ms * 4) / 17,
                      ni = (Ms * 8) / 17,
                      Ks = (Ms * 15) / 17,
                      Sn = (Ms * 5) / 68,
                      Ki = (Ms * 15) / 68,
                      Os = ze[di];
                    let qs, ui, fi;
                    os === ds
                      ? ((qs = Os.z), (ui = -Os.y), (fi = -Os.x))
                      : os === Gs
                      ? ((qs = -Os.z), (ui = -Os.y), (fi = Os.x))
                      : os === Us
                      ? ((qs = Os.x), (ui = Os.z), (fi = Os.y))
                      : os === $s
                      ? ((qs = Os.x), (ui = -Os.z), (fi = -Os.y))
                      : os === vi
                      ? ((qs = Os.x), (ui = -Os.y), (fi = Os.z))
                      : os === En && ((qs = -Os.x), (ui = -Os.y), (fi = -Os.z)),
                      ve || (qs = -qs);
                    const va = re._levels[0][os][di * 4 + 3] / 255;
                    for (let ri = 0; ri < 3; ri++) {
                      let js = re._levels[0][os][di * 4 + ri] / 255;
                      re.type === O.xIP
                        ? ((js *= va * 8), (js *= js))
                        : (js = Math.pow(js, 2.2)),
                        (Ge[nt + ri] += js * Hs),
                        (Ge[dt + ri] += js * ni * qs),
                        (Ge[_t + ri] += js * ni * ui),
                        (Ge[Ct + ri] += js * ni * fi),
                        (Ge[wt + ri] += js * Ks * qs * fi),
                        (Ge[It + ri] += js * Ks * fi * ui),
                        (Ge[Vt + ri] += js * Ks * ui * qs),
                        (Ge[Wt + ri] += js * Sn * (3 * fi * fi - 1)),
                        (Ge[Zt + ri] += js * Ki * (qs * qs - ui * ui)),
                        (us += Ms);
                    }
                  }
              for (let os = 0; os < Ge.length; os++)
                Ge[os] *= (4 * Math.PI) / us;
              return Ge;
            }
            var qi = a(732),
              en = a(3587),
              zi = a(8372),
              mi = a(8713),
              tn = a(5751),
              Wi = a(2816),
              sn = a(3322),
              nn = a(3221),
              ki = a(5107),
              rn = a(1012),
              Vi = a(7078),
              Gi = a(8182),
              an = a(5212),
              on = a(7075),
              oi = a(9578),
              ii = a(356),
              ln = a(8740),
              li = a(5545),
              hn = a(889),
              cn = a(1951),
              Ls = a(4378),
              xn = a(5865),
              wi = a(4185),
              An = a(2280),
              _n = a(8620),
              Cn = a(6813),
              mn = a(73),
              gi = a(3404),
              Pn = a(7964),
              $t = a(7627),
              gn = a(4647),
              ee = a(258),
              S = a(5004),
              D = a(9968),
              le = a(7580),
              Ce = a(3648),
              Ue = a(6869),
              rt = a(381),
              Je = a(1724),
              St = a(428),
              Bt = a(3269),
              Nt = a(492),
              Ht = a(7847),
              ns = a(5719),
              xs = a(8320),
              _s = a(6236),
              Rs = a(5985),
              ms = a(1166),
              Vs = a(86),
              hi = a(3678),
              yn = a(3121),
              dn = a(8280),
              Un = a(3962),
              es = a(2628),
              Nn = a(4608),
              un = a(8069),
              zn = a(590),
              wn = a(2329),
              In = a(7680),
              Wn = a(3518),
              Mn = a(3659),
              Rn = a(24),
              Ds = a(1345),
              vn = a(6527),
              Dn = a(8345),
              Ii = a(7379),
              yi = a(8874),
              vs = a(2583),
              Hi = a(8580),
              ci = a(6795),
              fn = a(5849),
              On = a(9386),
              Ln = a(1873),
              Kn = a(4534),
              qn = a(4656),
              er = a(5425),
              tr = a(1485),
              sr = a(7088),
              ir = a(9409),
              nr = a(9521),
              rr = a(5441),
              kn = a(3471),
              ar = a(7301),
              or = a(7968),
              lr = a(7061),
              hr = a(3248),
              cr = a(7570),
              dr = a(8934),
              ur = a(5440),
              fr = a(2761),
              pr = a(8949),
              _r = a(7122),
              cs = a(8250),
              mr = a(9509),
              gr = a(6608),
              Fs = a(8462),
              jn = a(6204);
            class yr extends s.b {
              constructor(re, ve) {
                super(),
                  (this._assets = new Set()),
                  (this._loadingAssets = new Set()),
                  (this._waitingAssets = new Set()),
                  (this._registry = ve),
                  (this._loading = !1),
                  (this._loaded = !1),
                  (this._failed = []),
                  re.forEach((Me) => {
                    if (Me instanceof jn.x)
                      Me.registry || (Me.registry = ve), this._assets.add(Me);
                    else {
                      const ze = ve.get(Me);
                      ze ? this._assets.add(ze) : this._waitForAsset(Me);
                    }
                  });
              }
              destroy() {
                const re = this;
                this._registry.off("load", this._onLoad),
                  this._registry.off("error", this._onError),
                  this._waitingAssets.forEach(function (ve) {
                    re._registry.off("add:" + ve, this._onAddAsset);
                  }),
                  this.off("progress"),
                  this.off("load");
              }
              _assetHasDependencies(re) {
                var ve;
                return (
                  re.type === "model" &&
                  ((ve = re.file) == null ? void 0 : ve.url) &&
                  re.file.url &&
                  re.file.url.match(/.json$/g)
                );
              }
              load(re, ve) {
                if (this._loading) return;
                (this._loading = !0),
                  (this._callback = re),
                  (this._scope = ve),
                  this._registry.on("load", this._onLoad, this),
                  this._registry.on("error", this._onError, this);
                let Me = !1;
                this._assets.forEach((ze) => {
                  ze.loaded ||
                    ((Me = !0),
                    this._assetHasDependencies(ze) &&
                      this._registry.loadFromUrl(
                        ze.file.url,
                        ze.type,
                        (Ge, nt) => {
                          if (Ge) {
                            this._onError(Ge, ze);
                            return;
                          }
                          this._onLoad(ze);
                        }
                      ),
                    this._loadingAssets.add(ze),
                    this._registry.add(ze));
                }),
                  this._loadingAssets.forEach((ze) => {
                    this._assetHasDependencies(ze) || this._registry.load(ze);
                  }),
                  !Me &&
                    this._waitingAssets.size === 0 &&
                    this._loadingComplete();
              }
              ready(re, ve = this) {
                this._loaded
                  ? re.call(ve, Array.from(this._assets))
                  : this.once("load", function (Me) {
                      re.call(ve, Me);
                    });
              }
              _loadingComplete() {
                this._loaded ||
                  ((this._loaded = !0),
                  this._registry.off("load", this._onLoad, this),
                  this._registry.off("error", this._onError, this),
                  this._failed.length
                    ? (this._callback &&
                        this._callback.call(
                          this._scope,
                          "Failed to load some assets",
                          this._failed
                        ),
                      this.fire("error", this._failed))
                    : (this._callback && this._callback.call(this._scope),
                      this.fire("load", Array.from(this._assets))));
              }
              _onLoad(re) {
                this._loadingAssets.has(re) &&
                  (this.fire("progress", re), this._loadingAssets.delete(re)),
                  this._loadingAssets.size === 0 &&
                    setTimeout(() => {
                      this._loadingComplete(this._failed);
                    }, 0);
              }
              _onError(re, ve) {
                this._loadingAssets.has(ve) &&
                  (this._failed.push(ve), this._loadingAssets.delete(ve)),
                  this._loadingAssets.size === 0 &&
                    setTimeout(() => {
                      this._loadingComplete(this._failed);
                    }, 0);
              }
              _onAddAsset(re) {
                this._waitingAssets.delete(re),
                  this._assets.add(re),
                  re.loaded ||
                    (this._loadingAssets.add(re), this._registry.load(re));
              }
              _waitForAsset(re) {
                this._waitingAssets.add(re),
                  this._registry.once("add:" + re, this._onAddAsset, this);
              }
            }
            var vr = a(5755),
              Er = a(6612),
              Sr = a(2416),
              Yn = a(5611),
              Tr = a(2794);
            const Bn = 4096,
              Xn = 512;
            class xr extends s.b {
              constructor(re, ve = {}) {
                super(),
                  (this.type = "bitmap"),
                  (this.app = re),
                  (this.intensity = 0),
                  (this.fontWeight = ve.fontWeight || "normal"),
                  (this.fontSize = parseInt(ve.fontSize, 10)),
                  (this.glyphSize = this.fontSize),
                  (this.fontName = ve.fontName || "Arial"),
                  (this.color = ve.color || new _.I(1, 1, 1)),
                  (this.padding = ve.padding || 0);
                const Me = ve.width > Bn ? Bn : ve.width || Xn,
                  ze = ve.height > Bn ? Bn : ve.height || Xn,
                  Ge = document.createElement("canvas");
                (Ge.height = ze), (Ge.width = Me);
                const nt = new je.x(this.app.graphicsDevice, {
                  name: "font",
                  format: O.jKI,
                  minFilter: O.Snx,
                  magFilter: O.I5X,
                  addressU: O.uFb,
                  addressV: O.uFb,
                  mipmaps: !0,
                });
                nt.setSource(Ge),
                  (this.textures = [nt]),
                  (this.chars = ""),
                  (this.data = {});
              }
              createTextures(re) {
                const ve = this._normalizeCharsSet(re);
                if (ve.length !== this.chars.length) {
                  this._renderAtlas(ve);
                  return;
                }
                for (let Me = 0; Me < ve.length; Me++)
                  if (ve[Me] !== this.chars[Me]) {
                    this._renderAtlas(ve);
                    return;
                  }
              }
              updateTextures(re) {
                const ve = this._normalizeCharsSet(re),
                  Me = [];
                for (let ze = 0; ze < ve.length; ze++) {
                  const Ge = ve[ze];
                  this.data.chars[Ge] || Me.push(Ge);
                }
                Me.length > 0 && this._renderAtlas(this.chars.concat(Me));
              }
              destroy() {
                for (let re = 0; re < this.textures.length; re++)
                  this.textures[re].destroy();
                (this.chars = null),
                  (this.color = null),
                  (this.data = null),
                  (this.fontName = null),
                  (this.fontSize = null),
                  (this.glyphSize = null),
                  (this.intensity = null),
                  (this.textures = null),
                  (this.type = null),
                  (this.fontWeight = null);
              }
              _getAndClearContext(re, ve) {
                const Me = re.width,
                  ze = re.height,
                  Ge = re.getContext("2d", { alpha: !0 });
                return (
                  Ge.clearRect(0, 0, Me, ze),
                  (Ge.fillStyle = ve),
                  Ge.fillRect(0, 0, Me, ze),
                  Ge
                );
              }
              _colorToRgbString(re, ve) {
                let Me;
                const ze = Math.round(255 * re.r),
                  Ge = Math.round(255 * re.g),
                  nt = Math.round(255 * re.b);
                return (
                  ve
                    ? (Me = `rgba(${ze}, ${Ge}, ${nt}, ${re.a})`)
                    : (Me = `rgb(${ze}, ${Ge}, ${nt})`),
                  Me
                );
              }
              renderCharacter(re, ve, Me, ze, Ge) {
                (re.fillStyle = Ge), re.fillText(ve, Me, ze);
              }
              _renderAtlas(re) {
                this.chars = re;
                let ve = 1,
                  Me = this.textures[ve - 1].getSource();
                const ze = Me.width,
                  Ge = Me.height,
                  nt = this._colorToRgbString(this.color, !1),
                  dt = this.color.a;
                this.color.a = 0.00392156862745098;
                const _t = this._colorToRgbString(this.color, !0);
                this.color.a = dt;
                const Ct = "center",
                  wt = "alphabetic";
                let It = this._getAndClearContext(Me, _t);
                (It.font =
                  this.fontWeight +
                  " " +
                  this.fontSize.toString() +
                  "px " +
                  this.fontName),
                  (It.textAlign = Ct),
                  (It.textBaseline = wt),
                  (this.data = this._createJson(
                    this.chars,
                    this.fontName,
                    ze,
                    Ge
                  ));
                const Vt = f.Z.getSymbols(this.chars.join("")),
                  Wt = this.textures.length;
                let Zt = 0,
                  ds = 0;
                const Gs = {};
                for (let as = 0; as < Vt.length; as++) {
                  const gs = Vt[as];
                  (Gs[gs] = this._getTextMetrics(gs)),
                    (Zt = Math.max(Zt, Gs[gs].height)),
                    (ds = Math.max(ds, Gs[gs].descent));
                }
                this.glyphSize = Math.max(this.glyphSize, Zt);
                const Us = this.glyphSize + this.padding * 2,
                  $s = this.glyphSize + this.padding * 2,
                  vi = this.glyphSize / 2 + this.padding,
                  En = $s - ds - this.padding;
                let us = 0,
                  os = 0;
                for (let as = 0; as < Vt.length; as++) {
                  const gs = Vt[as],
                    di = f.Z.getCodePoint(Vt[as]);
                  let Ms = this.fontSize;
                  (It.font =
                    this.fontWeight +
                    " " +
                    Ms.toString() +
                    "px " +
                    this.fontName),
                    (It.textAlign = Ct),
                    (It.textBaseline = wt);
                  let Hs = It.measureText(gs).width;
                  Hs > Ms &&
                    ((Ms = (this.fontSize * this.fontSize) / Hs),
                    (It.font =
                      this.fontWeight +
                      " " +
                      Ms.toString() +
                      "px " +
                      this.fontName),
                    (Hs = this.fontSize)),
                    this.renderCharacter(It, gs, us + vi, os + En, nt);
                  const ni = this.padding + (this.glyphSize - Hs) / 2,
                    Ks = -this.padding + Gs[gs].descent - ds,
                    Sn = Hs;
                  if (
                    (this._addChar(
                      this.data,
                      gs,
                      di,
                      us,
                      os,
                      Us,
                      $s,
                      ni,
                      Ks,
                      Sn,
                      ve - 1,
                      ze,
                      Ge
                    ),
                    (us += Us),
                    us + Us > ze && ((us = 0), (os += $s), os + $s > Ge))
                  )
                    if (
                      (this.textures[ve - 1].upload(), ve++, (os = 0), ve > Wt)
                    ) {
                      (Me = document.createElement("canvas")),
                        (Me.height = Ge),
                        (Me.width = ze),
                        (It = this._getAndClearContext(Me, _t));
                      const Ki = new je.x(this.app.graphicsDevice, {
                        format: O.jKI,
                        mipmaps: !0,
                        name: "font-atlas",
                      });
                      Ki.setSource(Me),
                        (Ki.minFilter = O.Snx),
                        (Ki.magFilter = O.I5X),
                        (Ki.addressU = O.uFb),
                        (Ki.addressV = O.uFb),
                        this.textures.push(Ki);
                    } else
                      (Me = this.textures[ve - 1].getSource()),
                        (It = this._getAndClearContext(Me, _t));
                }
                if ((this.textures[ve - 1].upload(), ve < Wt)) {
                  for (let as = ve; as < Wt; as++) this.textures[as].destroy();
                  this.textures.splice(ve);
                }
                this.fire("render");
              }
              _createJson(re, ve, Me, ze) {
                return {
                  version: 3,
                  intensity: this.intensity,
                  info: {
                    face: ve,
                    width: Me,
                    height: ze,
                    maps: [{ width: Me, height: ze }],
                  },
                  chars: {},
                };
              }
              _addChar(re, ve, Me, ze, Ge, nt, dt, _t, Ct, wt, It, Vt, Wt) {
                re.info.maps.length < It + 1 &&
                  re.info.maps.push({ width: Vt, height: Wt });
                const Zt = this.fontSize / 32;
                re.chars[ve] = {
                  id: Me,
                  letter: ve,
                  x: ze,
                  y: Ge,
                  width: nt,
                  height: dt,
                  xadvance: wt / Zt,
                  xoffset: _t / Zt,
                  yoffset: (Ct + this.padding) / Zt,
                  scale: Zt,
                  range: 1,
                  map: It,
                  bounds: [0, 0, nt / Zt, dt / Zt],
                };
              }
              _normalizeCharsSet(re) {
                const ve = this.app.systems.element.getUnicodeConverter();
                ve && (re = ve(re));
                const Me = {},
                  ze = f.Z.getSymbols(re);
                for (let nt = 0; nt < ze.length; nt++) {
                  const dt = ze[nt];
                  Me[dt] || (Me[dt] = dt);
                }
                return Object.keys(Me).sort();
              }
              _getTextMetrics(re) {
                const ve = document.createElement("span");
                (ve.id = "content-span"), (ve.innerHTML = re);
                const Me = document.createElement("div");
                (Me.id = "content-block"),
                  (Me.style.display = "inline-block"),
                  (Me.style.width = "1px"),
                  (Me.style.height = "0px");
                const ze = document.createElement("div");
                ze.appendChild(ve),
                  ze.appendChild(Me),
                  (ze.style.font = this.fontSize + "px " + this.fontName),
                  document.body.appendChild(ze);
                let nt = -1,
                  dt = -1,
                  _t = -1;
                try {
                  (Me.style["vertical-align"] = "baseline"),
                    (nt = Me.offsetTop - ve.offsetTop),
                    (Me.style["vertical-align"] = "bottom"),
                    (_t = Me.offsetTop - ve.offsetTop),
                    (dt = _t - nt);
                } finally {
                  document.body.removeChild(ze);
                }
                return { ascent: nt, descent: dt, height: _t };
              }
            }
            var Ar = a(8804),
              Cr = a(4091),
              Pr = a(6604),
              Mr = a(3009),
              br = a(5067),
              wr = a(5229),
              Ir = a(6706),
              Rr = a(1257),
              Dr = a(8652),
              Or = a(3913),
              Lr = a(8586),
              Zn = a(8493),
              Br = a(3671),
              Fr = a(216),
              Ur = a(1912),
              Nr = a(8001),
              zr = a(325),
              Wr = a(2353),
              kr = a(496),
              Vr = a(1676),
              Gr = a(5404),
              Hr = a(1642);
            class Kr {
              load(re, ve, Me) {
                throw new Error("not implemented");
              }
              open(re, ve, Me) {
                throw new Error("not implemented");
              }
              patch(re, ve) {}
            }
            var jr = a(8936),
              Yr = a(1297),
              Xr = a(8169),
              Zr = a(8297);
            class Jr {
              constructor(re) {
                (this._app = re), (this.maxRetries = 0);
              }
              load(re, ve) {
                Zr.p.load(re, this.maxRetries, ve);
              }
              open(re, ve) {
                return ve.settings;
              }
            }
            var Qr = a(8115),
              $r = a(1761),
              qr = a(7265),
              ea = a(8769),
              Jn = a(8020),
              ta = a(5275),
              bn = a(6327),
              sa = a(2710),
              Vn = a(9124),
              ia = a(36),
              na = a(4759),
              ra = a(3428),
              aa = a(68),
              As = a(2872),
              oa = a(7649),
              la = a(5541),
              ha = a(5268),
              ca = a(8657),
              da = a(1502),
              ua = a(1376),
              fa = a(8878),
              pa = a(5571),
              _a = a(6337),
              ma = a(100),
              ga = a(2953),
              ya = a(8010),
              Xt = a(8433);
          },
          2100: (Se, W, a) => {
            "use strict";
            a.d(W, { b: () => x });
            function x() {
              return (
                typeof AudioContext != "undefined" ||
                typeof webkitAudioContext != "undefined"
              );
            }
          },
          6874: (Se, W, a) => {
            "use strict";
            a.d(W, { $: () => g });
            var x = a(4585),
              T = a(2100);
            class g {
              constructor(d, h, f = {}) {
                var s, l, n;
                if (
                  ((this.volume = (s = f.volume) != null ? s : 1),
                  (this.loop = (l = f.loop) != null ? l : !1),
                  (this.pitch = (n = f.pitch) != null ? n : 1),
                  (this.sound = h),
                  (this.paused = !1),
                  (this.suspended = !1),
                  (this.manager = d),
                  (this.source = null),
                  (0, T.b)())
                ) {
                  (this.startTime = 0), (this.startOffset = 0);
                  const o = d.context;
                  this.gain = o.createGain();
                } else
                  h.audio &&
                    ((this.source = h.audio.cloneNode(!1)),
                    this.source.pause());
              }
              getVolume() {
                return this.volume;
              }
              getLoop() {
                return this.loop;
              }
              setLoop(d) {
                (this.loop = d), this.source && (this.source.loop = d);
              }
              getPitch() {
                return this.pitch;
              }
              onManagerVolumeChange() {
                this.setVolume(this.getVolume());
              }
              onManagerSuspend() {
                this.isPlaying() &&
                  !this.suspended &&
                  ((this.suspended = !0), this.pause());
              }
              onManagerResume() {
                this.suspended && ((this.suspended = !1), this.unpause());
              }
              play() {
                if (this.source)
                  throw new Error("Call stop() before calling play()");
                this._createSource(),
                  this.source &&
                    ((this.startTime = this.manager.context.currentTime),
                    this.source.start(
                      0,
                      this.startOffset % this.source.buffer.duration
                    ),
                    this.setVolume(this.volume),
                    this.setLoop(this.loop),
                    this.setPitch(this.pitch),
                    this.manager.on(
                      "volumechange",
                      this.onManagerVolumeChange,
                      this
                    ),
                    this.manager.on("suspend", this.onManagerSuspend, this),
                    this.manager.on("resume", this.onManagerResume, this),
                    this.manager.suspended && this.onManagerSuspend());
              }
              pause() {
                this.source &&
                  ((this.paused = !0),
                  (this.startOffset +=
                    this.manager.context.currentTime - this.startTime),
                  this.source.stop(0),
                  (this.source = null));
              }
              unpause() {
                if (this.source || !this.paused) {
                  console.warn("Call pause() before unpausing.");
                  return;
                }
                this._createSource(),
                  this.source &&
                    ((this.startTime = this.manager.context.currentTime),
                    this.source.start(
                      0,
                      this.startOffset % this.source.buffer.duration
                    ),
                    this.setVolume(this.volume),
                    this.setLoop(this.loop),
                    this.setPitch(this.pitch),
                    (this.paused = !1));
              }
              stop() {
                this.source && (this.source.stop(0), (this.source = null)),
                  this.manager.off(
                    "volumechange",
                    this.onManagerVolumeChange,
                    this
                  ),
                  this.manager.off("suspend", this.onManagerSuspend, this),
                  this.manager.off("resume", this.onManagerResume, this);
              }
              setVolume(d) {
                (d = x.m.clamp(d, 0, 1)),
                  (this.volume = d),
                  this.gain && (this.gain.gain.value = d * this.manager.volume);
              }
              setPitch(d) {
                (this.pitch = d),
                  this.source && (this.source.playbackRate.value = d);
              }
              isPlaying() {
                return (
                  !this.paused &&
                  this.source.playbackState === this.source.PLAYING_STATE
                );
              }
              getDuration() {
                return this.source ? this.source.buffer.duration : 0;
              }
              _createSource() {
                const d = this.manager.context;
                this.sound.buffer &&
                  ((this.source = d.createBufferSource()),
                  (this.source.buffer = this.sound.buffer),
                  this.source.connect(this.gain),
                  this.gain.connect(d.destination),
                  this.loop || (this.source.onended = this.pause.bind(this)));
              }
            }
            (0, T.b)() ||
              Object.assign(g.prototype, {
                play: function () {
                  this.source &&
                    ((this.paused = !1),
                    this.setVolume(this.volume),
                    this.setLoop(this.loop),
                    this.setPitch(this.pitch),
                    this.source.play()),
                    this.manager.on(
                      "volumechange",
                      this.onManagerVolumeChange,
                      this
                    ),
                    this.manager.on("suspend", this.onManagerSuspend, this),
                    this.manager.on("resume", this.onManagerResume, this),
                    this.manager.suspended && this.onManagerSuspend();
                },
                pause: function () {
                  this.source && ((this.paused = !0), this.source.pause());
                },
                unpause: function () {
                  this.source && ((this.paused = !1), this.source.play());
                },
                stop: function () {
                  this.source && this.source.pause(),
                    this.manager.off(
                      "volumechange",
                      this.onManagerVolumeChange,
                      this
                    ),
                    this.manager.off("suspend", this.onManagerSuspend, this),
                    this.manager.off("resume", this.onManagerResume, this);
                },
                setVolume: function (c) {
                  (c = x.m.clamp(c, 0, 1)),
                    (this.volume = c),
                    this.source &&
                      (this.source.volume = c * this.manager.volume);
                },
                setPitch: function (c) {
                  (this.pitch = c),
                    this.source && (this.source.playbackRate = c);
                },
                getDuration: function () {
                  return this.source && !isNaN(this.source.duration)
                    ? this.source.duration
                    : 0;
                },
                isPlaying: function () {
                  return !this.source.paused;
                },
              });
          },
          9725: (Se, W, a) => {
            "use strict";
            a.d(W, { b: () => f });
            var x = a(4585),
              T = a(6556),
              g = a(1304),
              c = a(2100),
              d = a(6874);
            const h = 1e4;
            class f extends d.$ {
              constructor(l, n, o) {
                super(l, n, o),
                  (this.position = new T.A()),
                  (this.velocity = new T.A()),
                  (0, c.b)()
                    ? (this.panner = l.context.createPanner())
                    : ((this.maxDistance = h),
                      (this.minDistance = 1),
                      (this.rollOffFactor = 1),
                      (this.distanceModel = g.mU));
              }
              getPosition() {
                return this.position;
              }
              setPosition(l) {
                this.position.copy(l);
                const n = this.panner;
                "positionX" in n
                  ? ((n.positionX.value = l.x),
                    (n.positionY.value = l.y),
                    (n.positionZ.value = l.z))
                  : n.setPosition && n.setPosition(l.x, l.y, l.z);
              }
              getVelocity() {
                return this.velocity;
              }
              setVelocity(l) {
                this.velocity.copy(l);
              }
              getMaxDistance() {
                return this.panner.maxDistance;
              }
              setMaxDistance(l) {
                this.panner.maxDistance = l;
              }
              getMinDistance() {
                return this.panner.refDistance;
              }
              setMinDistance(l) {
                this.panner.refDistance = l;
              }
              getRollOffFactor() {
                return this.panner.rolloffFactor;
              }
              setRollOffFactor(l) {
                this.panner.rolloffFactor = l;
              }
              getDistanceModel() {
                return this.panner.distanceModel;
              }
              setDistanceModel(l) {
                this.panner.distanceModel = l;
              }
              _createSource() {
                const l = this.manager.context;
                (this.source = l.createBufferSource()),
                  (this.source.buffer = this.sound.buffer),
                  this.source.connect(this.panner),
                  this.panner.connect(this.gain),
                  this.gain.connect(l.destination),
                  this.loop || (this.source.onended = this.pause.bind(this));
              }
            }
            if (!(0, c.b)()) {
              let s = new T.A();
              const l = function (o, i, e, t, r, u) {
                s = s.sub2(o, i);
                const y = s.length();
                if (y < e) return 1;
                if (y > t) return 0;
                let p = 0;
                return (
                  u === g.WY
                    ? (p = 1 - (r * (y - e)) / (t - e))
                    : u === g.mU
                    ? (p = e / (e + r * (y - e)))
                    : u === g.r1 && (p = Math.pow(y / e, -r)),
                  x.m.clamp(p, 0, 1)
                );
              };
              Object.assign(f.prototype, {
                setPosition: function (n) {
                  if ((this.position.copy(n), this.source)) {
                    const i = this.manager.listener.getPosition(),
                      e = l(
                        i,
                        this.position,
                        this.minDistance,
                        this.maxDistance,
                        this.rollOffFactor,
                        this.distanceModel
                      ),
                      t = this.getVolume();
                    this.source.volume = t * e;
                  }
                },
                getMaxDistance: function () {
                  return this.maxDistance;
                },
                setMaxDistance: function (n) {
                  this.maxDistance = n;
                },
                getMinDistance: function () {
                  return this.minDistance;
                },
                setMinDistance: function (n) {
                  this.minDistance = n;
                },
                getRollOffFactor: function () {
                  return this.rollOffFactor;
                },
                setRollOffFactor: function (n) {
                  this.rollOffFactor = n;
                },
                getDistanceModel: function () {
                  return this.distanceModel;
                },
                setDistanceModel: function (n) {
                  this.distanceModel = n;
                },
              });
            }
          },
          1304: (Se, W, a) => {
            "use strict";
            a.d(W, { WY: () => x, mU: () => T, r1: () => g });
            const x = "linear",
              T = "inverse",
              g = "exponential";
          },
          2158: (Se, W, a) => {
            "use strict";
            a.d(W, { Q1: () => c, WM: () => h, sT: () => d });
            var x = a(7921);
            let T = 0;
            const g = {
              [x.He_]: "texture2D",
              [x.Hfq]: "textureCube",
              [x.lTf]: "texture3D",
            };
            class c {
              constructor(s, l) {
                (this.name = s), (this.visibility = l);
              }
            }
            class d {
              constructor(s, l, n = x.He_, o = x.qUb) {
                (this.scopeId = void 0),
                  (this.name = s),
                  (this.visibility = l),
                  (this.textureDimension = n),
                  (this.sampleType = o);
              }
            }
            class h {
              constructor(s, l = [], n = []) {
                (this.id = T++),
                  (this.device = s),
                  (this.bufferFormats = l),
                  (this.bufferFormatsMap = new Map()),
                  l.forEach((i, e) => this.bufferFormatsMap.set(i.name, e)),
                  (this.textureFormats = n);
                const o = s.scope;
                (this.textureFormatsMap = new Map()),
                  n.forEach((i, e) => {
                    this.textureFormatsMap.set(i.name, e),
                      (i.scopeId = o.resolve(i.name));
                  }),
                  (this.impl = s.createBindGroupFormatImpl(this));
              }
              destroy() {
                this.impl.destroy();
              }
              getTexture(s) {
                const l = this.textureFormatsMap.get(s);
                return l !== void 0 ? this.textureFormats[l] : null;
              }
              getShaderDeclarationTextures(s) {
                let l = "",
                  n = this.bufferFormats.length;
                return (
                  this.textureFormats.forEach((o) => {
                    const i = g[o.textureDimension];
                    l += `layout(set = ${s}, binding = ${n++}) uniform ${i} ${
                      o.name
                    };
layout(set = ${s}, binding = ${n++}) uniform sampler ${o.name}_sampler;
`;
                  }),
                  l
                );
              }
              loseContext() {}
            }
          },
          7008: (Se, W, a) => {
            "use strict";
            a.d(W, { v: () => g });
            var x = a(7921);
            let T = 0;
            class g {
              constructor(d, h, f) {
                (this.renderVersionUpdated = -1),
                  (this.uniformBuffers = void 0),
                  (this.uniformBufferOffsets = []),
                  (this.id = T++),
                  (this.device = d),
                  (this.format = h),
                  (this.dirty = !0),
                  (this.impl = d.createBindGroupImpl(this)),
                  (this.textures = []),
                  (this.uniformBuffers = []),
                  (this.defaultUniformBuffer = f),
                  f && this.setUniformBuffer(x.ASF, f);
              }
              destroy() {
                this.impl.destroy(),
                  (this.impl = null),
                  (this.format = null),
                  (this.defaultUniformBuffer = null);
              }
              setUniformBuffer(d, h) {
                const f = this.format.bufferFormatsMap.get(d);
                this.uniformBuffers[f] !== h &&
                  ((this.uniformBuffers[f] = h), (this.dirty = !0));
              }
              setTexture(d, h) {
                const f = this.format.textureFormatsMap.get(d);
                this.textures[f] !== h
                  ? ((this.textures[f] = h), (this.dirty = !0))
                  : this.renderVersionUpdated < h.renderVersionDirty &&
                    (this.dirty = !0);
              }
              update() {
                const d = this.format.textureFormats;
                for (let h = 0; h < d.length; h++) {
                  const f = d[h],
                    s = f.scopeId.value;
                  this.setTexture(f.name, s);
                }
                this.uniformBufferOffsets.length = this.uniformBuffers.length;
                for (let h = 0; h < this.uniformBuffers.length; h++) {
                  const f = this.uniformBuffers[h];
                  (this.uniformBufferOffsets[h] = f.offset),
                    this.renderVersionUpdated < f.renderVersionDirty &&
                      (this.dirty = !0);
                }
                this.dirty &&
                  ((this.dirty = !1),
                  (this.renderVersionUpdated = this.device.renderVersion),
                  this.impl.update(this));
              }
            }
          },
          8277: (Se, W, a) => {
            "use strict";
            a.d(W, { a: () => p });
            var x = a(4475),
              T = a(7921);
            const g = 7,
              c = 15,
              d = 0,
              h = 3,
              f = 7,
              s = 11,
              l = 14,
              n = 18,
              o = 22,
              i = 23,
              e = 24,
              t = 25,
              r = 26,
              u = 15,
              y = o;
            class p {
              constructor(
                m = !1,
                E = T.cn$,
                v = T.NdT,
                P = T.rqb,
                I,
                A,
                B,
                C = !0,
                w = !0,
                k = !0,
                K = !0
              ) {
                (this.target0 = 0),
                  this.setColorBlend(E, v, P),
                  this.setAlphaBlend(
                    I != null ? I : E,
                    A != null ? A : v,
                    B != null ? B : P
                  ),
                  this.setColorWrite(C, w, k, K),
                  (this.blend = m);
              }
              set blend(m) {
                this.target0 = x.u.set(this.target0, m ? 1 : 0, r);
              }
              get blend() {
                return x.u.all(this.target0, r);
              }
              setColorBlend(m, E, v) {
                (this.target0 = x.u.set(this.target0, m, d, g)),
                  (this.target0 = x.u.set(this.target0, E, h, c)),
                  (this.target0 = x.u.set(this.target0, v, f, c));
              }
              setAlphaBlend(m, E, v) {
                (this.target0 = x.u.set(this.target0, m, s, g)),
                  (this.target0 = x.u.set(this.target0, E, l, c)),
                  (this.target0 = x.u.set(this.target0, v, n, c));
              }
              setColorWrite(m, E, v, P) {
                (this.redWrite = m),
                  (this.greenWrite = E),
                  (this.blueWrite = v),
                  (this.alphaWrite = P);
              }
              get colorOp() {
                return x.u.get(this.target0, d, g);
              }
              get colorSrcFactor() {
                return x.u.get(this.target0, h, c);
              }
              get colorDstFactor() {
                return x.u.get(this.target0, f, c);
              }
              get alphaOp() {
                return x.u.get(this.target0, s, g);
              }
              get alphaSrcFactor() {
                return x.u.get(this.target0, l, c);
              }
              get alphaDstFactor() {
                return x.u.get(this.target0, n, c);
              }
              set redWrite(m) {
                this.target0 = x.u.set(this.target0, m ? 1 : 0, o);
              }
              get redWrite() {
                return x.u.all(this.target0, o);
              }
              set greenWrite(m) {
                this.target0 = x.u.set(this.target0, m ? 1 : 0, i);
              }
              get greenWrite() {
                return x.u.all(this.target0, i);
              }
              set blueWrite(m) {
                this.target0 = x.u.set(this.target0, m ? 1 : 0, e);
              }
              get blueWrite() {
                return x.u.all(this.target0, e);
              }
              set alphaWrite(m) {
                this.target0 = x.u.set(this.target0, m ? 1 : 0, t);
              }
              get alphaWrite() {
                return x.u.all(this.target0, t);
              }
              get allWrite() {
                return x.u.get(this.target0, y, u);
              }
              copy(m) {
                return (this.target0 = m.target0), this;
              }
              clone() {
                return new this.constructor().copy(this);
              }
              get key() {
                return this.target0;
              }
              equals(m) {
                return this.target0 === m.target0;
              }
            }
            (p.NOBLEND = Object.freeze(new p())),
              (p.NOWRITE = Object.freeze(
                new p(
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  !1,
                  !1,
                  !1,
                  !1
                )
              )),
              (p.ALPHABLEND = Object.freeze(new p(!0, T.cn$, T._HM, T.Hiv)));
          },
          7921: (Se, W, a) => {
            "use strict";
            a.d(W, {
              $4V: () => jt,
              $8O: () => ct,
              $B1: () => $,
              $E: () => te,
              $GK: () => Fi,
              $Op: () => Re,
              $Rf: () => Bi,
              $_P: () => V,
              $eZ: () => pt,
              $fY: () => Be,
              $tA: () => w,
              A8C: () => bs,
              AHc: () => P,
              AMs: () => $i,
              ASF: () => _n,
              AZ8: () => ei,
              Aap: () => N,
              Ak$: () => xn,
              Ak1: () => Z,
              Ax$: () => u,
              Az9: () => qt,
              BmF: () => Ne,
              BuW: () => ai,
              BzP: () => An,
              CNh: () => vt,
              CZC: () => s,
              Cdl: () => Pi,
              D35: () => bi,
              DIG: () => Cn,
              DYM: () => xe,
              EA4: () => mi,
              EFh: () => be,
              EKq: () => lt,
              HBB: () => oi,
              HWi: () => at,
              He_: () => Ts,
              Hfq: () => Js,
              Hiv: () => i,
              Hsr: () => ke,
              Huo: () => ws,
              I5X: () => me,
              IAT: () => gt,
              JOC: () => xt,
              JT4: () => _i,
              JxJ: () => ss,
              KZS: () => le,
              KdK: () => Vi,
              KnZ: () => zs,
              KtK: () => it,
              LAy: () => Pt,
              LFx: () => Rt,
              Lb6: () => ee,
              Lp7: () => ce,
              MbK: () => mn,
              Mc_: () => ys,
              MgX: () => Ze,
              MwV: () => Tt,
              NFS: () => p,
              NPC: () => Ai,
              NTX: () => ks,
              NdT: () => d,
              NeV: () => ut,
              O$k: () => Is,
              OL2: () => Y,
              OVG: () => o,
              OrD: () => ls,
              P3e: () => ps,
              P4A: () => Qt,
              PBu: () => Yt,
              PDh: () => l,
              PFm: () => Ot,
              PcA: () => Lt,
              Pd9: () => tt,
              PdC: () => gi,
              Pgy: () => Ls,
              Q0q: () => ot,
              Q5v: () => Ie,
              Q8W: () => r,
              QKK: () => pe,
              QQe: () => an,
              QSU: () => He,
              QUn: () => Ye,
              Qqf: () => wi,
              R0Y: () => rt,
              R4W: () => en,
              ROU: () => Ns,
              RR1: () => h,
              Rbg: () => Te,
              S81: () => Ci,
              SA$: () => ue,
              SK8: () => rs,
              SSp: () => mt,
              ScY: () => zt,
              Sdj: () => nn,
              Si0: () => zi,
              Snx: () => J,
              Spw: () => Li,
              SuC: () => x,
              T4M: () => Ss,
              T73: () => Ji,
              TES: () => _e,
              TWf: () => ye,
              Tfk: () => A,
              U$: () => Qi,
              UD6: () => k,
              UPc: () => U,
              UUS: () => Le,
              Vcj: () => Et,
              WtN: () => Qe,
              X8g: () => $e,
              Y1U: () => Ps,
              Y7R: () => st,
              YsN: () => Mi,
              ZIZ: () => b,
              ZtC: () => H,
              Zzy: () => B,
              _3e: () => ae,
              _HM: () => n,
              _t$: () => At,
              _v4: () => j,
              _wK: () => Ue,
              a7f: () => G,
              aA6: () => D,
              agD: () => ln,
              anS: () => ft,
              b4e: () => _,
              cAh: () => K,
              cNy: () => Xi,
              cgc: () => rn,
              cn$: () => y,
              d1j: () => et,
              dJb: () => li,
              dKq: () => Ce,
              d_l: () => Zi,
              dxy: () => v,
              eV7: () => Mt,
              fGB: () => de,
              fUD: () => F,
              feq: () => L,
              fmW: () => qi,
              fmY: () => he,
              g0o: () => Dt,
              g8z: () => M,
              g98: () => xi,
              gJK: () => S,
              gKr: () => is,
              gLS: () => fs,
              gXY: () => f,
              gXw: () => Pn,
              hJD: () => t,
              hw4: () => X,
              iJ1: () => Gt,
              ipN: () => De,
              jJZ: () => gn,
              jKI: () => ht,
              jYq: () => Ft,
              kRF: () => $t,
              kVJ: () => We,
              kYl: () => we,
              ka9: () => yt,
              krP: () => qe,
              lN5: () => Q,
              lRO: () => pi,
              lTf: () => Bs,
              liJ: () => e,
              lmt: () => St,
              m4F: () => Gi,
              mK: () => on,
              mQ2: () => sn,
              n9: () => R,
              nKe: () => Es,
              nVg: () => g,
              nZ6: () => Ni,
              oWk: () => I,
              pS1: () => hs,
              peA: () => ge,
              piJ: () => ne,
              puI: () => Zs,
              pwe: () => Wi,
              q0F: () => z,
              qBv: () => Ae,
              qCh: () => oe,
              qFC: () => Kt,
              qTk: () => tn,
              qUb: () => si,
              qVn: () => ie,
              qYt: () => ii,
              q_o: () => Ee,
              r8O: () => Ui,
              rT2: () => Ti,
              rWR: () => ts,
              rqb: () => c,
              s36: () => Ke,
              sUt: () => Pe,
              stI: () => Xe,
              sxQ: () => cn,
              syi: () => Jt,
              to1: () => ji,
              u9l: () => se,
              uAW: () => E,
              uC3: () => q,
              uFb: () => T,
              uN2: () => Yi,
              uOW: () => je,
              vW_: () => ki,
              vcW: () => Ws,
              vec: () => Je,
              vyI: () => Oi,
              wD$: () => Ve,
              wNl: () => Oe,
              weO: () => ti,
              wfm: () => Qs,
              x5T: () => Fe,
              x5Y: () => fe,
              xIP: () => Xs,
              xJm: () => m,
              y4i: () => hn,
              yP3: () => Di,
              yc: () => bt,
              yib: () => O,
              zZc: () => Ys,
              zk9: () => C,
            });
            const x = 0,
              T = 1,
              g = 2,
              c = 0,
              d = 1,
              h = 2,
              f = 3,
              s = 4,
              l = 5,
              n = 6,
              o = 7,
              i = 8,
              e = 9,
              t = 10,
              r = 11,
              u = 12,
              y = 0,
              p = 1,
              _ = 2,
              m = 3,
              E = 4,
              v = 0,
              P = 1,
              I = 2,
              A = 3,
              B = 1,
              C = 2,
              w = 4,
              k = 0,
              K = 1,
              te = 2,
              X = 3,
              $ = 4,
              ne = 5,
              Y = 0,
              Z = 1,
              ye = 2,
              pe = 3,
              O = 0,
              me = 1,
              N = 2,
              V = 3,
              L = 4,
              J = 5,
              ae = 0,
              R = 1,
              j = 2,
              se = 3,
              ce = 4,
              ie = 5,
              b = 6,
              M = 7,
              F = 0,
              z = 1,
              oe = 2,
              de = 0,
              ge = 1,
              Re = 2,
              Te = 3,
              Ne = 4,
              Le = 5,
              ke = 6,
              ht = 7,
              _e = 8,
              U = 9,
              H = 10,
              Ee = 11,
              G = 12,
              Q = 13,
              q = 14,
              xe = 15,
              be = 16,
              Pe = 17,
              we = 18,
              Oe = 19,
              $e = 20,
              gt = 21,
              qe = 22,
              Tt = 23,
              Mt = 24,
              Dt = 25,
              ut = 26,
              At = 27,
              xt = 28,
              jt = 29,
              Gt = 30,
              yt = 31,
              Ae = new Map([
                [de, { name: "A8", size: 1 }],
                [ge, { name: "L8", size: 1 }],
                [Re, { name: "LA8", size: 2 }],
                [Te, { name: "RGB565", size: 2 }],
                [Ne, { name: "RGBA5551", size: 2 }],
                [Le, { name: "RGBA4", size: 2 }],
                [ke, { name: "RGB8", size: 4 }],
                [ht, { name: "RGBA8", size: 4 }],
                [Ee, { name: "RGB16F", size: 8 }],
                [G, { name: "RGBA16F", size: 8 }],
                [Q, { name: "RGB32F", size: 16 }],
                [q, { name: "RGBA32F", size: 16 }],
                [xe, { name: "R32F", size: 4 }],
                [be, { name: "DEPTH", size: 4 }],
                [Pe, { name: "DEPTHSTENCIL", size: 4 }],
                [we, { name: "111110F", size: 4 }],
                [Oe, { name: "SRGB", size: 4 }],
                [$e, { name: "SRGBA", size: 4 }],
                [yt, { name: "BGRA8", size: 4 }],
                [_e, { name: "DXT1", blockSize: 8 }],
                [U, { name: "DXT3", blockSize: 16 }],
                [H, { name: "DXT5", blockSize: 16 }],
                [gt, { name: "ETC1", blockSize: 8 }],
                [qe, { name: "ETC2_RGB", blockSize: 8 }],
                [Tt, { name: "ETC2_RGBA", blockSize: 16 }],
                [Mt, { name: "PVRTC_2BPP_RGB_1", blockSize: 8 }],
                [Dt, { name: "PVRTC_2BPP_RGBA_1", blockSize: 8 }],
                [ut, { name: "PVRTC_4BPP_RGB_1", blockSize: 8 }],
                [At, { name: "PVRTC_4BPP_RGBA_1", blockSize: 8 }],
                [xt, { name: "ASTC_4x4", blockSize: 16 }],
                [jt, { name: "ATC_RGB", blockSize: 8 }],
                [Gt, { name: "ATC_RGBA", blockSize: 16 }],
              ]),
              Xe = (Bt) => Ae.get(Bt).blockSize !== void 0,
              Ye = (Bt) => {
                switch (Bt) {
                  case Q:
                  case q:
                    return Float32Array;
                  case Te:
                  case Ne:
                  case Le:
                  case Ee:
                  case G:
                    return Uint16Array;
                  default:
                    return Uint8Array;
                }
              },
              it = 0,
              st = 1,
              He = 2,
              at = 3,
              Pt = 4,
              he = 5,
              fe = 6,
              Ie = "POSITION",
              ue = "NORMAL",
              De = "TANGENT",
              et = "BLENDWEIGHT",
              Ze = "BLENDINDICES",
              Ve = "COLOR",
              tt = "TEXCOORD",
              Be = "TEXCOORD0",
              ot = "TEXCOORD1",
              Qe = "TEXCOORD2",
              mt = "TEXCOORD3",
              je = "TEXCOORD4",
              lt = "TEXCOORD5",
              Et = "TEXCOORD6",
              ct = "TEXCOORD7",
              pt = "ATTR",
              vt = "ATTR0",
              Fe = "ATTR1",
              Yt = "ATTR2",
              Ot = "ATTR3",
              Rt = "ATTR4",
              Kt = "ATTR5",
              Lt = "ATTR6",
              Ft = "ATTR7",
              Jt = "ATTR8",
              zt = "ATTR9",
              ss = "ATTR10",
              qt = "ATTR11",
              fs = "ATTR12",
              ls = "ATTR13",
              Es = "ATTR14",
              Ke = "ATTR15",
              hs = 1,
              is = 0,
              ys = 1,
              ps = 2,
              Ns = 3,
              zs = 4,
              bs = 5,
              Ws = 6,
              Ss = 7,
              ws = 1,
              ks = 2,
              Ys = "default",
              Xs = "rgbm",
              Zs = "rgbe",
              We = "rgbp",
              ft = "swizzleGGGR",
              bt = 0,
              ts = 1,
              Qt = 2,
              rs = 3,
              Ps = "1d",
              Ts = "2d",
              ei = "2d-array",
              Js = "cube",
              ti = "cube-array",
              Bs = "3d",
              si = 0,
              Ti = 1,
              xi = 2,
              Is = "none",
              ai = "cube",
              Qs = "equirect",
              ji = "octahedral",
              Di = "glsl",
              Yi = "wgsl",
              Ai = 0,
              Oi = 1,
              Ci = 2,
              Li = 3,
              Bi = 4,
              Fi = 5,
              Ui = 6,
              pi = 0,
              Xi = 1,
              Pi = 2,
              Zi = 3,
              Ji = 4,
              Ni = 5,
              Mi = 6,
              bi = 7,
              _i = 8,
              Qi = 9,
              $i = 10,
              qi = 11,
              en = 12,
              zi = 13,
              mi = 14,
              tn = 15,
              Wi = 16,
              sn = 17,
              nn = 18,
              ki = 19,
              rn = 20,
              Vi = 21,
              Gi = 22,
              an = 23,
              on = 24,
              oi = [
                "bool",
                "int",
                "float",
                "vec2",
                "vec3",
                "vec4",
                "ivec2",
                "ivec3",
                "ivec4",
                "bec2",
                "bec3",
                "bec4",
                "mat2",
                "mat3",
                "mat4",
                "sampler2D",
                "samplerCube",
                "",
                "sampler2DShadow",
                "samplerCubeShadow",
                "sampler3D",
                "",
                "",
                "",
              ],
              ii = "webgl1",
              ln = "webgl2",
              li = "webgpu",
              hn = 1,
              cn = 2,
              Ls = 4,
              xn = 0,
              wi = 1,
              An = ["mesh", "view"],
              _n = "default",
              Cn = [
                Int8Array,
                Uint8Array,
                Int16Array,
                Uint16Array,
                Int32Array,
                Uint32Array,
                Float32Array,
              ],
              mn = [1, 1, 2, 2, 4, 4, 4],
              gi = [
                "INT8",
                "UINT8",
                "INT16",
                "UINT16",
                "INT32",
                "UINT32",
                "FLOAT32",
              ],
              Pn = {
                Int8Array: Ai,
                Uint8Array: Oi,
                Int16Array: Ci,
                Uint16Array: Li,
                Int32Array: Bi,
                Uint32Array: Fi,
                Float32Array: Ui,
              },
              $t = [Uint8Array, Uint16Array, Uint32Array],
              gn = [1, 2, 4],
              ee = {};
            (ee[Ie] = 0),
              (ee[ue] = 1),
              (ee[et] = 2),
              (ee[Ze] = 3),
              (ee[Ve] = 4),
              (ee[Be] = 5),
              (ee[ot] = 6),
              (ee[Qe] = 7),
              (ee[mt] = 8),
              (ee[je] = 9),
              (ee[lt] = 10),
              (ee[Et] = 11),
              (ee[ct] = 12),
              (ee[De] = 13),
              (ee[vt] = 0),
              (ee[Fe] = 1),
              (ee[Yt] = 2),
              (ee[Ot] = 3),
              (ee[Rt] = 4),
              (ee[Kt] = 5),
              (ee[Lt] = 6),
              (ee[Ft] = 7),
              (ee[Jt] = 8),
              (ee[zt] = 9),
              (ee[ss] = 10),
              (ee[qt] = 11),
              (ee[fs] = 12),
              (ee[ls] = 13),
              (ee[Es] = 14),
              (ee[Ke] = 15);
            const S = "1.51",
              D = "1.55",
              le = "1.56",
              Ce = "1.57",
              Ue = "1.58",
              rt = "1.60",
              Je = "1.62",
              St = "1.65";
          },
          7013: (Se, W, a) => {
            "use strict";
            a.d(W, { b: () => h });
            var x = a(4475),
              T = a(7921);
            const g = 7,
              c = 0,
              d = 3;
            class h {
              constructor(s = T.u9l, l = !0) {
                (this.data = 0), (this.func = s), (this.write = l);
              }
              set test(s) {
                this.func = s ? T.u9l : T.g8z;
              }
              get test() {
                return this.func !== T.g8z;
              }
              set write(s) {
                this.data = x.u.set(this.data, s ? 1 : 0, d);
              }
              get write() {
                return x.u.all(this.data, d);
              }
              set func(s) {
                this.data = x.u.set(this.data, s, c, g);
              }
              get func() {
                return x.u.get(this.data, c, g);
              }
              copy(s) {
                return (this.data = s.data), this;
              }
              clone() {
                return new this.constructor().copy(this);
              }
              get key() {
                return this.data;
              }
              equals(s) {
                return this.data === s.data;
              }
            }
            (h.DEFAULT = Object.freeze(new h())),
              (h.NODEPTH = Object.freeze(new h(T.g8z, !1))),
              (h.WRITEDEPTH = Object.freeze(new h(T.g8z, !0)));
          },
          7338: (Se, W, a) => {
            "use strict";
            a.d(W, { c: () => x });
            class x {
              constructor() {
                this._cache = new Map();
              }
              get(g, c) {
                return (
                  this._cache.has(g) ||
                    (this._cache.set(g, c()),
                    g.on("destroy", () => {
                      this.remove(g);
                    }),
                    g.on("devicelost", () => {
                      var d;
                      (d = this._cache.get(g)) == null ||
                        d.loseContext == null ||
                        d.loseContext(g);
                    })),
                  this._cache.get(g)
                );
              }
              remove(g) {
                var c;
                (c = this._cache.get(g)) == null ||
                  c.destroy == null ||
                  c.destroy(g),
                  this._cache.delete(g);
              }
            }
          },
          9227: (Se, W, a) => {
            "use strict";
            a.d(W, { Ns: () => d, fd: () => T, z_: () => c });
            var x = a(4585);
            class T {
              constructor(f) {
                (this.device = void 0), (this.device = f);
              }
            }
            class g {
              constructor() {
                (this.gpuBuffer = void 0),
                  (this.stagingBuffer = void 0),
                  (this.offset = void 0),
                  (this.size = void 0);
              }
            }
            class c {
              constructor() {
                (this.storage = void 0),
                  (this.gpuBuffer = void 0),
                  (this.offset = void 0);
              }
            }
            class d {
              constructor(f, s, l) {
                (this.bufferSize = void 0),
                  (this.gpuBuffers = []),
                  (this.stagingBuffers = []),
                  (this.usedBuffers = []),
                  (this.activeBuffer = null),
                  (this.device = f),
                  (this.bufferSize = s),
                  (this.bufferAlignment = l);
              }
              destroy() {
                this.gpuBuffers.forEach((f) => {
                  f.destroy(this.device);
                }),
                  (this.gpuBuffers = null),
                  this.stagingBuffers.forEach((f) => {
                    f.destroy(this.device);
                  }),
                  (this.stagingBuffers = null),
                  (this.usedBuffers = null),
                  (this.activeBuffer = null);
              }
              alloc(f, s) {
                if (this.activeBuffer) {
                  const o = x.m.roundUp(
                    this.activeBuffer.size,
                    this.bufferAlignment
                  );
                  this.bufferSize - o < s && this.scheduleSubmit();
                }
                if (!this.activeBuffer) {
                  let o = this.gpuBuffers.pop();
                  o ||
                    (o = this.createBuffer(this.device, this.bufferSize, !1));
                  let i = this.stagingBuffers.pop();
                  i ||
                    (i = this.createBuffer(this.device, this.bufferSize, !0)),
                    (this.activeBuffer = new g()),
                    (this.activeBuffer.stagingBuffer = i),
                    (this.activeBuffer.gpuBuffer = o),
                    (this.activeBuffer.offset = 0),
                    (this.activeBuffer.size = 0);
                }
                const l = this.activeBuffer,
                  n = x.m.roundUp(l.size, this.bufferAlignment);
                (f.gpuBuffer = l.gpuBuffer),
                  (f.offset = n),
                  (f.storage = l.stagingBuffer.alloc(n, s)),
                  (l.size = n + s);
              }
              scheduleSubmit() {
                this.activeBuffer &&
                  (this.usedBuffers.push(this.activeBuffer),
                  (this.activeBuffer = null));
              }
              submit() {
                this.scheduleSubmit();
              }
            }
          },
          3998: (Se, W, a) => {
            "use strict";
            a.d(W, { l: () => g });
            var x = a(2200),
              T = a(3226);
            class g {
              constructor() {
                (this.frameAllocations = []),
                  (this.pastFrameAllocations = new Map()),
                  (this._enabled = !1),
                  (this._enableRequest = !1),
                  (this._frameTime = 0);
              }
              loseContext() {
                this.pastFrameAllocations.clear();
              }
              set enabled(d) {
                this._enableRequest = d;
              }
              get enabled() {
                return this._enableRequest;
              }
              processEnableRequest() {
                this._enableRequest !== this._enabled &&
                  ((this._enabled = this._enableRequest),
                  this._enabled || (this._frameTime = 0));
              }
              request(d) {
                this.pastFrameAllocations.set(d, this.frameAllocations),
                  (this.frameAllocations = []);
              }
              report(d, h) {
                if (h) {
                  const f = this.pastFrameAllocations.get(d);
                  if ((h.length > 0 && (this._frameTime = h[0]), T.$.get(x.wf)))
                    for (let s = 0; s < f.length; ++s) f[s];
                }
                this.pastFrameAllocations.delete(d);
              }
              getSlot(d) {
                const h = this.frameAllocations.length;
                return this.frameAllocations.push(d), h;
              }
              get slotCount() {
                return this.frameAllocations.length;
              }
            }
          },
          7982: (Se, W, a) => {
            "use strict";
            a.d(W, { j: () => x });
            class x {
              static set(g) {
                x._graphicsDevice = g;
              }
              static get() {
                return x._graphicsDevice;
              }
            }
            x._graphicsDevice = null;
          },
          4738: (Se, W, a) => {
            "use strict";
            a.d(W, { $: () => o });
            var x = a(9078),
              T = a(5338),
              g = a(4444),
              c = a(7921),
              d = a(8277),
              h = a(7013),
              f = a(6132),
              s = a(6615),
              l = a(8385),
              n = a(30);
            class o extends T.b {
              constructor(e, t) {
                var r, u, y, p, _, m, E, v;
                super(),
                  (this.canvas = void 0),
                  (this.isWebGPU = !1),
                  (this.scope = void 0),
                  (this.boneLimit = void 0),
                  (this.maxAnisotropy = void 0),
                  (this.maxCubeMapSize = void 0),
                  (this.maxTextureSize = void 0),
                  (this.maxVolumeSize = void 0),
                  (this.maxColorAttachments = 1),
                  (this.precision = void 0),
                  (this.samples = void 0),
                  (this.supportsStencil = void 0),
                  (this.supportsMrt = !1),
                  (this.supportsVolumeTextures = !1),
                  (this.renderTarget = null),
                  (this.renderVersion = 0),
                  (this.renderPassIndex = void 0),
                  (this.insideRenderPass = !1),
                  (this.supportsInstancing = void 0),
                  (this.supportsUniformBuffers = !1),
                  (this.textureFloatRenderable = void 0),
                  (this.textureHalfFloatRenderable = void 0),
                  (this.quadVertexBuffer = void 0),
                  (this.blendState = new d.a()),
                  (this.depthState = new h.b()),
                  (this.stencilEnabled = !1),
                  (this.stencilFront = new n.p()),
                  (this.stencilBack = new n.p()),
                  (this.dynamicBuffers = void 0),
                  (this.gpuProfiler = void 0),
                  (this.defaultClearOptions = {
                    color: [0, 0, 0, 1],
                    depth: 1,
                    stencil: 0,
                    flags: c.Zzy | c.zk9,
                  }),
                  (this.canvas = e),
                  (this.initOptions = (0, x.g)({}, t)),
                  (u = (r = this.initOptions).depth) != null || (r.depth = !0),
                  (p = (y = this.initOptions).stencil) != null ||
                    (y.stencil = !0),
                  (m = (_ = this.initOptions).antialias) != null ||
                    (_.antialias = !0),
                  (v = (E = this.initOptions).powerPreference) != null ||
                    (E.powerPreference = "high-performance"),
                  (this._width = 0),
                  (this._height = 0),
                  (this._maxPixelRatio = g.J.browser
                    ? Math.min(1, window.devicePixelRatio)
                    : 1),
                  (this.shaders = []),
                  (this.buffers = []),
                  (this.textures = []),
                  (this.targets = []),
                  (this._vram = { tex: 0, vb: 0, ib: 0, ub: 0 }),
                  (this._shaderStats = {
                    vsCompiled: 0,
                    fsCompiled: 0,
                    linked: 0,
                    materialShaders: 0,
                    compileTime: 0,
                  }),
                  this.initializeContextCaches(),
                  (this._drawCallsPerFrame = 0),
                  (this._shaderSwitchesPerFrame = 0),
                  (this._primsPerFrame = []);
                for (let P = c.KtK; P <= c.x5Y; P++) this._primsPerFrame[P] = 0;
                (this._renderTargetCreationTime = 0),
                  (this.scope = new f.X("Device")),
                  (this.textureBias = this.scope.resolve("textureBias")),
                  this.textureBias.setValue(0);
              }
              postInit() {
                const e = new l.g(this, [
                    { semantic: c.Q5v, components: 2, type: c.r8O },
                  ]),
                  t = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
                this.quadVertexBuffer = new s.o(this, e, 4, c.dxy, t);
              }
              destroy() {
                var e, t, r;
                this.fire("destroy"),
                  (e = this.quadVertexBuffer) == null || e.destroy(),
                  (this.quadVertexBuffer = null),
                  (t = this.dynamicBuffers) == null || t.destroy(),
                  (this.dynamicBuffers = null),
                  (r = this.gpuProfiler) == null || r.destroy(),
                  (this.gpuProfiler = null);
              }
              onDestroyShader(e) {
                this.fire("destroy:shader", e);
                const t = this.shaders.indexOf(e);
                t !== -1 && this.shaders.splice(t, 1);
              }
              postDestroy() {
                (this.scope = null), (this.canvas = null);
              }
              toJSON(e) {}
              initializeContextCaches() {
                (this.indexBuffer = null),
                  (this.vertexBuffers = []),
                  (this.shader = null),
                  (this.renderTarget = null);
              }
              initializeRenderState() {
                (this.blendState = new d.a()),
                  (this.depthState = new h.b()),
                  (this.cullMode = c.Ak1),
                  (this.vx = this.vy = this.vw = this.vh = 0),
                  (this.sx = this.sy = this.sw = this.sh = 0);
              }
              setStencilState(e, t) {}
              setBlendState(e) {}
              setDepthState(e) {}
              setCullMode(e) {}
              setRenderTarget(e) {
                this.renderTarget = e;
              }
              setIndexBuffer(e) {
                this.indexBuffer = e;
              }
              setVertexBuffer(e) {
                e && this.vertexBuffers.push(e);
              }
              getRenderTarget() {
                return this.renderTarget;
              }
              initRenderTarget(e) {
                e.initialized || (e.init(), this.targets.push(e));
              }
              _isBrowserInterface(e) {
                return (
                  this._isImageBrowserInterface(e) ||
                  this._isImageCanvasInterface(e) ||
                  this._isImageVideoInterface(e)
                );
              }
              _isImageBrowserInterface(e) {
                return (
                  (typeof ImageBitmap != "undefined" &&
                    e instanceof ImageBitmap) ||
                  (typeof HTMLImageElement != "undefined" &&
                    e instanceof HTMLImageElement)
                );
              }
              _isImageCanvasInterface(e) {
                return (
                  typeof HTMLCanvasElement != "undefined" &&
                  e instanceof HTMLCanvasElement
                );
              }
              _isImageVideoInterface(e) {
                return (
                  typeof HTMLVideoElement != "undefined" &&
                  e instanceof HTMLVideoElement
                );
              }
              resizeCanvas(e, t) {}
              setResolution(e, t) {
                (this._width = e),
                  (this._height = t),
                  (this.canvas.width = e),
                  (this.canvas.height = t),
                  this.fire(o.EVENT_RESIZE, e, t);
              }
              updateClientRect() {
                this.clientRect = this.canvas.getBoundingClientRect();
              }
              get width() {
                return this.canvas.width;
              }
              get height() {
                return this.canvas.height;
              }
              set fullscreen(e) {}
              get fullscreen() {
                return !1;
              }
              set maxPixelRatio(e) {
                this._maxPixelRatio !== e &&
                  ((this._maxPixelRatio = e),
                  this.resizeCanvas(this._width, this._height));
              }
              get maxPixelRatio() {
                return this._maxPixelRatio;
              }
              get deviceType() {
                return this._deviceType;
              }
              getBoneLimit() {
                return this.boneLimit;
              }
              setBoneLimit(e) {
                this.boneLimit = e;
              }
              frameStart() {
                (this.renderPassIndex = 0), this.renderVersion++;
              }
              frameEnd() {}
            }
            o.EVENT_RESIZE = "resizecanvas";
          },
          9459: (Se, W, a) => {
            "use strict";
            a.d(W, { G: () => g });
            var x = a(7921);
            let T = 0;
            class g {
              constructor(d, h, f, s = x.dxy, l) {
                (this.device = d),
                  (this.format = h),
                  (this.numIndices = f),
                  (this.usage = s),
                  (this.id = T++),
                  (this.impl = d.createIndexBufferImpl(this));
                const n = x.jJZ[h];
                (this.bytesPerIndex = n),
                  (this.numBytes = this.numIndices * n),
                  l
                    ? this.setData(l)
                    : (this.storage = new ArrayBuffer(this.numBytes)),
                  this.adjustVramSizeTracking(d._vram, this.numBytes),
                  this.device.buffers.push(this);
              }
              destroy() {
                const d = this.device,
                  h = d.buffers.indexOf(this);
                h !== -1 && d.buffers.splice(h, 1),
                  this.device.indexBuffer === this &&
                    (this.device.indexBuffer = null),
                  this.impl.initialized &&
                    (this.impl.destroy(d),
                    this.adjustVramSizeTracking(
                      d._vram,
                      -this.storage.byteLength
                    ));
              }
              adjustVramSizeTracking(d, h) {
                d.ib += h;
              }
              loseContext() {
                this.impl.loseContext();
              }
              getFormat() {
                return this.format;
              }
              getNumIndices() {
                return this.numIndices;
              }
              lock() {
                return this.storage;
              }
              unlock() {
                this.impl.unlock(this);
              }
              setData(d) {
                return d.byteLength !== this.numBytes
                  ? !1
                  : ((this.storage = d), this.unlock(), !0);
              }
              _lockTypedArray() {
                const d = this.lock();
                return this.format === x.qCh
                  ? new Uint32Array(d)
                  : this.format === x.q0F
                  ? new Uint16Array(d)
                  : new Uint8Array(d);
              }
              writeData(d, h) {
                const f = this._lockTypedArray();
                if (d.length > h)
                  if (ArrayBuffer.isView(d)) (d = d.subarray(0, h)), f.set(d);
                  else for (let s = 0; s < h; s++) f[s] = d[s];
                else f.set(d);
                this.unlock();
              }
              readData(d) {
                const h = this._lockTypedArray(),
                  f = this.numIndices;
                if (ArrayBuffer.isView(d)) d.set(h);
                else {
                  d.length = 0;
                  for (let s = 0; s < f; s++) d[s] = h[s];
                }
                return f;
              }
            }
          },
          2277: (Se, W, a) => {
            "use strict";
            a.d(W, { CD: () => c });
            var x = a(1367);
            class T {
              constructor() {
                (this.clearValue = new x.I(0, 0, 0, 1)),
                  (this.clear = !1),
                  (this.store = !1),
                  (this.resolve = !0),
                  (this.mipmaps = !1);
              }
            }
            class g {
              constructor() {
                (this.clearDepthValue = 1),
                  (this.clearStencilValue = 0),
                  (this.clearDepth = !1),
                  (this.clearStencil = !1),
                  (this.storeDepth = !1),
                  (this.storeStencil = !1);
              }
            }
            class c {
              get colorOps() {
                return this.colorArrayOps[0];
              }
              constructor(h, f) {
                (this.name = void 0),
                  (this.renderTarget = void 0),
                  (this.samples = 0),
                  (this.colorArrayOps = []),
                  (this.depthStencilOps = void 0),
                  (this.requiresCubemaps = !0),
                  (this.fullSizeClearRect = !0),
                  (this.execute = void 0),
                  (this.before = void 0),
                  (this.after = void 0),
                  (this.device = h),
                  (this.execute = f);
              }
              init(h) {
                var f;
                (this.renderTarget = h || null),
                  (this.samples = Math.max(
                    this.renderTarget
                      ? this.renderTarget.samples
                      : this.device.samples,
                    1
                  )),
                  (this.depthStencilOps = new g());
                const s = h
                  ? (f = h._colorBuffers) == null
                    ? void 0
                    : f.length
                  : 1;
                for (let n = 0; n < s; n++) {
                  var l;
                  const o = new T();
                  (this.colorArrayOps[n] = o),
                    this.samples === 1 && ((o.store = !0), (o.resolve = !1)),
                    (l = this.renderTarget) != null &&
                      (l = l._colorBuffers) != null &&
                      l[n].mipmaps &&
                      (o.mipmaps = !0);
                }
              }
              setClearColor(h) {
                const f = this.colorArrayOps.length;
                for (let s = 0; s < f; s++) {
                  const l = this.colorArrayOps[s];
                  l.clearValue.copy(h), (l.clear = !0);
                }
              }
              setClearDepth(h) {
                (this.depthStencilOps.clearDepthValue = h),
                  (this.depthStencilOps.clearDepth = !0);
              }
              setClearStencil(h) {
                (this.depthStencilOps.clearStencilValue = h),
                  (this.depthStencilOps.clearStencil = !0);
              }
              render() {
                var h, f, s;
                const l = this.device,
                  n = this.renderTarget !== void 0;
                (h = this.before) == null || h.call(this),
                  n && l.startPass(this),
                  (f = this.execute) == null || f.call(this),
                  n && l.endPass(this),
                  (s = this.after) == null || s.call(this),
                  l.renderPassIndex++;
              }
            }
          },
          3412: (Se, W, a) => {
            "use strict";
            a.d(W, { A: () => c });
            var x = a(7921),
              T = a(4738);
            let g = 0;
            class c {
              constructor(h = {}) {
                var f, s, l, n, o, i, e;
                (this.name = void 0),
                  (this._device = void 0),
                  (this._colorBuffer = void 0),
                  (this._colorBuffers = void 0),
                  (this._depthBuffer = void 0),
                  (this._depth = void 0),
                  (this._stencil = void 0),
                  (this._samples = void 0),
                  (this.autoResolve = void 0),
                  (this._face = void 0),
                  (this.flipY = void 0),
                  (this.id = g++);
                const t = arguments[1],
                  r = arguments[2];
                if (
                  (h instanceof T.$
                    ? ((this._colorBuffer = t), (h = r))
                    : (this._colorBuffer = h.colorBuffer),
                  this._colorBuffer &&
                    (this._colorBuffers = [this._colorBuffer]),
                  (this._depthBuffer = h.depthBuffer),
                  (this._face = (f = h.face) != null ? f : 0),
                  this._depthBuffer)
                ) {
                  const v = this._depthBuffer._format;
                  v === x.EFh
                    ? ((this._depth = !0), (this._stencil = !1))
                    : v === x.sUt
                    ? ((this._depth = !0), (this._stencil = !0))
                    : ((this._depth = !1), (this._stencil = !1));
                } else {
                  var u, y;
                  (this._depth = (u = h.depth) != null ? u : !0),
                    (this._stencil = (y = h.stencil) != null ? y : !1);
                }
                h.colorBuffers &&
                  (this._colorBuffers ||
                    ((this._colorBuffers = [...h.colorBuffers]),
                    (this._colorBuffer = h.colorBuffers[0])));
                const p =
                  ((s = this._colorBuffer) == null ? void 0 : s.device) ||
                  ((l = this._depthBuffer) == null ? void 0 : l.device) ||
                  h.graphicsDevice;
                (this._device = p),
                  (n = this._colorBuffers) == null ||
                    n.forEach((v) => {
                      v._isRenderTarget = !0;
                    });
                const { maxSamples: _ } = this._device;
                if (
                  ((this._samples = Math.min(
                    (o = h.samples) != null ? o : 1,
                    _
                  )),
                  p.isWebGPU && (this._samples = this._samples > 1 ? _ : 1),
                  (this.autoResolve = (i = h.autoResolve) != null ? i : !0),
                  (this.name = h.name),
                  !this.name)
                ) {
                  var m;
                  this.name = (m = this._colorBuffer) == null ? void 0 : m.name;
                }
                if (!this.name) {
                  var E;
                  this.name = (E = this._depthBuffer) == null ? void 0 : E.name;
                }
                this.name || (this.name = "Untitled"),
                  (this.flipY = (e = h.flipY) != null ? e : !1),
                  this.validateMrt(),
                  (this.impl = p.createRenderTargetImpl(this));
              }
              destroy() {
                const h = this._device;
                if (h) {
                  const f = h.targets.indexOf(this);
                  f !== -1 && h.targets.splice(f, 1),
                    h.renderTarget === this && h.setRenderTarget(null),
                    this.destroyFrameBuffers();
                }
              }
              destroyFrameBuffers() {
                const h = this._device;
                h && this.impl.destroy(h);
              }
              destroyTextureBuffers() {
                var h, f;
                (h = this._depthBuffer) == null || h.destroy(),
                  (this._depthBuffer = null),
                  (f = this._colorBuffers) == null ||
                    f.forEach((s) => {
                      s.destroy();
                    }),
                  (this._colorBuffers = null),
                  (this._colorBuffer = null);
              }
              validateMrt() {}
              init() {
                this.impl.init(this._device, this);
              }
              get initialized() {
                return this.impl.initialized;
              }
              loseContext() {
                this.impl.loseContext();
              }
              resolve(h = !0, f = !!this._depthBuffer) {
                this._device &&
                  this._samples > 1 &&
                  this.impl.resolve(this._device, this, h, f);
              }
              copy(h, f, s) {
                if (!this._device)
                  if (h._device) this._device = h._device;
                  else return !1;
                return this._device.copyRenderTarget(h, this, f, s);
              }
              get samples() {
                return this._samples;
              }
              get depth() {
                return this._depth;
              }
              get stencil() {
                return this._stencil;
              }
              get colorBuffer() {
                return this._colorBuffer;
              }
              getColorBuffer(h) {
                var f;
                return (f = this._colorBuffers) == null ? void 0 : f[h];
              }
              get depthBuffer() {
                return this._depthBuffer;
              }
              get face() {
                return this._face;
              }
              get width() {
                var h, f;
                return (
                  ((h = this._colorBuffer) == null ? void 0 : h.width) ||
                  ((f = this._depthBuffer) == null ? void 0 : f.width) ||
                  this._device.width
                );
              }
              get height() {
                var h, f;
                return (
                  ((h = this._colorBuffer) == null ? void 0 : h.height) ||
                  ((f = this._depthBuffer) == null ? void 0 : f.height) ||
                  this._device.height
                );
              }
            }
          },
          8298: (Se, W, a) => {
            "use strict";
            a.d(W, { q: () => c });
            var x = a(1934);
            let T = 0;
            class g {
              constructor() {
                T++, (this.version = new x.G()), (this.version.globalId = T);
              }
              increment() {
                this.version.revision++;
              }
            }
            class c {
              constructor(h) {
                (this.name = h),
                  (this.value = null),
                  (this.versionObject = new g());
              }
              toJSON(h) {}
              setValue(h) {
                (this.value = h), this.versionObject.increment();
              }
              getValue() {
                return this.value;
              }
            }
          },
          6132: (Se, W, a) => {
            "use strict";
            a.d(W, { X: () => T });
            var x = a(8298);
            class T {
              constructor(c) {
                (this.name = c), (this.variables = new Map());
              }
              resolve(c) {
                return (
                  this.variables.has(c) || this.variables.set(c, new x.q(c)),
                  this.variables.get(c)
                );
              }
              removeValue(c) {
                for (const d in this.variables) {
                  const h = this.variables[d];
                  h.value === c && (h.value = null);
                }
              }
            }
          },
          2462: (Se, W, a) => {
            "use strict";
            a.d(W, { Z: () => x });
            var x = `

#define pcFragColor0 gl_FragData[0]

#if COLOR_ATTACHMENT_1
#define pcFragColor1 gl_FragData[1]
#endif

#if COLOR_ATTACHMENT_2
#define pcFragColor2 gl_FragData[2]
#endif

#if COLOR_ATTACHMENT_3
#define pcFragColor3 gl_FragData[3]
#endif

#if COLOR_ATTACHMENT_4
#define pcFragColor4 gl_FragData[4]
#endif

#if COLOR_ATTACHMENT_5
#define pcFragColor5 gl_FragData[5]
#endif

#if COLOR_ATTACHMENT_6
#define pcFragColor6 gl_FragData[6]
#endif

#if COLOR_ATTACHMENT_7
#define pcFragColor7 gl_FragData[7]
#endif

#define texture2DBias texture2D

// pass / accept shadow map or texture as a function parameter, on webgl this is simply passed as is
// but this is needed for WebGPU
#define SHADOWMAP_PASS(name) name
#define SHADOWMAP_ACCEPT(name) sampler2D name
#define TEXTURE_PASS(name) name
#define TEXTURE_ACCEPT(name) sampler2D name

#ifndef SUPPORTS_TEXLOD

		// fallback for lod instructions
		#define texture2DLodEXT texture2D
		#define texture2DProjLodEXT textureProj
		#define textureCubeLodEXT textureCube
		#define textureShadow texture2D

#else

		#define textureShadow(res, uv) texture2DGradEXT(res, uv, vec2(1, 1), vec2(1, 1))

#endif

#ifdef SUPPORTS_MRT
		#define gl_FragColor pcFragColor0
#endif

`;
          },
          7086: (Se, W, a) => {
            "use strict";
            a.d(W, { Z: () => x });
            var x = `
layout(location = 0) out highp vec4 pc_fragColor;

#ifndef REMOVE_COLOR_ATTACHMENT_1
#if COLOR_ATTACHMENT_1
layout(location = 1) out highp vec4 pc_fragColor1;
#endif
#endif

#ifndef REMOVE_COLOR_ATTACHMENT_2
#if COLOR_ATTACHMENT_2
layout(location = 2) out highp vec4 pc_fragColor2;
#endif
#endif

#ifndef REMOVE_COLOR_ATTACHMENT_3
#if COLOR_ATTACHMENT_3
layout(location = 3) out highp vec4 pc_fragColor3;
#endif
#endif

#ifndef REMOVE_COLOR_ATTACHMENT_4
#if COLOR_ATTACHMENT_4
layout(location = 4) out highp vec4 pc_fragColor4;
#endif
#endif

#ifndef REMOVE_COLOR_ATTACHMENT_5
#if COLOR_ATTACHMENT_5
layout(location = 5) out highp vec4 pc_fragColor5;
#endif
#endif

#ifndef REMOVE_COLOR_ATTACHMENT_6
#if COLOR_ATTACHMENT_6
layout(location = 6) out highp vec4 pc_fragColor6;
#endif
#endif

#ifndef REMOVE_COLOR_ATTACHMENT_7
#if COLOR_ATTACHMENT_7
layout(location = 7) out highp vec4 pc_fragColor7;
#endif
#endif

#define gl_FragColor pc_fragColor

#define pcFragColor0 pc_fragColor
#define pcFragColor1 pc_fragColor1
#define pcFragColor2 pc_fragColor2
#define pcFragColor3 pc_fragColor3
#define pcFragColor4 pc_fragColor4
#define pcFragColor5 pc_fragColor5
#define pcFragColor6 pc_fragColor6
#define pcFragColor7 pc_fragColor7

#define varying in

#define texture2D texture
#define texture2DBias texture
#define textureCube texture
#define texture2DProj textureProj
#define texture2DLodEXT textureLod
#define texture2DProjLodEXT textureProjLod
#define textureCubeLodEXT textureLod
#define texture2DGradEXT textureGrad
#define texture2DProjGradEXT textureProjGrad
#define textureCubeGradEXT textureGrad

// sample shadows using textureGrad to remove derivatives in the dynamic loops (which are used by
// clustered lighting) - as DirectX shader compiler tries to unroll the loops and takes long time
// to compile the shader. Using textureLod would be even better, but WebGl does not translate it to
// lod instruction for DirectX correctly and uses SampleCmp instead of SampleCmpLevelZero or similar.
#define textureShadow(res, uv) textureGrad(res, uv, vec2(1, 1), vec2(1, 1))

// pass / accept shadow map or texture as a function parameter, on webgl this is simply passed as is
// but this is needed for WebGPU
#define SHADOWMAP_PASS(name) name
#define SHADOWMAP_ACCEPT(name) sampler2DShadow name
#define TEXTURE_PASS(name) name
#define TEXTURE_ACCEPT(name) sampler2D name

#define GL2
#define SUPPORTS_TEXLOD
#define SUPPORTS_MRT
`;
          },
          8694: (Se, W, a) => {
            "use strict";
            a.d(W, { Z: () => x });
            var x = `

// texelFetch support and others
#extension GL_EXT_samplerless_texture_functions : require

layout(location = 0) out highp vec4 pc_fragColor;
layout(location = 1) out highp vec4 pc_fragColor1;
layout(location = 2) out highp vec4 pc_fragColor2;
layout(location = 3) out highp vec4 pc_fragColor3;
layout(location = 4) out highp vec4 pc_fragColor4;
layout(location = 5) out highp vec4 pc_fragColor5;
layout(location = 6) out highp vec4 pc_fragColor6;
layout(location = 7) out highp vec4 pc_fragColor7;

#define gl_FragColor pc_fragColor

#define pcFragColor0 pc_fragColor
#define pcFragColor1 pc_fragColor1
#define pcFragColor2 pc_fragColor2
#define pcFragColor3 pc_fragColor3
#define pcFragColor4 pc_fragColor4
#define pcFragColor5 pc_fragColor5
#define pcFragColor6 pc_fragColor6
#define pcFragColor7 pc_fragColor7

#define texture2D(res, uv) texture(sampler2D(res, res ## _sampler), uv)
#define texture2DBias(res, uv, bias) texture(sampler2D(res, res ## _sampler), uv, bias)
#define texture2DLodEXT(res, uv, lod) textureLod(sampler2D(res, res ## _sampler), uv, lod)
#define textureCube(res, uv) texture(samplerCube(res, res ## _sampler), uv)
#define textureCubeLodEXT(res, uv, lod) textureLod(samplerCube(res, res ## _sampler), uv, lod)
#define textureShadow(res, uv) textureLod(sampler2DShadow(res, res ## _sampler), uv, 0.0)

// TODO: implement other texture sampling macros
// #define texture2DProj textureProj
// #define texture2DProjLodEXT textureProjLod
// #define texture2DGradEXT textureGrad
// #define texture2DProjGradEXT textureProjGrad
// #define textureCubeGradEXT textureGrad

// pass / accept shadow map as a function parameter, passes both the texture as well as sampler
// as the combined sampler can be only created at a point of use
#define SHADOWMAP_PASS(name) name, name ## _sampler
#define SHADOWMAP_ACCEPT(name) texture2D name, sampler name ## _sampler
#define TEXTURE_PASS(name) name, name ## _sampler
#define TEXTURE_ACCEPT(name) texture2D name, sampler name ## _sampler

#define GL2
#define WEBGPU
#define SUPPORTS_TEXLOD
#define SUPPORTS_MRT
`;
          },
          5910: (Se, W, a) => {
            "use strict";
            a.d(W, { Z: () => x });
            var x = `
#define attribute in
#define varying out
#define texture2D texture
#define GL2
#define VERTEXSHADER
`;
          },
          9453: (Se, W, a) => {
            "use strict";
            a.d(W, { Z: () => x });
            var x = `

// texelFetch support and others
#extension GL_EXT_samplerless_texture_functions : require

#define texture2D(res, uv) texture(sampler2D(res, res ## _sampler), uv)

#define GL2
#define WEBGPU
#define VERTEXSHADER
`;
          },
          1071: (Se, W, a) => {
            "use strict";
            a.d(W, { C: () => T });
            var x = a(7921);
            class T {
              constructor(c, d, h) {
                (this.uniformFormats = []),
                  (this.bindGroupFormats = []),
                  (this.vertexFormat = void 0),
                  (this.uniformFormats[x.Qqf] = c),
                  (this.bindGroupFormats[x.Qqf] = d),
                  (this.vertexFormat = h);
              }
              hasUniform(c) {
                for (let d = 0; d < this.uniformFormats.length; d++) {
                  const h = this.uniformFormats[d];
                  if (h != null && h.get(c)) return !0;
                }
                return !1;
              }
              hasTexture(c) {
                for (let d = 0; d < this.bindGroupFormats.length; d++) {
                  const h = this.bindGroupFormats[d];
                  if (h != null && h.getTexture(c)) return !0;
                }
                return !1;
              }
              getVertexElement(c) {
                var d;
                return (d = this.vertexFormat) == null
                  ? void 0
                  : d.elements.find((h) => h.name === c);
              }
              generateKey(c) {
                let d =
                  JSON.stringify(this.uniformFormats) +
                  JSON.stringify(this.bindGroupFormats);
                if (c.isWebGPU) {
                  var h;
                  d +=
                    (h = this.vertexFormat) == null
                      ? void 0
                      : h.renderingHashString;
                }
                return d;
              }
            }
          },
          3862: (Se, W, a) => {
            "use strict";
            a.d(W, { x: () => l });
            var x = a(7921),
              T = a(2462),
              g = a(7086),
              c = a(5910),
              d = a(8694),
              h = a(9453),
              f = `

// convert clip space position into texture coordinates to sample scene grab textures
vec2 getGrabScreenPos(vec4 clipPos) {
		vec2 uv = (clipPos.xy / clipPos.w) * 0.5 + 0.5;

		#ifdef WEBGPU
				uv.y = 1.0 - uv.y;
		#endif

		return uv;
}

// convert uv coordinates to sample image effect texture (render target texture rendered without
// forward renderer which does the flip in the projection matrix)
vec2 getImageEffectUV(vec2 uv) {
		#ifdef WEBGPU
				uv.y = 1.0 - uv.y;
		#endif

		return uv;
}
`;
            const s = {
              vertex_position: x.Q5v,
              vertex_normal: x.SA$,
              vertex_tangent: x.ipN,
              vertex_texCoord0: x.$fY,
              vertex_texCoord1: x.Q0q,
              vertex_texCoord2: x.WtN,
              vertex_texCoord3: x.SSp,
              vertex_texCoord4: x.uOW,
              vertex_texCoord5: x.EKq,
              vertex_texCoord6: x.Vcj,
              vertex_texCoord7: x.$8O,
              vertex_color: x.wD$,
              vertex_boneIndices: x.MgX,
              vertex_boneWeights: x.d1j,
            };
            class l {
              static createDefinition(o, i) {
                var e, t;
                const r = (v, P, I, A) => {
                    const B = o.isWebGPU
                      ? v
                      : o.webgl2
                      ? P
                      : l.gl1Extensions(o, i) + I;
                    let C = "";
                    for (let w = 0; w < o.maxColorAttachments; w++)
                      C += `#define COLOR_ATTACHMENT_${w}
`;
                    return C + B;
                  },
                  u = (e = i.name) != null ? e : "Untitled",
                  y = i.vertexDefines || r(h.Z, c.Z, ""),
                  p =
                    l.versionCode(o) +
                    y +
                    f +
                    l.getShaderNameCode(u) +
                    i.vertexCode,
                  _ = i.fragmentDefines || r(d.Z, g.Z, T.Z),
                  m =
                    (i.fragmentPreamble || "") +
                    l.versionCode(o) +
                    _ +
                    l.precisionCode(o) +
                    `
` +
                    f +
                    l.getShaderNameCode(u) +
                    (i.fragmentCode || l.dummyFragmentCode()),
                  E =
                    (t = i.attributes) != null
                      ? t
                      : l.collectAttributes(i.vertexCode);
                return {
                  name: u,
                  attributes: E,
                  vshader: p,
                  fshader: m,
                  useTransformFeedback: i.useTransformFeedback,
                };
              }
              static getShaderNameCode(o) {
                return `#define SHADER_NAME ${o}
`;
              }
              static gl1Extensions(o, i, e) {
                let t;
                return (
                  e
                    ? (t = i.vertexExtensions
                        ? `${i.vertexExtensions}
`
                        : "")
                    : ((t = i.fragmentExtensions
                        ? `${i.fragmentExtensions}
`
                        : ""),
                      o.extStandardDerivatives &&
                        (t += `#extension GL_OES_standard_derivatives : enable
`),
                      o.extTextureLod &&
                        ((t += `#extension GL_EXT_shader_texture_lod : enable
`),
                        (t += `#define SUPPORTS_TEXLOD
`)),
                      o.extDrawBuffers &&
                        ((t += `#extension GL_EXT_draw_buffers : require
`),
                        (t += `#define SUPPORTS_MRT
`))),
                  t
                );
              }
              static dummyFragmentCode() {
                return "void main(void) {gl_FragColor = vec4(0.0);}";
              }
              static versionCode(o) {
                return o.isWebGPU
                  ? `#version 450
`
                  : o.webgl2
                  ? `#version 300 es
`
                  : "";
              }
              static precisionCode(o, i) {
                let e = "";
                i &&
                  i !== "highp" &&
                  i !== "mediump" &&
                  i !== "lowp" &&
                  (i = null),
                  i &&
                    (i === "highp" &&
                      o.maxPrecision !== "highp" &&
                      (i = "mediump"),
                    i === "mediump" &&
                      o.maxPrecision === "lowp" &&
                      (i = "lowp"));
                const t = i || o.precision;
                return (
                  o.isWebGPU
                    ? (e = `precision ${t} float;
precision ${t} int;
`)
                    : ((e = `precision ${t} float;
`),
                      o.webgl2 &&
                        (e += `precision ${t} sampler2DShadow;
`)),
                  e
                );
              }
              static collectAttributes(o) {
                const i = {};
                let e = 0,
                  t = o.indexOf("attribute");
                for (; t >= 0 && !(t > 0 && o[t - 1] === "/"); ) {
                  const r = o.indexOf(";", t),
                    u = o.lastIndexOf(" ", r),
                    y = o.substring(u + 1, r),
                    p = s[y];
                  p !== void 0 ? (i[y] = p) : ((i[y] = "ATTR" + e), e++),
                    (t = o.indexOf("attribute", t + 1));
                }
                return i;
              }
            }
          },
          6977: (Se, W, a) => {
            "use strict";
            a.d(W, { e: () => i });
            const x =
                /[ \t]*#(ifn?def|if|endif|else|elif|define|undef|extension)/g,
              T = /define[ \t]+([^\n]+)\r?(?:\n|$)/g,
              g = /extension[ \t]+([\w-]+)[ \t]*:[ \t]*(enable|require)/g,
              c = /undef[ \t]+([^\n]+)\r?(?:\n|$)/g,
              d = /(ifdef|ifndef|if)[ \t]*([^\r\n]+)\r?\n/g,
              h = /(endif|else|elif)([ \t]+[^\r\n]+)?\r?(?:\n|$)/g,
              f = /([\w-]+)/,
              s = /(!|\s)?defined\(([\w-]+)\)/,
              l = /[><=|&+-]/g;
            class n {
              static run(t, r = !1) {
                (t = t.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, "$1")),
                  (t = t.split(/\r?\n/).map((p) => p.trimEnd()).join(`
`));
                const u = new Map();
                if (r) {
                  const p = new Map(),
                    _ = /(pcFragColor[1-8])\b/g,
                    m = t.match(_);
                  m == null ||
                    m.forEach((E) => {
                      var v;
                      const P = parseInt(E.charAt(E.length - 1), 10);
                      p.set(P, ((v = p.get(P)) != null ? v : 0) + 1);
                    }),
                    p.forEach((E, v) => {
                      E === 1 && u.set(`REMOVE_COLOR_ATTACHMENT_${v}`, "");
                    });
                }
                t = this._preprocess(t, u);
                const y = new Map();
                return (
                  u.forEach((p, _) => {
                    Number.isInteger(parseFloat(p)) &&
                      !p.includes(".") &&
                      y.set(_, p);
                  }),
                  t !== null &&
                    ((t = t
                      .split(/\r?\n/)
                      .map((p) => (p.trim() === "" ? "" : p))
                      .map(
                        (p) => (
                          y.forEach((_, m) => {
                            p = p.replace(
                              new RegExp(`\\[${m}\\]`, "g"),
                              `[${_}]`
                            );
                          }),
                          p
                        )
                      ).join(`
`)),
                    (t = t.replace(
                      /(\n\n){3,}/gm,
                      `

`
                    ))),
                  t
                );
              }
              static _preprocess(t, r = new Map()) {
                const u = t,
                  y = [];
                let p = !1,
                  _;
                for (; (_ = x.exec(t)) !== null; ) {
                  const m = _[1];
                  switch (m) {
                    case "define": {
                      T.lastIndex = _.index;
                      const E = T.exec(t);
                      p || (p = E === null);
                      const v = E[1];
                      f.lastIndex = E.index;
                      const I = f.exec(v)[1];
                      let A = v.substring(I.length).trim();
                      A === "" && (A = "true"),
                        n._keep(y) && r.set(I, A),
                        (x.lastIndex = E.index + E[0].length);
                      break;
                    }
                    case "undef": {
                      c.lastIndex = _.index;
                      const E = c.exec(t),
                        v = E[1].trim();
                      n._keep(y) && r.delete(v),
                        (x.lastIndex = E.index + E[0].length);
                      break;
                    }
                    case "extension": {
                      g.lastIndex = _.index;
                      const E = g.exec(t);
                      if ((p || (p = E === null), E)) {
                        const v = E[1];
                        n._keep(y) && r.set(v, "true");
                      }
                      x.lastIndex = E.index + E[0].length;
                      break;
                    }
                    case "ifdef":
                    case "ifndef":
                    case "if": {
                      d.lastIndex = _.index;
                      const E = d.exec(t),
                        v = E[2],
                        P = n.evaluate(v, r);
                      p || (p = P.error);
                      let I = P.result;
                      m === "ifndef" && (I = !I),
                        y.push({
                          anyKeep: I,
                          keep: I,
                          start: _.index,
                          end: d.lastIndex,
                        }),
                        (x.lastIndex = E.index + E[0].length);
                      break;
                    }
                    case "endif":
                    case "else":
                    case "elif": {
                      h.lastIndex = _.index;
                      const E = h.exec(t),
                        v = y.pop(),
                        P = v.keep ? t.substring(v.end, _.index) : "";
                      (t =
                        t.substring(0, v.start) + P + t.substring(h.lastIndex)),
                        (x.lastIndex = v.start + P.length);
                      const I = E[1];
                      if (I === "else" || I === "elif") {
                        let A = !1;
                        if (!v.anyKeep)
                          if (I === "else") A = !v.keep;
                          else {
                            const B = n.evaluate(E[2], r);
                            (A = B.result), p || (p = B.error);
                          }
                        y.push({
                          anyKeep: v.anyKeep || A,
                          keep: A,
                          start: x.lastIndex,
                          end: x.lastIndex,
                        });
                      }
                      break;
                    }
                  }
                }
                return p
                  ? (console.warn("Failed to preprocess shader: ", {
                      source: u,
                    }),
                    u)
                  : t;
              }
              static _keep(t) {
                for (let r = 0; r < t.length; r++) if (!t[r].keep) return !1;
                return !0;
              }
              static evaluate(t, r) {
                const u = l.exec(t) === null;
                let y = !1;
                const p = s.exec(t);
                p && ((y = p[1] === "!"), (t = p[2])), (t = t.trim());
                let _ = r.has(t);
                return y && (_ = !_), { result: _, error: !u };
              }
            }
            let o = 0;
            class i {
              constructor(t, r) {
                (this.meshUniformBufferFormat = void 0),
                  (this.meshBindGroupFormat = void 0),
                  (this.id = o++),
                  (this.device = t),
                  (this.definition = r),
                  (this.name = r.name || "Untitled"),
                  (r.vshader = n.run(r.vshader)),
                  (r.fshader = n.run(r.fshader, t.webgl2)),
                  this.init(),
                  (this.impl = t.createShaderImpl(this));
              }
              init() {
                (this.ready = !1), (this.failed = !1);
              }
              get label() {
                return `Shader Id ${this.id} ${this.name}`;
              }
              destroy() {
                this.device.onDestroyShader(this), this.impl.destroy(this);
              }
              loseContext() {
                this.init(), this.impl.loseContext();
              }
              restoreContext() {
                this.impl.restoreContext(this.device, this);
              }
            }
          },
          30: (Se, W, a) => {
            "use strict";
            a.d(W, { p: () => c });
            var x = a(7921),
              T = a(576);
            const g = new T.X();
            class c {
              set func(h) {
                (this._func = h), (this._dirty = !0);
              }
              get func() {
                return this._func;
              }
              set ref(h) {
                (this._ref = h), (this._dirty = !0);
              }
              get ref() {
                return this._ref;
              }
              set fail(h) {
                (this._fail = h), (this._dirty = !0);
              }
              get fail() {
                return this._fail;
              }
              set zfail(h) {
                (this._zfail = h), (this._dirty = !0);
              }
              get zfail() {
                return this._zfail;
              }
              set zpass(h) {
                (this._zpass = h), (this._dirty = !0);
              }
              get zpass() {
                return this._zpass;
              }
              set readMask(h) {
                (this._readMask = h), (this._dirty = !0);
              }
              get readMask() {
                return this._readMask;
              }
              set writeMask(h) {
                (this._writeMask = h), (this._dirty = !0);
              }
              get writeMask() {
                return this._writeMask;
              }
              constructor(h = {}) {
                var f, s, l, n, o, i, e;
                (this._func = void 0),
                  (this._ref = void 0),
                  (this._fail = void 0),
                  (this._zfail = void 0),
                  (this._zpass = void 0),
                  (this._readMask = void 0),
                  (this._writeMask = void 0),
                  (this._dirty = !0),
                  (this._key = void 0),
                  (this._func = (f = h.func) != null ? f : x.g8z),
                  (this._ref = (s = h.ref) != null ? s : 0),
                  (this._readMask = (l = h.readMask) != null ? l : 255),
                  (this._writeMask = (n = h.writeMask) != null ? n : 255),
                  (this._fail = (o = h.fail) != null ? o : x.gKr),
                  (this._zfail = (i = h.zfail) != null ? i : x.gKr),
                  (this._zpass = (e = h.zpass) != null ? e : x.gKr),
                  this._evalKey();
              }
              _evalKey() {
                const {
                    _func: h,
                    _ref: f,
                    _fail: s,
                    _zfail: l,
                    _zpass: n,
                    _readMask: o,
                    _writeMask: i,
                  } = this,
                  e = `${h},${f},${s},${l},${n},${o},${i}`;
                (this._key = g.get(e)), (this._dirty = !1);
              }
              get key() {
                return this._dirty && this._evalKey(), this._key;
              }
              copy(h) {
                return (
                  (this._func = h._func),
                  (this._ref = h._ref),
                  (this._readMask = h._readMask),
                  (this._writeMask = h._writeMask),
                  (this._fail = h._fail),
                  (this._zfail = h._zfail),
                  (this._zpass = h._zpass),
                  (this._dirty = h._dirty),
                  (this._key = h._key),
                  this
                );
              }
              clone() {
                return new this.constructor().copy(this);
              }
            }
            c.DEFAULT = Object.freeze(new c());
          },
          5432: (Se, W, a) => {
            "use strict";
            a.d(W, { O: () => T });
            var x = a(7921);
            class T {
              static calcLevelDimension(c, d) {
                return Math.max(c >> d, 1);
              }
              static calcLevelGpuSize(c, d, h, f) {
                var s, l, n;
                const o = x.qBv.get(f),
                  i =
                    (s = (l = x.qBv.get(f)) == null ? void 0 : l.size) != null
                      ? s
                      : 0;
                if (i > 0) return c * d * h * i;
                const e = (n = o.blockSize) != null ? n : 0;
                let t = Math.floor((c + 3) / 4);
                const r = Math.floor((d + 3) / 4),
                  u = Math.floor((h + 3) / 4);
                return (
                  (f === x.eV7 || f === x.g0o) &&
                    (t = Math.max(Math.floor(t / 2), 1)),
                  t * r * u * e
                );
              }
              static calcGpuSize(c, d, h, f, s, l) {
                let n = 0;
                for (
                  ;
                  (n += T.calcLevelGpuSize(c, d, h, f)),
                    !(!s || (c === 1 && d === 1 && h === 1));

                )
                  (c = Math.max(c >> 1, 1)),
                    (d = Math.max(d >> 1, 1)),
                    (h = Math.max(h >> 1, 1));
                return n * (l ? 6 : 1);
              }
            }
          },
          8869: (Se, W, a) => {
            "use strict";
            a.d(W, { x: () => h });
            var x = a(4585),
              T = a(3412),
              g = a(5432),
              c = a(7921);
            let d = 0;
            class h {
              constructor(s, l = {}) {
                var n, o, i, e, t, r, u, y, p, _, m, E, v, P, I, A, B, C;
                if (
                  ((this.name = void 0),
                  (this._isRenderTarget = !1),
                  (this._gpuSize = 0),
                  (this.id = d++),
                  (this._invalid = !1),
                  (this._lockedLevel = -1),
                  (this.renderVersionDirty = 0),
                  (this.device = s),
                  (this.name = (n = l.name) != null ? n : null),
                  (this._width = (o = l.width) != null ? o : 4),
                  (this._height = (i = l.height) != null ? i : 4),
                  (this._format = (e = l.format) != null ? e : c.jKI),
                  (this._compressed = (0, c.stI)(this._format)),
                  s.supportsVolumeTextures)
                ) {
                  var w, k;
                  (this._volume = (w = l.volume) != null ? w : !1),
                    (this._depth = (k = l.depth) != null ? k : 1);
                } else (this._volume = !1), (this._depth = 1);
                (this._cubemap = (t = l.cubemap) != null ? t : !1),
                  (this.fixCubemapSeams =
                    (r = l.fixCubemapSeams) != null ? r : !1),
                  (this._flipY = (u = l.flipY) != null ? u : !1),
                  (this._premultiplyAlpha =
                    (y = l.premultiplyAlpha) != null ? y : !1),
                  (this._mipmaps =
                    (p = (_ = l.mipmaps) != null ? _ : l.autoMipmap) != null
                      ? p
                      : !0),
                  (this._minFilter = (m = l.minFilter) != null ? m : c.Snx),
                  (this._magFilter = (E = l.magFilter) != null ? E : c.I5X),
                  (this._anisotropy = (v = l.anisotropy) != null ? v : 1),
                  (this._addressU = (P = l.addressU) != null ? P : c.SuC),
                  (this._addressV = (I = l.addressV) != null ? I : c.SuC),
                  (this._addressW = (A = l.addressW) != null ? A : c.SuC),
                  (this._compareOnRead =
                    (B = l.compareOnRead) != null ? B : !1),
                  (this._compareFunc = (C = l.compareFunc) != null ? C : c.n9),
                  (this.type = c.zZc),
                  l.hasOwnProperty("type")
                    ? (this.type = l.type)
                    : l.hasOwnProperty("rgbm")
                    ? (this.type = l.rgbm ? c.xIP : c.zZc)
                    : l.hasOwnProperty("swizzleGGGR") &&
                      (this.type = l.swizzleGGGR ? c.anS : c.zZc),
                  (this.projection = c.O$k),
                  this._cubemap
                    ? (this.projection = c.BuW)
                    : l.projection &&
                      l.projection !== c.BuW &&
                      (this.projection = l.projection),
                  (this.impl = s.createTextureImpl(this)),
                  this.dirtyAll(),
                  (this._levels = l.levels),
                  this._levels
                    ? this.upload()
                    : (this._levels = this._cubemap
                        ? [[null, null, null, null, null, null]]
                        : [null]),
                  s.textures.push(this);
              }
              destroy() {
                if (this.device) {
                  const s = this.device,
                    l = s.textures.indexOf(this);
                  l !== -1 && s.textures.splice(l, 1),
                    s.scope.removeValue(this),
                    this.impl.destroy(s),
                    this.adjustVramSizeTracking(s._vram, -this._gpuSize),
                    (this._levels = null),
                    (this.device = null);
                }
              }
              loseContext() {
                this.impl.loseContext(), this.dirtyAll();
              }
              adjustVramSizeTracking(s, l) {
                s.tex += l;
              }
              propertyChanged(s) {
                this.impl.propertyChanged(s),
                  (this.renderVersionDirty = this.device.renderVersion);
              }
              get requiredMipLevels() {
                return this.mipmaps
                  ? Math.floor(Math.log2(Math.max(this.width, this.height))) + 1
                  : 1;
              }
              set minFilter(s) {
                this._minFilter !== s &&
                  ((this._minFilter = s), this.propertyChanged(1));
              }
              get minFilter() {
                return this._minFilter;
              }
              set magFilter(s) {
                this._magFilter !== s &&
                  ((this._magFilter = s), this.propertyChanged(2));
              }
              get magFilter() {
                return this._magFilter;
              }
              set addressU(s) {
                this._addressU !== s &&
                  ((this._addressU = s), this.propertyChanged(4));
              }
              get addressU() {
                return this._addressU;
              }
              set addressV(s) {
                this._addressV !== s &&
                  ((this._addressV = s), this.propertyChanged(8));
              }
              get addressV() {
                return this._addressV;
              }
              set addressW(s) {
                this.device.supportsVolumeTextures &&
                  this._volume &&
                  s !== this._addressW &&
                  ((this._addressW = s), this.propertyChanged(16));
              }
              get addressW() {
                return this._addressW;
              }
              set compareOnRead(s) {
                this._compareOnRead !== s &&
                  ((this._compareOnRead = s), this.propertyChanged(32));
              }
              get compareOnRead() {
                return this._compareOnRead;
              }
              set compareFunc(s) {
                this._compareFunc !== s &&
                  ((this._compareFunc = s), this.propertyChanged(64));
              }
              get compareFunc() {
                return this._compareFunc;
              }
              set anisotropy(s) {
                this._anisotropy !== s &&
                  ((this._anisotropy = s), this.propertyChanged(128));
              }
              get anisotropy() {
                return this._anisotropy;
              }
              set mipmaps(s) {
                this._mipmaps !== s &&
                  ((this._mipmaps = s),
                  this.device.isWebGPU,
                  s && (this._needsMipmapsUpload = !0));
              }
              get mipmaps() {
                return this._mipmaps;
              }
              get width() {
                return this._width;
              }
              get height() {
                return this._height;
              }
              get depth() {
                return this._depth;
              }
              get format() {
                return this._format;
              }
              get cubemap() {
                return this._cubemap;
              }
              get gpuSize() {
                const s =
                  this.pot &&
                  this._mipmaps &&
                  !(this._compressed && this._levels.length === 1);
                return g.O.calcGpuSize(
                  this._width,
                  this._height,
                  this._depth,
                  this._format,
                  s,
                  this._cubemap
                );
              }
              get volume() {
                return this._volume;
              }
              set flipY(s) {
                this._flipY !== s &&
                  ((this._flipY = s), (this._needsUpload = !0));
              }
              get flipY() {
                return this._flipY;
              }
              set premultiplyAlpha(s) {
                this._premultiplyAlpha !== s &&
                  ((this._premultiplyAlpha = s), (this._needsUpload = !0));
              }
              get premultiplyAlpha() {
                return this._premultiplyAlpha;
              }
              get pot() {
                return (
                  x.m.powerOfTwo(this._width) && x.m.powerOfTwo(this._height)
                );
              }
              get encoding() {
                switch (this.type) {
                  case c.xIP:
                    return "rgbm";
                  case c.puI:
                    return "rgbe";
                  case c.kVJ:
                    return "rgbp";
                  default:
                    return this.format === c.q_o ||
                      this.format === c.lN5 ||
                      this.format === c.a7f ||
                      this.format === c.uC3
                      ? "linear"
                      : "srgb";
                }
              }
              dirtyAll() {
                (this._levelsUpdated = this._cubemap
                  ? [[!0, !0, !0, !0, !0, !0]]
                  : [!0]),
                  (this._needsUpload = !0),
                  (this._needsMipmapsUpload = this._mipmaps),
                  (this._mipmapsUploaded = !1),
                  this.propertyChanged(255);
              }
              lock(s = {}) {
                s.level === void 0 && (s.level = 0),
                  s.face === void 0 && (s.face = 0),
                  s.mode === void 0 && (s.mode = c.NTX),
                  (this._lockedLevel = s.level);
                const l = this.cubemap ? this._levels[s.face] : this._levels;
                if (l[s.level] === null) {
                  const n = Math.max(1, this._width >> s.level),
                    o = Math.max(1, this._height >> s.level),
                    i = Math.max(1, this._depth >> s.level),
                    e = new ArrayBuffer(
                      g.O.calcLevelGpuSize(n, o, i, this._format)
                    );
                  l[s.level] = new ((0, c.QUn)(this._format))(e);
                }
                return l[s.level];
              }
              setSource(s, l = 0) {
                let n = !1,
                  o,
                  i;
                if (this._cubemap) {
                  if (s[0]) {
                    (o = s[0].width || 0), (i = s[0].height || 0);
                    for (let e = 0; e < 6; e++) {
                      const t = s[e];
                      if (
                        !t ||
                        t.width !== o ||
                        t.height !== i ||
                        !this.device._isBrowserInterface(t)
                      ) {
                        n = !0;
                        break;
                      }
                    }
                  } else n = !0;
                  if (!n)
                    for (let e = 0; e < 6; e++)
                      this._levels[l][e] !== s[e] &&
                        (this._levelsUpdated[l][e] = !0);
                } else
                  this.device._isBrowserInterface(s) || (n = !0),
                    n ||
                      (s !== this._levels[l] && (this._levelsUpdated[l] = !0),
                      (o = s.width),
                      (i = s.height));
                if (n)
                  if (((this._width = 4), (this._height = 4), this._cubemap))
                    for (let e = 0; e < 6; e++)
                      (this._levels[l][e] = null),
                        (this._levelsUpdated[l][e] = !0);
                  else (this._levels[l] = null), (this._levelsUpdated[l] = !0);
                else
                  l === 0 && ((this._width = o), (this._height = i)),
                    (this._levels[l] = s);
                (this._invalid !== n || !n) &&
                  ((this._invalid = n), this.upload());
              }
              getSource(s = 0) {
                return this._levels[s];
              }
              unlock() {
                this._lockedLevel, this.upload(), (this._lockedLevel = -1);
              }
              upload() {
                var s, l;
                (this._needsUpload = !0),
                  (this._needsMipmapsUpload = this._mipmaps),
                  (s = (l = this.impl).uploadImmediate) == null ||
                    s.call(l, this.device, this);
              }
              downloadAsync() {
                return pn(this, null, function* () {
                  const s = [];
                  for (let o = 0; o < (this.cubemap ? 6 : 1); o++) {
                    var l, n;
                    const i = new T.A({
                      colorBuffer: this,
                      depth: !1,
                      face: o,
                    });
                    this.device.setRenderTarget(i),
                      this.device.initRenderTarget(i);
                    const e = this.cubemap ? this._levels[o] : this._levels;
                    let t = e[0];
                    e[0] &&
                      this.device._isBrowserInterface(e[0]) &&
                      (e[0] = null),
                      (t = this.lock({ face: o }));
                    const r =
                      (l = (n = this.device).readPixelsAsync) == null
                        ? void 0
                        : l
                            .call(n, 0, 0, this.width, this.height, t)
                            .then(() => i.destroy());
                    s.push(r);
                  }
                  yield Promise.all(s);
                });
              }
              getDds() {
                let s = 128,
                  l = 0;
                for (; this._levels[l]; ) {
                  if (this.cubemap)
                    for (let B = 0; B < 6; B++) {
                      if (!this._levels[l][B]) return;
                      const C = this._levels[l][B].length;
                      if (!C) return;
                      s += C;
                    }
                  else {
                    const B = this._levels[l].length;
                    if (!B) return;
                    s += B;
                  }
                  (s += this._levels[l].length), l++;
                }
                const n = new ArrayBuffer(s),
                  o = new Uint32Array(n, 0, 128 / 4),
                  i = 542327876,
                  e = 124,
                  t = 528391,
                  r = 131072,
                  u = 32,
                  y = 65,
                  p = 4096,
                  _ = 4194304,
                  m = 8,
                  E = 65024;
                let v = t;
                this._levels.length > 1 && (v |= r);
                let P = p;
                this._levels.length > 1 && (P |= _),
                  (this._levels.length > 1 || this.cubemap) && (P |= m);
                const I = this.cubemap ? E : 0;
                (o[0] = i),
                  (o[1] = e),
                  (o[2] = v),
                  (o[3] = this.height),
                  (o[4] = this.width),
                  (o[5] = this.width * this.height * 4),
                  (o[6] = 0),
                  (o[7] = this._levels.length);
                for (let B = 0; B < 11; B++) o[8 + B] = 0;
                (o[19] = u),
                  (o[20] = y),
                  (o[21] = 0),
                  (o[22] = 32),
                  (o[23] = 16711680),
                  (o[24] = 65280),
                  (o[25] = 255),
                  (o[26] = 4278190080),
                  (o[27] = P),
                  (o[28] = I),
                  (o[29] = 0),
                  (o[30] = 0),
                  (o[31] = 0);
                let A = 128;
                if (this.cubemap)
                  for (let B = 0; B < 6; B++)
                    for (let C = 0; C < this._levels.length; C++) {
                      const w = this._levels[C][B],
                        k = new Uint8Array(n, A, w.length);
                      for (let K = 0; K < w.length; K++) k[K] = w[K];
                      A += w.length;
                    }
                else
                  for (let B = 0; B < this._levels.length; B++) {
                    const C = this._levels[B],
                      w = new Uint8Array(n, A, C.length);
                    for (let k = 0; k < C.length; k++) w[k] = C[k];
                    A += C.length;
                  }
                return n;
              }
            }
          },
          289: (Se, W, a) => {
            "use strict";
            a.d(W, { M: () => c, f: () => d });
            var x = a(4585),
              T = a(7921);
            const g = [];
            (g[T.Cdl] = 1),
              (g[T.d_l] = 2),
              (g[T.T73] = 3),
              (g[T.nZ6] = 4),
              (g[T.cNy] = 1),
              (g[T.YsN] = 2),
              (g[T.D35] = 3),
              (g[T.JT4] = 4),
              (g[T.lRO] = 1),
              (g[T.U$] = 2),
              (g[T.AMs] = 3),
              (g[T.fmW] = 4),
              (g[T.R4W] = 8),
              (g[T.Si0] = 12),
              (g[T.EA4] = 16);
            class c {
              constructor(f, s, l = 0) {
                if (
                  ((this.name = void 0),
                  (this.type = void 0),
                  (this.byteSize = void 0),
                  (this.offset = void 0),
                  (this.scopeId = void 0),
                  (this.count = void 0),
                  (this.shortName = f),
                  (this.name = l ? `${f}[0]` : f),
                  (this.type = s),
                  (this.updateType = s),
                  l)
                )
                  switch (s) {
                    case T.Cdl:
                      this.updateType = T.mQ2;
                      break;
                    case T.d_l:
                      this.updateType = T.KdK;
                      break;
                    case T.T73:
                      this.updateType = T.m4F;
                      break;
                    case T.nZ6:
                      this.updateType = T.QQe;
                      break;
                    case T.EA4:
                      this.updateType = T.mK;
                      break;
                  }
                this.count = l;
                let n = g[s];
                l && (n = x.m.roundUp(n, 4)),
                  (this.byteSize = n * 4),
                  l && (this.byteSize *= l);
              }
              calculateOffset(f) {
                let s = this.byteSize <= 8 ? this.byteSize : 16;
                this.count && (s = 16),
                  (f = x.m.roundUp(f, s)),
                  (this.offset = f / 4);
              }
            }
            class d {
              constructor(f, s) {
                (this.byteSize = 0),
                  (this.map = new Map()),
                  (this.scope = f.scope),
                  (this.uniforms = s);
                let l = 0;
                for (let n = 0; n < s.length; n++) {
                  const o = s[n];
                  o.calculateOffset(l),
                    (l = o.offset * 4 + o.byteSize),
                    (o.scopeId = this.scope.resolve(o.name)),
                    this.map.set(o.name, o);
                }
                this.byteSize = x.m.roundUp(l, 16);
              }
              get(f) {
                return this.map.get(f);
              }
              getShaderDeclaration(f, s) {
                const l = T.BzP[f];
                let n = `layout(set = ${f}, binding = ${s}, std140) uniform ub_${l} {
`;
                return (
                  this.uniforms.forEach((o) => {
                    const i = T.HBB[o.type];
                    n += `    ${i} ${o.shortName}${
                      o.count ? `[${o.count}]` : ""
                    };
`;
                  }),
                  n +
                    `};
`
                );
              }
            }
          },
          4051: (Se, W, a) => {
            "use strict";
            a.d(W, { M: () => c });
            var x = a(7921),
              T = a(9227);
            const g = [];
            (g[x.Cdl] = function (d, h, f) {
              const s = d.storageFloat32;
              s[f] = h;
            }),
              (g[x.d_l] = (d, h, f) => {
                const s = d.storageFloat32;
                (s[f] = h[0]), (s[f + 1] = h[1]);
              }),
              (g[x.T73] = (d, h, f) => {
                const s = d.storageFloat32;
                (s[f] = h[0]), (s[f + 1] = h[1]), (s[f + 2] = h[2]);
              }),
              (g[x.nZ6] = (d, h, f) => {
                const s = d.storageFloat32;
                (s[f] = h[0]),
                  (s[f + 1] = h[1]),
                  (s[f + 2] = h[2]),
                  (s[f + 3] = h[3]);
              }),
              (g[x.cNy] = function (d, h, f) {
                const s = d.storageInt32;
                s[f] = h;
              }),
              (g[x.YsN] = function (d, h, f) {
                const s = d.storageInt32;
                (s[f] = h[0]), (s[f + 1] = h[1]);
              }),
              (g[x.D35] = function (d, h, f) {
                const s = d.storageInt32;
                (s[f] = h[0]), (s[f + 1] = h[1]), (s[f + 2] = h[2]);
              }),
              (g[x.JT4] = function (d, h, f) {
                const s = d.storageInt32;
                (s[f] = h[0]),
                  (s[f + 1] = h[1]),
                  (s[f + 2] = h[2]),
                  (s[f + 3] = h[3]);
              }),
              (g[x.R4W] = (d, h, f) => {
                const s = d.storageFloat32;
                (s[f] = h[0]),
                  (s[f + 1] = h[1]),
                  (s[f + 4] = h[2]),
                  (s[f + 5] = h[3]),
                  (s[f + 8] = h[4]),
                  (s[f + 9] = h[5]);
              }),
              (g[x.Si0] = (d, h, f) => {
                const s = d.storageFloat32;
                (s[f] = h[0]),
                  (s[f + 1] = h[1]),
                  (s[f + 2] = h[2]),
                  (s[f + 4] = h[3]),
                  (s[f + 5] = h[4]),
                  (s[f + 6] = h[5]),
                  (s[f + 8] = h[6]),
                  (s[f + 9] = h[7]),
                  (s[f + 10] = h[8]);
              }),
              (g[x.mQ2] = function (d, h, f, s) {
                const l = d.storageFloat32;
                for (let n = 0; n < s; n++) l[f + n * 4] = h[n];
              }),
              (g[x.KdK] = (d, h, f, s) => {
                const l = d.storageFloat32;
                for (let n = 0; n < s; n++)
                  (l[f + n * 4] = h[n * 2]), (l[f + n * 4 + 1] = h[n * 2 + 1]);
              }),
              (g[x.m4F] = (d, h, f, s) => {
                const l = d.storageFloat32;
                for (let n = 0; n < s; n++)
                  (l[f + n * 4] = h[n * 3]),
                    (l[f + n * 4 + 1] = h[n * 3 + 1]),
                    (l[f + n * 4 + 2] = h[n * 3 + 2]);
              });
            class c {
              constructor(h, f, s = !0) {
                if (
                  ((this.device = void 0),
                  (this.persistent = void 0),
                  (this.allocation = void 0),
                  (this.storageFloat32 = void 0),
                  (this.storageInt32 = void 0),
                  (this.renderVersionDirty = 0),
                  (this.device = h),
                  (this.format = f),
                  (this.persistent = s),
                  s)
                ) {
                  this.impl = h.createUniformBufferImpl(this);
                  const l = new ArrayBuffer(f.byteSize);
                  this.assignStorage(new Int32Array(l)),
                    (h._vram.ub += this.format.byteSize);
                } else this.allocation = new T.z_();
              }
              destroy() {
                if (this.persistent) {
                  const h = this.device;
                  this.impl.destroy(h), (h._vram.ub -= this.format.byteSize);
                }
              }
              get offset() {
                return this.persistent ? 0 : this.allocation.offset;
              }
              assignStorage(h) {
                (this.storageInt32 = h),
                  (this.storageFloat32 = new Float32Array(
                    h.buffer,
                    h.byteOffset,
                    h.byteLength / 4
                  ));
              }
              loseContext() {
                var h;
                (h = this.impl) == null || h.loseContext();
              }
              setUniform(h) {
                const f = h.offset,
                  s = h.scopeId.value;
                if (s != null) {
                  const l = g[h.updateType];
                  l ? l(this, s, f, h.count) : this.storageFloat32.set(s, f);
                }
              }
              set(h) {
                const f = this.format.map.get(h);
                f && this.setUniform(f);
              }
              update() {
                const h = this.persistent;
                if (!h) {
                  const s = this.allocation,
                    l = s.gpuBuffer;
                  this.device.dynamicBuffers.alloc(s, this.format.byteSize),
                    this.assignStorage(s.storage),
                    l !== s.gpuBuffer &&
                      (this.renderVersionDirty = this.device.renderVersion);
                }
                const f = this.format.uniforms;
                for (let s = 0; s < f.length; s++) this.setUniform(f[s]);
                h
                  ? this.impl.unlock(this)
                  : ((this.storageFloat32 = null), (this.storageInt32 = null));
              }
            }
          },
          1934: (Se, W, a) => {
            "use strict";
            a.d(W, { G: () => x });
            class x {
              constructor() {
                (this.globalId = 0), (this.revision = 0);
              }
              equals(g) {
                return (
                  this.globalId === g.globalId && this.revision === g.revision
                );
              }
              copy(g) {
                (this.globalId = g.globalId), (this.revision = g.revision);
              }
              reset() {
                (this.globalId = 0), (this.revision = 0);
              }
            }
          },
          6615: (Se, W, a) => {
            "use strict";
            a.d(W, { o: () => g });
            var x = a(7921);
            let T = 0;
            class g {
              constructor(d, h, f, s = x.dxy, l) {
                (this.device = d),
                  (this.format = h),
                  (this.numVertices = f),
                  (this.usage = s),
                  (this.id = T++),
                  (this.impl = d.createVertexBufferImpl(this, h)),
                  (this.numBytes = h.verticesByteSize
                    ? h.verticesByteSize
                    : h.size * f),
                  this.adjustVramSizeTracking(d._vram, this.numBytes),
                  l
                    ? this.setData(l)
                    : (this.storage = new ArrayBuffer(this.numBytes)),
                  this.device.buffers.push(this);
              }
              destroy() {
                const d = this.device,
                  h = d.buffers.indexOf(this);
                h !== -1 && d.buffers.splice(h, 1),
                  this.impl.initialized &&
                    (this.impl.destroy(d),
                    this.adjustVramSizeTracking(
                      d._vram,
                      -this.storage.byteLength
                    ));
              }
              adjustVramSizeTracking(d, h) {
                d.vb += h;
              }
              loseContext() {
                this.impl.loseContext();
              }
              getFormat() {
                return this.format;
              }
              getUsage() {
                return this.usage;
              }
              getNumVertices() {
                return this.numVertices;
              }
              lock() {
                return this.storage;
              }
              unlock() {
                this.impl.unlock(this);
              }
              setData(d) {
                return d.byteLength !== this.numBytes
                  ? !1
                  : ((this.storage = d), this.unlock(), !0);
              }
            }
          },
          8385: (Se, W, a) => {
            "use strict";
            a.d(W, { g: () => h });
            var x = a(2752),
              T = a(4585),
              g = a(576),
              c = a(7921);
            const d = new g.X();
            class h {
              constructor(s, l, n) {
                (this.device = s),
                  (this._elements = []),
                  (this.hasUv0 = !1),
                  (this.hasUv1 = !1),
                  (this.hasColor = !1),
                  (this.hasTangents = !1),
                  (this.verticesByteSize = 0),
                  (this.vertexCount = n),
                  (this.interleaved = n === void 0),
                  (this.instancing = !1),
                  (this.size = l.reduce(
                    (t, r) =>
                      t + Math.ceil((r.components * c.MbK[r.type]) / 4) * 4,
                    0
                  ));
                let o = 0,
                  i;
                for (let t = 0, r = l.length; t < r; t++) {
                  var e;
                  const u = l[t];
                  (i = u.components * c.MbK[u.type]),
                    n && (o = T.m.roundUp(o, i));
                  const y = {
                    name: u.semantic,
                    offset: n ? o : u.hasOwnProperty("offset") ? u.offset : o,
                    stride: n
                      ? i
                      : u.hasOwnProperty("stride")
                      ? u.stride
                      : this.size,
                    dataType: u.type,
                    numComponents: u.components,
                    normalize: (e = u.normalize) != null ? e : !1,
                    size: i,
                  };
                  this._elements.push(y),
                    n ? (o += i * n) : (o += Math.ceil(i / 4) * 4),
                    u.semantic === c.$fY
                      ? (this.hasUv0 = !0)
                      : u.semantic === c.Q0q
                      ? (this.hasUv1 = !0)
                      : u.semantic === c.wD$
                      ? (this.hasColor = !0)
                      : u.semantic === c.ipN && (this.hasTangents = !0);
                }
                n && (this.verticesByteSize = o), this._evaluateHash();
              }
              get elements() {
                return this._elements;
              }
              static getDefaultInstancingFormat(s) {
                return (
                  h._defaultInstancingFormat ||
                    (h._defaultInstancingFormat = new h(s, [
                      { semantic: c.gLS, components: 4, type: c.r8O },
                      { semantic: c.OrD, components: 4, type: c.r8O },
                      { semantic: c.nKe, components: 4, type: c.r8O },
                      { semantic: c.s36, components: 4, type: c.r8O },
                    ])),
                  h._defaultInstancingFormat
                );
              }
              update() {
                this._evaluateHash();
              }
              _evaluateHash() {
                let s;
                const l = [];
                let n;
                const o = [],
                  i = this._elements.length;
                for (let e = 0; e < i; e++) {
                  const t = this._elements[e];
                  (s = t.name),
                    (s += t.dataType),
                    (s += t.numComponents),
                    (s += t.normalize),
                    l.push(s),
                    (n = s),
                    (n += t.offset),
                    (n += t.stride),
                    (n += t.size),
                    o.push(n);
                }
                l.sort(),
                  (this.batchingHash = (0, x.u)(l.join())),
                  (this.renderingHashString = o.join("_")),
                  (this.renderingHash = d.get(this.renderingHashString));
              }
            }
            h._defaultInstancingFormat = null;
          },
          6938: (Se, W, a) => {
            "use strict";
            a.d(W, { O: () => r });
            var x = a(7921);
            function T(u) {
              this.array[this.index] = u;
            }
            function g(u, y) {
              (this.array[this.index] = u), (this.array[this.index + 1] = y);
            }
            function c(u, y, p) {
              (this.array[this.index] = u),
                (this.array[this.index + 1] = y),
                (this.array[this.index + 2] = p);
            }
            function d(u, y, p, _) {
              (this.array[this.index] = u),
                (this.array[this.index + 1] = y),
                (this.array[this.index + 2] = p),
                (this.array[this.index + 3] = _);
            }
            function h(u, y, p) {
              this.array[u] = y[p];
            }
            function f(u, y, p) {
              (this.array[u] = y[p]), (this.array[u + 1] = y[p + 1]);
            }
            function s(u, y, p) {
              (this.array[u] = y[p]),
                (this.array[u + 1] = y[p + 1]),
                (this.array[u + 2] = y[p + 2]);
            }
            function l(u, y, p) {
              (this.array[u] = y[p]),
                (this.array[u + 1] = y[p + 1]),
                (this.array[u + 2] = y[p + 2]),
                (this.array[u + 3] = y[p + 3]);
            }
            function n(u, y, p) {
              y[p] = this.array[u];
            }
            function o(u, y, p) {
              (y[p] = this.array[u]), (y[p + 1] = this.array[u + 1]);
            }
            function i(u, y, p) {
              (y[p] = this.array[u]),
                (y[p + 1] = this.array[u + 1]),
                (y[p + 2] = this.array[u + 2]);
            }
            function e(u, y, p) {
              (y[p] = this.array[u]),
                (y[p + 1] = this.array[u + 1]),
                (y[p + 2] = this.array[u + 2]),
                (y[p + 3] = this.array[u + 3]);
            }
            class t {
              constructor(y, p, _) {
                switch (
                  ((this.index = 0),
                  (this.numComponents = p.numComponents),
                  _.interleaved
                    ? (this.array = new x.DIG[p.dataType](y, p.offset))
                    : (this.array = new x.DIG[p.dataType](
                        y,
                        p.offset,
                        _.vertexCount * p.numComponents
                      )),
                  (this.stride =
                    p.stride / this.array.constructor.BYTES_PER_ELEMENT),
                  p.numComponents)
                ) {
                  case 1:
                    (this.set = T),
                      (this.getToArray = n),
                      (this.setFromArray = h);
                    break;
                  case 2:
                    (this.set = g),
                      (this.getToArray = o),
                      (this.setFromArray = f);
                    break;
                  case 3:
                    (this.set = c),
                      (this.getToArray = i),
                      (this.setFromArray = s);
                    break;
                  case 4:
                    (this.set = d),
                      (this.getToArray = e),
                      (this.setFromArray = l);
                    break;
                }
              }
              get(y) {
                return this.array[this.index + y];
              }
              set(y, p, _, m) {}
              getToArray(y, p, _) {}
              setFromArray(y, p, _) {}
            }
            class r {
              constructor(y) {
                (this.vertexBuffer = y),
                  (this.vertexFormatSize = y.getFormat().size),
                  (this.buffer = this.vertexBuffer.lock()),
                  (this.accessors = []),
                  (this.element = {});
                const p = this.vertexBuffer.getFormat();
                for (let _ = 0; _ < p.elements.length; _++) {
                  const m = p.elements[_];
                  (this.accessors[_] = new t(this.buffer, m, p)),
                    (this.element[m.name] = this.accessors[_]);
                }
              }
              next(y = 1) {
                let p = 0;
                const _ = this.accessors,
                  m = this.accessors.length;
                for (; p < m; ) {
                  const E = _[p++];
                  E.index += y * E.stride;
                }
              }
              end() {
                this.vertexBuffer.unlock();
              }
              writeData(y, p, _) {
                const m = this.element[y];
                if (m) {
                  _ > this.vertexBuffer.numVertices &&
                    (_ = this.vertexBuffer.numVertices);
                  const E = m.numComponents;
                  if (this.vertexBuffer.getFormat().interleaved) {
                    let v = 0;
                    for (let P = 0; P < _; P++)
                      m.setFromArray(v, p, P * E), (v += m.stride);
                  } else if (p.length > _ * E) {
                    const v = _ * E;
                    if (ArrayBuffer.isView(p))
                      (p = p.subarray(0, v)), m.array.set(p);
                    else for (let P = 0; P < v; P++) m.array[P] = p[P];
                  } else m.array.set(p);
                }
              }
              readData(y, p) {
                const _ = this.element[y];
                let m = 0;
                if (_) {
                  m = this.vertexBuffer.numVertices;
                  let E;
                  const v = _.numComponents;
                  if (this.vertexBuffer.getFormat().interleaved) {
                    Array.isArray(p) && (p.length = 0), (_.index = 0);
                    let P = 0;
                    for (E = 0; E < m; E++)
                      _.getToArray(P, p, E * v), (P += _.stride);
                  } else if (ArrayBuffer.isView(p)) p.set(_.array);
                  else {
                    p.length = 0;
                    const P = m * v;
                    for (E = 0; E < P; E++) p[E] = _.array[E];
                  }
                }
                return m;
              }
            }
          },
          9207: (Se, W, a) => {
            "use strict";
            a.d(W, { S: () => ce });
            var x = {};
            function T(ie) {
              window.console &&
                window.console.error &&
                window.console.error(ie);
            }
            function g(ie) {
              window.console && window.console.log && window.console.log(ie);
            }
            function c(ie, b) {
              (x[ie] = !0), b !== void 0 && T(b);
            }
            function d(ie) {
              var b = ie.getError;
              ie.getError = function () {
                var M;
                do (M = b.apply(ie)), M != ie.NO_ERROR && (x[M] = !0);
                while (M != ie.NO_ERROR);
                for (var M in x) if (x[M]) return delete x[M], parseInt(M);
                return ie.NO_ERROR;
              };
            }
            var h = function ie(b) {
              var M = b.gl;
              (this.ext = b),
                (this.isAlive = !0),
                (this.hasBeenBound = !1),
                (this.elementArrayBuffer = null),
                (this.attribs = new Array(b.maxVertexAttribs));
              for (var F = 0; F < this.attribs.length; F++) {
                var z = new ie.VertexAttrib(M);
                this.attribs[F] = z;
              }
              this.maxAttrib = 0;
            };
            (h.VertexAttrib = function (b) {
              (this.enabled = !1),
                (this.buffer = null),
                (this.size = 4),
                (this.type = b.FLOAT),
                (this.normalized = !1),
                (this.stride = 16),
                (this.offset = 0),
                (this.cached = ""),
                this.recache();
            }),
              (h.VertexAttrib.prototype.recache = function () {
                this.cached = [
                  this.size,
                  this.type,
                  this.normalized,
                  this.stride,
                  this.offset,
                ].join(":");
              });
            var f = function (b) {
              var M = this;
              (this.gl = b), d(b);
              var F = (this.original = {
                getParameter: b.getParameter,
                enableVertexAttribArray: b.enableVertexAttribArray,
                disableVertexAttribArray: b.disableVertexAttribArray,
                bindBuffer: b.bindBuffer,
                getVertexAttrib: b.getVertexAttrib,
                vertexAttribPointer: b.vertexAttribPointer,
              });
              (b.getParameter = function (oe) {
                return oe == M.VERTEX_ARRAY_BINDING_OES
                  ? M.currentVertexArrayObject == M.defaultVertexArrayObject
                    ? null
                    : M.currentVertexArrayObject
                  : F.getParameter.apply(this, arguments);
              }),
                (b.enableVertexAttribArray = function (oe) {
                  var de = M.currentVertexArrayObject;
                  de.maxAttrib = Math.max(de.maxAttrib, oe);
                  var ge = de.attribs[oe];
                  return (
                    (ge.enabled = !0),
                    F.enableVertexAttribArray.apply(this, arguments)
                  );
                }),
                (b.disableVertexAttribArray = function (oe) {
                  var de = M.currentVertexArrayObject;
                  de.maxAttrib = Math.max(de.maxAttrib, oe);
                  var ge = de.attribs[oe];
                  return (
                    (ge.enabled = !1),
                    F.disableVertexAttribArray.apply(this, arguments)
                  );
                }),
                (b.bindBuffer = function (oe, de) {
                  switch (oe) {
                    case b.ARRAY_BUFFER:
                      M.currentArrayBuffer = de;
                      break;
                    case b.ELEMENT_ARRAY_BUFFER:
                      M.currentVertexArrayObject.elementArrayBuffer = de;
                      break;
                  }
                  return F.bindBuffer.apply(this, arguments);
                }),
                (b.getVertexAttrib = function (oe, de) {
                  var ge = M.currentVertexArrayObject,
                    Re = ge.attribs[oe];
                  switch (de) {
                    case b.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:
                      return Re.buffer;
                    case b.VERTEX_ATTRIB_ARRAY_ENABLED:
                      return Re.enabled;
                    case b.VERTEX_ATTRIB_ARRAY_SIZE:
                      return Re.size;
                    case b.VERTEX_ATTRIB_ARRAY_STRIDE:
                      return Re.stride;
                    case b.VERTEX_ATTRIB_ARRAY_TYPE:
                      return Re.type;
                    case b.VERTEX_ATTRIB_ARRAY_NORMALIZED:
                      return Re.normalized;
                    default:
                      return F.getVertexAttrib.apply(this, arguments);
                  }
                }),
                (b.vertexAttribPointer = function (oe, de, ge, Re, Te, Ne) {
                  var Le = M.currentVertexArrayObject;
                  Le.maxAttrib = Math.max(Le.maxAttrib, oe);
                  var ke = Le.attribs[oe];
                  return (
                    (ke.buffer = M.currentArrayBuffer),
                    (ke.size = de),
                    (ke.type = ge),
                    (ke.normalized = Re),
                    (ke.stride = Te),
                    (ke.offset = Ne),
                    ke.recache(),
                    F.vertexAttribPointer.apply(this, arguments)
                  );
                }),
                b.instrumentExtension &&
                  b.instrumentExtension(this, "OES_vertex_array_object"),
                b.canvas.addEventListener(
                  "webglcontextrestored",
                  function () {
                    g(
                      "OESVertexArrayObject emulation library context restored"
                    ),
                      M.reset_();
                  },
                  !0
                ),
                this.reset_();
            };
            (f.prototype.VERTEX_ARRAY_BINDING_OES = 34229),
              (f.prototype.reset_ = function () {
                var b = this.vertexArrayObjects !== void 0;
                if (b)
                  for (var M = 0; M < this.vertexArrayObjects.length; ++M)
                    this.vertexArrayObjects.isAlive = !1;
                var F = this.gl;
                (this.maxVertexAttribs = F.getParameter(F.MAX_VERTEX_ATTRIBS)),
                  (this.defaultVertexArrayObject = new h(this)),
                  (this.currentVertexArrayObject = null),
                  (this.currentArrayBuffer = null),
                  (this.vertexArrayObjects = [this.defaultVertexArrayObject]),
                  this.bindVertexArrayOES(null);
              }),
              (f.prototype.createVertexArrayOES = function () {
                var b = new h(this);
                return this.vertexArrayObjects.push(b), b;
              }),
              (f.prototype.deleteVertexArrayOES = function (b) {
                (b.isAlive = !1),
                  this.vertexArrayObjects.splice(
                    this.vertexArrayObjects.indexOf(b),
                    1
                  ),
                  this.currentVertexArrayObject == b &&
                    this.bindVertexArrayOES(null);
              }),
              (f.prototype.isVertexArrayOES = function (b) {
                return !!(
                  b &&
                  b instanceof h &&
                  b.hasBeenBound &&
                  b.ext == this
                );
              }),
              (f.prototype.bindVertexArrayOES = function (b) {
                var M = this.gl;
                if (b && !b.isAlive) {
                  c(
                    M.INVALID_OPERATION,
                    "bindVertexArrayOES: attempt to bind deleted arrayObject"
                  );
                  return;
                }
                var F = this.original,
                  z = this.currentVertexArrayObject;
                (this.currentVertexArrayObject =
                  b || this.defaultVertexArrayObject),
                  (this.currentVertexArrayObject.hasBeenBound = !0);
                var oe = this.currentVertexArrayObject;
                if (z != oe) {
                  (!z || oe.elementArrayBuffer != z.elementArrayBuffer) &&
                    F.bindBuffer.call(
                      M,
                      M.ELEMENT_ARRAY_BUFFER,
                      oe.elementArrayBuffer
                    );
                  for (
                    var de = this.currentArrayBuffer,
                      ge = Math.max(z ? z.maxAttrib : 0, oe.maxAttrib),
                      Re = 0;
                    Re <= ge;
                    Re++
                  ) {
                    var Te = oe.attribs[Re],
                      Ne = z ? z.attribs[Re] : null;
                    if (
                      ((!z || Te.enabled != Ne.enabled) &&
                        (Te.enabled
                          ? F.enableVertexAttribArray.call(M, Re)
                          : F.disableVertexAttribArray.call(M, Re)),
                      Te.enabled)
                    ) {
                      var Le = !1;
                      (!z || Te.buffer != Ne.buffer) &&
                        (de != Te.buffer &&
                          (F.bindBuffer.call(M, M.ARRAY_BUFFER, Te.buffer),
                          (de = Te.buffer)),
                        (Le = !0)),
                        (Le || Te.cached != Ne.cached) &&
                          F.vertexAttribPointer.call(
                            M,
                            Re,
                            Te.size,
                            Te.type,
                            Te.normalized,
                            Te.stride,
                            Te.offset
                          );
                    }
                  }
                  this.currentArrayBuffer != de &&
                    F.bindBuffer.call(
                      M,
                      M.ARRAY_BUFFER,
                      this.currentArrayBuffer
                    );
                }
              });
            const s = function (b) {
              if (b.getSupportedExtensions) {
                var M = b.getSupportedExtensions();
                if (M.indexOf("OES_vertex_array_object") != -1) return;
              } else if (b.getExtension) {
                var F = b.getExtension("OES_vertex_array_object");
                if (F) return;
              }
              if (b.getSupportedExtensions) {
                var z = b.getSupportedExtensions;
                b.getSupportedExtensions = function () {
                  var ge = z.call(this) || [];
                  return ge.push("OES_vertex_array_object"), ge;
                };
              }
              var oe = b.getExtension;
              b.getExtension = function (ge) {
                return ge == "OES_vertex_array_object"
                  ? (b.__OESVertexArrayObject ||
                      (b.__OESVertexArrayObject = new f(b)),
                    b.__OESVertexArrayObject)
                  : oe
                  ? oe.call(this, ge)
                  : null;
              };
            };
            var l = a(4585),
              n = a(4444),
              o = a(1367),
              i = a(7921),
              e = a(4738),
              t = a(3412),
              r = a(8869);
            class u {
              constructor() {
                this.bufferId = null;
              }
              destroy(b) {
                this.bufferId &&
                  (b.gl.deleteBuffer(this.bufferId), (this.bufferId = null));
              }
              get initialized() {
                return !!this.bufferId;
              }
              loseContext() {
                this.bufferId = null;
              }
              unlock(b, M, F, z) {
                const oe = b.gl;
                this.bufferId || (this.bufferId = oe.createBuffer());
                let de;
                switch (M) {
                  case i.dxy:
                    de = oe.STATIC_DRAW;
                    break;
                  case i.AHc:
                    de = oe.DYNAMIC_DRAW;
                    break;
                  case i.oWk:
                    de = oe.STREAM_DRAW;
                    break;
                  case i.Tfk:
                    b.webgl2 ? (de = oe.DYNAMIC_COPY) : (de = oe.STATIC_DRAW);
                    break;
                }
                oe.bindBuffer(F, this.bufferId), oe.bufferData(F, z, de);
              }
            }
            class y extends u {
              constructor(...b) {
                super(...b), (this.vao = null);
              }
              destroy(b) {
                super.destroy(b),
                  (b.boundVao = null),
                  b.gl.bindVertexArray(null);
              }
              loseContext() {
                super.loseContext(), (this.vao = null);
              }
              unlock(b) {
                const M = b.device;
                super.unlock(M, b.usage, M.gl.ARRAY_BUFFER, b.storage);
              }
            }
            class p extends u {
              constructor(b) {
                super();
                const M = b.device.gl,
                  F = b.format;
                F === i.fUD
                  ? (this.glFormat = M.UNSIGNED_BYTE)
                  : F === i.q0F
                  ? (this.glFormat = M.UNSIGNED_SHORT)
                  : F === i.qCh && (this.glFormat = M.UNSIGNED_INT);
              }
              unlock(b) {
                const M = b.device;
                super.unlock(M, b.usage, M.gl.ELEMENT_ARRAY_BUFFER, b.storage);
              }
            }
            var _ = a(8483),
              m = a(7338);
            const E = [
              "gl_VertexID",
              "gl_InstanceID",
              "gl_DrawID",
              "gl_BaseVertex",
              "gl_BaseInstance",
            ];
            class v {
              constructor() {
                this.map = new Map();
              }
              destroy(b) {
                this.map.forEach((M) => {
                  b.gl.deleteShader(M);
                });
              }
              loseContext(b) {
                this.map.clear();
              }
            }
            class P {
              constructor() {
                this.shaders = [];
              }
              loseContext(b) {
                this.shaders = [];
              }
            }
            const I = new m.c(),
              A = new m.c(),
              B = new m.c();
            class C {
              constructor(b) {
                (this.compileDuration = 0),
                  this.init(),
                  this.compile(b.device, b),
                  C.getBatchShaders(b.device).push(b),
                  b.device.shaders.push(b);
              }
              destroy(b) {
                this.glProgram &&
                  (b.device.gl.deleteProgram(this.glProgram),
                  (this.glProgram = null));
              }
              init() {
                (this.uniforms = []),
                  (this.samplers = []),
                  (this.attributes = []),
                  (this.glProgram = null),
                  (this.glVertexShader = null),
                  (this.glFragmentShader = null);
              }
              static getBatchShaders(b) {
                return B.get(b, () => new P()).shaders;
              }
              static endShaderBatch(b) {
                const M = C.getBatchShaders(b);
                M.forEach((F) => F.impl.link(b, F)), (M.length = 0);
              }
              loseContext() {
                this.init();
              }
              restoreContext(b, M) {
                this.compile(b, M);
              }
              compile(b, M) {
                const F = M.definition;
                (this.glVertexShader = this._compileShaderSource(
                  b,
                  F.vshader,
                  !0
                )),
                  (this.glFragmentShader = this._compileShaderSource(
                    b,
                    F.fshader,
                    !1
                  ));
              }
              link(b, M) {
                if (this.glProgram) return;
                const F = b.gl,
                  z = F.createProgram();
                (this.glProgram = z),
                  F.attachShader(z, this.glVertexShader),
                  F.attachShader(z, this.glFragmentShader);
                const oe = M.definition,
                  de = oe.attributes;
                if (b.webgl2 && oe.useTransformFeedback) {
                  const ge = [];
                  for (const Re in de)
                    de.hasOwnProperty(Re) && ge.push("out_" + Re);
                  F.transformFeedbackVaryings(z, ge, F.INTERLEAVED_ATTRIBS);
                }
                for (const ge in de)
                  if (de.hasOwnProperty(ge)) {
                    const Re = de[ge],
                      Te = i.Lb6[Re];
                    F.bindAttribLocation(z, Te, ge);
                  }
                F.linkProgram(z);
              }
              _compileShaderSource(b, M, F) {
                const z = b.gl,
                  de = (F ? I : A).get(b, () => new v());
                let ge = de.map.get(M);
                return (
                  ge ||
                    ((ge = z.createShader(
                      F ? z.VERTEX_SHADER : z.FRAGMENT_SHADER
                    )),
                    z.shaderSource(ge, M),
                    z.compileShader(ge),
                    de.map.set(M, ge)),
                  ge
                );
              }
              finalize(b, M) {
                this.glProgram || this.link(b, M);
                const F = b.gl,
                  z = this.glProgram,
                  oe = M.definition;
                if (!F.getProgramParameter(z, F.LINK_STATUS)) {
                  if (
                    !this._isCompiled(
                      b,
                      M,
                      this.glVertexShader,
                      oe.vshader,
                      "vertex"
                    ) ||
                    !this._isCompiled(
                      b,
                      M,
                      this.glFragmentShader,
                      oe.fshader,
                      "fragment"
                    )
                  )
                    return !1;
                  const Ne =
                    "Failed to link shader program. Error: " +
                    F.getProgramInfoLog(z);
                  return console.error(Ne), !1;
                }
                let ge = 0;
                const Re = F.getProgramParameter(z, F.ACTIVE_ATTRIBUTES);
                for (; ge < Re; ) {
                  const Ne = F.getActiveAttrib(z, ge++),
                    Le = F.getAttribLocation(z, Ne.name);
                  if (E.indexOf(Ne.name) !== -1) continue;
                  oe.attributes[Ne.name] === void 0 &&
                    (console.error(
                      `Vertex shader attribute "${Ne.name}" is not mapped to a semantic in shader definition, shader [${M.label}]`,
                      M
                    ),
                    (M.failed = !0));
                  const ke = new _.M(
                    b,
                    oe.attributes[Ne.name],
                    b.pcUniformType[Ne.type],
                    Le
                  );
                  this.attributes.push(ke);
                }
                ge = 0;
                const Te = F.getProgramParameter(z, F.ACTIVE_UNIFORMS);
                for (; ge < Te; ) {
                  const Ne = F.getActiveUniform(z, ge++),
                    Le = F.getUniformLocation(z, Ne.name),
                    ke = new _.M(b, Ne.name, b.pcUniformType[Ne.type], Le);
                  Ne.type === F.SAMPLER_2D ||
                  Ne.type === F.SAMPLER_CUBE ||
                  (b.webgl2 &&
                    (Ne.type === F.SAMPLER_2D_SHADOW ||
                      Ne.type === F.SAMPLER_CUBE_SHADOW ||
                      Ne.type === F.SAMPLER_3D))
                    ? this.samplers.push(ke)
                    : this.uniforms.push(ke);
                }
                return (M.ready = !0), !0;
              }
              _isCompiled(b, M, F, z, oe) {
                const de = b.gl;
                if (!de.getShaderParameter(F, de.COMPILE_STATUS)) {
                  const ge = de.getShaderInfoLog(F),
                    [Re, Te] = this._processError(z, ge),
                    Ne = `Failed to compile ${oe} shader:

${ge}
${Re}`;
                  return console.error(Ne), !1;
                }
                return !0;
              }
              _processError(b, M) {
                const F = {};
                let z = "";
                if (b) {
                  const oe = b.split(`
`);
                  let de = 0,
                    ge = oe.length;
                  if (M && M.startsWith("ERROR:")) {
                    const Re = M.match(/^ERROR:\s([0-9]+):([0-9]+):\s*(.+)/);
                    Re &&
                      ((F.message = Re[3]),
                      (F.line = parseInt(Re[2], 10)),
                      (de = Math.max(0, F.line - 6)),
                      (ge = Math.min(oe.length, F.line + 5)));
                  }
                  for (let Re = de; Re < ge; Re++)
                    z +=
                      Re +
                      1 +
                      ":	" +
                      oe[Re] +
                      `
`;
                  F.source = b;
                }
                return [z, F];
              }
            }
            function w(ie, b) {
              const M = ie.width,
                F = ie.height;
              if (M > b || F > b) {
                const z = b / Math.max(M, F),
                  oe = Math.floor(M * z),
                  de = Math.floor(F * z),
                  ge = document.createElement("canvas");
                return (
                  (ge.width = oe),
                  (ge.height = de),
                  ge.getContext("2d").drawImage(ie, 0, 0, M, F, 0, 0, oe, de),
                  ge
                );
              }
              return ie;
            }
            class k {
              constructor() {
                (this._glTexture = null),
                  (this._glTarget = void 0),
                  (this._glFormat = void 0),
                  (this._glInternalFormat = void 0),
                  (this._glPixelType = void 0),
                  (this.dirtyParameterFlags = 0);
              }
              destroy(b) {
                if (this._glTexture) {
                  for (let M = 0; M < b.textureUnits.length; M++) {
                    const F = b.textureUnits[M];
                    for (let z = 0; z < F.length; z++)
                      F[z] === this._glTexture && (F[z] = null);
                  }
                  b.gl.deleteTexture(this._glTexture), (this._glTexture = null);
                }
              }
              loseContext() {
                this._glTexture = null;
              }
              propertyChanged(b) {
                this.dirtyParameterFlags |= b;
              }
              initialize(b, M) {
                const F = b.gl;
                switch (
                  ((this._glTexture = F.createTexture()),
                  (this._glTarget = M._cubemap
                    ? F.TEXTURE_CUBE_MAP
                    : M._volume
                    ? F.TEXTURE_3D
                    : F.TEXTURE_2D),
                  M._format)
                ) {
                  case i.fGB:
                    (this._glFormat = F.ALPHA),
                      (this._glInternalFormat = F.ALPHA),
                      (this._glPixelType = F.UNSIGNED_BYTE);
                    break;
                  case i.peA:
                    (this._glFormat = F.LUMINANCE),
                      (this._glInternalFormat = F.LUMINANCE),
                      (this._glPixelType = F.UNSIGNED_BYTE);
                    break;
                  case i.$Op:
                    (this._glFormat = F.LUMINANCE_ALPHA),
                      (this._glInternalFormat = F.LUMINANCE_ALPHA),
                      (this._glPixelType = F.UNSIGNED_BYTE);
                    break;
                  case i.Rbg:
                    (this._glFormat = F.RGB),
                      (this._glInternalFormat = F.RGB),
                      (this._glPixelType = F.UNSIGNED_SHORT_5_6_5);
                    break;
                  case i.BmF:
                    (this._glFormat = F.RGBA),
                      (this._glInternalFormat = F.RGBA),
                      (this._glPixelType = F.UNSIGNED_SHORT_5_5_5_1);
                    break;
                  case i.UUS:
                    (this._glFormat = F.RGBA),
                      (this._glInternalFormat = F.RGBA),
                      (this._glPixelType = F.UNSIGNED_SHORT_4_4_4_4);
                    break;
                  case i.Hsr:
                    (this._glFormat = F.RGB),
                      (this._glInternalFormat = b.webgl2 ? F.RGB8 : F.RGB),
                      (this._glPixelType = F.UNSIGNED_BYTE);
                    break;
                  case i.jKI:
                    (this._glFormat = F.RGBA),
                      (this._glInternalFormat = b.webgl2 ? F.RGBA8 : F.RGBA),
                      (this._glPixelType = F.UNSIGNED_BYTE);
                    break;
                  case i.TES:
                    (this._glFormat = F.RGB),
                      (this._glInternalFormat =
                        b.extCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT);
                    break;
                  case i.UPc:
                    (this._glFormat = F.RGBA),
                      (this._glInternalFormat =
                        b.extCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT);
                    break;
                  case i.ZtC:
                    (this._glFormat = F.RGBA),
                      (this._glInternalFormat =
                        b.extCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT);
                    break;
                  case i.IAT:
                    (this._glFormat = F.RGB),
                      (this._glInternalFormat =
                        b.extCompressedTextureETC1.COMPRESSED_RGB_ETC1_WEBGL);
                    break;
                  case i.eV7:
                    (this._glFormat = F.RGB),
                      (this._glInternalFormat =
                        b.extCompressedTexturePVRTC.COMPRESSED_RGB_PVRTC_2BPPV1_IMG);
                    break;
                  case i.g0o:
                    (this._glFormat = F.RGBA),
                      (this._glInternalFormat =
                        b.extCompressedTexturePVRTC.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG);
                    break;
                  case i.NeV:
                    (this._glFormat = F.RGB),
                      (this._glInternalFormat =
                        b.extCompressedTexturePVRTC.COMPRESSED_RGB_PVRTC_4BPPV1_IMG);
                    break;
                  case i._t$:
                    (this._glFormat = F.RGBA),
                      (this._glInternalFormat =
                        b.extCompressedTexturePVRTC.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG);
                    break;
                  case i.krP:
                    (this._glFormat = F.RGB),
                      (this._glInternalFormat =
                        b.extCompressedTextureETC.COMPRESSED_RGB8_ETC2);
                    break;
                  case i.MwV:
                    (this._glFormat = F.RGBA),
                      (this._glInternalFormat =
                        b.extCompressedTextureETC.COMPRESSED_RGBA8_ETC2_EAC);
                    break;
                  case i.JOC:
                    (this._glFormat = F.RGBA),
                      (this._glInternalFormat =
                        b.extCompressedTextureASTC.COMPRESSED_RGBA_ASTC_4x4_KHR);
                    break;
                  case i.$4V:
                    (this._glFormat = F.RGB),
                      (this._glInternalFormat =
                        b.extCompressedTextureATC.COMPRESSED_RGB_ATC_WEBGL);
                    break;
                  case i.iJ1:
                    (this._glFormat = F.RGBA),
                      (this._glInternalFormat =
                        b.extCompressedTextureATC.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL);
                    break;
                  case i.q_o:
                    (this._glFormat = F.RGB),
                      b.webgl2
                        ? ((this._glInternalFormat = F.RGB16F),
                          (this._glPixelType = F.HALF_FLOAT))
                        : ((this._glInternalFormat = F.RGB),
                          (this._glPixelType =
                            b.extTextureHalfFloat.HALF_FLOAT_OES));
                    break;
                  case i.a7f:
                    (this._glFormat = F.RGBA),
                      b.webgl2
                        ? ((this._glInternalFormat = F.RGBA16F),
                          (this._glPixelType = F.HALF_FLOAT))
                        : ((this._glInternalFormat = F.RGBA),
                          (this._glPixelType =
                            b.extTextureHalfFloat.HALF_FLOAT_OES));
                    break;
                  case i.lN5:
                    (this._glFormat = F.RGB),
                      b.webgl2
                        ? (this._glInternalFormat = F.RGB32F)
                        : (this._glInternalFormat = F.RGB),
                      (this._glPixelType = F.FLOAT);
                    break;
                  case i.uC3:
                    (this._glFormat = F.RGBA),
                      b.webgl2
                        ? (this._glInternalFormat = F.RGBA32F)
                        : (this._glInternalFormat = F.RGBA),
                      (this._glPixelType = F.FLOAT);
                    break;
                  case i.DYM:
                    (this._glFormat = F.RED),
                      (this._glInternalFormat = F.R32F),
                      (this._glPixelType = F.FLOAT);
                    break;
                  case i.EFh:
                    b.webgl2
                      ? ((this._glFormat = F.DEPTH_COMPONENT),
                        (this._glInternalFormat = F.DEPTH_COMPONENT32F),
                        (this._glPixelType = F.FLOAT))
                      : ((this._glFormat = F.DEPTH_COMPONENT),
                        (this._glInternalFormat = F.DEPTH_COMPONENT),
                        (this._glPixelType = F.UNSIGNED_SHORT));
                    break;
                  case i.sUt:
                    (this._glFormat = F.DEPTH_STENCIL),
                      b.webgl2
                        ? ((this._glInternalFormat = F.DEPTH24_STENCIL8),
                          (this._glPixelType = F.UNSIGNED_INT_24_8))
                        : ((this._glInternalFormat = F.DEPTH_STENCIL),
                          (this._glPixelType =
                            b.extDepthTexture.UNSIGNED_INT_24_8_WEBGL));
                    break;
                  case i.kYl:
                    (this._glFormat = F.RGB),
                      (this._glInternalFormat = F.R11F_G11F_B10F),
                      (this._glPixelType = F.UNSIGNED_INT_10F_11F_11F_REV);
                    break;
                  case i.wNl:
                    (this._glFormat = F.RGB),
                      (this._glInternalFormat = F.SRGB8),
                      (this._glPixelType = F.UNSIGNED_BYTE);
                    break;
                  case i.X8g:
                    (this._glFormat = F.RGBA),
                      (this._glInternalFormat = F.SRGB8_ALPHA8),
                      (this._glPixelType = F.UNSIGNED_BYTE);
                    break;
                }
              }
              upload(b, M) {
                const F = b.gl;
                if (
                  !M._needsUpload &&
                  ((M._needsMipmapsUpload && M._mipmapsUploaded) || !M.pot)
                )
                  return;
                let z = 0,
                  oe,
                  de;
                const ge = M.requiredMipLevels;
                for (; M._levels[z] || z === 0; ) {
                  if (!M._needsUpload && z === 0) {
                    z++;
                    continue;
                  } else if (z && (!M._needsMipmapsUpload || !M._mipmaps))
                    break;
                  if (
                    ((oe = M._levels[z]),
                    z === 1 &&
                      !M._compressed &&
                      M._levels.length < ge &&
                      (F.generateMipmap(this._glTarget),
                      (M._mipmapsUploaded = !0)),
                    M._cubemap)
                  ) {
                    let Re;
                    if (b._isBrowserInterface(oe[0]))
                      for (Re = 0; Re < 6; Re++) {
                        if (!M._levelsUpdated[0][Re]) continue;
                        let Te = oe[Re];
                        b._isImageBrowserInterface(Te) &&
                          (Te.width > b.maxCubeMapSize ||
                            Te.height > b.maxCubeMapSize) &&
                          ((Te = w(Te, b.maxCubeMapSize)),
                          z === 0 &&
                            ((M._width = Te.width), (M._height = Te.height))),
                          b.setUnpackFlipY(!1),
                          b.setUnpackPremultiplyAlpha(M._premultiplyAlpha),
                          F.texImage2D(
                            F.TEXTURE_CUBE_MAP_POSITIVE_X + Re,
                            z,
                            this._glInternalFormat,
                            this._glFormat,
                            this._glPixelType,
                            Te
                          );
                      }
                    else
                      for (de = 1 / Math.pow(2, z), Re = 0; Re < 6; Re++) {
                        if (!M._levelsUpdated[0][Re]) continue;
                        const Te = oe[Re];
                        M._compressed
                          ? F.compressedTexImage2D(
                              F.TEXTURE_CUBE_MAP_POSITIVE_X + Re,
                              z,
                              this._glInternalFormat,
                              Math.max(M._width * de, 1),
                              Math.max(M._height * de, 1),
                              0,
                              Te
                            )
                          : (b.setUnpackFlipY(!1),
                            b.setUnpackPremultiplyAlpha(M._premultiplyAlpha),
                            F.texImage2D(
                              F.TEXTURE_CUBE_MAP_POSITIVE_X + Re,
                              z,
                              this._glInternalFormat,
                              Math.max(M._width * de, 1),
                              Math.max(M._height * de, 1),
                              0,
                              this._glFormat,
                              this._glPixelType,
                              Te
                            ));
                      }
                  } else
                    M._volume
                      ? ((de = 1 / Math.pow(2, z)),
                        M._compressed
                          ? F.compressedTexImage3D(
                              F.TEXTURE_3D,
                              z,
                              this._glInternalFormat,
                              Math.max(M._width * de, 1),
                              Math.max(M._height * de, 1),
                              Math.max(M._depth * de, 1),
                              0,
                              oe
                            )
                          : (b.setUnpackFlipY(!1),
                            b.setUnpackPremultiplyAlpha(M._premultiplyAlpha),
                            F.texImage3D(
                              F.TEXTURE_3D,
                              z,
                              this._glInternalFormat,
                              Math.max(M._width * de, 1),
                              Math.max(M._height * de, 1),
                              Math.max(M._depth * de, 1),
                              0,
                              this._glFormat,
                              this._glPixelType,
                              oe
                            )))
                      : (b._isBrowserInterface(oe)
                          ? (b._isImageBrowserInterface(oe) &&
                              (oe.width > b.maxTextureSize ||
                                oe.height > b.maxTextureSize) &&
                              ((oe = w(oe, b.maxTextureSize)),
                              z === 0 &&
                                ((M._width = oe.width),
                                (M._height = oe.height))),
                            b.setUnpackFlipY(M._flipY),
                            b.setUnpackPremultiplyAlpha(M._premultiplyAlpha),
                            F.texImage2D(
                              F.TEXTURE_2D,
                              z,
                              this._glInternalFormat,
                              this._glFormat,
                              this._glPixelType,
                              oe
                            ))
                          : ((de = 1 / Math.pow(2, z)),
                            M._compressed
                              ? F.compressedTexImage2D(
                                  F.TEXTURE_2D,
                                  z,
                                  this._glInternalFormat,
                                  Math.max(Math.floor(M._width * de), 1),
                                  Math.max(Math.floor(M._height * de), 1),
                                  0,
                                  oe
                                )
                              : (b.setUnpackFlipY(!1),
                                b.setUnpackPremultiplyAlpha(
                                  M._premultiplyAlpha
                                ),
                                F.texImage2D(
                                  F.TEXTURE_2D,
                                  z,
                                  this._glInternalFormat,
                                  Math.max(M._width * de, 1),
                                  Math.max(M._height * de, 1),
                                  0,
                                  this._glFormat,
                                  this._glPixelType,
                                  oe
                                ))),
                        z === 0
                          ? (M._mipmapsUploaded = !1)
                          : (M._mipmapsUploaded = !0));
                  z++;
                }
                if (M._needsUpload)
                  if (M._cubemap)
                    for (let Re = 0; Re < 6; Re++) M._levelsUpdated[0][Re] = !1;
                  else M._levelsUpdated[0] = !1;
                !M._compressed &&
                  M._mipmaps &&
                  M._needsMipmapsUpload &&
                  (M.pot || b.webgl2) &&
                  M._levels.length === 1 &&
                  (F.generateMipmap(this._glTarget), (M._mipmapsUploaded = !0)),
                  M._gpuSize && M.adjustVramSizeTracking(b._vram, -M._gpuSize),
                  (M._gpuSize = M.gpuSize),
                  M.adjustVramSizeTracking(b._vram, M._gpuSize);
              }
            }
            class K {
              constructor(b, M) {
                (this.msaaFB = void 0),
                  (this.resolveFB = void 0),
                  (this.msaaFB = b),
                  (this.resolveFB = M);
              }
              destroy(b) {
                this.msaaFB &&
                  (b.deleteRenderbuffer(this.msaaFB), (this.msaaFB = null)),
                  this.resolveFB &&
                    (b.deleteRenderbuffer(this.resolveFB),
                    (this.resolveFB = null));
              }
            }
            class te {
              constructor() {
                (this._glFrameBuffer = null),
                  (this._glDepthBuffer = null),
                  (this._glResolveFrameBuffer = null),
                  (this.colorMrtFramebuffers = null),
                  (this._glMsaaColorBuffers = []),
                  (this._glMsaaDepthBuffer = null);
              }
              destroy(b) {
                var M;
                const F = b.gl;
                this._glFrameBuffer &&
                  (F.deleteFramebuffer(this._glFrameBuffer),
                  (this._glFrameBuffer = null)),
                  this._glDepthBuffer &&
                    (F.deleteRenderbuffer(this._glDepthBuffer),
                    (this._glDepthBuffer = null)),
                  this._glResolveFrameBuffer &&
                    (F.deleteFramebuffer(this._glResolveFrameBuffer),
                    (this._glResolveFrameBuffer = null)),
                  this._glMsaaColorBuffers.forEach((z) => {
                    F.deleteRenderbuffer(z);
                  }),
                  (this._glMsaaColorBuffers.length = 0),
                  (M = this.colorMrtFramebuffers) == null ||
                    M.forEach((z) => {
                      z.destroy(F);
                    }),
                  (this.colorMrtFramebuffers = null),
                  this._glMsaaDepthBuffer &&
                    (F.deleteRenderbuffer(this._glMsaaDepthBuffer),
                    (this._glMsaaDepthBuffer = null));
              }
              get initialized() {
                return this._glFrameBuffer !== null;
              }
              init(b, M) {
                var F, z, oe, de;
                const ge = b.gl;
                (this._glFrameBuffer = ge.createFramebuffer()),
                  b.setFramebuffer(this._glFrameBuffer);
                const Re =
                    (F = (z = M._colorBuffers) == null ? void 0 : z.length) !=
                    null
                      ? F
                      : 0,
                  Te = b.webgl2
                    ? ge.COLOR_ATTACHMENT0
                    : (oe =
                        (de = b.extDrawBuffers) == null
                          ? void 0
                          : de.COLOR_ATTACHMENT0_WEBGL) != null
                    ? oe
                    : ge.COLOR_ATTACHMENT0,
                  Ne = [];
                for (let _e = 0; _e < Re; ++_e) {
                  const U = M.getColorBuffer(_e);
                  U &&
                    (U.impl._glTexture ||
                      ((U._width = Math.min(U.width, b.maxRenderBufferSize)),
                      (U._height = Math.min(U.height, b.maxRenderBufferSize)),
                      b.setTexture(U, 0)),
                    ge.framebufferTexture2D(
                      ge.FRAMEBUFFER,
                      Te + _e,
                      U._cubemap
                        ? ge.TEXTURE_CUBE_MAP_POSITIVE_X + M._face
                        : ge.TEXTURE_2D,
                      U.impl._glTexture,
                      0
                    ),
                    Ne.push(Te + _e));
                }
                b.drawBuffers && b.drawBuffers(Ne);
                const Le = M._depthBuffer;
                if (Le)
                  Le.impl._glTexture ||
                    ((Le._width = Math.min(Le.width, b.maxRenderBufferSize)),
                    (Le._height = Math.min(Le.height, b.maxRenderBufferSize)),
                    b.setTexture(Le, 0)),
                    M._stencil
                      ? ge.framebufferTexture2D(
                          ge.FRAMEBUFFER,
                          ge.DEPTH_STENCIL_ATTACHMENT,
                          Le._cubemap
                            ? ge.TEXTURE_CUBE_MAP_POSITIVE_X + M._face
                            : ge.TEXTURE_2D,
                          M._depthBuffer.impl._glTexture,
                          0
                        )
                      : ge.framebufferTexture2D(
                          ge.FRAMEBUFFER,
                          ge.DEPTH_ATTACHMENT,
                          Le._cubemap
                            ? ge.TEXTURE_CUBE_MAP_POSITIVE_X + M._face
                            : ge.TEXTURE_2D,
                          M._depthBuffer.impl._glTexture,
                          0
                        );
                else if (M._depth && !(M._samples > 1 && b.webgl2)) {
                  if (
                    (this._glDepthBuffer ||
                      (this._glDepthBuffer = ge.createRenderbuffer()),
                    ge.bindRenderbuffer(ge.RENDERBUFFER, this._glDepthBuffer),
                    M._stencil)
                  )
                    ge.renderbufferStorage(
                      ge.RENDERBUFFER,
                      ge.DEPTH_STENCIL,
                      M.width,
                      M.height
                    ),
                      ge.framebufferRenderbuffer(
                        ge.FRAMEBUFFER,
                        ge.DEPTH_STENCIL_ATTACHMENT,
                        ge.RENDERBUFFER,
                        this._glDepthBuffer
                      );
                  else {
                    const U = b.webgl2
                      ? ge.DEPTH_COMPONENT32F
                      : ge.DEPTH_COMPONENT16;
                    ge.renderbufferStorage(
                      ge.RENDERBUFFER,
                      U,
                      M.width,
                      M.height
                    ),
                      ge.framebufferRenderbuffer(
                        ge.FRAMEBUFFER,
                        ge.DEPTH_ATTACHMENT,
                        ge.RENDERBUFFER,
                        this._glDepthBuffer
                      );
                  }
                  ge.bindRenderbuffer(ge.RENDERBUFFER, null);
                }
                if (b.webgl2 && M._samples > 1) {
                  var ke, ht;
                  (this._glResolveFrameBuffer = this._glFrameBuffer),
                    (this._glFrameBuffer = ge.createFramebuffer()),
                    b.setFramebuffer(this._glFrameBuffer);
                  const _e =
                    (ke =
                      (ht = M._colorBuffers) == null ? void 0 : ht.length) !=
                    null
                      ? ke
                      : 0;
                  for (let U = 0; U < _e; ++U) {
                    const H = M.getColorBuffer(U);
                    if (H) {
                      const Ee = ge.createRenderbuffer();
                      this._glMsaaColorBuffers.push(Ee),
                        ge.bindRenderbuffer(ge.RENDERBUFFER, Ee),
                        ge.renderbufferStorageMultisample(
                          ge.RENDERBUFFER,
                          M._samples,
                          H.impl._glInternalFormat,
                          M.width,
                          M.height
                        ),
                        ge.framebufferRenderbuffer(
                          ge.FRAMEBUFFER,
                          ge.COLOR_ATTACHMENT0 + U,
                          ge.RENDERBUFFER,
                          Ee
                        );
                    }
                  }
                  M._depth &&
                    (this._glMsaaDepthBuffer ||
                      (this._glMsaaDepthBuffer = ge.createRenderbuffer()),
                    ge.bindRenderbuffer(
                      ge.RENDERBUFFER,
                      this._glMsaaDepthBuffer
                    ),
                    M._stencil
                      ? (ge.renderbufferStorageMultisample(
                          ge.RENDERBUFFER,
                          M._samples,
                          ge.DEPTH24_STENCIL8,
                          M.width,
                          M.height
                        ),
                        ge.framebufferRenderbuffer(
                          ge.FRAMEBUFFER,
                          ge.DEPTH_STENCIL_ATTACHMENT,
                          ge.RENDERBUFFER,
                          this._glMsaaDepthBuffer
                        ))
                      : (ge.renderbufferStorageMultisample(
                          ge.RENDERBUFFER,
                          M._samples,
                          ge.DEPTH_COMPONENT32F,
                          M.width,
                          M.height
                        ),
                        ge.framebufferRenderbuffer(
                          ge.FRAMEBUFFER,
                          ge.DEPTH_ATTACHMENT,
                          ge.RENDERBUFFER,
                          this._glMsaaDepthBuffer
                        ))),
                    _e > 1 &&
                      (this._createMsaaMrtFramebuffers(b, M, _e),
                      b.setFramebuffer(this._glFrameBuffer),
                      b.drawBuffers(Ne));
                }
              }
              _createMsaaMrtFramebuffers(b, M, F) {
                const z = b.gl;
                this.colorMrtFramebuffers = [];
                for (let oe = 0; oe < F; ++oe) {
                  const de = M.getColorBuffer(oe),
                    ge = z.createFramebuffer();
                  b.setFramebuffer(ge);
                  const Re = this._glMsaaColorBuffers[oe];
                  z.bindRenderbuffer(z.RENDERBUFFER, Re),
                    z.renderbufferStorageMultisample(
                      z.RENDERBUFFER,
                      M._samples,
                      de.impl._glInternalFormat,
                      M.width,
                      M.height
                    ),
                    z.framebufferRenderbuffer(
                      z.FRAMEBUFFER,
                      z.COLOR_ATTACHMENT0,
                      z.RENDERBUFFER,
                      Re
                    ),
                    b.drawBuffers([z.COLOR_ATTACHMENT0]);
                  const Te = z.createFramebuffer();
                  b.setFramebuffer(Te),
                    z.framebufferTexture2D(
                      z.FRAMEBUFFER,
                      z.COLOR_ATTACHMENT0,
                      de._cubemap
                        ? z.TEXTURE_CUBE_MAP_POSITIVE_X + M._face
                        : z.TEXTURE_2D,
                      de.impl._glTexture,
                      0
                    ),
                    (this.colorMrtFramebuffers[oe] = new K(ge, Te));
                }
              }
              _checkFbo(b, M, F = "") {
                const z = b.gl;
                switch (z.checkFramebufferStatus(z.FRAMEBUFFER)) {
                  case z.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                    break;
                  case z.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                    break;
                  case z.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                    break;
                  case z.FRAMEBUFFER_UNSUPPORTED:
                    break;
                }
              }
              loseContext() {
                (this._glFrameBuffer = null),
                  (this._glDepthBuffer = null),
                  (this._glResolveFrameBuffer = null),
                  (this._glMsaaColorBuffers.length = 0),
                  (this._glMsaaDepthBuffer = null),
                  (this.colorMrtFramebuffers = null);
              }
              internalResolve(b, M, F, z, oe) {
                const de = b.gl;
                de.bindFramebuffer(de.READ_FRAMEBUFFER, M),
                  de.bindFramebuffer(de.DRAW_FRAMEBUFFER, F),
                  de.blitFramebuffer(
                    0,
                    0,
                    z.width,
                    z.height,
                    0,
                    0,
                    z.width,
                    z.height,
                    oe,
                    de.NEAREST
                  );
              }
              resolve(b, M, F, z) {
                if (b.webgl2) {
                  const oe = b.gl;
                  if (this.colorMrtFramebuffers) {
                    if (F)
                      for (
                        let de = 0;
                        de < this.colorMrtFramebuffers.length;
                        de++
                      ) {
                        const ge = this.colorMrtFramebuffers[de];
                        this.internalResolve(
                          b,
                          ge.msaaFB,
                          ge.resolveFB,
                          M,
                          oe.COLOR_BUFFER_BIT
                        );
                      }
                    z &&
                      this.internalResolve(
                        b,
                        this._glFrameBuffer,
                        this._glResolveFrameBuffer,
                        M,
                        oe.DEPTH_BUFFER_BIT
                      );
                  } else
                    this.internalResolve(
                      b,
                      this._glFrameBuffer,
                      this._glResolveFrameBuffer,
                      M,
                      (F ? oe.COLOR_BUFFER_BIT : 0) |
                        (z ? oe.DEPTH_BUFFER_BIT : 0)
                    );
                  oe.bindFramebuffer(oe.FRAMEBUFFER, this._glFrameBuffer);
                }
              }
            }
            var X = a(3862),
              $ = a(6977),
              ne = a(8277),
              Y = a(7013),
              Z = a(30),
              ye = a(3998);
            class pe {
              constructor() {
                (this.renderVersion = void 0), (this.queries = []);
              }
              destroy(b) {
                this.queries.forEach((M) => b.deleteQuery(M)),
                  (this.queries = null);
              }
            }
            class O extends ye.l {
              constructor(b) {
                super(),
                  (this.device = void 0),
                  (this.freeQueries = []),
                  (this.frameQueries = []),
                  (this.previousFrameQueries = []),
                  (this.timings = []),
                  (this.device = b),
                  (this.ext = b.extDisjointTimerQuery);
              }
              destroy() {
                this.freeQueries.forEach((b) => this.device.gl.deleteQuery(b)),
                  this.frameQueries.forEach((b) =>
                    this.device.gl.deleteQuery(b)
                  ),
                  this.previousFrameQueries.forEach((b) =>
                    b.destroy(this.device.gl)
                  ),
                  (this.freeQueries = null),
                  (this.frameQueries = null),
                  (this.previousFrameQueries = null);
              }
              loseContext() {
                super.loseContext(),
                  (this.freeQueries = []),
                  (this.frameQueries = []),
                  (this.previousFrameQueries = []);
              }
              restoreContext() {
                this.ext = this.device.extDisjointTimerQuery;
              }
              getQuery() {
                var b;
                return (b = this.freeQueries.pop()) != null
                  ? b
                  : this.device.gl.createQuery();
              }
              start(b) {
                if (this.ext) {
                  const M = this.getSlot(b),
                    F = this.getQuery();
                  return (
                    (this.frameQueries[M] = F),
                    this.device.gl.beginQuery(this.ext.TIME_ELAPSED_EXT, F),
                    M
                  );
                }
              }
              end(b) {
                b !== void 0 &&
                  this.device.gl.endQuery(this.ext.TIME_ELAPSED_EXT);
              }
              frameStart() {
                this.processEnableRequest(),
                  this._enabled &&
                    (this.frameGPUMarkerSlot = this.start("GpuFrame"));
              }
              frameEnd() {
                this._enabled && this.end(this.frameGPUMarkerSlot);
              }
              request() {
                if (this._enabled) {
                  const b = this.ext,
                    M = this.device.gl,
                    F = this.device.renderVersion,
                    z = this.frameQueries;
                  if (z.length > 0) {
                    this.frameQueries = [];
                    const oe = new pe();
                    (oe.queries = z),
                      (oe.renderVersion = F),
                      this.previousFrameQueries.push(oe);
                  }
                  if (this.previousFrameQueries.length > 0) {
                    const oe = this.previousFrameQueries[0],
                      de = oe.queries,
                      ge = de[de.length - 1],
                      Re = M.getQueryParameter(ge, M.QUERY_RESULT_AVAILABLE),
                      Te = M.getParameter(b.GPU_DISJOINT_EXT);
                    if (Re && !Te) {
                      this.previousFrameQueries.shift();
                      const Ne = this.timings;
                      Ne.length = 0;
                      for (let Le = 0; Le < de.length; Le++) {
                        const ke = de[Le],
                          ht = M.getQueryParameter(ke, M.QUERY_RESULT);
                        (Ne[Le] = ht * 1e-6), this.freeQueries.push(ke);
                      }
                      this.report(oe.renderVersion, Ne);
                    }
                    Te &&
                      (this.previousFrameQueries.forEach((Ne) => {
                        this.report(Ne.renderVersion, null), Ne.destroy(M);
                      }),
                      (this.previousFrameQueries.length = 0));
                  }
                  super.request(F);
                }
              }
            }
            const me = [],
              N = `
attribute vec2 vertex_position;
varying vec2 vUv0;
void main(void)
{
		gl_Position = vec4(vertex_position, 0.5, 1.0);
		vUv0 = vertex_position.xy*0.5+0.5;
}
`,
              V = `
void main(void) { 
		gl_FragColor = vec4(2147483648.0);
}
`,
              L = `
uniform sampler2D source;
vec4 packFloat(float depth) {
		const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
		const vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);
		vec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);
		res -= res.xxyz * bit_mask;
		return res;
}
void main(void) {
		float c = texture2D(source, vec2(0.0)).r;
		float diff = abs(c - 2147483648.0) / 2147483648.0;
		gl_FragColor = packFloat(diff);
}
`,
              J = `
varying vec2 vUv0;
uniform sampler2D source;
void main(void) {
		gl_FragColor = texture2D(source, vUv0);
}
`;
            function ae(ie, b, M) {
              const F = ie.renderTarget;
              ie.setRenderTarget(b),
                ie.updateBegin(),
                ie.setCullMode(i.OL2),
                ie.setBlendState(ne.a.NOBLEND),
                ie.setDepthState(Y.b.NODEPTH),
                ie.setStencilState(null, null),
                ie.setVertexBuffer(ie.quadVertexBuffer, 0),
                ie.setShader(M),
                ie.draw({ type: i.fmY, base: 0, count: 4, indexed: !1 }),
                ie.updateEnd(),
                ie.setRenderTarget(F),
                ie.updateBegin();
            }
            function R(ie, b) {
              let M = !0;
              const F = ie.createTexture();
              ie.bindTexture(ie.TEXTURE_2D, F),
                ie.texParameteri(
                  ie.TEXTURE_2D,
                  ie.TEXTURE_MIN_FILTER,
                  ie.NEAREST
                ),
                ie.texParameteri(
                  ie.TEXTURE_2D,
                  ie.TEXTURE_MAG_FILTER,
                  ie.NEAREST
                ),
                ie.texParameteri(
                  ie.TEXTURE_2D,
                  ie.TEXTURE_WRAP_S,
                  ie.CLAMP_TO_EDGE
                ),
                ie.texParameteri(
                  ie.TEXTURE_2D,
                  ie.TEXTURE_WRAP_T,
                  ie.CLAMP_TO_EDGE
                ),
                ie.texImage2D(
                  ie.TEXTURE_2D,
                  0,
                  ie.RGBA,
                  2,
                  2,
                  0,
                  ie.RGBA,
                  b,
                  null
                );
              const z = ie.createFramebuffer();
              return (
                ie.bindFramebuffer(ie.FRAMEBUFFER, z),
                ie.framebufferTexture2D(
                  ie.FRAMEBUFFER,
                  ie.COLOR_ATTACHMENT0,
                  ie.TEXTURE_2D,
                  F,
                  0
                ),
                ie.checkFramebufferStatus(ie.FRAMEBUFFER) !==
                  ie.FRAMEBUFFER_COMPLETE && (M = !1),
                ie.bindTexture(ie.TEXTURE_2D, null),
                ie.deleteTexture(F),
                ie.bindFramebuffer(ie.FRAMEBUFFER, null),
                ie.deleteFramebuffer(z),
                M
              );
            }
            function j(ie, b) {
              let M = !0;
              const F = ie.createTexture();
              ie.bindTexture(ie.TEXTURE_2D, F),
                ie.texParameteri(
                  ie.TEXTURE_2D,
                  ie.TEXTURE_MIN_FILTER,
                  ie.NEAREST
                ),
                ie.texParameteri(
                  ie.TEXTURE_2D,
                  ie.TEXTURE_MAG_FILTER,
                  ie.NEAREST
                ),
                ie.texParameteri(
                  ie.TEXTURE_2D,
                  ie.TEXTURE_WRAP_S,
                  ie.CLAMP_TO_EDGE
                ),
                ie.texParameteri(
                  ie.TEXTURE_2D,
                  ie.TEXTURE_WRAP_T,
                  ie.CLAMP_TO_EDGE
                );
              const z = new Uint16Array(4 * 2 * 2);
              return (
                ie.texImage2D(
                  ie.TEXTURE_2D,
                  0,
                  ie.RGBA,
                  2,
                  2,
                  0,
                  ie.RGBA,
                  b,
                  z
                ),
                ie.getError() !== ie.NO_ERROR &&
                  ((M = !1),
                  console.log(
                    "Above error related to HALF_FLOAT_OES can be ignored, it was triggered by testing half float texture support"
                  )),
                ie.bindTexture(ie.TEXTURE_2D, null),
                ie.deleteTexture(F),
                M
              );
            }
            function se(ie) {
              if (!ie.textureFloatRenderable) return !1;
              const b = new $.e(
                  ie,
                  X.x.createDefinition(ie, {
                    name: "ptest1",
                    vertexCode: N,
                    fragmentCode: V,
                  })
                ),
                M = new $.e(
                  ie,
                  X.x.createDefinition(ie, {
                    name: "ptest2",
                    vertexCode: N,
                    fragmentCode: L,
                  })
                ),
                F = {
                  format: i.uC3,
                  width: 1,
                  height: 1,
                  mipmaps: !1,
                  minFilter: i.yib,
                  magFilter: i.yib,
                  name: "testFHP",
                },
                z = new r.x(ie, F),
                oe = new t.A({ colorBuffer: z, depth: !1 });
              ae(ie, oe, b), (F.format = i.jKI);
              const de = new r.x(ie, F),
                ge = new t.A({ colorBuffer: de, depth: !1 });
              ie.constantTexSource.setValue(z), ae(ie, ge, M);
              const Re = ie.activeFramebuffer;
              ie.setFramebuffer(ge.impl._glFrameBuffer);
              const Te = new Uint8Array(4);
              ie.readPixels(0, 0, 1, 1, Te), ie.setFramebuffer(Re);
              const Ne = Te[0] / 255,
                Le = Te[1] / 255,
                ke = Te[2] / 255,
                ht = Te[3] / 255,
                _e = Ne / (256 * 256 * 256) + Le / (256 * 256) + ke / 256 + ht;
              return (
                z.destroy(),
                oe.destroy(),
                de.destroy(),
                ge.destroy(),
                b.destroy(),
                M.destroy(),
                _e === 0
              );
            }
            class ce extends e.$ {
              constructor(b, M = {}) {
                super(b, M),
                  (this.gl = void 0),
                  (this.webgl2 = void 0),
                  (M = this.initOptions),
                  (this.defaultFramebuffer = null),
                  this.updateClientRect(),
                  (this.contextLost = !1),
                  (this._contextLostHandler = (U) => {
                    U.preventDefault(),
                      (this.contextLost = !0),
                      this.loseContext(),
                      this.fire("devicelost");
                  }),
                  (this._contextRestoredHandler = () => {
                    this.restoreContext(),
                      (this.contextLost = !1),
                      this.fire("devicerestored");
                  });
                const F =
                  typeof navigator != "undefined" && navigator.userAgent;
                (this.forceDisableMultisampling =
                  F &&
                  F.includes("AppleWebKit") &&
                  (F.includes("15.4") || F.includes("15_4"))),
                  this.forceDisableMultisampling && (M.antialias = !1);
                let z = null;
                if (M.gl) z = M.gl;
                else {
                  const H = (M.preferWebGl2 !== void 0 ? M.preferWebGl2 : !0)
                    ? ["webgl2", "webgl", "experimental-webgl"]
                    : ["webgl", "experimental-webgl"];
                  for (
                    let Ee = 0;
                    Ee < H.length && ((z = b.getContext(H[Ee], M)), !z);
                    Ee++
                  );
                }
                if (!z) throw new Error("WebGL not supported");
                (this.gl = z),
                  (this.webgl2 =
                    typeof WebGL2RenderingContext != "undefined" &&
                    z instanceof WebGL2RenderingContext),
                  (this._deviceType = this.webgl2 ? i.agD : i.qYt);
                const oe = z.getParameter(z.ALPHA_BITS);
                this.framebufferFormat = oe ? i.jKI : i.Hsr;
                const de = n.J.browserName === "chrome",
                  ge = n.J.browserName === "safari",
                  Re =
                    n.J.browser && navigator.appVersion.indexOf("Mac") !== -1;
                (this._tempEnableSafariTextureUnitWorkaround = ge),
                  (this._tempMacChromeBlitFramebufferWorkaround =
                    Re && de && !M.alpha),
                  this.webgl2 || s(z),
                  b.addEventListener(
                    "webglcontextlost",
                    this._contextLostHandler,
                    !1
                  ),
                  b.addEventListener(
                    "webglcontextrestored",
                    this._contextRestoredHandler,
                    !1
                  ),
                  this.initializeExtensions(),
                  this.initializeCapabilities(),
                  this.initializeRenderState(),
                  this.initializeContextCaches(),
                  (this.supportsImageBitmap =
                    !ge && typeof ImageBitmap != "undefined"),
                  (this.glAddress = [
                    z.REPEAT,
                    z.CLAMP_TO_EDGE,
                    z.MIRRORED_REPEAT,
                  ]),
                  (this.glBlendEquation = [
                    z.FUNC_ADD,
                    z.FUNC_SUBTRACT,
                    z.FUNC_REVERSE_SUBTRACT,
                    this.webgl2
                      ? z.MIN
                      : this.extBlendMinmax
                      ? this.extBlendMinmax.MIN_EXT
                      : z.FUNC_ADD,
                    this.webgl2
                      ? z.MAX
                      : this.extBlendMinmax
                      ? this.extBlendMinmax.MAX_EXT
                      : z.FUNC_ADD,
                  ]),
                  (this.glBlendFunctionColor = [
                    z.ZERO,
                    z.ONE,
                    z.SRC_COLOR,
                    z.ONE_MINUS_SRC_COLOR,
                    z.DST_COLOR,
                    z.ONE_MINUS_DST_COLOR,
                    z.SRC_ALPHA,
                    z.SRC_ALPHA_SATURATE,
                    z.ONE_MINUS_SRC_ALPHA,
                    z.DST_ALPHA,
                    z.ONE_MINUS_DST_ALPHA,
                    z.CONSTANT_COLOR,
                    z.ONE_MINUS_CONSTANT_COLOR,
                  ]),
                  (this.glBlendFunctionAlpha = [
                    z.ZERO,
                    z.ONE,
                    z.SRC_COLOR,
                    z.ONE_MINUS_SRC_COLOR,
                    z.DST_COLOR,
                    z.ONE_MINUS_DST_COLOR,
                    z.SRC_ALPHA,
                    z.SRC_ALPHA_SATURATE,
                    z.ONE_MINUS_SRC_ALPHA,
                    z.DST_ALPHA,
                    z.ONE_MINUS_DST_ALPHA,
                    z.CONSTANT_ALPHA,
                    z.ONE_MINUS_CONSTANT_ALPHA,
                  ]),
                  (this.glComparison = [
                    z.NEVER,
                    z.LESS,
                    z.EQUAL,
                    z.LEQUAL,
                    z.GREATER,
                    z.NOTEQUAL,
                    z.GEQUAL,
                    z.ALWAYS,
                  ]),
                  (this.glStencilOp = [
                    z.KEEP,
                    z.ZERO,
                    z.REPLACE,
                    z.INCR,
                    z.INCR_WRAP,
                    z.DECR,
                    z.DECR_WRAP,
                    z.INVERT,
                  ]),
                  (this.glClearFlag = [
                    0,
                    z.COLOR_BUFFER_BIT,
                    z.DEPTH_BUFFER_BIT,
                    z.COLOR_BUFFER_BIT | z.DEPTH_BUFFER_BIT,
                    z.STENCIL_BUFFER_BIT,
                    z.STENCIL_BUFFER_BIT | z.COLOR_BUFFER_BIT,
                    z.STENCIL_BUFFER_BIT | z.DEPTH_BUFFER_BIT,
                    z.STENCIL_BUFFER_BIT |
                      z.COLOR_BUFFER_BIT |
                      z.DEPTH_BUFFER_BIT,
                  ]),
                  (this.glCull = [0, z.BACK, z.FRONT, z.FRONT_AND_BACK]),
                  (this.glFilter = [
                    z.NEAREST,
                    z.LINEAR,
                    z.NEAREST_MIPMAP_NEAREST,
                    z.NEAREST_MIPMAP_LINEAR,
                    z.LINEAR_MIPMAP_NEAREST,
                    z.LINEAR_MIPMAP_LINEAR,
                  ]),
                  (this.glPrimitive = [
                    z.POINTS,
                    z.LINES,
                    z.LINE_LOOP,
                    z.LINE_STRIP,
                    z.TRIANGLES,
                    z.TRIANGLE_STRIP,
                    z.TRIANGLE_FAN,
                  ]),
                  (this.glType = [
                    z.BYTE,
                    z.UNSIGNED_BYTE,
                    z.SHORT,
                    z.UNSIGNED_SHORT,
                    z.INT,
                    z.UNSIGNED_INT,
                    z.FLOAT,
                  ]),
                  (this.pcUniformType = {}),
                  (this.pcUniformType[z.BOOL] = i.lRO),
                  (this.pcUniformType[z.INT] = i.cNy),
                  (this.pcUniformType[z.FLOAT] = i.Cdl),
                  (this.pcUniformType[z.FLOAT_VEC2] = i.d_l),
                  (this.pcUniformType[z.FLOAT_VEC3] = i.T73),
                  (this.pcUniformType[z.FLOAT_VEC4] = i.nZ6),
                  (this.pcUniformType[z.INT_VEC2] = i.YsN),
                  (this.pcUniformType[z.INT_VEC3] = i.D35),
                  (this.pcUniformType[z.INT_VEC4] = i.JT4),
                  (this.pcUniformType[z.BOOL_VEC2] = i.U$),
                  (this.pcUniformType[z.BOOL_VEC3] = i.AMs),
                  (this.pcUniformType[z.BOOL_VEC4] = i.fmW),
                  (this.pcUniformType[z.FLOAT_MAT2] = i.R4W),
                  (this.pcUniformType[z.FLOAT_MAT3] = i.Si0),
                  (this.pcUniformType[z.FLOAT_MAT4] = i.EA4),
                  (this.pcUniformType[z.SAMPLER_2D] = i.qTk),
                  (this.pcUniformType[z.SAMPLER_CUBE] = i.pwe),
                  this.webgl2 &&
                    ((this.pcUniformType[z.SAMPLER_2D_SHADOW] = i.Sdj),
                    (this.pcUniformType[z.SAMPLER_CUBE_SHADOW] = i.vW_),
                    (this.pcUniformType[z.SAMPLER_3D] = i.cgc)),
                  (this.targetToSlot = {}),
                  (this.targetToSlot[z.TEXTURE_2D] = 0),
                  (this.targetToSlot[z.TEXTURE_CUBE_MAP] = 1),
                  (this.targetToSlot[z.TEXTURE_3D] = 2);
                let Te, Ne, Le, ke, ht;
                (this.commitFunction = []),
                  (this.commitFunction[i.lRO] = function (U, H) {
                    U.value !== H &&
                      (z.uniform1i(U.locationId, H), (U.value = H));
                  }),
                  (this.commitFunction[i.cNy] = this.commitFunction[i.lRO]),
                  (this.commitFunction[i.Cdl] = function (U, H) {
                    U.value !== H &&
                      (z.uniform1f(U.locationId, H), (U.value = H));
                  }),
                  (this.commitFunction[i.d_l] = function (U, H) {
                    (ht = U.value),
                      (Te = H[0]),
                      (Ne = H[1]),
                      (ht[0] !== Te || ht[1] !== Ne) &&
                        (z.uniform2fv(U.locationId, H),
                        (ht[0] = Te),
                        (ht[1] = Ne));
                  }),
                  (this.commitFunction[i.T73] = function (U, H) {
                    (ht = U.value),
                      (Te = H[0]),
                      (Ne = H[1]),
                      (Le = H[2]),
                      (ht[0] !== Te || ht[1] !== Ne || ht[2] !== Le) &&
                        (z.uniform3fv(U.locationId, H),
                        (ht[0] = Te),
                        (ht[1] = Ne),
                        (ht[2] = Le));
                  }),
                  (this.commitFunction[i.nZ6] = function (U, H) {
                    (ht = U.value),
                      (Te = H[0]),
                      (Ne = H[1]),
                      (Le = H[2]),
                      (ke = H[3]),
                      (ht[0] !== Te ||
                        ht[1] !== Ne ||
                        ht[2] !== Le ||
                        ht[3] !== ke) &&
                        (z.uniform4fv(U.locationId, H),
                        (ht[0] = Te),
                        (ht[1] = Ne),
                        (ht[2] = Le),
                        (ht[3] = ke));
                  }),
                  (this.commitFunction[i.YsN] = function (U, H) {
                    (ht = U.value),
                      (Te = H[0]),
                      (Ne = H[1]),
                      (ht[0] !== Te || ht[1] !== Ne) &&
                        (z.uniform2iv(U.locationId, H),
                        (ht[0] = Te),
                        (ht[1] = Ne));
                  }),
                  (this.commitFunction[i.U$] = this.commitFunction[i.YsN]),
                  (this.commitFunction[i.D35] = function (U, H) {
                    (ht = U.value),
                      (Te = H[0]),
                      (Ne = H[1]),
                      (Le = H[2]),
                      (ht[0] !== Te || ht[1] !== Ne || ht[2] !== Le) &&
                        (z.uniform3iv(U.locationId, H),
                        (ht[0] = Te),
                        (ht[1] = Ne),
                        (ht[2] = Le));
                  }),
                  (this.commitFunction[i.AMs] = this.commitFunction[i.D35]),
                  (this.commitFunction[i.JT4] = function (U, H) {
                    (ht = U.value),
                      (Te = H[0]),
                      (Ne = H[1]),
                      (Le = H[2]),
                      (ke = H[3]),
                      (ht[0] !== Te ||
                        ht[1] !== Ne ||
                        ht[2] !== Le ||
                        ht[3] !== ke) &&
                        (z.uniform4iv(U.locationId, H),
                        (ht[0] = Te),
                        (ht[1] = Ne),
                        (ht[2] = Le),
                        (ht[3] = ke));
                  }),
                  (this.commitFunction[i.fmW] = this.commitFunction[i.JT4]),
                  (this.commitFunction[i.R4W] = function (U, H) {
                    z.uniformMatrix2fv(U.locationId, !1, H);
                  }),
                  (this.commitFunction[i.Si0] = function (U, H) {
                    z.uniformMatrix3fv(U.locationId, !1, H);
                  }),
                  (this.commitFunction[i.EA4] = function (U, H) {
                    z.uniformMatrix4fv(U.locationId, !1, H);
                  }),
                  (this.commitFunction[i.mQ2] = function (U, H) {
                    z.uniform1fv(U.locationId, H);
                  }),
                  (this.commitFunction[i.KdK] = function (U, H) {
                    z.uniform2fv(U.locationId, H);
                  }),
                  (this.commitFunction[i.m4F] = function (U, H) {
                    z.uniform3fv(U.locationId, H);
                  }),
                  (this.commitFunction[i.QQe] = function (U, H) {
                    z.uniform4fv(U.locationId, H);
                  }),
                  (this.supportsBoneTextures =
                    this.extTextureFloat && this.maxVertexTextures > 0);
                let _e = this.vertexUniformsCount;
                (_e -= 16),
                  (_e -= 8),
                  (_e -= 1),
                  (_e -= 16),
                  (this.boneLimit = Math.floor(_e / 3)),
                  (this.boneLimit = Math.min(this.boneLimit, 128)),
                  this.unmaskedRenderer === "Mali-450 MP" &&
                    (this.boneLimit = 34),
                  (this.constantTexSource = this.scope.resolve("source")),
                  this.extTextureFloat
                    ? this.webgl2
                      ? (this.textureFloatRenderable =
                          !!this.extColorBufferFloat)
                      : (this.textureFloatRenderable = R(z, z.FLOAT))
                    : (this.textureFloatRenderable = !1),
                  this.extColorBufferHalfFloat
                    ? (this.textureHalfFloatRenderable =
                        !!this.extColorBufferHalfFloat)
                    : this.extTextureHalfFloat
                    ? this.webgl2
                      ? (this.textureHalfFloatRenderable =
                          !!this.extColorBufferFloat)
                      : (this.textureHalfFloatRenderable = R(
                          z,
                          this.extTextureHalfFloat.HALF_FLOAT_OES
                        ))
                    : (this.textureHalfFloatRenderable = !1),
                  (this.supportsMorphTargetTexturesCore =
                    this.maxPrecision === "highp" &&
                    this.maxVertexTextures >= 2),
                  (this.supportsDepthShadow = this.webgl2),
                  (this._textureFloatHighPrecision = void 0),
                  (this._textureHalfFloatUpdatable = void 0),
                  (this.areaLightLutFormat = i.jKI),
                  this.extTextureHalfFloat &&
                  this.textureHalfFloatUpdatable &&
                  this.extTextureHalfFloatLinear
                    ? (this.areaLightLutFormat = i.a7f)
                    : this.extTextureFloat &&
                      this.extTextureFloatLinear &&
                      (this.areaLightLutFormat = i.uC3),
                  this.postInit();
              }
              postInit() {
                super.postInit(), (this.gpuProfiler = new O(this));
              }
              destroy() {
                super.destroy();
                const b = this.gl;
                this.webgl2 &&
                  this.feedback &&
                  b.deleteTransformFeedback(this.feedback),
                  this.clearVertexArrayObjectCache(),
                  this.canvas.removeEventListener(
                    "webglcontextlost",
                    this._contextLostHandler,
                    !1
                  ),
                  this.canvas.removeEventListener(
                    "webglcontextrestored",
                    this._contextRestoredHandler,
                    !1
                  ),
                  (this._contextLostHandler = null),
                  (this._contextRestoredHandler = null),
                  (this.gl = null),
                  super.postDestroy();
              }
              createVertexBufferImpl(b, M) {
                return new y();
              }
              createIndexBufferImpl(b) {
                return new p(b);
              }
              createShaderImpl(b) {
                return new C(b);
              }
              createTextureImpl(b) {
                return new k();
              }
              createRenderTargetImpl(b) {
                return new te();
              }
              getPrecision() {
                const b = this.gl;
                let M = "highp";
                if (b.getShaderPrecisionFormat) {
                  const F = b.getShaderPrecisionFormat(
                      b.VERTEX_SHADER,
                      b.HIGH_FLOAT
                    ),
                    z = b.getShaderPrecisionFormat(
                      b.VERTEX_SHADER,
                      b.MEDIUM_FLOAT
                    ),
                    oe = b.getShaderPrecisionFormat(
                      b.FRAGMENT_SHADER,
                      b.HIGH_FLOAT
                    ),
                    de = b.getShaderPrecisionFormat(
                      b.FRAGMENT_SHADER,
                      b.MEDIUM_FLOAT
                    );
                  if (F && z && oe && de) {
                    const ge = F.precision > 0 && oe.precision > 0,
                      Re = z.precision > 0 && de.precision > 0;
                    ge || (Re ? (M = "mediump") : (M = "lowp"));
                  }
                }
                return M;
              }
              getExtension() {
                for (let b = 0; b < arguments.length; b++)
                  if (this.supportedExtensions.indexOf(arguments[b]) !== -1)
                    return this.gl.getExtension(arguments[b]);
                return null;
              }
              get extDisjointTimerQuery() {
                return (
                  this._extDisjointTimerQuery ||
                    (this.webgl2 &&
                      (this._extDisjointTimerQuery = this.getExtension(
                        "EXT_disjoint_timer_query_webgl2",
                        "EXT_disjoint_timer_query"
                      ))),
                  this._extDisjointTimerQuery
                );
              }
              initializeExtensions() {
                var b;
                const M = this.gl;
                if (
                  ((this.supportedExtensions =
                    (b = M.getSupportedExtensions()) != null ? b : []),
                  (this._extDisjointTimerQuery = null),
                  this.webgl2)
                )
                  (this.extBlendMinmax = !0),
                    (this.extDrawBuffers = !0),
                    (this.drawBuffers = M.drawBuffers.bind(M)),
                    (this.extInstancing = !0),
                    (this.extStandardDerivatives = !0),
                    (this.extTextureFloat = !0),
                    (this.extTextureHalfFloat = !0),
                    (this.extTextureLod = !0),
                    (this.extUintElement = !0),
                    (this.extVertexArrayObject = !0),
                    (this.extColorBufferFloat = this.getExtension(
                      "EXT_color_buffer_float"
                    )),
                    (this.extDepthTexture = !0);
                else {
                  var F;
                  if (
                    ((this.extBlendMinmax =
                      this.getExtension("EXT_blend_minmax")),
                    (this.extDrawBuffers =
                      this.getExtension("WEBGL_draw_buffers")),
                    (this.extInstancing = this.getExtension(
                      "ANGLE_instanced_arrays"
                    )),
                    (this.drawBuffers =
                      (F = this.extDrawBuffers) == null
                        ? void 0
                        : F.drawBuffersWEBGL.bind(this.extDrawBuffers)),
                    this.extInstancing)
                  ) {
                    const z = this.extInstancing;
                    (M.drawArraysInstanced =
                      z.drawArraysInstancedANGLE.bind(z)),
                      (M.drawElementsInstanced =
                        z.drawElementsInstancedANGLE.bind(z)),
                      (M.vertexAttribDivisor =
                        z.vertexAttribDivisorANGLE.bind(z));
                  }
                  if (
                    ((this.extStandardDerivatives = this.getExtension(
                      "OES_standard_derivatives"
                    )),
                    (this.extTextureFloat =
                      this.getExtension("OES_texture_float")),
                    (this.extTextureHalfFloat = this.getExtension(
                      "OES_texture_half_float"
                    )),
                    (this.extTextureLod = this.getExtension(
                      "EXT_shader_texture_lod"
                    )),
                    (this.extUintElement = this.getExtension(
                      "OES_element_index_uint"
                    )),
                    (this.extVertexArrayObject = this.getExtension(
                      "OES_vertex_array_object"
                    )),
                    this.extVertexArrayObject)
                  ) {
                    const z = this.extVertexArrayObject;
                    (M.createVertexArray = z.createVertexArrayOES.bind(z)),
                      (M.deleteVertexArray = z.deleteVertexArrayOES.bind(z)),
                      (M.isVertexArray = z.isVertexArrayOES.bind(z)),
                      (M.bindVertexArray = z.bindVertexArrayOES.bind(z));
                  }
                  (this.extColorBufferFloat = null),
                    (this.extDepthTexture = M.getExtension(
                      "WEBGL_depth_texture"
                    ));
                }
                (this.extDebugRendererInfo = this.getExtension(
                  "WEBGL_debug_renderer_info"
                )),
                  (this.extTextureFloatLinear = this.getExtension(
                    "OES_texture_float_linear"
                  )),
                  (this.extTextureHalfFloatLinear = this.getExtension(
                    "OES_texture_half_float_linear"
                  )),
                  (this.extFloatBlend = this.getExtension("EXT_float_blend")),
                  (this.extTextureFilterAnisotropic = this.getExtension(
                    "EXT_texture_filter_anisotropic",
                    "WEBKIT_EXT_texture_filter_anisotropic"
                  )),
                  (this.extCompressedTextureETC1 = this.getExtension(
                    "WEBGL_compressed_texture_etc1"
                  )),
                  (this.extCompressedTextureETC = this.getExtension(
                    "WEBGL_compressed_texture_etc"
                  )),
                  (this.extCompressedTexturePVRTC = this.getExtension(
                    "WEBGL_compressed_texture_pvrtc",
                    "WEBKIT_WEBGL_compressed_texture_pvrtc"
                  )),
                  (this.extCompressedTextureS3TC = this.getExtension(
                    "WEBGL_compressed_texture_s3tc",
                    "WEBKIT_WEBGL_compressed_texture_s3tc"
                  )),
                  (this.extCompressedTextureATC = this.getExtension(
                    "WEBGL_compressed_texture_atc"
                  )),
                  (this.extCompressedTextureASTC = this.getExtension(
                    "WEBGL_compressed_texture_astc"
                  )),
                  (this.extParallelShaderCompile = this.getExtension(
                    "KHR_parallel_shader_compile"
                  )),
                  (this.extColorBufferHalfFloat = this.getExtension(
                    "EXT_color_buffer_half_float"
                  ));
              }
              initializeCapabilities() {
                const b = this.gl;
                let M;
                const F =
                  typeof navigator != "undefined" ? navigator.userAgent : "";
                this.maxPrecision = this.precision = this.getPrecision();
                const z = b.getContextAttributes();
                (this.supportsMsaa = z.antialias),
                  (this.supportsStencil = z.stencil),
                  (this.supportsInstancing = !!this.extInstancing),
                  (this.maxTextureSize = b.getParameter(b.MAX_TEXTURE_SIZE)),
                  (this.maxCubeMapSize = b.getParameter(
                    b.MAX_CUBE_MAP_TEXTURE_SIZE
                  )),
                  (this.maxRenderBufferSize = b.getParameter(
                    b.MAX_RENDERBUFFER_SIZE
                  )),
                  (this.maxTextures = b.getParameter(
                    b.MAX_TEXTURE_IMAGE_UNITS
                  )),
                  (this.maxCombinedTextures = b.getParameter(
                    b.MAX_COMBINED_TEXTURE_IMAGE_UNITS
                  )),
                  (this.maxVertexTextures = b.getParameter(
                    b.MAX_VERTEX_TEXTURE_IMAGE_UNITS
                  )),
                  (this.vertexUniformsCount = b.getParameter(
                    b.MAX_VERTEX_UNIFORM_VECTORS
                  )),
                  (this.fragmentUniformsCount = b.getParameter(
                    b.MAX_FRAGMENT_UNIFORM_VECTORS
                  )),
                  this.webgl2
                    ? ((this.maxDrawBuffers = b.getParameter(
                        b.MAX_DRAW_BUFFERS
                      )),
                      (this.maxColorAttachments = b.getParameter(
                        b.MAX_COLOR_ATTACHMENTS
                      )),
                      (this.maxVolumeSize = b.getParameter(
                        b.MAX_3D_TEXTURE_SIZE
                      )),
                      (this.supportsMrt = !0),
                      (this.supportsVolumeTextures = !0))
                    : ((M = this.extDrawBuffers),
                      (this.supportsMrt = !!M),
                      (this.maxDrawBuffers = M
                        ? b.getParameter(M.MAX_DRAW_BUFFERS_WEBGL)
                        : 1),
                      (this.maxColorAttachments = M
                        ? b.getParameter(M.MAX_COLOR_ATTACHMENTS_WEBGL)
                        : 1),
                      (this.maxVolumeSize = 1)),
                  (M = this.extDebugRendererInfo),
                  (this.unmaskedRenderer = M
                    ? b.getParameter(M.UNMASKED_RENDERER_WEBGL)
                    : ""),
                  (this.unmaskedVendor = M
                    ? b.getParameter(M.UNMASKED_VENDOR_WEBGL)
                    : "");
                const oe = /\bMali-G52+/,
                  de = /SM-[a-zA-Z0-9]+/;
                (this.supportsGpuParticles =
                  !(this.unmaskedVendor === "ARM" && F.match(de)) &&
                  !this.unmaskedRenderer.match(oe)),
                  (M = this.extTextureFilterAnisotropic),
                  (this.maxAnisotropy = M
                    ? b.getParameter(M.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                    : 1),
                  (this.samples = b.getParameter(b.SAMPLES)),
                  (this.maxSamples =
                    this.webgl2 && !this.forceDisableMultisampling
                      ? b.getParameter(b.MAX_SAMPLES)
                      : 1),
                  (this.supportsAreaLights = this.webgl2 || !n.J.android),
                  (this.supportsTextureFetch = this.webgl2),
                  this.maxTextures <= 8 && (this.supportsAreaLights = !1);
              }
              initializeRenderState() {
                super.initializeRenderState();
                const b = this.gl;
                b.disable(b.BLEND),
                  b.blendFunc(b.ONE, b.ZERO),
                  b.blendEquation(b.FUNC_ADD),
                  b.colorMask(!0, !0, !0, !0),
                  (this.blendColor = new o.I(0, 0, 0, 0)),
                  b.blendColor(0, 0, 0, 0),
                  b.enable(b.CULL_FACE),
                  b.cullFace(b.BACK),
                  b.enable(b.DEPTH_TEST),
                  b.depthFunc(b.LEQUAL),
                  b.depthMask(!0),
                  (this.stencil = !1),
                  b.disable(b.STENCIL_TEST),
                  (this.stencilFuncFront = this.stencilFuncBack = i.g8z),
                  (this.stencilRefFront = this.stencilRefBack = 0),
                  (this.stencilMaskFront = this.stencilMaskBack = 255),
                  b.stencilFunc(b.ALWAYS, 0, 255),
                  (this.stencilFailFront = this.stencilFailBack = i.gKr),
                  (this.stencilZfailFront = this.stencilZfailBack = i.gKr),
                  (this.stencilZpassFront = this.stencilZpassBack = i.gKr),
                  (this.stencilWriteMaskFront = 255),
                  (this.stencilWriteMaskBack = 255),
                  b.stencilOp(b.KEEP, b.KEEP, b.KEEP),
                  b.stencilMask(255),
                  (this.alphaToCoverage = !1),
                  (this.raster = !0),
                  this.webgl2 &&
                    (b.disable(b.SAMPLE_ALPHA_TO_COVERAGE),
                    b.disable(b.RASTERIZER_DISCARD)),
                  (this.depthBiasEnabled = !1),
                  b.disable(b.POLYGON_OFFSET_FILL),
                  (this.clearDepth = 1),
                  b.clearDepth(1),
                  (this.clearColor = new o.I(0, 0, 0, 0)),
                  b.clearColor(0, 0, 0, 0),
                  (this.clearStencil = 0),
                  b.clearStencil(0),
                  this.webgl2
                    ? b.hint(b.FRAGMENT_SHADER_DERIVATIVE_HINT, b.NICEST)
                    : this.extStandardDerivatives &&
                      b.hint(
                        this.extStandardDerivatives
                          .FRAGMENT_SHADER_DERIVATIVE_HINT_OES,
                        b.NICEST
                      ),
                  b.enable(b.SCISSOR_TEST),
                  b.pixelStorei(b.UNPACK_COLORSPACE_CONVERSION_WEBGL, b.NONE),
                  (this.unpackFlipY = !1),
                  b.pixelStorei(b.UNPACK_FLIP_Y_WEBGL, !1),
                  (this.unpackPremultiplyAlpha = !1),
                  b.pixelStorei(b.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
                  b.pixelStorei(b.UNPACK_ALIGNMENT, 1);
              }
              initializeContextCaches() {
                super.initializeContextCaches(),
                  (this._vaoMap = new Map()),
                  (this.boundVao = null),
                  (this.activeFramebuffer = null),
                  (this.feedback = null),
                  (this.transformFeedbackBuffer = null),
                  (this.textureUnit = 0),
                  (this.textureUnits = []);
                for (let b = 0; b < this.maxCombinedTextures; b++)
                  this.textureUnits.push([null, null, null]);
              }
              loseContext() {
                var b;
                for (const M of this.shaders) M.loseContext();
                for (const M of this.textures) M.loseContext();
                for (const M of this.buffers) M.loseContext();
                for (const M of this.targets) M.loseContext();
                (b = this.gpuProfiler) == null || b.loseContext();
              }
              restoreContext() {
                var b;
                this.initializeExtensions(),
                  this.initializeCapabilities(),
                  this.initializeRenderState(),
                  this.initializeContextCaches();
                for (const M of this.shaders) M.restoreContext();
                for (const M of this.buffers) M.unlock();
                (b = this.gpuProfiler) == null || b.restoreContext();
              }
              endShaderBatch() {
                C.endShaderBatch(this);
              }
              setViewport(b, M, F, z) {
                (this.vx !== b ||
                  this.vy !== M ||
                  this.vw !== F ||
                  this.vh !== z) &&
                  (this.gl.viewport(b, M, F, z),
                  (this.vx = b),
                  (this.vy = M),
                  (this.vw = F),
                  (this.vh = z));
              }
              setScissor(b, M, F, z) {
                (this.sx !== b ||
                  this.sy !== M ||
                  this.sw !== F ||
                  this.sh !== z) &&
                  (this.gl.scissor(b, M, F, z),
                  (this.sx = b),
                  (this.sy = M),
                  (this.sw = F),
                  (this.sh = z));
              }
              setFramebuffer(b) {
                if (this.activeFramebuffer !== b) {
                  const M = this.gl;
                  M.bindFramebuffer(M.FRAMEBUFFER, b),
                    (this.activeFramebuffer = b);
                }
              }
              copyRenderTarget(b, M, F, z) {
                const oe = this.gl;
                if (!this.webgl2 && z) return !1;
                if (F) {
                  if (M) {
                    if (
                      b &&
                      (!b._colorBuffer ||
                        !M._colorBuffer ||
                        b._colorBuffer._format !== M._colorBuffer._format)
                    )
                      return !1;
                  } else if (!b._colorBuffer) return !1;
                }
                if (
                  z &&
                  b &&
                  !b._depth &&
                  (!b._depthBuffer ||
                    !M._depthBuffer ||
                    b._depthBuffer._format !== M._depthBuffer._format)
                )
                  return !1;
                if (this.webgl2 && M) {
                  const de = this.renderTarget;
                  (this.renderTarget = M),
                    this.updateBegin(),
                    oe.bindFramebuffer(
                      oe.READ_FRAMEBUFFER,
                      b ? b.impl._glFrameBuffer : null
                    ),
                    oe.bindFramebuffer(
                      oe.DRAW_FRAMEBUFFER,
                      M.impl._glFrameBuffer
                    );
                  const ge = b ? b.width : M.width,
                    Re = b ? b.height : M.height;
                  oe.blitFramebuffer(
                    0,
                    0,
                    ge,
                    Re,
                    0,
                    0,
                    ge,
                    Re,
                    (F ? oe.COLOR_BUFFER_BIT : 0) |
                      (z ? oe.DEPTH_BUFFER_BIT : 0),
                    oe.NEAREST
                  ),
                    (this.renderTarget = de),
                    oe.bindFramebuffer(
                      oe.FRAMEBUFFER,
                      de ? de.impl._glFrameBuffer : null
                    );
                } else {
                  const de = this.getCopyShader();
                  this.constantTexSource.setValue(b._colorBuffer),
                    ae(this, M, de);
                }
                return !0;
              }
              getCopyShader() {
                return (
                  this._copyShader ||
                    (this._copyShader = new $.e(
                      this,
                      X.x.createDefinition(this, {
                        name: "outputTex2D",
                        vertexCode: N,
                        fragmentCode: J,
                      })
                    )),
                  this._copyShader
                );
              }
              frameStart() {
                super.frameStart(), this.gpuProfiler.frameStart();
              }
              frameEnd() {
                super.frameEnd(),
                  this.gpuProfiler.frameEnd(),
                  this.gpuProfiler.request();
              }
              startPass(b) {
                this.setRenderTarget(b.renderTarget), this.updateBegin();
                const M = b.colorOps,
                  F = b.depthStencilOps;
                if ((M != null && M.clear) || F.clearDepth || F.clearStencil) {
                  const z = b.renderTarget,
                    oe = z ? z.width : this.width,
                    de = z ? z.height : this.height;
                  this.setViewport(0, 0, oe, de), this.setScissor(0, 0, oe, de);
                  let ge = 0;
                  const Re = {};
                  M != null &&
                    M.clear &&
                    ((ge |= i.Zzy),
                    (Re.color = [
                      M.clearValue.r,
                      M.clearValue.g,
                      M.clearValue.b,
                      M.clearValue.a,
                    ])),
                    F.clearDepth &&
                      ((ge |= i.zk9), (Re.depth = F.clearDepthValue)),
                    F.clearStencil &&
                      ((ge |= i.$tA), (Re.stencil = F.clearStencilValue)),
                    (Re.flags = ge),
                    this.clear(Re);
                }
                this.insideRenderPass = !0;
              }
              endPass(b) {
                this.unbindVertexArray();
                const M = this.renderTarget,
                  F = b.colorArrayOps.length;
                if (M) {
                  var z;
                  if (this.webgl2) {
                    me.length = 0;
                    const oe = this.gl;
                    for (let de = 0; de < F; de++) {
                      const ge = b.colorArrayOps[de];
                      ge.store ||
                        ge.resolve ||
                        me.push(oe.COLOR_ATTACHMENT0 + de);
                    }
                    b.depthStencilOps.storeDepth ||
                      me.push(oe.DEPTH_ATTACHMENT),
                      b.depthStencilOps.storeStencil ||
                        me.push(oe.STENCIL_ATTACHMENT),
                      me.length > 0 &&
                        b.fullSizeClearRect &&
                        oe.invalidateFramebuffer(oe.DRAW_FRAMEBUFFER, me);
                  }
                  (z = b.colorOps) != null &&
                    z.resolve &&
                    this.webgl2 &&
                    b.samples > 1 &&
                    M.autoResolve &&
                    M.resolve(!0, !1);
                  for (let oe = 0; oe < F; oe++)
                    if (b.colorArrayOps[oe].mipmaps) {
                      const ge = M._colorBuffers[oe];
                      ge &&
                        ge.impl._glTexture &&
                        ge.mipmaps &&
                        (ge.pot || this.webgl2) &&
                        (this.activeTexture(this.maxCombinedTextures - 1),
                        this.bindTexture(ge),
                        this.gl.generateMipmap(ge.impl._glTarget));
                    }
                }
                this.insideRenderPass = !1;
              }
              updateBegin() {
                if (
                  ((this.boundVao = null),
                  this._tempEnableSafariTextureUnitWorkaround)
                )
                  for (let M = 0; M < this.textureUnits.length; ++M)
                    for (let F = 0; F < 3; ++F) this.textureUnits[M][F] = null;
                const b = this.renderTarget;
                b
                  ? b.impl.initialized
                    ? this.setFramebuffer(b.impl._glFrameBuffer)
                    : this.initRenderTarget(b)
                  : this.setFramebuffer(this.defaultFramebuffer);
              }
              updateEnd() {
                this.unbindVertexArray();
                const b = this.renderTarget;
                if (b) {
                  this.webgl2 && b._samples > 1 && b.autoResolve && b.resolve();
                  const M = b._colorBuffer;
                  M &&
                    M.impl._glTexture &&
                    M.mipmaps &&
                    (M.pot || this.webgl2) &&
                    (this.activeTexture(this.maxCombinedTextures - 1),
                    this.bindTexture(M),
                    this.gl.generateMipmap(M.impl._glTarget));
                }
              }
              setUnpackFlipY(b) {
                if (this.unpackFlipY !== b) {
                  this.unpackFlipY = b;
                  const M = this.gl;
                  M.pixelStorei(M.UNPACK_FLIP_Y_WEBGL, b);
                }
              }
              setUnpackPremultiplyAlpha(b) {
                if (this.unpackPremultiplyAlpha !== b) {
                  this.unpackPremultiplyAlpha = b;
                  const M = this.gl;
                  M.pixelStorei(M.UNPACK_PREMULTIPLY_ALPHA_WEBGL, b);
                }
              }
              activeTexture(b) {
                this.textureUnit !== b &&
                  (this.gl.activeTexture(this.gl.TEXTURE0 + b),
                  (this.textureUnit = b));
              }
              bindTexture(b) {
                const M = b.impl,
                  F = M._glTarget,
                  z = M._glTexture,
                  oe = this.textureUnit,
                  de = this.targetToSlot[F];
                this.textureUnits[oe][de] !== z &&
                  (this.gl.bindTexture(F, z), (this.textureUnits[oe][de] = z));
              }
              bindTextureOnUnit(b, M) {
                const F = b.impl,
                  z = F._glTarget,
                  oe = F._glTexture,
                  de = this.targetToSlot[z];
                this.textureUnits[M][de] !== oe &&
                  (this.activeTexture(M),
                  this.gl.bindTexture(z, oe),
                  (this.textureUnits[M][de] = oe));
              }
              setTextureParameters(b) {
                const M = this.gl,
                  F = b.impl.dirtyParameterFlags,
                  z = b.impl._glTarget;
                if (F & 1) {
                  let oe = b._minFilter;
                  ((!b.pot && !this.webgl2) ||
                    !b._mipmaps ||
                    (b._compressed && b._levels.length === 1)) &&
                    (oe === i.Aap || oe === i.$_P
                      ? (oe = i.yib)
                      : (oe === i.feq || oe === i.Snx) && (oe = i.I5X)),
                    M.texParameteri(z, M.TEXTURE_MIN_FILTER, this.glFilter[oe]);
                }
                if (
                  (F & 2 &&
                    M.texParameteri(
                      z,
                      M.TEXTURE_MAG_FILTER,
                      this.glFilter[b._magFilter]
                    ),
                  F & 4 &&
                    (this.webgl2
                      ? M.texParameteri(
                          z,
                          M.TEXTURE_WRAP_S,
                          this.glAddress[b._addressU]
                        )
                      : M.texParameteri(
                          z,
                          M.TEXTURE_WRAP_S,
                          this.glAddress[b.pot ? b._addressU : i.uFb]
                        )),
                  F & 8 &&
                    (this.webgl2
                      ? M.texParameteri(
                          z,
                          M.TEXTURE_WRAP_T,
                          this.glAddress[b._addressV]
                        )
                      : M.texParameteri(
                          z,
                          M.TEXTURE_WRAP_T,
                          this.glAddress[b.pot ? b._addressV : i.uFb]
                        )),
                  F & 16 &&
                    this.webgl2 &&
                    M.texParameteri(
                      z,
                      M.TEXTURE_WRAP_R,
                      this.glAddress[b._addressW]
                    ),
                  F & 32 &&
                    this.webgl2 &&
                    M.texParameteri(
                      z,
                      M.TEXTURE_COMPARE_MODE,
                      b._compareOnRead ? M.COMPARE_REF_TO_TEXTURE : M.NONE
                    ),
                  F & 64 &&
                    this.webgl2 &&
                    M.texParameteri(
                      z,
                      M.TEXTURE_COMPARE_FUNC,
                      this.glComparison[b._compareFunc]
                    ),
                  F & 128)
                ) {
                  const oe = this.extTextureFilterAnisotropic;
                  oe &&
                    M.texParameterf(
                      z,
                      oe.TEXTURE_MAX_ANISOTROPY_EXT,
                      l.m.clamp(
                        Math.round(b._anisotropy),
                        1,
                        this.maxAnisotropy
                      )
                    );
                }
              }
              setTexture(b, M) {
                const F = b.impl;
                F._glTexture || F.initialize(this, b),
                  F.dirtyParameterFlags > 0 ||
                  b._needsUpload ||
                  b._needsMipmapsUpload
                    ? (this.activeTexture(M),
                      this.bindTexture(b),
                      F.dirtyParameterFlags &&
                        (this.setTextureParameters(b),
                        (F.dirtyParameterFlags = 0)),
                      (b._needsUpload || b._needsMipmapsUpload) &&
                        (F.upload(this, b),
                        (b._needsUpload = !1),
                        (b._needsMipmapsUpload = !1)))
                    : this.bindTextureOnUnit(b, M);
              }
              createVertexArray(b) {
                let M, F;
                const z = b.length > 1;
                if (z) {
                  M = "";
                  for (let oe = 0; oe < b.length; oe++) {
                    const de = b[oe];
                    M += de.id + de.format.renderingHash;
                  }
                  F = this._vaoMap.get(M);
                }
                if (!F) {
                  const oe = this.gl;
                  (F = oe.createVertexArray()),
                    oe.bindVertexArray(F),
                    oe.bindBuffer(oe.ELEMENT_ARRAY_BUFFER, null);
                  for (let de = 0; de < b.length; de++) {
                    const ge = b[de];
                    oe.bindBuffer(oe.ARRAY_BUFFER, ge.impl.bufferId);
                    const Re = ge.format.elements;
                    for (let Te = 0; Te < Re.length; Te++) {
                      const Ne = Re[Te],
                        Le = i.Lb6[Ne.name];
                      oe.vertexAttribPointer(
                        Le,
                        Ne.numComponents,
                        this.glType[Ne.dataType],
                        Ne.normalize,
                        Ne.stride,
                        Ne.offset
                      ),
                        oe.enableVertexAttribArray(Le),
                        ge.format.instancing && oe.vertexAttribDivisor(Le, 1);
                    }
                  }
                  oe.bindVertexArray(null),
                    oe.bindBuffer(oe.ARRAY_BUFFER, null),
                    z && this._vaoMap.set(M, F);
                }
                return F;
              }
              unbindVertexArray() {
                this.boundVao &&
                  ((this.boundVao = null), this.gl.bindVertexArray(null));
              }
              setBuffers() {
                const b = this.gl;
                let M;
                if (this.vertexBuffers.length === 1) {
                  const z = this.vertexBuffers[0];
                  z.impl.vao ||
                    (z.impl.vao = this.createVertexArray(this.vertexBuffers)),
                    (M = z.impl.vao);
                } else M = this.createVertexArray(this.vertexBuffers);
                this.boundVao !== M &&
                  ((this.boundVao = M), b.bindVertexArray(M)),
                  (this.vertexBuffers.length = 0);
                const F = this.indexBuffer
                  ? this.indexBuffer.impl.bufferId
                  : null;
                b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, F);
              }
              draw(b, M, F) {
                const z = this.gl;
                let oe, de, ge, Re, Te, Ne, Le, ke;
                const ht = this.shader;
                if (!ht) return;
                const _e = ht.impl.samplers,
                  U = ht.impl.uniforms;
                F || this.setBuffers();
                let H = 0;
                for (let Q = 0, q = _e.length; Q < q; Q++) {
                  if (((oe = _e[Q]), (de = oe.scopeId.value), !de)) return;
                  if (de instanceof r.x)
                    (ge = de),
                      this.setTexture(ge, H),
                      oe.slot !== H &&
                        (z.uniform1i(oe.locationId, H), (oe.slot = H)),
                      H++;
                  else {
                    (oe.array.length = 0), (Re = de.length);
                    for (let xe = 0; xe < Re; xe++)
                      (ge = de[xe]),
                        this.setTexture(ge, H),
                        (oe.array[xe] = H),
                        H++;
                    z.uniform1iv(oe.locationId, oe.array);
                  }
                }
                for (let Q = 0, q = U.length; Q < q; Q++)
                  (Te = U[Q]),
                    (Ne = Te.scopeId),
                    (Le = Te.version),
                    (ke = Ne.versionObject.version),
                    (Le.globalId !== ke.globalId ||
                      Le.revision !== ke.revision) &&
                      ((Le.globalId = ke.globalId),
                      (Le.revision = ke.revision),
                      Ne.value !== null &&
                        this.commitFunction[Te.dataType](Te, Ne.value));
                this.webgl2 &&
                  this.transformFeedbackBuffer &&
                  (z.bindBufferBase(
                    z.TRANSFORM_FEEDBACK_BUFFER,
                    0,
                    this.transformFeedbackBuffer.impl.bufferId
                  ),
                  z.beginTransformFeedback(z.POINTS));
                const Ee = this.glPrimitive[b.type],
                  G = b.count;
                if (b.indexed) {
                  const Q = this.indexBuffer,
                    q = Q.impl.glFormat,
                    xe = b.base * Q.bytesPerIndex;
                  M > 0
                    ? z.drawElementsInstanced(Ee, G, q, xe, M)
                    : z.drawElements(Ee, G, q, xe);
                } else {
                  const Q = b.base;
                  M > 0
                    ? z.drawArraysInstanced(Ee, Q, G, M)
                    : z.drawArrays(Ee, Q, G);
                }
                this.webgl2 &&
                  this.transformFeedbackBuffer &&
                  (z.endTransformFeedback(),
                  z.bindBufferBase(z.TRANSFORM_FEEDBACK_BUFFER, 0, null)),
                  this._drawCallsPerFrame++;
              }
              clear(b) {
                var M;
                const F = this.defaultClearOptions;
                b = b || F;
                const z = (M = b.flags) != null ? M : F.flags;
                if (z !== 0) {
                  const Re = this.gl;
                  if (z & i.Zzy) {
                    var oe;
                    const Te = (oe = b.color) != null ? oe : F.color,
                      Ne = Te[0],
                      Le = Te[1],
                      ke = Te[2],
                      ht = Te[3],
                      _e = this.clearColor;
                    (Ne !== _e.r ||
                      Le !== _e.g ||
                      ke !== _e.b ||
                      ht !== _e.a) &&
                      (this.gl.clearColor(Ne, Le, ke, ht),
                      this.clearColor.set(Ne, Le, ke, ht)),
                      this.setBlendState(ne.a.NOBLEND);
                  }
                  if (z & i.zk9) {
                    var de;
                    const Te = (de = b.depth) != null ? de : F.depth;
                    Te !== this.clearDepth &&
                      (this.gl.clearDepth(Te), (this.clearDepth = Te)),
                      this.setDepthState(Y.b.WRITEDEPTH);
                  }
                  if (z & i.$tA) {
                    var ge;
                    const Te = (ge = b.stencil) != null ? ge : F.stencil;
                    Te !== this.clearStencil &&
                      (this.gl.clearStencil(Te), (this.clearStencil = Te));
                  }
                  Re.clear(this.glClearFlag[z]);
                }
              }
              submit() {
                this.gl.flush();
              }
              readPixels(b, M, F, z, oe) {
                const de = this.gl;
                de.readPixels(b, M, F, z, de.RGBA, de.UNSIGNED_BYTE, oe);
              }
              readPixelsAsync(b, M, F, z, oe) {
                return pn(this, null, function* () {
                  var de, ge, Re;
                  const Te = this.gl;
                  if (!this.webgl2) return this.readPixels(b, M, F, z, oe);
                  const Ne = (U, H) => {
                      const Ee = Te.fenceSync(Te.SYNC_GPU_COMMANDS_COMPLETE, 0);
                      return (
                        this.submit(),
                        new Promise((G, Q) => {
                          function q() {
                            const xe = Te.clientWaitSync(Ee, U, 0);
                            xe === Te.WAIT_FAILED
                              ? (Te.deleteSync(Ee),
                                Q(
                                  new Error("webgl clientWaitSync sync failed")
                                ))
                              : xe === Te.TIMEOUT_EXPIRED
                              ? setTimeout(q, H)
                              : (Te.deleteSync(Ee), G());
                          }
                          q();
                        })
                      );
                    },
                    Le =
                      (de = this.renderTarget.colorBuffer) == null
                        ? void 0
                        : de.impl,
                    ke =
                      (ge = Le == null ? void 0 : Le._glFormat) != null
                        ? ge
                        : Te.RGBA,
                    ht =
                      (Re = Le == null ? void 0 : Le._glPixelType) != null
                        ? Re
                        : Te.UNSIGNED_BYTE,
                    _e = Te.createBuffer();
                  Te.bindBuffer(Te.PIXEL_PACK_BUFFER, _e),
                    Te.bufferData(
                      Te.PIXEL_PACK_BUFFER,
                      oe.byteLength,
                      Te.STREAM_READ
                    ),
                    Te.readPixels(b, M, F, z, ke, ht, 0),
                    Te.bindBuffer(Te.PIXEL_PACK_BUFFER, null),
                    yield Ne(0, 20),
                    Te.bindBuffer(Te.PIXEL_PACK_BUFFER, _e),
                    Te.getBufferSubData(Te.PIXEL_PACK_BUFFER, 0, oe),
                    Te.bindBuffer(Te.PIXEL_PACK_BUFFER, null),
                    Te.deleteBuffer(_e);
                });
              }
              setAlphaToCoverage(b) {
                this.webgl2 &&
                  this.alphaToCoverage !== b &&
                  ((this.alphaToCoverage = b),
                  b
                    ? this.gl.enable(this.gl.SAMPLE_ALPHA_TO_COVERAGE)
                    : this.gl.disable(this.gl.SAMPLE_ALPHA_TO_COVERAGE));
              }
              setTransformFeedbackBuffer(b) {
                if (
                  this.transformFeedbackBuffer !== b &&
                  ((this.transformFeedbackBuffer = b), this.webgl2)
                ) {
                  const M = this.gl;
                  b
                    ? (this.feedback ||
                        (this.feedback = M.createTransformFeedback()),
                      M.bindTransformFeedback(
                        M.TRANSFORM_FEEDBACK,
                        this.feedback
                      ))
                    : M.bindTransformFeedback(M.TRANSFORM_FEEDBACK, null);
                }
              }
              setRaster(b) {
                this.raster !== b &&
                  ((this.raster = b),
                  this.webgl2 &&
                    (b
                      ? this.gl.disable(this.gl.RASTERIZER_DISCARD)
                      : this.gl.enable(this.gl.RASTERIZER_DISCARD)));
              }
              setDepthBias(b) {
                this.depthBiasEnabled !== b &&
                  ((this.depthBiasEnabled = b),
                  b
                    ? this.gl.enable(this.gl.POLYGON_OFFSET_FILL)
                    : this.gl.disable(this.gl.POLYGON_OFFSET_FILL));
              }
              setDepthBiasValues(b, M) {
                this.gl.polygonOffset(M, b);
              }
              setStencilTest(b) {
                if (this.stencil !== b) {
                  const M = this.gl;
                  b ? M.enable(M.STENCIL_TEST) : M.disable(M.STENCIL_TEST),
                    (this.stencil = b);
                }
              }
              setStencilFunc(b, M, F) {
                (this.stencilFuncFront !== b ||
                  this.stencilRefFront !== M ||
                  this.stencilMaskFront !== F ||
                  this.stencilFuncBack !== b ||
                  this.stencilRefBack !== M ||
                  this.stencilMaskBack !== F) &&
                  (this.gl.stencilFunc(this.glComparison[b], M, F),
                  (this.stencilFuncFront = this.stencilFuncBack = b),
                  (this.stencilRefFront = this.stencilRefBack = M),
                  (this.stencilMaskFront = this.stencilMaskBack = F));
              }
              setStencilFuncFront(b, M, F) {
                if (
                  this.stencilFuncFront !== b ||
                  this.stencilRefFront !== M ||
                  this.stencilMaskFront !== F
                ) {
                  const z = this.gl;
                  z.stencilFuncSeparate(z.FRONT, this.glComparison[b], M, F),
                    (this.stencilFuncFront = b),
                    (this.stencilRefFront = M),
                    (this.stencilMaskFront = F);
                }
              }
              setStencilFuncBack(b, M, F) {
                if (
                  this.stencilFuncBack !== b ||
                  this.stencilRefBack !== M ||
                  this.stencilMaskBack !== F
                ) {
                  const z = this.gl;
                  z.stencilFuncSeparate(z.BACK, this.glComparison[b], M, F),
                    (this.stencilFuncBack = b),
                    (this.stencilRefBack = M),
                    (this.stencilMaskBack = F);
                }
              }
              setStencilOperation(b, M, F, z) {
                (this.stencilFailFront !== b ||
                  this.stencilZfailFront !== M ||
                  this.stencilZpassFront !== F ||
                  this.stencilFailBack !== b ||
                  this.stencilZfailBack !== M ||
                  this.stencilZpassBack !== F) &&
                  (this.gl.stencilOp(
                    this.glStencilOp[b],
                    this.glStencilOp[M],
                    this.glStencilOp[F]
                  ),
                  (this.stencilFailFront = this.stencilFailBack = b),
                  (this.stencilZfailFront = this.stencilZfailBack = M),
                  (this.stencilZpassFront = this.stencilZpassBack = F)),
                  (this.stencilWriteMaskFront !== z ||
                    this.stencilWriteMaskBack !== z) &&
                    (this.gl.stencilMask(z),
                    (this.stencilWriteMaskFront = z),
                    (this.stencilWriteMaskBack = z));
              }
              setStencilOperationFront(b, M, F, z) {
                (this.stencilFailFront !== b ||
                  this.stencilZfailFront !== M ||
                  this.stencilZpassFront !== F) &&
                  (this.gl.stencilOpSeparate(
                    this.gl.FRONT,
                    this.glStencilOp[b],
                    this.glStencilOp[M],
                    this.glStencilOp[F]
                  ),
                  (this.stencilFailFront = b),
                  (this.stencilZfailFront = M),
                  (this.stencilZpassFront = F)),
                  this.stencilWriteMaskFront !== z &&
                    (this.gl.stencilMaskSeparate(this.gl.FRONT, z),
                    (this.stencilWriteMaskFront = z));
              }
              setStencilOperationBack(b, M, F, z) {
                (this.stencilFailBack !== b ||
                  this.stencilZfailBack !== M ||
                  this.stencilZpassBack !== F) &&
                  (this.gl.stencilOpSeparate(
                    this.gl.BACK,
                    this.glStencilOp[b],
                    this.glStencilOp[M],
                    this.glStencilOp[F]
                  ),
                  (this.stencilFailBack = b),
                  (this.stencilZfailBack = M),
                  (this.stencilZpassBack = F)),
                  this.stencilWriteMaskBack !== z &&
                    (this.gl.stencilMaskSeparate(this.gl.BACK, z),
                    (this.stencilWriteMaskBack = z));
              }
              setBlendState(b) {
                const M = this.blendState;
                if (!M.equals(b)) {
                  const F = this.gl,
                    {
                      blend: z,
                      colorOp: oe,
                      alphaOp: de,
                      colorSrcFactor: ge,
                      colorDstFactor: Re,
                      alphaSrcFactor: Te,
                      alphaDstFactor: Ne,
                    } = b;
                  if (
                    (M.blend !== z &&
                      (z ? F.enable(F.BLEND) : F.disable(F.BLEND)),
                    M.colorOp !== oe || M.alphaOp !== de)
                  ) {
                    const Le = this.glBlendEquation;
                    F.blendEquationSeparate(Le[oe], Le[de]);
                  }
                  (M.colorSrcFactor !== ge ||
                    M.colorDstFactor !== Re ||
                    M.alphaSrcFactor !== Te ||
                    M.alphaDstFactor !== Ne) &&
                    F.blendFuncSeparate(
                      this.glBlendFunctionColor[ge],
                      this.glBlendFunctionColor[Re],
                      this.glBlendFunctionAlpha[Te],
                      this.glBlendFunctionAlpha[Ne]
                    ),
                    M.allWrite !== b.allWrite &&
                      this.gl.colorMask(
                        b.redWrite,
                        b.greenWrite,
                        b.blueWrite,
                        b.alphaWrite
                      ),
                    M.copy(b);
                }
              }
              setBlendColor(b, M, F, z) {
                const oe = this.blendColor;
                (b !== oe.r || M !== oe.g || F !== oe.b || z !== oe.a) &&
                  (this.gl.blendColor(b, M, F, z), oe.set(b, M, F, z));
              }
              setStencilState(b, M) {
                if (b || M)
                  if ((this.setStencilTest(!0), b === M))
                    this.setStencilFunc(b.func, b.ref, b.readMask),
                      this.setStencilOperation(
                        b.fail,
                        b.zfail,
                        b.zpass,
                        b.writeMask
                      );
                  else {
                    var F, z;
                    (F = b) != null || (b = Z.p.DEFAULT),
                      this.setStencilFuncFront(b.func, b.ref, b.readMask),
                      this.setStencilOperationFront(
                        b.fail,
                        b.zfail,
                        b.zpass,
                        b.writeMask
                      ),
                      (z = M) != null || (M = Z.p.DEFAULT),
                      this.setStencilFuncBack(M.func, M.ref, M.readMask),
                      this.setStencilOperationBack(
                        M.fail,
                        M.zfail,
                        M.zpass,
                        M.writeMask
                      );
                  }
                else this.setStencilTest(!1);
              }
              setDepthState(b) {
                const M = this.depthState;
                if (!M.equals(b)) {
                  const F = this.gl,
                    z = b.write;
                  M.write !== z && F.depthMask(z);
                  let { func: oe, test: de } = b;
                  !de && z && ((de = !0), (oe = i.g8z)),
                    M.func !== oe && F.depthFunc(this.glComparison[oe]),
                    M.test !== de &&
                      (de ? F.enable(F.DEPTH_TEST) : F.disable(F.DEPTH_TEST)),
                    M.copy(b);
                }
              }
              setCullMode(b) {
                if (this.cullMode !== b) {
                  if (b === i.OL2) this.gl.disable(this.gl.CULL_FACE);
                  else {
                    this.cullMode === i.OL2 &&
                      this.gl.enable(this.gl.CULL_FACE);
                    const M = this.glCull[b];
                    this.cullFace !== M &&
                      (this.gl.cullFace(M), (this.cullFace = M));
                  }
                  this.cullMode = b;
                }
              }
              setShader(b) {
                if (b !== this.shader) {
                  if (b.failed) return !1;
                  if (!b.ready && !b.impl.finalize(this, b))
                    return (b.failed = !0), !1;
                  (this.shader = b),
                    this.gl.useProgram(b.impl.glProgram),
                    (this.attributesInvalidated = !0);
                }
                return !0;
              }
              getHdrFormat(b, M, F, z) {
                const oe =
                    this.extTextureHalfFloat &&
                    (!M || this.textureHalfFloatRenderable) &&
                    (!F || this.textureHalfFloatUpdatable) &&
                    (!z || this.extTextureHalfFloatLinear),
                  de =
                    this.extTextureFloat &&
                    (!M || this.textureFloatRenderable) &&
                    (!z || this.extTextureFloatLinear);
                return oe && de
                  ? b
                    ? i.uC3
                    : i.a7f
                  : oe
                  ? i.a7f
                  : de
                  ? i.uC3
                  : null;
              }
              clearVertexArrayObjectCache() {
                const b = this.gl;
                this._vaoMap.forEach((M, F, z) => {
                  b.deleteVertexArray(M);
                }),
                  this._vaoMap.clear();
              }
              resizeCanvas(b, M) {
                (this._width = b), (this._height = M);
                const F = Math.min(
                  this._maxPixelRatio,
                  n.J.browser ? window.devicePixelRatio : 1
                );
                (b = Math.floor(b * F)),
                  (M = Math.floor(M * F)),
                  (this.canvas.width !== b || this.canvas.height !== M) &&
                    ((this.canvas.width = b),
                    (this.canvas.height = M),
                    this.fire(e.$.EVENT_RESIZE, b, M));
              }
              get width() {
                return this.gl.drawingBufferWidth || this.canvas.width;
              }
              get height() {
                return this.gl.drawingBufferHeight || this.canvas.height;
              }
              set fullscreen(b) {
                b
                  ? this.gl.canvas.requestFullscreen()
                  : document.exitFullscreen();
              }
              get fullscreen() {
                return !!document.fullscreenElement;
              }
              get textureFloatHighPrecision() {
                return (
                  this._textureFloatHighPrecision === void 0 &&
                    (this._textureFloatHighPrecision = se(this)),
                  this._textureFloatHighPrecision
                );
              }
              get textureHalfFloatUpdatable() {
                return (
                  this._textureHalfFloatUpdatable === void 0 &&
                    (this.webgl2
                      ? (this._textureHalfFloatUpdatable = !0)
                      : (this._textureHalfFloatUpdatable = j(
                          this.gl,
                          this.extTextureHalfFloat.HALF_FLOAT_OES
                        ))),
                  this._textureHalfFloatUpdatable
                );
              }
            }
          },
          8483: (Se, W, a) => {
            "use strict";
            a.d(W, { M: () => g });
            var x = a(7921),
              T = a(1934);
            class g {
              constructor(d, h, f, s) {
                if (
                  ((this.locationId = s),
                  (this.scopeId = d.scope.resolve(h)),
                  (this.version = new T.G()),
                  h.substring(h.length - 3) === "[0]")
                )
                  switch (f) {
                    case x.Cdl:
                      f = x.mQ2;
                      break;
                    case x.d_l:
                      f = x.KdK;
                      break;
                    case x.T73:
                      f = x.m4F;
                      break;
                    case x.nZ6:
                      f = x.QQe;
                      break;
                  }
                (this.dataType = f),
                  (this.value = [null, null, null, null]),
                  (this.array = []);
              }
            }
          },
          5675: (Se, W, a) => {
            "use strict";
            a.d(W, {
              $K: () => G,
              $W: () => at,
              AC: () => B,
              As: () => ht,
              Ax: () => qe,
              B9: () => de,
              Bo: () => Ze,
              Bq: () => he,
              Bx: () => Qt,
              C0: () => x,
              CA: () => Ee,
              Ct: () => Fe,
              Cz: () => yt,
              D5: () => fe,
              Dg: () => U,
              E3: () => Ae,
              EI: () => P,
              EQ: () => Xe,
              Ec: () => j,
              Eq: () => zs,
              FV: () => g,
              FY: () => ei,
              Fe: () => Ys,
              Fi: () => R,
              G9: () => _e,
              GB: () => q,
              GJ: () => we,
              GU: () => Dt,
              HF: () => A,
              HY: () => ks,
              Hb: () => V,
              Hx: () => Ne,
              II: () => oe,
              IJ: () => Ot,
              IU: () => Ke,
              IZ: () => se,
              Ii: () => ct,
              JD: () => ys,
              JQ: () => si,
              JX: () => h,
              Jx: () => T,
              K3: () => ie,
              K5: () => M,
              KV: () => v,
              KW: () => $,
              Kx: () => Re,
              L_: () => r,
              Lx: () => p,
              Ly: () => We,
              MH: () => ls,
              MR: () => xt,
              NB: () => xi,
              NM: () => E,
              Nj: () => _,
              O: () => i,
              O7: () => Tt,
              OE: () => Te,
              OY: () => ke,
              PC: () => ne,
              PD: () => He,
              PI: () => bs,
              QA: () => qt,
              QB: () => o,
              Qh: () => Oe,
              Qk: () => Z,
              R4: () => me,
              R5: () => Et,
              R7: () => hs,
              R9: () => Pe,
              RI: () => $e,
              Rm: () => m,
              SN: () => u,
              T: () => L,
              Tt: () => ft,
              UK: () => Lt,
              Uq: () => Ts,
              V: () => y,
              VF: () => Xs,
              Vy: () => ce,
              WR: () => Le,
              Ww: () => b,
              X2: () => De,
              XI: () => mt,
              YE: () => k,
              Yv: () => Qe,
              Ze: () => ae,
              _Q: () => ws,
              _l: () => ps,
              _m: () => pt,
              aF: () => Is,
              aK: () => it,
              an: () => bt,
              au: () => At,
              b8: () => Kt,
              bC: () => Pt,
              bG: () => J,
              bT: () => ss,
              cJ: () => d,
              cM: () => Ns,
              ci: () => z,
              ck: () => et,
              cm: () => K,
              d7: () => Js,
              dL: () => l,
              dR: () => ue,
              dv: () => X,
              dy: () => F,
              dz: () => jt,
              en: () => rs,
              fQ: () => Mt,
              gv: () => Qs,
              h1: () => c,
              hk: () => Bs,
              hv: () => pe,
              iB: () => N,
              iG: () => Q,
              iH: () => Gt,
              j: () => I,
              j6: () => xe,
              j9: () => Es,
              kU: () => ti,
              kg: () => Ps,
              kj: () => Jt,
              lL: () => Ss,
              m9: () => tt,
              mB: () => Ws,
              mY: () => ot,
              mf: () => Ft,
              mu: () => Ti,
              nr: () => Zs,
              oZ: () => Ie,
              ob: () => O,
              pN: () => w,
              pT: () => ai,
              pU: () => je,
              pp: () => Rt,
              qV: () => Yt,
              qq: () => t,
              rU: () => Y,
              sI: () => ut,
              sT: () => fs,
              sY: () => vt,
              tm: () => be,
              tt: () => C,
              tw: () => e,
              uV: () => Be,
              uk: () => Ve,
              vA: () => n,
              vN: () => s,
              v_: () => zt,
              vi: () => is,
              w9: () => ge,
              wE: () => H,
              wJ: () => Ye,
              wW: () => gt,
              we: () => lt,
              xY: () => f,
              y1: () => st,
              yM: () => ye,
              zL: () => ts,
              zS: () => te,
            });
            const x = "mouse",
              T = "keyboard",
              g = "gamepad",
              c = "mousex",
              d = "mousey",
              h = "padlx",
              f = "padly",
              s = "padrx",
              l = "padry",
              n = "key",
              o = "keydown",
              i = "keyup",
              e = "mousedown",
              t = "mousemove",
              r = "mouseup",
              u = "mousewheel",
              y = "touchstart",
              p = "touchend",
              _ = "touchmove",
              m = "touchcancel",
              E = "select",
              v = "selectstart",
              P = "selectend",
              I = 8,
              A = 9,
              B = 13,
              C = 13,
              w = 16,
              k = 17,
              K = 18,
              te = 19,
              X = 20,
              $ = 27,
              ne = 32,
              Y = 33,
              Z = 34,
              ye = 35,
              pe = 36,
              O = 37,
              me = 38,
              N = 39,
              V = 40,
              L = 44,
              J = 45,
              ae = 46,
              R = 48,
              j = 49,
              se = 50,
              ce = 51,
              ie = 52,
              b = 53,
              M = 54,
              F = 55,
              z = 56,
              oe = 57,
              de = 59,
              ge = 61,
              Re = 65,
              Te = 66,
              Ne = 67,
              Le = 68,
              ke = 69,
              ht = 70,
              _e = 71,
              U = 72,
              H = 73,
              Ee = 74,
              G = 75,
              Q = 76,
              q = 77,
              xe = 78,
              be = 79,
              Pe = 80,
              we = 81,
              Oe = 82,
              $e = 83,
              gt = 84,
              qe = 85,
              Tt = 86,
              Mt = 87,
              Dt = 88,
              ut = 89,
              At = 90,
              xt = 91,
              jt = 93,
              Gt = 96,
              yt = 97,
              Ae = 98,
              Xe = 99,
              Ye = 100,
              it = 101,
              st = 102,
              He = 103,
              at = 104,
              Pt = 105,
              he = 106,
              fe = 107,
              Ie = 108,
              ue = 109,
              De = 110,
              et = 111,
              Ze = 112,
              Ve = 113,
              tt = 114,
              Be = 115,
              ot = 116,
              Qe = 117,
              mt = 118,
              je = 119,
              lt = 120,
              Et = 121,
              ct = 122,
              pt = 123,
              vt = 188,
              Fe = 190,
              Yt = 191,
              Ot = 219,
              Rt = 220,
              Kt = 221,
              Lt = 224,
              Ft = -1,
              Jt = 0,
              zt = 1,
              ss = 2,
              qt = 0,
              fs = 1,
              ls = 2,
              Es = 3,
              Ke = 0,
              hs = 1,
              is = 2,
              ys = 3,
              ps = 4,
              Ns = 5,
              zs = 6,
              bs = 7,
              Ws = 8,
              Ss = 9,
              ws = 10,
              ks = 11,
              Ys = 12,
              Xs = 13,
              Zs = 14,
              We = 15,
              ft = 16,
              bt = 0,
              ts = 1,
              Qt = 2,
              rs = 3,
              Ps = "gamepadconnected",
              Ts = "gamepaddisconnected",
              ei = 0,
              Js = 1,
              ti = 2,
              Bs = 3,
              si = 2,
              Ti = 0,
              xi = 1,
              Is = 3,
              ai = 4,
              Qs = 5;
          },
          9212: (Se, W, a) => {
            "use strict";
            a.d(W, { Q: () => d });
            var x = a(9795),
              T = a(5675),
              g = a(6848),
              c = a(4094);
            class d {
              constructor(f, s = {}) {
                (this._keyboard = s.keyboard || null),
                  (this._mouse = s.mouse || null),
                  (this._gamepads = s.gamepads || null),
                  (this._element = null),
                  (this._actions = {}),
                  (this._axes = {}),
                  (this._axesValues = {}),
                  f && this.attach(f);
              }
              attach(f) {
                (this._element = f),
                  this._keyboard && this._keyboard.attach(f),
                  this._mouse && this._mouse.attach(f);
              }
              detach() {
                this._keyboard && this._keyboard.detach(),
                  this._mouse && this._mouse.detach(),
                  (this._element = null);
              }
              disableContextMenu() {
                this._mouse || this._enableMouse(),
                  this._mouse.disableContextMenu();
              }
              enableContextMenu() {
                this._mouse || this._enableMouse(),
                  this._mouse.enableContextMenu();
              }
              update(f) {
                this._keyboard && this._keyboard.update(),
                  this._mouse && this._mouse.update(),
                  this._gamepads && this._gamepads.update(),
                  (this._axesValues = {});
                for (const s in this._axes) this._axesValues[s] = [];
              }
              appendAction(f, s) {
                (this._actions[f] = this._actions[f] || []),
                  this._actions[f].push(s);
              }
              registerKeys(f, s) {
                if (
                  (this._keyboard || this._enableKeyboard(), this._actions[f])
                )
                  throw new Error(`Action: ${f} already registered`);
                if (s === void 0) throw new Error("Invalid button");
                s.length || (s = [s]),
                  this.appendAction(f, { type: T.Jx, keys: s });
              }
              registerMouse(f, s) {
                if ((this._mouse || this._enableMouse(), s === void 0))
                  throw new Error("Invalid button");
                this.appendAction(f, { type: T.C0, button: s });
              }
              registerPadButton(f, s, l) {
                if (l === void 0) throw new Error("Invalid button");
                this.appendAction(f, { type: T.FV, button: l, pad: s });
              }
              registerAxis(f) {
                const s = f.name;
                this._axes[s] || (this._axes[s] = []);
                const l = this._axes[s].push(s);
                (f = f || {}), (f.pad = f.pad || T.QA);
                const n = function (i, e, t, r) {
                  switch (e) {
                    case "mousex":
                      i._mouse.on(T.qq, function (u) {
                        i._axesValues[s][l] = u.dx / 10;
                      });
                      break;
                    case "mousey":
                      i._mouse.on(T.qq, function (u) {
                        i._axesValues[s][l] = u.dy / 10;
                      });
                      break;
                    case "key":
                      i._axes[s].push(function () {
                        return i._keyboard.isPressed(r) ? t : 0;
                      });
                      break;
                    case "padrx":
                      i._axes[s].push(function () {
                        return i._gamepads.getAxis(f.pad, T.Bx);
                      });
                      break;
                    case "padry":
                      i._axes[s].push(function () {
                        return i._gamepads.getAxis(f.pad, T.en);
                      });
                      break;
                    case "padlx":
                      i._axes[s].push(function () {
                        return i._gamepads.getAxis(f.pad, T.an);
                      });
                      break;
                    case "padly":
                      i._axes[s].push(function () {
                        return i._gamepads.getAxis(f.pad, T.zL);
                      });
                      break;
                    default:
                      throw new Error("Unknown axis");
                  }
                };
                n(this, f.positive, 1, f.positiveKey),
                  (f.negativeKey || f.negative !== f.positive) &&
                    n(this, f.negative, -1, f.negativeKey);
              }
              isPressed(f) {
                if (!this._actions[f]) return !1;
                const s = this._actions[f].length;
                for (let l = 0; l < s; ++l) {
                  const n = this._actions[f][l];
                  switch (n.type) {
                    case T.Jx:
                      if (this._keyboard) {
                        const o = n.keys.length;
                        for (let i = 0; i < o; i++)
                          if (this._keyboard.isPressed(n.keys[i])) return !0;
                      }
                      break;
                    case T.C0:
                      if (this._mouse && this._mouse.isPressed(n.button))
                        return !0;
                      break;
                    case T.FV:
                      if (
                        this._gamepads &&
                        this._gamepads.isPressed(n.pad, n.button)
                      )
                        return !0;
                      break;
                  }
                }
                return !1;
              }
              wasPressed(f) {
                if (!this._actions[f]) return !1;
                const s = this._actions[f].length;
                for (let l = 0; l < s; ++l) {
                  const n = this._actions[f][l];
                  switch (n.type) {
                    case T.Jx:
                      if (this._keyboard) {
                        const o = n.keys.length;
                        for (let i = 0; i < o; i++)
                          if (this._keyboard.wasPressed(n.keys[i])) return !0;
                      }
                      break;
                    case T.C0:
                      if (this._mouse && this._mouse.wasPressed(n.button))
                        return !0;
                      break;
                    case T.FV:
                      if (
                        this._gamepads &&
                        this._gamepads.wasPressed(n.pad, n.button)
                      )
                        return !0;
                      break;
                  }
                }
                return !1;
              }
              getAxis(f) {
                let s = 0;
                if (this._axes[f]) {
                  const l = this._axes[f].length;
                  for (let n = 0; n < l; n++)
                    if ((0, x.dt)(this._axes[f][n]) === "function") {
                      const o = this._axes[f][n]();
                      Math.abs(o) > Math.abs(s) && (s = o);
                    } else
                      this._axesValues[f] &&
                        Math.abs(this._axesValues[f][n]) > Math.abs(s) &&
                        (s = this._axesValues[f][n]);
                }
                return s;
              }
              _enableMouse() {
                if (((this._mouse = new c.T()), !this._element))
                  throw new Error("Controller must be attached to an Element");
                this._mouse.attach(this._element);
              }
              _enableKeyboard() {
                if (((this._keyboard = new g.N()), !this._element))
                  throw new Error("Controller must be attached to an Element");
                this._keyboard.attach(this._element);
              }
            }
          },
          3176: (Se, W, a) => {
            "use strict";
            a.d(W, { pF: () => y });
            var x = a(5338),
              T = a(5675),
              g = a(4585),
              c = a(4444);
            const d = Object.freeze([]);
            let h = function () {
              return d;
            };
            typeof navigator != "undefined" &&
              (h = (
                navigator.getGamepads ||
                navigator.webkitGetGamepads ||
                h
              ).bind(navigator));
            const f = {
                buttons: {
                  PAD_FACE_1: T.IU,
                  PAD_FACE_2: T.R7,
                  PAD_FACE_3: T.vi,
                  PAD_FACE_4: T.JD,
                  PAD_L_SHOULDER_1: T._l,
                  PAD_R_SHOULDER_1: T.cM,
                  PAD_L_SHOULDER_2: T.Eq,
                  PAD_R_SHOULDER_2: T.PI,
                  PAD_SELECT: T.mB,
                  PAD_START: T.lL,
                  PAD_L_STICK_BUTTON: T._Q,
                  PAD_R_STICK_BUTTON: T.HY,
                  PAD_UP: T.Fe,
                  PAD_DOWN: T.VF,
                  PAD_LEFT: T.nr,
                  PAD_RIGHT: T.Ly,
                  PAD_VENDOR: T.Tt,
                  XRPAD_TRIGGER: T.mu,
                  XRPAD_SQUEEZE: T.NB,
                  XRPAD_TOUCHPAD_BUTTON: T.JQ,
                  XRPAD_STICK_BUTTON: T.aF,
                  XRPAD_A: T.pT,
                  XRPAD_B: T.gv,
                },
                axes: {
                  PAD_L_STICK_X: T.an,
                  PAD_L_STICK_Y: T.zL,
                  PAD_R_STICK_X: T.Bx,
                  PAD_R_STICK_Y: T.en,
                  XRPAD_TOUCHPAD_X: T.FY,
                  XRPAD_TOUCHPAD_Y: T.d7,
                  XRPAD_STICK_X: T.kU,
                  XRPAD_STICK_Y: T.hk,
                },
              },
              s = {
                DEFAULT: {
                  buttons: [
                    "PAD_FACE_1",
                    "PAD_FACE_2",
                    "PAD_FACE_3",
                    "PAD_FACE_4",
                    "PAD_L_SHOULDER_1",
                    "PAD_R_SHOULDER_1",
                    "PAD_L_SHOULDER_2",
                    "PAD_R_SHOULDER_2",
                    "PAD_SELECT",
                    "PAD_START",
                    "PAD_L_STICK_BUTTON",
                    "PAD_R_STICK_BUTTON",
                    "PAD_UP",
                    "PAD_DOWN",
                    "PAD_LEFT",
                    "PAD_RIGHT",
                    "PAD_VENDOR",
                  ],
                  axes: [
                    "PAD_L_STICK_X",
                    "PAD_L_STICK_Y",
                    "PAD_R_STICK_X",
                    "PAD_R_STICK_Y",
                  ],
                },
                DEFAULT_DUAL: {
                  buttons: [
                    "PAD_FACE_1",
                    "PAD_FACE_2",
                    "PAD_FACE_3",
                    "PAD_FACE_4",
                    "PAD_L_SHOULDER_1",
                    "PAD_R_SHOULDER_1",
                    "PAD_L_SHOULDER_2",
                    "PAD_R_SHOULDER_2",
                    "PAD_SELECT",
                    "PAD_START",
                    "PAD_L_STICK_BUTTON",
                    "PAD_R_STICK_BUTTON",
                    "PAD_VENDOR",
                  ],
                  axes: [
                    "PAD_L_STICK_X",
                    "PAD_L_STICK_Y",
                    "PAD_R_STICK_X",
                    "PAD_R_STICK_Y",
                  ],
                  synthesizedButtons: {
                    PAD_UP: { axis: 0, min: 0, max: 1 },
                    PAD_DOWN: { axis: 0, min: -1, max: 0 },
                    PAD_LEFT: { axis: 0, min: -1, max: 0 },
                    PAD_RIGHT: { axis: 0, min: 0, max: 1 },
                  },
                },
                PS3: {
                  buttons: [
                    "PAD_FACE_1",
                    "PAD_FACE_2",
                    "PAD_FACE_4",
                    "PAD_FACE_3",
                    "PAD_L_SHOULDER_1",
                    "PAD_R_SHOULDER_1",
                    "PAD_L_SHOULDER_2",
                    "PAD_R_SHOULDER_2",
                    "PAD_SELECT",
                    "PAD_START",
                    "PAD_L_STICK_BUTTON",
                    "PAD_R_STICK_BUTTON",
                    "PAD_UP",
                    "PAD_DOWN",
                    "PAD_LEFT",
                    "PAD_RIGHT",
                    "PAD_VENDOR",
                  ],
                  axes: [
                    "PAD_L_STICK_X",
                    "PAD_L_STICK_Y",
                    "PAD_R_STICK_X",
                    "PAD_R_STICK_Y",
                  ],
                  mapping: "standard",
                },
                DEFAULT_XR: {
                  buttons: [
                    "XRPAD_TRIGGER",
                    "XRPAD_SQUEEZE",
                    "XRPAD_TOUCHPAD_BUTTON",
                    "XRPAD_STICK_BUTTON",
                    "XRPAD_A",
                    "XRPAD_B",
                  ],
                  axes: [
                    "XRPAD_TOUCHPAD_X",
                    "XRPAD_TOUCHPAD_Y",
                    "XRPAD_STICK_X",
                    "XRPAD_STICK_Y",
                  ],
                  mapping: "xr-standard",
                },
              },
              l = { "Product: 0268": "PS3" },
              n = {};
            function o(p) {
              const _ = n[p.id];
              if (_) return _;
              for (const v in l)
                if (p.id.indexOf(v) !== -1) {
                  const P = l[v];
                  if (!p.mapping) {
                    const I = s["RAW_" + P];
                    if (I) return I;
                  }
                  return s[P];
                }
              if (p.mapping === "xr-standard") return s.DEFAULT_XR;
              const m = s.DEFAULT,
                E = p.buttons.length < m.buttons.length ? s.DEFAULT_DUAL : m;
              return (E.mapping = p.mapping), E;
            }
            let i = 0.25;
            function e(p) {
              return new Promise((_) => {
                setTimeout(_, p);
              });
            }
            class t {
              constructor(_, m) {
                if (
                  ((this.value = 0),
                  (this.pressed = !1),
                  (this.touched = !1),
                  (this.wasPressed = !1),
                  (this.wasReleased = !1),
                  (this.wasTouched = !1),
                  typeof _ == "number")
                )
                  (this.value = _),
                    (this.pressed = _ === 1),
                    (this.touched = _ > 0);
                else {
                  var E;
                  (this.value = _.value),
                    (this.pressed = _.pressed),
                    (this.touched = (E = _.touched) != null ? E : _.value > 0);
                }
                if (m)
                  if (typeof m == "number")
                    (this.wasPressed = m !== 1 && this.pressed),
                      (this.wasReleased = m === 1 && !this.pressed),
                      (this.wasTouched = m === 0 && this.touched);
                  else {
                    var v;
                    (this.wasPressed = !m.pressed && this.pressed),
                      (this.wasReleased = m.pressed && !this.pressed),
                      (this.wasTouched =
                        !((v = m.touched) != null ? v : m.value > 0) &&
                        this.touched);
                  }
              }
              update(_) {
                var m;
                const { value: E, pressed: v } = _,
                  P = (m = _.touched) != null ? m : E > 0;
                (this.wasPressed = !this.pressed && v),
                  (this.wasReleased = this.pressed && !v),
                  (this.wasTouched = !this.touched && P),
                  (this.value = E),
                  (this.pressed = v),
                  (this.touched = P);
              }
            }
            const r = Object.freeze(new t(0));
            class u {
              constructor(_, m) {
                (this._compiledMapping = { buttons: [], axes: [] }),
                  (this.id = _.id),
                  (this.index = _.index),
                  (this._buttons = _.buttons.map((E) => new t(E))),
                  (this._axes = [..._.axes]),
                  (this._previousAxes = [..._.axes]),
                  (this.mapping = m.mapping),
                  (this.map = m),
                  (this.hand = _.hand || "none"),
                  (this.pad = _),
                  this._compileMapping();
              }
              get connected() {
                return this.pad.connected;
              }
              _compileMapping() {
                const { axes: _, buttons: m } = this._compiledMapping,
                  E = f.axes,
                  v = f.buttons;
                (_.length = 0),
                  (m.length = 0),
                  this.map.axes &&
                    this.map.axes.forEach((B, C) => {
                      _[E[B]] = () => this.pad.axes[C] || 0;
                    });
                for (let B = 0, C = _.length; B < C; B++)
                  _[B] || (_[B] = () => 0);
                const I = this.map.buttons;
                I &&
                  I.forEach((B, C) => {
                    m[v[B]] = () => this._buttons[C] || r;
                  });
                const A = this.map.synthesizedButtons;
                A &&
                  Object.entries(A).forEach((B) => {
                    const { axis: C, max: w, min: k } = B[1];
                    m[v[B[0]]] = () => {
                      var K, te;
                      return new t(
                        Math.abs(
                          g.m.clamp((K = this._axes[C]) != null ? K : 0, k, w)
                        ),
                        Math.abs(
                          g.m.clamp(
                            (te = this._previousAxes[C]) != null ? te : 0,
                            k,
                            w
                          )
                        )
                      );
                    };
                  });
                for (let B = 0, C = m.length; B < C; B++)
                  m[B] || (m[B] = () => r);
              }
              update(_) {
                this.pad = _;
                const m = this._previousAxes,
                  E = this._axes;
                (m.length = 0), m.push(...E), (E.length = 0), E.push(..._.axes);
                const v = this._buttons;
                for (let P = 0, I = v.length; P < I; P++)
                  v[P].update(_.buttons[P]);
                return this;
              }
              updateMap(_) {
                (_.mapping = "custom"),
                  (n[this.id] = _),
                  (this.map = _),
                  (this.mapping = "custom"),
                  this._compileMapping();
              }
              resetMap() {
                if (n[this.id]) {
                  delete n[this.id];
                  const _ = o(this.pad);
                  (this.map = _),
                    (this.mapping = _.mapping),
                    this._compileMapping();
                }
              }
              get axes() {
                return this._compiledMapping.axes.map((_) => _());
              }
              get buttons() {
                return this._compiledMapping.buttons.map((_) => _());
              }
              pulse(_, m, E) {
                return pn(this, null, function* () {
                  const v = this.pad.vibrationActuator
                    ? [this.pad.vibrationActuator]
                    : this.pad.hapticActuators || d;
                  if (v.length) {
                    var P, I, A;
                    const B =
                        (P = E == null ? void 0 : E.startDelay) != null ? P : 0,
                      C =
                        (I = E == null ? void 0 : E.strongMagnitude) != null
                          ? I
                          : _,
                      w =
                        (A = E == null ? void 0 : E.weakMagnitude) != null
                          ? A
                          : _;
                    return (yield Promise.all(
                      v.map(function (K) {
                        return pn(this, null, function* () {
                          return K
                            ? K.playEffect
                              ? K.playEffect(K.type, {
                                  duration: m,
                                  startDelay: B,
                                  strongMagnitude: C,
                                  weakMagnitude: w,
                                })
                              : K.pulse
                              ? (yield e(B), K.pulse(_, m))
                              : !1
                            : !0;
                        });
                      })
                    )).some((K) => K === !0 || K === "complete");
                  }
                  return !1;
                });
              }
              getButton(_) {
                const m = this._compiledMapping.buttons[_];
                return m ? m() : r;
              }
              isPressed(_) {
                return this.getButton(_).pressed;
              }
              wasPressed(_) {
                return this.getButton(_).wasPressed;
              }
              wasReleased(_) {
                return this.getButton(_).wasReleased;
              }
              isTouched(_) {
                return this.getButton(_).touched;
              }
              wasTouched(_) {
                return this.getButton(_).wasTouched;
              }
              getValue(_) {
                return this.getButton(_).value;
              }
              getAxis(_) {
                const m = this.axes[_];
                return m && Math.abs(m) > i ? m : 0;
              }
            }
            class y extends x.b {
              constructor() {
                super(),
                  (this.gamepadsSupported = c.J.gamepads),
                  (this.current = []),
                  (this._previous = []),
                  (this._ongamepadconnectedHandler =
                    this._ongamepadconnected.bind(this)),
                  (this._ongamepaddisconnectedHandler =
                    this._ongamepaddisconnected.bind(this)),
                  window.addEventListener(
                    "gamepadconnected",
                    this._ongamepadconnectedHandler,
                    !1
                  ),
                  window.addEventListener(
                    "gamepaddisconnected",
                    this._ongamepaddisconnectedHandler,
                    !1
                  ),
                  this.poll();
              }
              set deadZone(_) {
                i = _;
              }
              get deadZone() {
                return i;
              }
              get previous() {
                const _ = this.current;
                for (let m = 0, E = _.length; m < E; m++) {
                  const v = _[m]._buttons;
                  this._previous[m] || (this._previous[m] = []);
                  for (let P = 0, I = v.length; P < I; P++) {
                    const A = v[m];
                    this.previous[m][P] = A
                      ? (!A.wasPressed && A.pressed) || A.wasReleased
                      : !1;
                  }
                }
                return (
                  (this._previous.length = this.current.length), this._previous
                );
              }
              _ongamepadconnected(_) {
                const m = new u(_.gamepad, this.getMap(_.gamepad)),
                  E = this.current;
                let v = E.findIndex((P) => P.index === m.index);
                for (; v !== -1; )
                  E.splice(v, 1), (v = E.findIndex((P) => P.index === m.index));
                E.push(m), this.fire(T.kg, m);
              }
              _ongamepaddisconnected(_) {
                const m = this.current,
                  E = m.findIndex((v) => v.index === _.gamepad.index);
                E !== -1 && (this.fire(T.Uq, m[E]), m.splice(E, 1));
              }
              update() {
                this.poll();
              }
              poll(_ = []) {
                _.length > 0 && (_.length = 0);
                const m = h();
                for (let E = 0, v = m.length; E < v; E++)
                  if (m[E]) {
                    const P = this.findByIndex(m[E].index);
                    if (P) _.push(P.update(m[E]));
                    else {
                      const I = new u(m[E], this.getMap(m[E]));
                      this.current.push(I), _.push(I);
                    }
                  }
                return _;
              }
              destroy() {
                window.removeEventListener(
                  "gamepadconnected",
                  this._ongamepadconnectedHandler,
                  !1
                ),
                  window.removeEventListener(
                    "gamepaddisconnected",
                    this._ongamepaddisconnectedHandler,
                    !1
                  );
              }
              getMap(_) {
                return o(_);
              }
              isPressed(_, m) {
                var E;
                return (
                  ((E = this.current[_]) == null ? void 0 : E.isPressed(m)) ||
                  !1
                );
              }
              wasPressed(_, m) {
                var E;
                return (
                  ((E = this.current[_]) == null ? void 0 : E.wasPressed(m)) ||
                  !1
                );
              }
              wasReleased(_, m) {
                var E;
                return (
                  ((E = this.current[_]) == null ? void 0 : E.wasReleased(m)) ||
                  !1
                );
              }
              getAxis(_, m) {
                var E;
                return (
                  ((E = this.current[_]) == null ? void 0 : E.getAxis(m)) || 0
                );
              }
              pulse(_, m, E, v) {
                const P = this.current[_];
                return P ? P.pulse(m, E, v) : Promise.resolve(!1);
              }
              pulseAll(_, m, E) {
                return Promise.all(this.current.map((v) => v.pulse(_, m, E)));
              }
              findById(_) {
                return this.current.find((m) => m && m.id === _) || null;
              }
              findByIndex(_) {
                return this.current.find((m) => m && m.index === _) || null;
              }
            }
          },
          9818: (Se, W, a) => {
            "use strict";
            a.d(W, { _: () => x });
            class x {
              constructor(g, c) {
                c
                  ? ((this.key = c.keyCode),
                    (this.element = c.target),
                    (this.event = c))
                  : ((this.key = null),
                    (this.element = null),
                    (this.event = null));
              }
            }
          },
          6848: (Se, W, a) => {
            "use strict";
            a.d(W, { N: () => f });
            var x = a(5338),
              T = a(9818);
            const g = new T._();
            function c(s) {
              return (
                (g.key = s.keyCode), (g.element = s.target), (g.event = s), g
              );
            }
            function d(s) {
              return typeof s == "string" ? s.toUpperCase().charCodeAt(0) : s;
            }
            const h = {
              9: "Tab",
              13: "Enter",
              16: "Shift",
              17: "Control",
              18: "Alt",
              27: "Escape",
              37: "Left",
              38: "Up",
              39: "Right",
              40: "Down",
              46: "Delete",
              91: "Win",
            };
            class f extends x.b {
              constructor(l, n = {}) {
                super(),
                  (this._element = null),
                  (this._keyDownHandler = this._handleKeyDown.bind(this)),
                  (this._keyUpHandler = this._handleKeyUp.bind(this)),
                  (this._keyPressHandler = this._handleKeyPress.bind(this)),
                  (this._visibilityChangeHandler =
                    this._handleVisibilityChange.bind(this)),
                  (this._windowBlurHandler = this._handleWindowBlur.bind(this)),
                  (this._keymap = {}),
                  (this._lastmap = {}),
                  l && this.attach(l),
                  (this.preventDefault = n.preventDefault || !1),
                  (this.stopPropagation = n.stopPropagation || !1);
              }
              attach(l) {
                this._element && this.detach(),
                  (this._element = l),
                  this._element.addEventListener(
                    "keydown",
                    this._keyDownHandler,
                    !1
                  ),
                  this._element.addEventListener(
                    "keypress",
                    this._keyPressHandler,
                    !1
                  ),
                  this._element.addEventListener(
                    "keyup",
                    this._keyUpHandler,
                    !1
                  ),
                  document.addEventListener(
                    "visibilitychange",
                    this._visibilityChangeHandler,
                    !1
                  ),
                  window.addEventListener("blur", this._windowBlurHandler, !1);
              }
              detach() {
                this._element &&
                  (this._element.removeEventListener(
                    "keydown",
                    this._keyDownHandler
                  ),
                  this._element.removeEventListener(
                    "keypress",
                    this._keyPressHandler
                  ),
                  this._element.removeEventListener(
                    "keyup",
                    this._keyUpHandler
                  ),
                  (this._element = null),
                  document.removeEventListener(
                    "visibilitychange",
                    this._visibilityChangeHandler,
                    !1
                  ),
                  window.removeEventListener(
                    "blur",
                    this._windowBlurHandler,
                    !1
                  ));
              }
              toKeyIdentifier(l) {
                l = d(l);
                const n = h[l.toString()];
                if (n) return n;
                let o = l.toString(16).toUpperCase();
                const i = o.length;
                for (let e = 0; e < 4 - i; e++) o = "0" + o;
                return "U+" + o;
              }
              _handleKeyDown(l) {
                const n = l.keyCode || l.charCode;
                if (n === void 0) return;
                const o = this.toKeyIdentifier(n);
                (this._keymap[o] = !0),
                  this.fire("keydown", c(l)),
                  this.preventDefault && l.preventDefault(),
                  this.stopPropagation && l.stopPropagation();
              }
              _handleKeyUp(l) {
                const n = l.keyCode || l.charCode;
                if (n === void 0) return;
                const o = this.toKeyIdentifier(n);
                delete this._keymap[o],
                  this.fire("keyup", c(l)),
                  this.preventDefault && l.preventDefault(),
                  this.stopPropagation && l.stopPropagation();
              }
              _handleKeyPress(l) {
                this.fire("keypress", c(l)),
                  this.preventDefault && l.preventDefault(),
                  this.stopPropagation && l.stopPropagation();
              }
              _handleVisibilityChange() {
                document.visibilityState === "hidden" &&
                  this._handleWindowBlur();
              }
              _handleWindowBlur() {
                (this._keymap = {}), (this._lastmap = {});
              }
              update() {
                for (const l in this._lastmap) delete this._lastmap[l];
                for (const l in this._keymap)
                  this._keymap.hasOwnProperty(l) &&
                    (this._lastmap[l] = this._keymap[l]);
              }
              isPressed(l) {
                const n = d(l),
                  o = this.toKeyIdentifier(n);
                return !!this._keymap[o];
              }
              wasPressed(l) {
                const n = d(l),
                  o = this.toKeyIdentifier(n);
                return !!this._keymap[o] && !this._lastmap[o];
              }
              wasReleased(l) {
                const n = d(l),
                  o = this.toKeyIdentifier(n);
                return !this._keymap[o] && !!this._lastmap[o];
              }
            }
          },
          6135: (Se, W, a) => {
            "use strict";
            a.d(W, { T: () => g, j: () => T });
            var x = a(5675);
            function T() {
              return !!(
                document.pointerLockElement ||
                document.mozPointerLockElement ||
                document.webkitPointerLockElement
              );
            }
            class g {
              constructor(d, h) {
                let f = { x: 0, y: 0 };
                if (h) {
                  if (h instanceof g) throw Error("Expected MouseEvent");
                  f = d._getTargetCoords(h);
                } else h = {};
                if (f) (this.x = f.x), (this.y = f.y);
                else if (T()) (this.x = 0), (this.y = 0);
                else return;
                (this.wheelDelta = 0),
                  h.type === "wheel" &&
                    (h.deltaY > 0
                      ? (this.wheelDelta = 1)
                      : h.deltaY < 0 && (this.wheelDelta = -1)),
                  T()
                    ? ((this.dx =
                        h.movementX ||
                        h.webkitMovementX ||
                        h.mozMovementX ||
                        0),
                      (this.dy =
                        h.movementY ||
                        h.webkitMovementY ||
                        h.mozMovementY ||
                        0))
                    : ((this.dx = this.x - d._lastX),
                      (this.dy = this.y - d._lastY)),
                  h.type === "mousedown" || h.type === "mouseup"
                    ? (this.button = h.button)
                    : (this.button = x.mf),
                  (this.buttons = d._buttons.slice(0)),
                  (this.element = h.target),
                  (this.ctrlKey = h.ctrlKey || !1),
                  (this.altKey = h.altKey || !1),
                  (this.shiftKey = h.shiftKey || !1),
                  (this.metaKey = h.metaKey || !1),
                  (this.event = h);
              }
            }
          },
          4094: (Se, W, a) => {
            "use strict";
            a.d(W, { T: () => d });
            var x = a(4444),
              T = a(5338),
              g = a(5675),
              c = a(6135);
            class d extends T.b {
              constructor(f) {
                super(),
                  (this._lastX = 0),
                  (this._lastY = 0),
                  (this._buttons = [!1, !1, !1]),
                  (this._lastbuttons = [!1, !1, !1]),
                  (this._upHandler = this._handleUp.bind(this)),
                  (this._downHandler = this._handleDown.bind(this)),
                  (this._moveHandler = this._handleMove.bind(this)),
                  (this._wheelHandler = this._handleWheel.bind(this)),
                  (this._contextMenuHandler = (s) => {
                    s.preventDefault();
                  }),
                  (this._target = null),
                  (this._attached = !1),
                  this.attach(f);
              }
              static isPointerLocked() {
                return (0, c.j)();
              }
              attach(f) {
                if (((this._target = f), this._attached)) return;
                this._attached = !0;
                const s = x.J.passiveEvents ? { passive: !1 } : !1;
                window.addEventListener("mouseup", this._upHandler, s),
                  window.addEventListener("mousedown", this._downHandler, s),
                  window.addEventListener("mousemove", this._moveHandler, s),
                  window.addEventListener("wheel", this._wheelHandler, s);
              }
              detach() {
                if (!this._attached) return;
                (this._attached = !1), (this._target = null);
                const f = x.J.passiveEvents ? { passive: !1 } : !1;
                window.removeEventListener("mouseup", this._upHandler, f),
                  window.removeEventListener("mousedown", this._downHandler, f),
                  window.removeEventListener("mousemove", this._moveHandler, f),
                  window.removeEventListener("wheel", this._wheelHandler, f);
              }
              disableContextMenu() {
                this._target &&
                  this._target.addEventListener(
                    "contextmenu",
                    this._contextMenuHandler
                  );
              }
              enableContextMenu() {
                this._target &&
                  this._target.removeEventListener(
                    "contextmenu",
                    this._contextMenuHandler
                  );
              }
              enablePointerLock(f, s) {
                if (!document.body.requestPointerLock) {
                  s && s();
                  return;
                }
                const l = () => {
                    f(), document.removeEventListener("pointerlockchange", l);
                  },
                  n = () => {
                    s(), document.removeEventListener("pointerlockerror", n);
                  };
                f && document.addEventListener("pointerlockchange", l, !1),
                  s && document.addEventListener("pointerlockerror", n, !1),
                  document.body.requestPointerLock();
              }
              disablePointerLock(f) {
                if (!document.exitPointerLock) return;
                const s = () => {
                  f(), document.removeEventListener("pointerlockchange", s);
                };
                f && document.addEventListener("pointerlockchange", s, !1),
                  document.exitPointerLock();
              }
              update() {
                (this._lastbuttons[0] = this._buttons[0]),
                  (this._lastbuttons[1] = this._buttons[1]),
                  (this._lastbuttons[2] = this._buttons[2]);
              }
              isPressed(f) {
                return this._buttons[f];
              }
              wasPressed(f) {
                return this._buttons[f] && !this._lastbuttons[f];
              }
              wasReleased(f) {
                return !this._buttons[f] && this._lastbuttons[f];
              }
              _handleUp(f) {
                this._buttons[f.button] = !1;
                const s = new c.T(this, f);
                s.event && this.fire(g.L_, s);
              }
              _handleDown(f) {
                this._buttons[f.button] = !0;
                const s = new c.T(this, f);
                s.event && this.fire(g.tw, s);
              }
              _handleMove(f) {
                const s = new c.T(this, f);
                s.event &&
                  (this.fire(g.qq, s),
                  (this._lastX = s.x),
                  (this._lastY = s.y));
              }
              _handleWheel(f) {
                const s = new c.T(this, f);
                s.event && this.fire(g.SN, s);
              }
              _getTargetCoords(f) {
                const s = this._target.getBoundingClientRect(),
                  l = Math.floor(s.left),
                  n = Math.floor(s.top);
                return f.clientX < l ||
                  f.clientX >= l + this._target.clientWidth ||
                  f.clientY < n ||
                  f.clientY >= n + this._target.clientHeight
                  ? null
                  : { x: f.clientX - l, y: f.clientY - n };
              }
            }
          },
          5593: (Se, W, a) => {
            "use strict";
            a.d(W, { S: () => g });
            var x = a(5338),
              T = a(4946);
            class g extends x.b {
              constructor(d) {
                super(),
                  (this._element = null),
                  (this._startHandler = this._handleTouchStart.bind(this)),
                  (this._endHandler = this._handleTouchEnd.bind(this)),
                  (this._moveHandler = this._handleTouchMove.bind(this)),
                  (this._cancelHandler = this._handleTouchCancel.bind(this)),
                  this.attach(d);
              }
              attach(d) {
                this._element && this.detach(),
                  (this._element = d),
                  this._element.addEventListener(
                    "touchstart",
                    this._startHandler,
                    !1
                  ),
                  this._element.addEventListener(
                    "touchend",
                    this._endHandler,
                    !1
                  ),
                  this._element.addEventListener(
                    "touchmove",
                    this._moveHandler,
                    !1
                  ),
                  this._element.addEventListener(
                    "touchcancel",
                    this._cancelHandler,
                    !1
                  );
              }
              detach() {
                this._element &&
                  (this._element.removeEventListener(
                    "touchstart",
                    this._startHandler,
                    !1
                  ),
                  this._element.removeEventListener(
                    "touchend",
                    this._endHandler,
                    !1
                  ),
                  this._element.removeEventListener(
                    "touchmove",
                    this._moveHandler,
                    !1
                  ),
                  this._element.removeEventListener(
                    "touchcancel",
                    this._cancelHandler,
                    !1
                  )),
                  (this._element = null);
              }
              _handleTouchStart(d) {
                this.fire("touchstart", new T.Wb(this, d));
              }
              _handleTouchEnd(d) {
                this.fire("touchend", new T.Wb(this, d));
              }
              _handleTouchMove(d) {
                d.preventDefault(), this.fire("touchmove", new T.Wb(this, d));
              }
              _handleTouchCancel(d) {
                this.fire("touchcancel", new T.Wb(this, d));
              }
            }
          },
          4946: (Se, W, a) => {
            "use strict";
            a.d(W, { Wb: () => g, Xh: () => T, kX: () => x });
            function x(c) {
              let d = 0,
                h = 0,
                f = c.target;
              for (; !(f instanceof HTMLElement); ) f = f.parentNode;
              let s = f;
              do
                (d += s.offsetLeft - s.scrollLeft),
                  (h += s.offsetTop - s.scrollTop),
                  (s = s.offsetParent);
              while (s);
              return { x: c.pageX - d, y: c.pageY - h };
            }
            class T {
              constructor(d) {
                const h = x(d);
                (this.id = d.identifier),
                  (this.x = h.x),
                  (this.y = h.y),
                  (this.target = d.target),
                  (this.touch = d);
              }
            }
            class g {
              constructor(d, h) {
                if (
                  ((this.element = h.target),
                  (this.event = h),
                  (this.touches = []),
                  (this.changedTouches = []),
                  h)
                ) {
                  for (let f = 0, s = h.touches.length; f < s; f++)
                    this.touches.push(new T(h.touches[f]));
                  for (let f = 0, s = h.changedTouches.length; f < s; f++)
                    this.changedTouches.push(new T(h.changedTouches[f]));
                }
              }
              getTouchById(d, h) {
                for (let f = 0, s = h.length; f < s; f++)
                  if (h[f].id === d) return h[f];
                return null;
              }
            }
          },
          1467: (Se, W, a) => {
            "use strict";
            a.d(W, { d: () => f, e: () => h });
            var x = a(9795),
              T = a(3821),
              g = a(9296),
              c = a(959),
              d = a(4585);
            class h {
              get(l, n, o) {
                return (
                  typeof n == "function" && ((o = n), (n = {})),
                  this.request("GET", l, n, o)
                );
              }
              post(l, n, o, i) {
                return (
                  typeof o == "function" && ((i = o), (o = {})),
                  (o.postdata = n),
                  this.request("POST", l, o, i)
                );
              }
              put(l, n, o, i) {
                return (
                  typeof o == "function" && ((i = o), (o = {})),
                  (o.postdata = n),
                  this.request("PUT", l, o, i)
                );
              }
              del(l, n, o) {
                return (
                  typeof n == "function" && ((o = n), (n = {})),
                  this.request("DELETE", l, n, o)
                );
              }
              request(l, n, o, i) {
                let e,
                  t,
                  r,
                  u = !1;
                if (
                  (typeof o == "function" && ((i = o), (o = {})),
                  o.retry &&
                    (o = Object.assign({ retries: 0, maxRetries: 5 }, o)),
                  (o.callback = i),
                  o.async == null && (o.async = !0),
                  o.headers == null && (o.headers = {}),
                  o.postdata != null)
                )
                  if (o.postdata instanceof Document) r = o.postdata;
                  else if (o.postdata instanceof FormData) r = o.postdata;
                  else if (o.postdata instanceof Object) {
                    let p = o.headers["Content-Type"];
                    switch (
                      (p === void 0 &&
                        ((o.headers["Content-Type"] =
                          h.ContentType.FORM_URLENCODED),
                        (p = o.headers["Content-Type"])),
                      p)
                    ) {
                      case h.ContentType.FORM_URLENCODED: {
                        r = "";
                        let _ = !0;
                        for (const m in o.postdata)
                          if (o.postdata.hasOwnProperty(m)) {
                            _ ? (_ = !1) : (r += "&");
                            const E = encodeURIComponent(m),
                              v = encodeURIComponent(o.postdata[m]);
                            r += `${E}=${v}`;
                          }
                        break;
                      }
                      default:
                      case h.ContentType.JSON:
                        p == null &&
                          (o.headers["Content-Type"] = h.ContentType.JSON),
                          (r = JSON.stringify(o.postdata));
                        break;
                    }
                  } else r = o.postdata;
                if (o.cache === !1) {
                  const p = (0, T.z)();
                  (e = new c.o(n)),
                    e.query
                      ? (e.query = e.query + "&ts=" + p)
                      : (e.query = "ts=" + p),
                    (n = e.toString());
                }
                o.query &&
                  ((e = new c.o(n)),
                  (t = (0, x.l7)(e.getQuery(), o.query)),
                  e.setQuery(t),
                  (n = e.toString()));
                const y = new XMLHttpRequest();
                y.open(l, n, o.async),
                  (y.withCredentials =
                    o.withCredentials !== void 0 ? o.withCredentials : !1),
                  (y.responseType =
                    o.responseType || this._guessResponseType(n));
                for (const p in o.headers)
                  o.headers.hasOwnProperty(p) &&
                    y.setRequestHeader(p, o.headers[p]);
                (y.onreadystatechange = () => {
                  this._onReadyStateChange(l, n, o, y);
                }),
                  (y.onerror = () => {
                    this._onError(l, n, o, y), (u = !0);
                  });
                try {
                  y.send(r);
                } catch (p) {
                  u || o.error(y.status, y, p);
                }
                return y;
              }
              _guessResponseType(l) {
                const n = new c.o(l),
                  o = g.E.getExtension(n.path).toLowerCase();
                return h.binaryExtensions.indexOf(o) >= 0
                  ? h.ResponseType.ARRAY_BUFFER
                  : o === ".json"
                  ? h.ResponseType.JSON
                  : o === ".xml"
                  ? h.ResponseType.DOCUMENT
                  : h.ResponseType.TEXT;
              }
              _isBinaryContentType(l) {
                return (
                  [
                    h.ContentType.BASIS,
                    h.ContentType.BIN,
                    h.ContentType.DDS,
                    h.ContentType.GLB,
                    h.ContentType.MP3,
                    h.ContentType.MP4,
                    h.ContentType.OGG,
                    h.ContentType.OPUS,
                    h.ContentType.WAV,
                  ].indexOf(l) >= 0
                );
              }
              _isBinaryResponseType(l) {
                return (
                  l === h.ResponseType.ARRAY_BUFFER ||
                  l === h.ResponseType.BLOB ||
                  l === h.ResponseType.JSON
                );
              }
              _onReadyStateChange(l, n, o, i) {
                if (i.readyState === 4)
                  switch (i.status) {
                    case 0: {
                      i.responseURL && i.responseURL.startsWith("file:///")
                        ? this._onSuccess(l, n, o, i)
                        : this._onError(l, n, o, i);
                      break;
                    }
                    case 200:
                    case 201:
                    case 206:
                    case 304: {
                      this._onSuccess(l, n, o, i);
                      break;
                    }
                    default: {
                      this._onError(l, n, o, i);
                      break;
                    }
                  }
              }
              _onSuccess(l, n, o, i) {
                let e, t;
                const r = i.getResponseHeader("Content-Type");
                r && (t = r.split(";")[0].trim());
                try {
                  this._isBinaryContentType(t) ||
                  this._isBinaryResponseType(i.responseType)
                    ? (e = i.response)
                    : t === h.ContentType.JSON ||
                      n.split("?")[0].endsWith(".json")
                    ? (e = JSON.parse(i.responseText))
                    : i.responseType === h.ResponseType.DOCUMENT ||
                      t === h.ContentType.XML
                    ? (e = i.responseXML)
                    : (e = i.responseText),
                    o.callback(null, e);
                } catch (u) {
                  o.callback(u);
                }
              }
              _onError(l, n, o, i) {
                if (!o.retrying)
                  if (o.retry && o.retries < o.maxRetries) {
                    o.retries++, (o.retrying = !0);
                    const e = d.m.clamp(
                      Math.pow(2, o.retries) * h.retryDelay,
                      0,
                      o.maxRetryDelay || 5e3
                    );
                    console.log(
                      `${l}: ${n} - Error ${i.status}. Retrying in ${e} ms`
                    ),
                      setTimeout(() => {
                        (o.retrying = !1), this.request(l, n, o, o.callback);
                      }, e);
                  } else
                    o.callback(
                      i.status === 0 ? "Network error" : i.status,
                      null
                    );
              }
            }
            (h.ContentType = {
              AAC: "audio/aac",
              BASIS: "image/basis",
              BIN: "application/octet-stream",
              DDS: "image/dds",
              FORM_URLENCODED: "application/x-www-form-urlencoded",
              GIF: "image/gif",
              GLB: "model/gltf-binary",
              JPEG: "image/jpeg",
              JSON: "application/json",
              MP3: "audio/mpeg",
              MP4: "audio/mp4",
              OGG: "audio/ogg",
              OPUS: 'audio/ogg; codecs="opus"',
              PNG: "image/png",
              TEXT: "text/plain",
              WAV: "audio/x-wav",
              XML: "application/xml",
            }),
              (h.ResponseType = {
                TEXT: "text",
                ARRAY_BUFFER: "arraybuffer",
                BLOB: "blob",
                DOCUMENT: "document",
                JSON: "json",
              }),
              (h.binaryExtensions = [
                ".model",
                ".wav",
                ".ogg",
                ".mp3",
                ".mp4",
                ".m4a",
                ".aac",
                ".dds",
                ".basis",
                ".glb",
                ".opus",
              ]),
              (h.retryDelay = 100);
            const f = new h();
          },
          3467: (Se, W, a) => {
            "use strict";
            a.d(W, { J: () => s });
            var x = a(5338),
              T = a(4585),
              g = a(2100);
            const c = 0,
              d = 1,
              h = 2;
            function f(l, n) {
              return l % n || 0;
            }
            class s extends x.b {
              constructor(n, o, i) {
                super(),
                  (this.source = null),
                  (this._manager = n),
                  (this._volume =
                    i.volume !== void 0
                      ? T.m.clamp(Number(i.volume) || 0, 0, 1)
                      : 1),
                  (this._pitch =
                    i.pitch !== void 0
                      ? Math.max(0.01, Number(i.pitch) || 0)
                      : 1),
                  (this._loop = !!(i.loop !== void 0 && i.loop)),
                  (this._sound = o),
                  (this._state = h),
                  (this._suspended = !1),
                  (this._suspendEndEvent = 0),
                  (this._suspendInstanceEvents = !1),
                  (this._playWhenLoaded = !0),
                  (this._startTime = Math.max(0, Number(i.startTime) || 0)),
                  (this._duration = Math.max(0, Number(i.duration) || 0)),
                  (this._startOffset = null),
                  (this._onPlayCallback = i.onPlay),
                  (this._onPauseCallback = i.onPause),
                  (this._onResumeCallback = i.onResume),
                  (this._onStopCallback = i.onStop),
                  (this._onEndCallback = i.onEnd),
                  (0, g.b)()
                    ? ((this._startedAt = 0),
                      (this._currentTime = 0),
                      (this._currentOffset = 0),
                      (this._inputNode = null),
                      (this._connectorNode = null),
                      (this._firstNode = null),
                      (this._lastNode = null),
                      (this._waitingContextSuspension = !1),
                      this._initializeNodes(),
                      (this._endedHandler = this._onEnded.bind(this)))
                    : ((this._isReady = !1),
                      (this._loadedMetadataHandler =
                        this._onLoadedMetadata.bind(this)),
                      (this._timeUpdateHandler = this._onTimeUpdate.bind(this)),
                      (this._endedHandler = this._onEnded.bind(this)),
                      this._createSource());
              }
              set currentTime(n) {
                if (!(n < 0))
                  if (this._state === c) {
                    const o = this._suspendInstanceEvents;
                    (this._suspendInstanceEvents = !0),
                      this.stop(),
                      (this._startOffset = n),
                      this.play(),
                      (this._suspendInstanceEvents = o);
                  } else (this._startOffset = n), (this._currentTime = n);
              }
              get currentTime() {
                return this._startOffset !== null
                  ? this._startOffset
                  : this._state === d
                  ? this._currentTime
                  : this._state === h || !this.source
                  ? 0
                  : (this._updateCurrentTime(), this._currentTime);
              }
              set duration(n) {
                this._duration = Math.max(0, Number(n) || 0);
                const o = this._state === c;
                this.stop(), o && this.play();
              }
              get duration() {
                return this._sound
                  ? this._duration
                    ? f(this._duration, this._sound.duration)
                    : this._sound.duration
                  : 0;
              }
              get isPaused() {
                return this._state === d;
              }
              get isPlaying() {
                return this._state === c;
              }
              get isStopped() {
                return this._state === h;
              }
              get isSuspended() {
                return this._suspended;
              }
              set loop(n) {
                (this._loop = !!n),
                  this.source && (this.source.loop = this._loop);
              }
              get loop() {
                return this._loop;
              }
              set pitch(n) {
                (this._currentOffset = this.currentTime),
                  (this._startedAt = this._manager.context.currentTime),
                  (this._pitch = Math.max(Number(n) || 0, 0.01)),
                  this.source && (this.source.playbackRate.value = this._pitch);
              }
              get pitch() {
                return this._pitch;
              }
              set sound(n) {
                (this._sound = n),
                  this._state !== h ? this.stop() : this._createSource();
              }
              get sound() {
                return this._sound;
              }
              set startTime(n) {
                this._startTime = Math.max(0, Number(n) || 0);
                const o = this._state === c;
                this.stop(), o && this.play();
              }
              get startTime() {
                return this._startTime;
              }
              set volume(n) {
                (n = T.m.clamp(n, 0, 1)),
                  (this._volume = n),
                  this.gain &&
                    (this.gain.gain.value = n * this._manager.volume);
              }
              get volume() {
                return this._volume;
              }
              _onPlay() {
                this.fire("play"),
                  this._onPlayCallback && this._onPlayCallback(this);
              }
              _onPause() {
                this.fire("pause"),
                  this._onPauseCallback && this._onPauseCallback(this);
              }
              _onResume() {
                this.fire("resume"),
                  this._onResumeCallback && this._onResumeCallback(this);
              }
              _onStop() {
                this.fire("stop"),
                  this._onStopCallback && this._onStopCallback(this);
              }
              _onEnded() {
                if (this._suspendEndEvent > 0) {
                  this._suspendEndEvent--;
                  return;
                }
                this.fire("end"),
                  this._onEndCallback && this._onEndCallback(this),
                  this.stop();
              }
              _onManagerVolumeChange() {
                this.volume = this._volume;
              }
              _onManagerSuspend() {
                this._state === c &&
                  !this._suspended &&
                  ((this._suspended = !0), this.pause());
              }
              _onManagerResume() {
                this._suspended && ((this._suspended = !1), this.resume());
              }
              _initializeNodes() {
                (this.gain = this._manager.context.createGain()),
                  (this._inputNode = this.gain),
                  (this._connectorNode = this.gain),
                  this._connectorNode.connect(
                    this._manager.context.destination
                  );
              }
              play() {
                return (
                  this._state !== h && this.stop(),
                  (this._state = c),
                  (this._playWhenLoaded = !1),
                  this._waitingContextSuspension
                    ? !1
                    : this._manager.suspended
                    ? (this._manager.once(
                        "resume",
                        this._playAudioImmediate,
                        this
                      ),
                      (this._waitingContextSuspension = !0),
                      !1)
                    : (this._playAudioImmediate(), !0)
                );
              }
              _playAudioImmediate() {
                if (((this._waitingContextSuspension = !1), this._state !== c))
                  return;
                this.source || this._createSource();
                let n = f(this._startOffset, this.duration);
                (n = f(this._startTime + n, this._sound.duration)),
                  (this._startOffset = null),
                  this._duration
                    ? this.source.start(0, n, this._duration)
                    : this.source.start(0, n),
                  (this._startedAt = this._manager.context.currentTime),
                  (this._currentTime = 0),
                  (this._currentOffset = n),
                  (this.volume = this._volume),
                  (this.loop = this._loop),
                  (this.pitch = this._pitch),
                  this._manager.on(
                    "volumechange",
                    this._onManagerVolumeChange,
                    this
                  ),
                  this._manager.on("suspend", this._onManagerSuspend, this),
                  this._manager.on("resume", this._onManagerResume, this),
                  this._manager.on("destroy", this._onManagerDestroy, this),
                  this._suspendInstanceEvents || this._onPlay();
              }
              pause() {
                return (
                  (this._playWhenLoaded = !1),
                  this._state !== c
                    ? !1
                    : ((this._state = d),
                      this._waitingContextSuspension ||
                        (this._updateCurrentTime(),
                        this._suspendEndEvent++,
                        this.source.stop(0),
                        (this.source = null),
                        (this._startOffset = null),
                        this._suspendInstanceEvents || this._onPause()),
                      !0)
                );
              }
              resume() {
                if (this._state !== d) return !1;
                let n = this.currentTime;
                return (
                  (this._state = c),
                  this._waitingContextSuspension ||
                    (this.source || this._createSource(),
                    this._startOffset !== null &&
                      ((n = f(this._startOffset, this.duration)),
                      (n = f(this._startTime + n, this._sound.duration)),
                      (this._startOffset = null)),
                    this._duration
                      ? this.source.start(0, n, this._duration)
                      : this.source.start(0, n),
                    (this._startedAt = this._manager.context.currentTime),
                    (this._currentOffset = n),
                    (this.volume = this._volume),
                    (this.loop = this._loop),
                    (this.pitch = this._pitch),
                    (this._playWhenLoaded = !1),
                    this._suspendInstanceEvents || this._onResume()),
                  !0
                );
              }
              stop() {
                if (((this._playWhenLoaded = !1), this._state === h)) return !1;
                const n = this._state === c;
                return (
                  (this._state = h),
                  this._waitingContextSuspension ||
                    (this._manager.off(
                      "volumechange",
                      this._onManagerVolumeChange,
                      this
                    ),
                    this._manager.off("suspend", this._onManagerSuspend, this),
                    this._manager.off("resume", this._onManagerResume, this),
                    this._manager.off("destroy", this._onManagerDestroy, this),
                    (this._startedAt = 0),
                    (this._currentTime = 0),
                    (this._currentOffset = 0),
                    (this._startOffset = null),
                    this._suspendEndEvent++,
                    n && this.source && this.source.stop(0),
                    (this.source = null),
                    this._suspendInstanceEvents || this._onStop()),
                  !0
                );
              }
              setExternalNodes(n, o) {
                if (!n) {
                  console.error("The firstNode must be a valid Audio Node");
                  return;
                }
                o || (o = n);
                const i = this._manager.context.destination;
                this._firstNode !== n &&
                  (this._firstNode
                    ? this._connectorNode.disconnect(this._firstNode)
                    : this._connectorNode.disconnect(i),
                  (this._firstNode = n),
                  this._connectorNode.connect(n)),
                  this._lastNode !== o &&
                    (this._lastNode && this._lastNode.disconnect(i),
                    (this._lastNode = o),
                    this._lastNode.connect(i));
              }
              clearExternalNodes() {
                const n = this._manager.context.destination;
                this._firstNode &&
                  (this._connectorNode.disconnect(this._firstNode),
                  (this._firstNode = null)),
                  this._lastNode &&
                    (this._lastNode.disconnect(n), (this._lastNode = null)),
                  this._connectorNode.connect(n);
              }
              getExternalNodes() {
                return [this._firstNode, this._lastNode];
              }
              _createSource() {
                if (!this._sound) return null;
                const n = this._manager.context;
                return (
                  this._sound.buffer &&
                    ((this.source = n.createBufferSource()),
                    (this.source.buffer = this._sound.buffer),
                    this.source.connect(this._inputNode),
                    (this.source.onended = this._endedHandler),
                    (this.source.loopStart = f(
                      this._startTime,
                      this.source.buffer.duration
                    )),
                    this._duration &&
                      (this.source.loopEnd = Math.max(
                        this.source.loopStart,
                        f(
                          this._startTime + this._duration,
                          this.source.buffer.duration
                        )
                      ))),
                  this.source
                );
              }
              _updateCurrentTime() {
                this._currentTime = f(
                  (this._manager.context.currentTime - this._startedAt) *
                    this._pitch +
                    this._currentOffset,
                  this.duration
                );
              }
              _onManagerDestroy() {
                this.source &&
                  this._state === c &&
                  (this.source.stop(0), (this.source = null));
              }
            }
            (0, g.b)() ||
              (Object.assign(s.prototype, {
                play: function () {
                  return (
                    this._state !== h && this.stop(),
                    !this.source && !this._createSource()
                      ? !1
                      : ((this.volume = this._volume),
                        (this.pitch = this._pitch),
                        (this.loop = this._loop),
                        this.source.play(),
                        (this._state = c),
                        (this._playWhenLoaded = !1),
                        this._manager.on(
                          "volumechange",
                          this._onManagerVolumeChange,
                          this
                        ),
                        this._manager.on(
                          "suspend",
                          this._onManagerSuspend,
                          this
                        ),
                        this._manager.on("resume", this._onManagerResume, this),
                        this._manager.on(
                          "destroy",
                          this._onManagerDestroy,
                          this
                        ),
                        this._manager.suspended && this._onManagerSuspend(),
                        this._suspendInstanceEvents || this._onPlay(),
                        !0)
                  );
                },
                pause: function () {
                  return !this.source || this._state !== c
                    ? !1
                    : (this._suspendEndEvent++,
                      this.source.pause(),
                      (this._playWhenLoaded = !1),
                      (this._state = d),
                      (this._startOffset = null),
                      this._suspendInstanceEvents || this._onPause(),
                      !0);
                },
                resume: function () {
                  return !this.source || this._state !== d
                    ? !1
                    : ((this._state = c),
                      (this._playWhenLoaded = !1),
                      this.source.paused &&
                        (this.source.play(),
                        this._suspendInstanceEvents || this._onResume()),
                      !0);
                },
                stop: function () {
                  return !this.source || this._state === h
                    ? !1
                    : (this._manager.off(
                        "volumechange",
                        this._onManagerVolumeChange,
                        this
                      ),
                      this._manager.off(
                        "suspend",
                        this._onManagerSuspend,
                        this
                      ),
                      this._manager.off("resume", this._onManagerResume, this),
                      this._manager.off(
                        "destroy",
                        this._onManagerDestroy,
                        this
                      ),
                      this._suspendEndEvent++,
                      this.source.pause(),
                      (this._playWhenLoaded = !1),
                      (this._state = h),
                      (this._startOffset = null),
                      this._suspendInstanceEvents || this._onStop(),
                      !0);
                },
                setExternalNodes: function () {},
                clearExternalNodes: function () {},
                getExternalNodes: function () {
                  return [null, null];
                },
                _onLoadedMetadata: function () {
                  this.source.removeEventListener(
                    "loadedmetadata",
                    this._loadedMetadataHandler
                  ),
                    (this._isReady = !0);
                  let l = f(this._startOffset, this.duration);
                  (l = f(this._startTime + l, this._sound.duration)),
                    (this._startOffset = null),
                    (this.source.currentTime = l);
                },
                _createSource: function () {
                  return (
                    this._sound &&
                      this._sound.audio &&
                      ((this._isReady = !1),
                      (this.source = this._sound.audio.cloneNode(!0)),
                      this.source.addEventListener(
                        "loadedmetadata",
                        this._loadedMetadataHandler
                      ),
                      this.source.addEventListener(
                        "timeupdate",
                        this._timeUpdateHandler
                      ),
                      (this.source.onended = this._endedHandler)),
                    this.source
                  );
                },
                _onTimeUpdate: function () {
                  this._duration &&
                    this.source.currentTime >
                      f(
                        this._startTime + this._duration,
                        this.source.duration
                      ) &&
                    (this.loop
                      ? (this.source.currentTime = f(
                          this._startTime,
                          this.source.duration
                        ))
                      : (this.source.removeEventListener(
                          "timeupdate",
                          this._timeUpdateHandler
                        ),
                        this.source.pause(),
                        this._onEnded()));
                },
                _onManagerDestroy: function () {
                  this.source && this.source.pause();
                },
              }),
              Object.defineProperty(s.prototype, "volume", {
                get: function () {
                  return this._volume;
                },
                set: function (l) {
                  (l = T.m.clamp(l, 0, 1)),
                    (this._volume = l),
                    this.source &&
                      (this.source.volume = l * this._manager.volume);
                },
              }),
              Object.defineProperty(s.prototype, "pitch", {
                get: function () {
                  return this._pitch;
                },
                set: function (l) {
                  (this._pitch = Math.max(Number(l) || 0, 0.01)),
                    this.source && (this.source.playbackRate = this._pitch);
                },
              }),
              Object.defineProperty(s.prototype, "sound", {
                get: function () {
                  return this._sound;
                },
                set: function (l) {
                  this.stop(), (this._sound = l);
                },
              }),
              Object.defineProperty(s.prototype, "currentTime", {
                get: function () {
                  return this._startOffset !== null
                    ? this._startOffset
                    : this._state === h || !this.source
                    ? 0
                    : this.source.currentTime - this._startTime;
                },
                set: function (l) {
                  l < 0 ||
                    ((this._startOffset = l),
                    this.source &&
                      this._isReady &&
                      ((this.source.currentTime = f(
                        this._startTime + f(l, this.duration),
                        this._sound.duration
                      )),
                      (this._startOffset = null)));
                },
              }));
          },
          7302: (Se, W, a) => {
            "use strict";
            a.d(W, { b: () => f });
            var x = a(4585),
              T = a(6556),
              g = a(1304),
              c = a(2100),
              d = a(3467);
            const h = 1e4;
            class f extends d.J {
              constructor(l, n, o = {}) {
                super(l, n, o),
                  (this._position = new T.A()),
                  (this._velocity = new T.A()),
                  o.position && (this.position = o.position),
                  (this.maxDistance =
                    o.maxDistance !== void 0 ? Number(o.maxDistance) : h),
                  (this.refDistance =
                    o.refDistance !== void 0 ? Number(o.refDistance) : 1),
                  (this.rollOffFactor =
                    o.rollOffFactor !== void 0 ? Number(o.rollOffFactor) : 1),
                  (this.distanceModel =
                    o.distanceModel !== void 0 ? o.distanceModel : g.WY);
              }
              _initializeNodes() {
                (this.gain = this._manager.context.createGain()),
                  (this.panner = this._manager.context.createPanner()),
                  this.panner.connect(this.gain),
                  (this._inputNode = this.panner),
                  (this._connectorNode = this.gain),
                  this._connectorNode.connect(
                    this._manager.context.destination
                  );
              }
              set position(l) {
                this._position.copy(l);
                const n = this.panner;
                "positionX" in n
                  ? ((n.positionX.value = l.x),
                    (n.positionY.value = l.y),
                    (n.positionZ.value = l.z))
                  : n.setPosition && n.setPosition(l.x, l.y, l.z);
              }
              get position() {
                return this._position;
              }
              set velocity(l) {
                this._velocity.copy(l);
              }
              get velocity() {
                return this._velocity;
              }
              set maxDistance(l) {
                this.panner.maxDistance = l;
              }
              get maxDistance() {
                return this.panner.maxDistance;
              }
              set refDistance(l) {
                this.panner.refDistance = l;
              }
              get refDistance() {
                return this.panner.refDistance;
              }
              set rollOffFactor(l) {
                this.panner.rolloffFactor = l;
              }
              get rollOffFactor() {
                return this.panner.rolloffFactor;
              }
              set distanceModel(l) {
                this.panner.distanceModel = l;
              }
              get distanceModel() {
                return this.panner.distanceModel;
              }
            }
            if (!(0, c.b)()) {
              let s = new T.A();
              const l = function (o, i, e, t, r, u) {
                s = s.sub2(o, i);
                const y = s.length();
                if (y < e) return 1;
                if (y > t) return 0;
                let p = 0;
                return (
                  u === g.WY
                    ? (p = 1 - (r * (y - e)) / (t - e))
                    : u === g.mU
                    ? (p = e / (e + r * (y - e)))
                    : u === g.r1 && (p = Math.pow(y / e, -r)),
                  x.m.clamp(p, 0, 1)
                );
              };
              Object.defineProperty(f.prototype, "position", {
                get: function () {
                  return this._position;
                },
                set: function (n) {
                  if ((this._position.copy(n), this.source)) {
                    const i = this._manager.listener.getPosition(),
                      e = l(
                        i,
                        this._position,
                        this.refDistance,
                        this.maxDistance,
                        this.rollOffFactor,
                        this.distanceModel
                      ),
                      t = this.volume;
                    this.source.volume = t * e * this._manager.volume;
                  }
                },
              }),
                Object.defineProperty(f.prototype, "maxDistance", {
                  get: function () {
                    return this._maxDistance;
                  },
                  set: function (n) {
                    this._maxDistance = n;
                  },
                }),
                Object.defineProperty(f.prototype, "refDistance", {
                  get: function () {
                    return this._refDistance;
                  },
                  set: function (n) {
                    this._refDistance = n;
                  },
                }),
                Object.defineProperty(f.prototype, "rollOffFactor", {
                  get: function () {
                    return this._rollOffFactor;
                  },
                  set: function (n) {
                    this._rollOffFactor = n;
                  },
                }),
                Object.defineProperty(f.prototype, "distanceModel", {
                  get: function () {
                    return this._distanceModel;
                  },
                  set: function (n) {
                    this._distanceModel = n;
                  },
                });
            }
          },
          6389: (Se, W, a) => {
            "use strict";
            a.d(W, { Y: () => g });
            var x = a(9758),
              T = a(6556);
            class g {
              constructor(d) {
                (this._manager = d),
                  (this.position = new T.A()),
                  (this.velocity = new T.A()),
                  (this.orientation = new x.y());
              }
              getPosition() {
                return this.position;
              }
              setPosition(d) {
                this.position.copy(d);
                const h = this.listener;
                h &&
                  ("positionX" in h
                    ? ((h.positionX.value = d.x),
                      (h.positionY.value = d.y),
                      (h.positionZ.value = d.z))
                    : h.setPosition && h.setPosition(d.x, d.y, d.z));
              }
              getVelocity() {
                return this.velocity;
              }
              setVelocity(d) {}
              setOrientation(d) {
                this.orientation.copy(d);
                const h = this.listener;
                if (h) {
                  const f = d.data;
                  "forwardX" in h
                    ? ((h.forwardX.value = -f[8]),
                      (h.forwardY.value = -f[9]),
                      (h.forwardZ.value = -f[10]),
                      (h.upX.value = f[4]),
                      (h.upY.value = f[5]),
                      (h.upZ.value = f[6]))
                    : h.setOrientation &&
                      h.setOrientation(-f[8], -f[9], -f[10], f[4], f[5], f[6]);
                }
              }
              getOrientation() {
                return this.orientation;
              }
              get listener() {
                const d = this._manager.context;
                return d ? d.listener : null;
              }
            }
          },
          5491: (Se, W, a) => {
            "use strict";
            a.d(W, { P: () => s });
            var x = a(5338),
              T = a(4585),
              g = a(6874),
              c = a(9725),
              d = a(6389);
            const h = "running",
              f = ["click", "touchstart", "mousedown"];
            class s extends x.b {
              constructor() {
                super(),
                  (this._context = null),
                  (this.AudioContext =
                    (typeof AudioContext != "undefined" && AudioContext) ||
                    (typeof webkitAudioContext != "undefined" &&
                      webkitAudioContext)),
                  this.AudioContext,
                  (this._unlockHandlerFunc = this._unlockHandler.bind(this)),
                  (this._userSuspended = !1),
                  (this.listener = new d.Y(this)),
                  (this._volume = 1);
              }
              set volume(n) {
                (n = T.m.clamp(n, 0, 1)),
                  (this._volume = n),
                  this.fire("volumechange", n);
              }
              get volume() {
                return this._volume;
              }
              get suspended() {
                return this._userSuspended;
              }
              get context() {
                return (
                  !this._context &&
                    this.AudioContext &&
                    ((this._context = new this.AudioContext()),
                    this._context.state !== h &&
                      this._registerUnlockListeners()),
                  this._context
                );
              }
              suspend() {
                this._userSuspended ||
                  ((this._userSuspended = !0),
                  this._context &&
                    this._context.state === h &&
                    this._suspend());
              }
              resume() {
                this._userSuspended &&
                  ((this._userSuspended = !1),
                  this._context && this._context.state !== h && this._resume());
              }
              destroy() {
                if ((this.fire("destroy"), this._context)) {
                  var n;
                  this._removeUnlockListeners(),
                    (n = this._context) == null || n.close(),
                    (this._context = null);
                }
              }
              playSound(n, o = {}) {
                let i = null;
                return g.$ && ((i = new g.$(this, n, o)), i.play()), i;
              }
              playSound3d(n, o, i = {}) {
                let e = null;
                return (
                  c.b &&
                    ((e = new c.b(this, n, i)),
                    e.setPosition(o),
                    i.volume && e.setVolume(i.volume),
                    i.loop && e.setLoop(i.loop),
                    i.maxDistance && e.setMaxDistance(i.maxDistance),
                    i.minDistance && e.setMinDistance(i.minDistance),
                    i.rollOffFactor && e.setRollOffFactor(i.rollOffFactor),
                    i.distanceModel && e.setDistanceModel(i.distanceModel),
                    e.play()),
                  e
                );
              }
              _resume() {
                this._context
                  .resume()
                  .then(
                    () => {
                      const n = this._context.createBufferSource();
                      (n.buffer = this._context.createBuffer(
                        1,
                        1,
                        this._context.sampleRate
                      )),
                        n.connect(this._context.destination),
                        n.start(0),
                        (n.onended = (o) => {
                          n.disconnect(0), this.fire("resume");
                        });
                    },
                    (n) => {}
                  )
                  .catch((n) => {});
              }
              _suspend() {
                this._context
                  .suspend()
                  .then(
                    () => {
                      this.fire("suspend");
                    },
                    (n) => {}
                  )
                  .catch((n) => {});
              }
              _unlockHandler() {
                this._removeUnlockListeners(),
                  !this._userSuspended &&
                    this._context.state !== h &&
                    this._resume();
              }
              _registerUnlockListeners() {
                f.forEach((n) => {
                  window.addEventListener(n, this._unlockHandlerFunc, !1);
                });
              }
              _removeUnlockListeners() {
                f.forEach((n) => {
                  window.removeEventListener(n, this._unlockHandlerFunc, !1);
                });
              }
            }
          },
          9095: (Se, W, a) => {
            "use strict";
            a.d(W, { $: () => x });
            class x {
              constructor(g) {
                (this.audio = void 0),
                  (this.buffer = void 0),
                  g instanceof Audio ? (this.audio = g) : (this.buffer = g);
              }
              get duration() {
                let g = 0;
                return (
                  this.buffer
                    ? (g = this.buffer.duration)
                    : this.audio && (g = this.audio.duration),
                  g || 0
                );
              }
            }
          },
          8451: (Se, W, a) => {
            "use strict";
            a.d(W, { NB: () => T, fw: () => g, sr: () => x });
            class x {
              constructor(d, h, f, s) {
                (this.time = d),
                  (this.position = h),
                  (this.rotation = f),
                  (this.scale = s);
              }
            }
            class T {
              constructor() {
                (this._name = ""), (this._keys = []);
              }
            }
            class g {
              constructor() {
                (this.name = ""),
                  (this.duration = 0),
                  (this._nodes = []),
                  (this._nodeDict = {});
              }
              getNode(d) {
                return this._nodeDict[d];
              }
              addNode(d) {
                this._nodes.push(d), (this._nodeDict[d._name] = d);
              }
              get nodes() {
                return this._nodes;
              }
            }
          },
          242: (Se, W, a) => {
            "use strict";
            a.d(W, { O: () => c });
            var x = a(6847),
              T = a(6556);
            class g {
              constructor() {
                (this._written = !1),
                  (this._name = ""),
                  (this._keyFrames = []),
                  (this._quat = new x.D()),
                  (this._pos = new T.A()),
                  (this._scale = new T.A()),
                  (this._targetNode = null);
              }
              getTarget() {
                return this._targetNode;
              }
              setTarget(h) {
                this._targetNode = h;
              }
            }
            class c {
              constructor(h) {
                (this.looping = !0),
                  (this._animation = null),
                  (this._time = 0),
                  (this._interpolatedKeys = []),
                  (this._interpolatedKeyDict = {}),
                  (this._currKeyIndices = {}),
                  (this.graph = null);
                const f = (s) => {
                  const l = new g();
                  (l._name = s.name),
                    this._interpolatedKeys.push(l),
                    (this._interpolatedKeyDict[s.name] = l),
                    (this._currKeyIndices[s.name] = 0);
                  for (let n = 0; n < s._children.length; n++)
                    f(s._children[n]);
                };
                f(h);
              }
              set animation(h) {
                (this._animation = h), (this.currentTime = 0);
              }
              get animation() {
                return this._animation;
              }
              set currentTime(h) {
                this._time = h;
                const f = this._interpolatedKeys.length;
                for (let s = 0; s < f; s++) {
                  const n = this._interpolatedKeys[s]._name;
                  this._currKeyIndices[n] = 0;
                }
                this.addTime(0), this.updateGraph();
              }
              get currentTime() {
                return this._time;
              }
              get numNodes() {
                return this._interpolatedKeys.length;
              }
              addTime(h) {
                if (this._animation !== null) {
                  const f = this._animation._nodes,
                    s = this._animation.duration;
                  if (this._time === s && !this.looping) return;
                  if (((this._time += h), this._time > s)) {
                    this._time = this.looping ? 0 : s;
                    for (let n = 0; n < f.length; n++) {
                      const i = f[n]._name;
                      this._currKeyIndices[i] = 0;
                    }
                  } else if (this._time < 0) {
                    this._time = this.looping ? s : 0;
                    for (let n = 0; n < f.length; n++) {
                      const o = f[n],
                        i = o._name;
                      this._currKeyIndices[i] = o._keys.length - 2;
                    }
                  }
                  const l = h >= 0 ? 1 : -1;
                  for (let n = 0; n < f.length; n++) {
                    const o = f[n],
                      i = o._name,
                      e = o._keys,
                      t = this._interpolatedKeyDict[i];
                    if (t === void 0) continue;
                    let r = !1;
                    if (e.length !== 1)
                      for (
                        let u = this._currKeyIndices[i];
                        u < e.length - 1 && u >= 0;
                        u += l
                      ) {
                        const y = e[u],
                          p = e[u + 1];
                        if (y.time <= this._time && p.time >= this._time) {
                          const _ = (this._time - y.time) / (p.time - y.time);
                          t._pos.lerp(y.position, p.position, _),
                            t._quat.slerp(y.rotation, p.rotation, _),
                            t._scale.lerp(y.scale, p.scale, _),
                            (t._written = !0),
                            (this._currKeyIndices[i] = u),
                            (r = !0);
                          break;
                        }
                      }
                    (e.length === 1 ||
                      (!r && this._time === 0 && this.looping)) &&
                      (t._pos.copy(e[0].position),
                      t._quat.copy(e[0].rotation),
                      t._scale.copy(e[0].scale),
                      (t._written = !0));
                  }
                }
              }
              blend(h, f, s) {
                const l = this._interpolatedKeys.length;
                for (let n = 0; n < l; n++) {
                  const o = h._interpolatedKeys[n],
                    i = f._interpolatedKeys[n],
                    e = this._interpolatedKeys[n];
                  o._written && i._written
                    ? (e._quat.slerp(o._quat, f._interpolatedKeys[n]._quat, s),
                      e._pos.lerp(o._pos, f._interpolatedKeys[n]._pos, s),
                      e._scale.lerp(o._scale, i._scale, s),
                      (e._written = !0))
                    : o._written
                    ? (e._quat.copy(o._quat),
                      e._pos.copy(o._pos),
                      e._scale.copy(o._scale),
                      (e._written = !0))
                    : i._written &&
                      (e._quat.copy(i._quat),
                      e._pos.copy(i._pos),
                      e._scale.copy(i._scale),
                      (e._written = !0));
                }
              }
              setGraph(h) {
                if (((this.graph = h), h))
                  for (let f = 0; f < this._interpolatedKeys.length; f++) {
                    const s = this._interpolatedKeys[f],
                      l = h.findByName(s._name);
                    this._interpolatedKeys[f].setTarget(l);
                  }
                else
                  for (let f = 0; f < this._interpolatedKeys.length; f++)
                    this._interpolatedKeys[f].setTarget(null);
              }
              updateGraph() {
                if (this.graph)
                  for (let h = 0; h < this._interpolatedKeys.length; h++) {
                    const f = this._interpolatedKeys[h];
                    if (f._written) {
                      const s = f.getTarget();
                      s.localPosition.copy(f._pos),
                        s.localRotation.copy(f._quat),
                        s.localScale.copy(f._scale),
                        s._dirtyLocal || s._dirtifyLocal(),
                        (f._written = !1);
                    }
                  }
              }
            }
          },
          3240: (Se, W, a) => {
            "use strict";
            a.d(W, { y: () => T });
            var x = a(3114);
            class T {
              constructor(c, d, h, f, s = [x.kY]) {
                (this._ui = !1),
                  (this._sprite = !1),
                  (this._obj = {
                    model: [],
                    element: [],
                    sprite: [],
                    render: [],
                  }),
                  (this.id = void 0),
                  (this.name = void 0),
                  (this.dynamic = void 0),
                  (this.maxAabbSize = void 0),
                  (this.layers = void 0),
                  (this.id = c),
                  (this.name = d),
                  (this.dynamic = h),
                  (this.maxAabbSize = f),
                  (this.layers = s);
              }
            }
            (T.MODEL = "model"),
              (T.ELEMENT = "element"),
              (T.SPRITE = "sprite"),
              (T.RENDER = "render");
          },
          793: (Se, W, a) => {
            "use strict";
            a.d(W, { D: () => p });
            var x = a(4486),
              T = a(6556),
              g = a(3148),
              c = a(7921),
              d = a(3114),
              h = a(7678),
              f = a(8792),
              s = a(3200),
              l = a(3894),
              n = a(3240),
              o = a(1034);
            function i(_, m) {
              if ((_ && !m) || (!_ && m)) return !1;
              if (((_ = _.data), (m = m.data), _ === m)) return !0;
              if (_ instanceof Float32Array && m instanceof Float32Array) {
                if (_.length !== m.length) return !1;
                for (let E = 0; E < _.length; E++) if (_[E] !== m[E]) return !1;
                return !0;
              }
              return !1;
            }
            function e(_, m) {
              for (const E in _)
                if (_.hasOwnProperty(E) && !i(_[E], m[E])) return !1;
              for (const E in m)
                if (m.hasOwnProperty(E) && !i(m[E], _[E])) return !1;
              return !0;
            }
            const t = [0, 1, 3, 2, 3, 1],
              r = [0, 1, 3, 0, 3, 2],
              u = new x.T();
            function y(_) {
              return _.node.worldTransform.scaleSign;
            }
            class p {
              constructor(m, E, v) {
                (this.device = m),
                  (this.rootNode = E),
                  (this.scene = v),
                  (this._init = !1),
                  (this._batchGroups = {}),
                  (this._batchGroupCounter = 0),
                  (this._batchList = []),
                  (this._dirtyGroups = []);
              }
              destroy() {
                (this.device = null),
                  (this.rootNode = null),
                  (this.scene = null),
                  (this._batchGroups = {}),
                  (this._batchList = []),
                  (this._dirtyGroups = []);
              }
              addGroup(m, E, v, P, I) {
                if (
                  (P === void 0 &&
                    ((P = this._batchGroupCounter), this._batchGroupCounter++),
                  this._batchGroups[P])
                )
                  return;
                const A = new n.y(P, m, E, v, I);
                return (this._batchGroups[P] = A), A;
              }
              removeGroup(m) {
                if (!this._batchGroups[m]) return;
                const E = [];
                for (let v = 0; v < this._batchList.length; v++)
                  this._batchList[v].batchGroupId === m
                    ? this.destroyBatch(this._batchList[v])
                    : E.push(this._batchList[v]);
                (this._batchList = E),
                  this._removeModelsFromBatchGroup(this.rootNode, m),
                  delete this._batchGroups[m];
              }
              markGroupDirty(m) {
                this._dirtyGroups.indexOf(m) < 0 && this._dirtyGroups.push(m);
              }
              getGroupByName(m) {
                const E = this._batchGroups;
                for (const v in E)
                  if (E.hasOwnProperty(v) && E[v].name === m) return E[v];
                return null;
              }
              getBatches(m) {
                const E = [],
                  v = this._batchList.length;
                for (let P = 0; P < v; P++) {
                  const I = this._batchList[P];
                  I.batchGroupId === m && E.push(I);
                }
                return E;
              }
              _removeModelsFromBatchGroup(m, E) {
                if (m.enabled) {
                  m.model &&
                    m.model.batchGroupId === E &&
                    (m.model.batchGroupId = -1),
                    m.render &&
                      m.render.batchGroupId === E &&
                      (m.render.batchGroupId = -1),
                    m.element &&
                      m.element.batchGroupId === E &&
                      (m.element.batchGroupId = -1),
                    m.sprite &&
                      m.sprite.batchGroupId === E &&
                      (m.sprite.batchGroupId = -1);
                  for (let v = 0; v < m._children.length; v++)
                    this._removeModelsFromBatchGroup(m._children[v], E);
                }
              }
              insert(m, E, v) {
                const P = this._batchGroups[E];
                P &&
                  P._obj[m].indexOf(v) < 0 &&
                  (P._obj[m].push(v), this.markGroupDirty(E));
              }
              remove(m, E, v) {
                const P = this._batchGroups[E];
                if (P) {
                  const I = P._obj[m].indexOf(v);
                  I >= 0 && (P._obj[m].splice(I, 1), this.markGroupDirty(E));
                }
              }
              _extractRender(m, E, v, P) {
                return (
                  m.render &&
                    ((E = P[m.render.batchGroupId] =
                      E.concat(m.render.meshInstances)),
                    m.render.removeFromLayers()),
                  E
                );
              }
              _extractModel(m, E, v, P) {
                return (
                  m.model &&
                    m.model.model &&
                    ((E = P[m.model.batchGroupId] =
                      E.concat(m.model.meshInstances)),
                    m.model.removeModelFromLayers()),
                  E
                );
              }
              _extractElement(m, E, v) {
                if (!m.element) return;
                let P = !1;
                m.element._text &&
                m.element._text._model.meshInstances.length > 0
                  ? (E.push(m.element._text._model.meshInstances[0]),
                    m.element.removeModelFromLayers(m.element._text._model),
                    (P = !0))
                  : m.element._image &&
                    (E.push(m.element._image._renderable.meshInstance),
                    m.element.removeModelFromLayers(
                      m.element._image._renderable.model
                    ),
                    m.element._image._renderable.unmaskMeshInstance &&
                      (E.push(m.element._image._renderable.unmaskMeshInstance),
                      (!m.element._image._renderable.unmaskMeshInstance
                        .stencilFront ||
                        !m.element._image._renderable.unmaskMeshInstance
                          .stencilBack) &&
                        (m.element._dirtifyMask(), m.element._onPrerender())),
                    (P = !0)),
                  P && (v._ui = !0);
              }
              _collectAndRemoveMeshInstances(m, E) {
                for (let v = 0; v < E.length; v++) {
                  const P = E[v],
                    I = this._batchGroups[P];
                  if (!I) continue;
                  let A = m[P];
                  A || (A = m[P] = []);
                  for (let B = 0; B < I._obj.model.length; B++)
                    A = this._extractModel(I._obj.model[B], A, I, m);
                  for (let B = 0; B < I._obj.render.length; B++)
                    A = this._extractRender(I._obj.render[B], A, I, m);
                  for (let B = 0; B < I._obj.element.length; B++)
                    this._extractElement(I._obj.element[B], A, I);
                  for (let B = 0; B < I._obj.sprite.length; B++) {
                    const C = I._obj.sprite[B];
                    C.sprite &&
                      C.sprite._meshInstance &&
                      (I.dynamic || C.sprite.sprite._renderMode === d._r) &&
                      (A.push(C.sprite._meshInstance),
                      C.sprite.removeModelFromLayers(),
                      (I._sprite = !0),
                      (C.sprite._batchGroup = I));
                  }
                }
              }
              generate(m) {
                const E = {};
                m || (m = Object.keys(this._batchGroups));
                const v = [];
                for (let C = 0; C < this._batchList.length; C++) {
                  if (m.indexOf(this._batchList[C].batchGroupId) < 0) {
                    v.push(this._batchList[C]);
                    continue;
                  }
                  this.destroyBatch(this._batchList[C]);
                }
                if (
                  ((this._batchList = v),
                  this._collectAndRemoveMeshInstances(E, m),
                  m === this._dirtyGroups)
                )
                  this._dirtyGroups.length = 0;
                else {
                  const C = [];
                  for (let w = 0; w < this._dirtyGroups.length; w++)
                    m.indexOf(this._dirtyGroups[w]) < 0 &&
                      C.push(this._dirtyGroups[w]);
                  this._dirtyGroups = C;
                }
                let P, I, A, B;
                for (const C in E)
                  if (
                    E.hasOwnProperty(C) &&
                    ((P = E[C]), (A = this._batchGroups[C]), !!A)
                  ) {
                    I = this.prepare(
                      P,
                      A.dynamic,
                      A.maxAabbSize,
                      A._ui || A._sprite
                    );
                    for (let w = 0; w < I.length; w++)
                      (B = this.create(I[w], A.dynamic, parseInt(C, 10))),
                        B && B.addToLayers(this.scene, A.layers);
                  }
              }
              prepare(m, E, v = Number.POSITIVE_INFINITY, P) {
                if (m.length === 0) return [];
                const I = v * 0.5,
                  A = this.device.supportsBoneTextures
                    ? 1024
                    : this.device.boneLimit,
                  B = this.device.extUintElement ? 4294967295 : 65535,
                  C = new g.k(),
                  w = new g.k();
                let k = null,
                  K;
                const te = [];
                let X = 0;
                P &&
                  m.sort(function (Z, ye) {
                    return Z.drawOrder - ye.drawOrder;
                  });
                let $ = m,
                  ne;
                const Y = P
                  ? function (Z) {
                      k ? k.add(Z.aabb) : (k = Z.aabb.clone()), ne.push(Z);
                    }
                  : function (Z) {
                      ne.push(Z);
                    };
                for (; $.length > 0; ) {
                  (te[X] = [$[0]]), (ne = []);
                  const Z = $[0].material,
                    ye = $[0].layer,
                    pe = $[0]._shaderDefs,
                    O = $[0].parameters,
                    me = $[0].stencilFront;
                  let N = $[0].mesh.vertexBuffer.getNumVertices();
                  const V = $[0].drawOrder;
                  C.copy($[0].aabb);
                  const L = y($[0]),
                    J = $[0].mesh.vertexBuffer.format.batchingHash,
                    ae = $[0].mesh.primitive[0].indexed;
                  k = null;
                  for (let R = 1; R < $.length; R++) {
                    const j = $[R];
                    if (E && te[X].length >= A) {
                      ne = ne.concat($.slice(R));
                      break;
                    }
                    if (
                      Z !== j.material ||
                      ye !== j.layer ||
                      J !== j.mesh.vertexBuffer.format.batchingHash ||
                      ae !== j.mesh.primitive[0].indexed ||
                      pe !== j._shaderDefs ||
                      N + j.mesh.vertexBuffer.getNumVertices() > B
                    ) {
                      Y(j);
                      continue;
                    }
                    if (
                      (w.copy(C),
                      w.add(j.aabb),
                      w.halfExtents.x > I ||
                        w.halfExtents.y > I ||
                        w.halfExtents.z > I)
                    ) {
                      Y(j);
                      continue;
                    }
                    if (
                      me &&
                      (!(K = j.stencilFront) ||
                        me.func !== K.func ||
                        me.zpass !== K.zpass)
                    ) {
                      Y(j);
                      continue;
                    }
                    if (L !== y(j)) {
                      Y(j);
                      continue;
                    }
                    if (!e(O, j.parameters)) {
                      Y(j);
                      continue;
                    }
                    if (P && k && k.intersects(j.aabb) && j.drawOrder !== V) {
                      Y(j);
                      continue;
                    }
                    C.add(j.aabb),
                      (N += j.mesh.vertexBuffer.getNumVertices()),
                      te[X].push(j);
                  }
                  X++, ($ = ne);
                }
                return te;
              }
              collectBatchedMeshData(m, E) {
                let v = null,
                  P = 0,
                  I = 0,
                  A = null;
                for (let B = 0; B < m.length; B++)
                  if (m[B].visible) {
                    const C = m[B].mesh,
                      w = C.vertexBuffer.numVertices;
                    if (((P += w), C.primitive[0].indexed))
                      I += C.primitive[0].count;
                    else {
                      const k = C.primitive[0].type;
                      (k === c.x5Y || k === c.fmY) &&
                        C.primitive[0].count === 4 &&
                        (I += 6);
                    }
                    if (!v) {
                      (A = m[B].material), (v = {});
                      const k = C.vertexBuffer.format.elements;
                      for (let K = 0; K < k.length; K++) {
                        const te = k[K].name;
                        v[te] = {
                          numComponents: k[K].numComponents,
                          dataType: k[K].dataType,
                          normalize: k[K].normalize,
                          count: 0,
                        };
                      }
                      E &&
                        (v[c.MgX] = {
                          numComponents: 1,
                          dataType: c.r8O,
                          normalize: !1,
                          count: 0,
                        });
                    }
                  }
                return {
                  streams: v,
                  batchNumVerts: P,
                  batchNumIndices: I,
                  material: A,
                };
              }
              create(m, E, v) {
                if (!this._init) {
                  const k =
                    "#define BONE_LIMIT " +
                    this.device.getBoneLimit() +
                    `
`;
                  (this.transformVS =
                    k +
                    `#define DYNAMICBATCH
` +
                    s.n.transformVS),
                    (this.skinTexVS = s.n.skinBatchTexVS),
                    (this.skinConstVS = s.n.skinBatchConstVS),
                    (this.vertexFormats = {}),
                    (this._init = !0);
                }
                let P = null,
                  I,
                  A,
                  B,
                  C = null;
                const w = this.collectBatchedMeshData(m, E);
                if (w.streams) {
                  const k = w.streams;
                  let K = w.material;
                  const te = w.batchNumVerts,
                    X = w.batchNumIndices;
                  (C = new l.E(m, E, v)), this._batchList.push(C);
                  let $,
                    ne,
                    Y,
                    Z = 0,
                    ye = 0,
                    pe;
                  const O = new T.A(),
                    me = te <= 65535 ? Uint16Array : Uint32Array,
                    N = new me(X);
                  for (I in k)
                    (P = k[I]),
                      (P.typeArrayType = c.DIG[P.dataType]),
                      (P.elementByteSize = c.MbK[P.dataType]),
                      (P.buffer = new P.typeArrayType(te * P.numComponents));
                  for (let J = 0; J < m.length; J++)
                    if (m[J].visible) {
                      (A = m[J].mesh),
                        (B = A.vertexBuffer.numVertices),
                        E || (pe = m[J].node.getWorldTransform());
                      for (I in k)
                        if (I !== c.MgX) {
                          P = k[I];
                          const ae = new P.typeArrayType(
                              P.buffer.buffer,
                              P.elementByteSize * P.count
                            ),
                            R = A.getVertexStream(I, ae) * P.numComponents;
                          if (((P.count += R), !E && P.numComponents >= 3)) {
                            if (I === c.Q5v)
                              for (let j = 0; j < R; j += P.numComponents)
                                O.set(ae[j], ae[j + 1], ae[j + 2]),
                                  pe.transformPoint(O, O),
                                  (ae[j] = O.x),
                                  (ae[j + 1] = O.y),
                                  (ae[j + 2] = O.z);
                            else if (I === c.SA$ || I === c.ipN) {
                              pe.invertTo3x3(u), u.transpose();
                              for (let j = 0; j < R; j += P.numComponents)
                                O.set(ae[j], ae[j + 1], ae[j + 2]),
                                  u.transformVector(O, O),
                                  (ae[j] = O.x),
                                  (ae[j + 1] = O.y),
                                  (ae[j + 2] = O.z);
                            }
                          }
                        }
                      if (E) {
                        P = k[c.MgX];
                        for (let ae = 0; ae < B; ae++) P.buffer[P.count++] = J;
                      }
                      if (A.primitive[0].indexed) {
                        ($ = A.primitive[0].base), (ne = A.primitive[0].count);
                        const ae = A.indexBuffer[0].getFormat();
                        Y = new c.kRF[ae](A.indexBuffer[0].storage);
                      } else {
                        const ae = A.primitive[0].type;
                        if (ae === c.x5Y || ae === c.fmY)
                          if (A.primitive[0].count === 4)
                            ($ = 0), (ne = 6), (Y = ae === c.x5Y ? t : r);
                          else {
                            ne = 0;
                            continue;
                          }
                      }
                      for (let ae = 0; ae < ne; ae++)
                        N[ae + ye] = Y[$ + ae] + Z;
                      (ye += ne), (Z += B);
                    }
                  A = new h.K(this.device);
                  for (I in k)
                    (P = k[I]),
                      A.setVertexStream(
                        I,
                        P.buffer,
                        P.numComponents,
                        void 0,
                        P.dataType,
                        P.normalize
                      );
                  N.length > 0 && A.setIndices(N),
                    A.update(c.LAy, !1),
                    E &&
                      ((K = K.clone()),
                      (K.chunks.transformVS = this.transformVS),
                      (K.chunks.skinTexVS = this.skinTexVS),
                      (K.chunks.skinConstVS = this.skinConstVS),
                      K.update());
                  const V = new f.l(A, K, this.rootNode);
                  (V.castShadow = C.origMeshInstances[0].castShadow),
                    (V.parameters = C.origMeshInstances[0].parameters),
                    (V.layer = C.origMeshInstances[0].layer),
                    (V._shaderDefs = C.origMeshInstances[0]._shaderDefs),
                    (V.cull = C.origMeshInstances[0].cull);
                  const L = this._batchGroups[v];
                  if ((L && L._ui && (V.cull = !1), E)) {
                    const J = [];
                    for (let ae = 0; ae < C.origMeshInstances.length; ae++)
                      J.push(C.origMeshInstances[ae].node);
                    V.skinInstance = new o.H(this.device, J, this.rootNode);
                  }
                  (V._updateAabb = !1),
                    (V.drawOrder = C.origMeshInstances[0].drawOrder),
                    (V.stencilFront = C.origMeshInstances[0].stencilFront),
                    (V.stencilBack = C.origMeshInstances[0].stencilBack),
                    (V.flipFacesFactor = y(C.origMeshInstances[0])),
                    (V.castShadow = C.origMeshInstances[0].castShadow),
                    (C.meshInstance = V),
                    C.updateBoundingBox();
                }
                return C;
              }
              updateAll() {
                this._dirtyGroups.length > 0 &&
                  this.generate(this._dirtyGroups);
                for (let m = 0; m < this._batchList.length; m++)
                  this._batchList[m].dynamic &&
                    this._batchList[m].updateBoundingBox();
              }
              clone(m, E) {
                const v = new l.E(E, m.dynamic, m.batchGroupId);
                this._batchList.push(v);
                const P = [];
                for (let I = 0; I < E.length; I++) P.push(E[I].node);
                return (
                  (v.meshInstance = new f.l(
                    m.meshInstance.mesh,
                    m.meshInstance.material,
                    m.meshInstance.node
                  )),
                  (v.meshInstance._updateAabb = !1),
                  (v.meshInstance.parameters = E[0].parameters),
                  (v.meshInstance.cull = E[0].cull),
                  (v.meshInstance.layer = E[0].layer),
                  m.dynamic &&
                    (v.meshInstance.skinInstance = new o.H(
                      this.device,
                      P,
                      this.rootNode
                    )),
                  (v.meshInstance.castShadow = m.meshInstance.castShadow),
                  (v.meshInstance._shader = m.meshInstance._shader.slice()),
                  (v.meshInstance.castShadow = m.meshInstance.castShadow),
                  v
                );
              }
              destroyBatch(m) {
                m.destroy(this.scene, this._batchGroups[m.batchGroupId].layers);
              }
            }
          },
          3894: (Se, W, a) => {
            "use strict";
            a.d(W, { E: () => T });
            var x = a(3148);
            class T {
              constructor(c, d, h) {
                (this._aabb = new x.k()),
                  (this.origMeshInstances = void 0),
                  (this.meshInstance = null),
                  (this.dynamic = void 0),
                  (this.batchGroupId = void 0),
                  (this.origMeshInstances = c),
                  (this.dynamic = d),
                  (this.batchGroupId = h);
              }
              destroy(c, d) {
                this.meshInstance &&
                  (this.removeFromLayers(c, d),
                  this.meshInstance.destroy(),
                  (this.meshInstance = null));
              }
              addToLayers(c, d) {
                for (let h = 0; h < d.length; h++) {
                  const f = c.layers.getLayerById(d[h]);
                  f && f.addMeshInstances([this.meshInstance]);
                }
              }
              removeFromLayers(c, d) {
                for (let h = 0; h < d.length; h++) {
                  const f = c.layers.getLayerById(d[h]);
                  f && f.removeMeshInstances([this.meshInstance]);
                }
              }
              updateBoundingBox() {
                this._aabb.copy(this.origMeshInstances[0].aabb);
                for (let c = 1; c < this.origMeshInstances.length; c++)
                  this._aabb.add(this.origMeshInstances[c].aabb);
                (this.meshInstance.aabb = this._aabb),
                  (this.meshInstance._aabbVer = 0);
              }
            }
          },
          1034: (Se, W, a) => {
            "use strict";
            a.d(W, { H: () => T });
            var x = a(8691);
            class T extends x.u {
              constructor(c, d, h) {
                super();
                const f = d.length;
                this.init(c, f),
                  (this.device = c),
                  (this.rootNode = h),
                  (this.bones = d);
              }
              updateMatrices(c, d) {}
              updateMatrixPalette(c, d) {
                const h = this.matrixPalette,
                  f = this.bones.length;
                for (let s = 0; s < f; s++) {
                  const l = this.bones[s].getWorldTransform().data,
                    n = s * 12;
                  (h[n] = l[0]),
                    (h[n + 1] = l[4]),
                    (h[n + 2] = l[8]),
                    (h[n + 3] = l[12]),
                    (h[n + 4] = l[1]),
                    (h[n + 5] = l[5]),
                    (h[n + 6] = l[9]),
                    (h[n + 7] = l[13]),
                    (h[n + 8] = l[2]),
                    (h[n + 9] = l[6]),
                    (h[n + 10] = l[10]),
                    (h[n + 11] = l[14]);
                }
                this.uploadBones(this.device);
              }
            }
          },
          6165: (Se, W, a) => {
            "use strict";
            a.d(W, { V: () => e });
            var x = a(1367),
              T = a(9758),
              g = a(6556),
              c = a(6630),
              d = a(4585),
              h = a(5230),
              f = a(3114);
            const s = new g.A(),
              l = new g.A(),
              n = new g.A(),
              o = new T.y(),
              i = [
                new g.A(),
                new g.A(),
                new g.A(),
                new g.A(),
                new g.A(),
                new g.A(),
                new g.A(),
                new g.A(),
              ];
            class e {
              constructor() {
                (this.shaderPassInfo = void 0),
                  (this._aspectRatio = 1.7777777777777777),
                  (this._aspectRatioMode = f.HJ),
                  (this._calculateProjection = null),
                  (this._calculateTransform = null),
                  (this._clearColor = new x.I(0.75, 0.75, 0.75, 1)),
                  (this._clearColorBuffer = !0),
                  (this._clearDepth = 1),
                  (this._clearDepthBuffer = !0),
                  (this._clearStencil = 0),
                  (this._clearStencilBuffer = !0),
                  (this._cullFaces = !0),
                  (this._farClip = 1e3),
                  (this._flipFaces = !1),
                  (this._fov = 45),
                  (this._frustumCulling = !0),
                  (this._horizontalFov = !1),
                  (this._layers = [f.kY, f.Pp, f.Fk, f.Q7, f.vt]),
                  (this._layersSet = new Set(this._layers)),
                  (this._nearClip = 0.1),
                  (this._node = null),
                  (this._orthoHeight = 10),
                  (this._projection = f.pm),
                  (this._rect = new c.T(0, 0, 1, 1)),
                  (this._renderTarget = null),
                  (this._scissorRect = new c.T(0, 0, 1, 1)),
                  (this._scissorRectClear = !1),
                  (this._aperture = 16),
                  (this._shutter = 0.001),
                  (this._sensitivity = 1e3),
                  (this._projMat = new T.y()),
                  (this._projMatDirty = !0),
                  (this._projMatSkybox = new T.y()),
                  (this._viewMat = new T.y()),
                  (this._viewMatDirty = !0),
                  (this._viewProjMat = new T.y()),
                  (this._viewProjMatDirty = !0),
                  (this.frustum = new h.i()),
                  (this._xr = null),
                  (this._xrProperties = {
                    horizontalFov: this._horizontalFov,
                    fov: this._fov,
                    aspectRatio: this._aspectRatio,
                    farClip: this._farClip,
                    nearClip: this._nearClip,
                  });
              }
              get fullSizeClearRect() {
                const r = this._scissorRectClear
                  ? this.scissorRect
                  : this._rect;
                return r.x === 0 && r.y === 0 && r.z === 1 && r.w === 1;
              }
              set aspectRatio(r) {
                this._aspectRatio !== r &&
                  ((this._aspectRatio = r), (this._projMatDirty = !0));
              }
              get aspectRatio() {
                var r;
                return (r = this.xr) != null && r.active
                  ? this._xrProperties.aspectRatio
                  : this._aspectRatio;
              }
              set aspectRatioMode(r) {
                this._aspectRatioMode !== r &&
                  ((this._aspectRatioMode = r), (this._projMatDirty = !0));
              }
              get aspectRatioMode() {
                return this._aspectRatioMode;
              }
              set calculateProjection(r) {
                (this._calculateProjection = r), (this._projMatDirty = !0);
              }
              get calculateProjection() {
                return this._calculateProjection;
              }
              set calculateTransform(r) {
                this._calculateTransform = r;
              }
              get calculateTransform() {
                return this._calculateTransform;
              }
              set clearColor(r) {
                this._clearColor.copy(r);
              }
              get clearColor() {
                return this._clearColor;
              }
              set clearColorBuffer(r) {
                this._clearColorBuffer = r;
              }
              get clearColorBuffer() {
                return this._clearColorBuffer;
              }
              set clearDepth(r) {
                this._clearDepth = r;
              }
              get clearDepth() {
                return this._clearDepth;
              }
              set clearDepthBuffer(r) {
                this._clearDepthBuffer = r;
              }
              get clearDepthBuffer() {
                return this._clearDepthBuffer;
              }
              set clearStencil(r) {
                this._clearStencil = r;
              }
              get clearStencil() {
                return this._clearStencil;
              }
              set clearStencilBuffer(r) {
                this._clearStencilBuffer = r;
              }
              get clearStencilBuffer() {
                return this._clearStencilBuffer;
              }
              set cullFaces(r) {
                this._cullFaces = r;
              }
              get cullFaces() {
                return this._cullFaces;
              }
              set farClip(r) {
                this._farClip !== r &&
                  ((this._farClip = r), (this._projMatDirty = !0));
              }
              get farClip() {
                var r;
                return (r = this.xr) != null && r.active
                  ? this._xrProperties.farClip
                  : this._farClip;
              }
              set flipFaces(r) {
                this._flipFaces = r;
              }
              get flipFaces() {
                return this._flipFaces;
              }
              set fov(r) {
                this._fov !== r && ((this._fov = r), (this._projMatDirty = !0));
              }
              get fov() {
                var r;
                return (r = this.xr) != null && r.active
                  ? this._xrProperties.fov
                  : this._fov;
              }
              set frustumCulling(r) {
                this._frustumCulling = r;
              }
              get frustumCulling() {
                return this._frustumCulling;
              }
              set horizontalFov(r) {
                this._horizontalFov !== r &&
                  ((this._horizontalFov = r), (this._projMatDirty = !0));
              }
              get horizontalFov() {
                var r;
                return (r = this.xr) != null && r.active
                  ? this._xrProperties.horizontalFov
                  : this._horizontalFov;
              }
              set layers(r) {
                (this._layers = r.slice(0)),
                  (this._layersSet = new Set(this._layers));
              }
              get layers() {
                return this._layers;
              }
              get layersSet() {
                return this._layersSet;
              }
              set nearClip(r) {
                this._nearClip !== r &&
                  ((this._nearClip = r), (this._projMatDirty = !0));
              }
              get nearClip() {
                var r;
                return (r = this.xr) != null && r.active
                  ? this._xrProperties.nearClip
                  : this._nearClip;
              }
              set node(r) {
                this._node = r;
              }
              get node() {
                return this._node;
              }
              set orthoHeight(r) {
                this._orthoHeight !== r &&
                  ((this._orthoHeight = r), (this._projMatDirty = !0));
              }
              get orthoHeight() {
                return this._orthoHeight;
              }
              set projection(r) {
                this._projection !== r &&
                  ((this._projection = r), (this._projMatDirty = !0));
              }
              get projection() {
                return this._projection;
              }
              get projectionMatrix() {
                return this._evaluateProjectionMatrix(), this._projMat;
              }
              set rect(r) {
                this._rect.copy(r);
              }
              get rect() {
                return this._rect;
              }
              set renderTarget(r) {
                this._renderTarget = r;
              }
              get renderTarget() {
                return this._renderTarget;
              }
              set scissorRect(r) {
                this._scissorRect.copy(r);
              }
              get scissorRect() {
                return this._scissorRect;
              }
              get viewMatrix() {
                if (this._viewMatDirty) {
                  const r = this._node.getWorldTransform();
                  this._viewMat.copy(r).invert(), (this._viewMatDirty = !1);
                }
                return this._viewMat;
              }
              set aperture(r) {
                this._aperture = r;
              }
              get aperture() {
                return this._aperture;
              }
              set sensitivity(r) {
                this._sensitivity = r;
              }
              get sensitivity() {
                return this._sensitivity;
              }
              set shutter(r) {
                this._shutter = r;
              }
              get shutter() {
                return this._shutter;
              }
              set xr(r) {
                this._xr !== r && ((this._xr = r), (this._projMatDirty = !0));
              }
              get xr() {
                return this._xr;
              }
              clone() {
                return new e().copy(this);
              }
              copy(r) {
                return (
                  (this._aspectRatio = r._aspectRatio),
                  (this._farClip = r._farClip),
                  (this._fov = r._fov),
                  (this._horizontalFov = r._horizontalFov),
                  (this._nearClip = r._nearClip),
                  (this._xrProperties.aspectRatio =
                    r._xrProperties.aspectRatio),
                  (this._xrProperties.farClip = r._xrProperties.farClip),
                  (this._xrProperties.fov = r._xrProperties.fov),
                  (this._xrProperties.horizontalFov =
                    r._xrProperties.horizontalFov),
                  (this._xrProperties.nearClip = r._xrProperties.nearClip),
                  (this.aspectRatioMode = r.aspectRatioMode),
                  (this.calculateProjection = r.calculateProjection),
                  (this.calculateTransform = r.calculateTransform),
                  (this.clearColor = r.clearColor),
                  (this.clearColorBuffer = r.clearColorBuffer),
                  (this.clearDepth = r.clearDepth),
                  (this.clearDepthBuffer = r.clearDepthBuffer),
                  (this.clearStencil = r.clearStencil),
                  (this.clearStencilBuffer = r.clearStencilBuffer),
                  (this.cullFaces = r.cullFaces),
                  (this.flipFaces = r.flipFaces),
                  (this.frustumCulling = r.frustumCulling),
                  (this.layers = r.layers),
                  (this.orthoHeight = r.orthoHeight),
                  (this.projection = r.projection),
                  (this.rect = r.rect),
                  (this.renderTarget = r.renderTarget),
                  (this.scissorRect = r.scissorRect),
                  (this.aperture = r.aperture),
                  (this.shutter = r.shutter),
                  (this.sensitivity = r.sensitivity),
                  (this.shaderPassInfo = r.shaderPassInfo),
                  (this._projMatDirty = !0),
                  this
                );
              }
              _updateViewProjMat() {
                (this._projMatDirty ||
                  this._viewMatDirty ||
                  this._viewProjMatDirty) &&
                  (this._viewProjMat.mul2(
                    this.projectionMatrix,
                    this.viewMatrix
                  ),
                  (this._viewProjMatDirty = !1));
              }
              worldToScreen(r, u, y, p = new g.A()) {
                this._updateViewProjMat(),
                  this._viewProjMat.transformPoint(r, p);
                const _ = this._viewProjMat.data,
                  m = r.x * _[3] + r.y * _[7] + r.z * _[11] + 1 * _[15];
                return (
                  (p.x = (p.x / m + 1) * 0.5 * u),
                  (p.y = (1 - p.y / m) * 0.5 * y),
                  p
                );
              }
              screenToWorld(r, u, y, p, _, m = new g.A()) {
                const E = this.farClip - this.nearClip;
                if (
                  (s.set(r / p, (_ - u) / _, y / E),
                  s.mulScalar(2),
                  s.sub(g.A.ONE),
                  this._projection === f.pm)
                ) {
                  T.y._getPerspectiveHalfSize(
                    l,
                    this.fov,
                    this.aspectRatio,
                    this.nearClip,
                    this.horizontalFov
                  ),
                    (l.x *= s.x),
                    (l.y *= s.y);
                  const v = this._node.getWorldTransform();
                  (l.z = -this.nearClip), v.transformPoint(l, n);
                  const P = this._node.getPosition();
                  m.sub2(n, P), m.normalize(), m.mulScalar(y), m.add(P);
                } else
                  this._updateViewProjMat(),
                    o.copy(this._viewProjMat).invert(),
                    o.transformPoint(s, m);
                return m;
              }
              _evaluateProjectionMatrix() {
                if (this._projMatDirty) {
                  if (this._projection === f.pm)
                    this._projMat.setPerspective(
                      this.fov,
                      this.aspectRatio,
                      this.nearClip,
                      this.farClip,
                      this.horizontalFov
                    ),
                      this._projMatSkybox.copy(this._projMat);
                  else {
                    const r = this._orthoHeight,
                      u = r * this.aspectRatio;
                    this._projMat.setOrtho(
                      -u,
                      u,
                      -r,
                      r,
                      this.nearClip,
                      this.farClip
                    ),
                      this._projMatSkybox.setPerspective(
                        this.fov,
                        this.aspectRatio,
                        this.nearClip,
                        this.farClip
                      );
                  }
                  this._projMatDirty = !1;
                }
              }
              getProjectionMatrixSkybox() {
                return this._evaluateProjectionMatrix(), this._projMatSkybox;
              }
              getExposure() {
                const r = Math.log2(
                  (((this._aperture * this._aperture) / this._shutter) * 100) /
                    this._sensitivity
                );
                return 1 / (Math.pow(2, r) * 1.2);
              }
              getScreenSize(r) {
                if (this._projection === f.pm) {
                  const u = this._node.getPosition().distance(r.center);
                  if (u < r.radius) return 1;
                  const y = Math.asin(r.radius / u),
                    p = Math.tan(y),
                    _ = Math.tan((this.fov / 2) * d.m.DEG_TO_RAD);
                  return Math.min(p / _, 1);
                }
                return d.m.clamp(r.radius / this._orthoHeight, 0, 1);
              }
              getFrustumCorners(r = this.nearClip, u = this.farClip) {
                const y = (this.fov * Math.PI) / 180;
                let p =
                    this._projection === f.pm
                      ? Math.tan(y / 2) * r
                      : this._orthoHeight,
                  _ = p * this.aspectRatio;
                const m = i;
                return (
                  (m[0].x = _),
                  (m[0].y = -p),
                  (m[0].z = -r),
                  (m[1].x = _),
                  (m[1].y = p),
                  (m[1].z = -r),
                  (m[2].x = -_),
                  (m[2].y = p),
                  (m[2].z = -r),
                  (m[3].x = -_),
                  (m[3].y = -p),
                  (m[3].z = -r),
                  this._projection === f.pm &&
                    ((p = Math.tan(y / 2) * u), (_ = p * this.aspectRatio)),
                  (m[4].x = _),
                  (m[4].y = -p),
                  (m[4].z = -u),
                  (m[5].x = _),
                  (m[5].y = p),
                  (m[5].z = -u),
                  (m[6].x = -_),
                  (m[6].y = p),
                  (m[6].z = -u),
                  (m[7].x = -_),
                  (m[7].y = -p),
                  (m[7].z = -u),
                  m
                );
              }
              setXrProperties(r) {
                Object.assign(this._xrProperties, r), (this._projMatDirty = !0);
              }
            }
          },
          6462: (Se, W, a) => {
            "use strict";
            a.d(W, { d: () => n });
            var x = a(5338);
            const T = {
              equals: function (o, i) {
                if (o.size !== i.size) return !1;
                for (const e of o) if (!i.has(e)) return !1;
                return !0;
              },
            };
            var g = a(324),
              c = a(3114);
            class d {
              constructor() {
                (this.layerIndex = 0),
                  (this.cameraIndex = 0),
                  (this.camera = null),
                  (this.renderTarget = null),
                  (this.lightClusters = null),
                  (this.clearColor = !1),
                  (this.clearDepth = !1),
                  (this.clearStencil = !1),
                  (this.triggerPostprocess = !1),
                  (this.firstCameraUse = !1),
                  (this.lastCameraUse = !1),
                  (this.directionalLightsSet = new Set()),
                  (this.directionalLights = []),
                  (this.directionalLightsIndices = []),
                  (this.viewBindGroups = []);
              }
              destroy() {
                this.viewBindGroups.forEach((i) => {
                  i.defaultUniformBuffer.destroy(), i.destroy();
                }),
                  (this.viewBindGroups.length = 0);
              }
              get hasDirectionalShadowLights() {
                return this.directionalLights.length > 0;
              }
              reset() {
                (this.lightClusters = null),
                  this.directionalLightsSet.clear(),
                  (this.directionalLights.length = 0),
                  (this.directionalLightsIndices.length = 0);
              }
              isLayerEnabled(i) {
                return (
                  i.layerList[this.layerIndex].enabled &&
                  i.subLayerEnabled[this.layerIndex]
                );
              }
              collectDirectionalLights(i, e, t) {
                this.directionalLightsSet.clear(),
                  (this.directionalLights.length = 0),
                  (this.directionalLightsIndices.length = 0);
                for (let r = 0; r < e.length; r++) {
                  const u = e[r];
                  if (u.castShadows) {
                    for (let y = 0; y < i.length; y++)
                      if (
                        i[y]._splitLights[c.WQ].indexOf(u) >= 0 &&
                        !this.directionalLightsSet.has(u)
                      ) {
                        this.directionalLightsSet.add(u),
                          this.directionalLights.push(u);
                        const p = t.indexOf(u);
                        this.directionalLightsIndices.push(p);
                      }
                  }
                }
              }
            }
            var h = a(349);
            class f {
              constructor() {
                (this.shadowCastersSet = new Set()),
                  (this.shadowCastersList = []);
              }
              clearShadowCasters() {
                this.shadowCastersSet.clear(),
                  (this.shadowCastersList.length = 0);
              }
              addShadowCasters(i) {
                for (let e = 0; e < i.length; e++) {
                  const t = i[e];
                  this.shadowCastersSet.has(t) ||
                    (this.shadowCastersSet.add(t),
                    this.shadowCastersList.push(t));
                }
              }
            }
            const s = new Set(),
              l = [];
            class n extends x.b {
              constructor(i = "Untitled") {
                super(),
                  (this.layerList = []),
                  (this.layerIdMap = new Map()),
                  (this.layerNameMap = new Map()),
                  (this.subLayerList = []),
                  (this.subLayerEnabled = []),
                  (this.cameras = []),
                  (this._renderActions = []),
                  (this.name = i),
                  (this._opaqueOrder = {}),
                  (this._transparentOrder = {}),
                  (this._dirty = !1),
                  (this._dirtyBlend = !1),
                  (this._dirtyLights = !1),
                  (this._dirtyCameras = !1),
                  (this._meshInstances = []),
                  (this._meshInstancesSet = new Set()),
                  (this._lights = []),
                  (this._lightsMap = new Map()),
                  (this._lightCompositionData = []),
                  (this._splitLights = [[], [], []]),
                  (this._worldClusters = []),
                  (this._emptyWorldClusters = null);
              }
              destroy() {
                this._emptyWorldClusters &&
                  (this._emptyWorldClusters.destroy(),
                  (this._emptyWorldClusters = null)),
                  this._worldClusters.forEach((i) => {
                    i.destroy();
                  }),
                  (this._worldClusters = null),
                  this._renderActions.forEach((i) => i.destroy()),
                  (this._renderActions = null);
              }
              getEmptyWorldClusters(i) {
                return (
                  this._emptyWorldClusters ||
                    ((this._emptyWorldClusters = new h.P(i)),
                    (this._emptyWorldClusters.name = "ClusterEmpty"),
                    this._emptyWorldClusters.update([], !1, null)),
                  this._emptyWorldClusters
                );
              }
              _splitLightsArray(i) {
                const e = i._splitLights;
                (e[c.WQ].length = 0),
                  (e[c.bA].length = 0),
                  (e[c.z0].length = 0);
                const t = i._lights;
                for (let r = 0; r < t.length; r++) {
                  const u = t[r];
                  u.enabled && e[u._type].push(u);
                }
                e[c.WQ].sort((r, u) => r.key - u.key),
                  e[c.bA].sort((r, u) => r.key - u.key),
                  e[c.z0].sort((r, u) => r.key - u.key);
              }
              _update(i, e = !1) {
                const t = this.layerList.length;
                let r = 0;
                if (!this._dirty || !this._dirtyLights || !this._dirtyCameras)
                  for (let p = 0; p < t; p++) {
                    const _ = this.layerList[p];
                    _._dirty && (this._dirty = !0),
                      _._dirtyLights && (this._dirtyLights = !0),
                      _._dirtyCameras && (this._dirtyCameras = !0);
                  }
                function u(p, _, m) {
                  let E = !1;
                  const v = m.length;
                  for (let P = 0; P < v; P++) {
                    const I = m[P];
                    if (!_.has(I)) {
                      _.add(I), p.push(I);
                      const A = I.material;
                      A && A._dirtyBlend && ((E = !0), (A._dirtyBlend = !1));
                    }
                  }
                  return E;
                }
                if (this._dirty) {
                  (r |= c.GI),
                    (this._meshInstances.length = 0),
                    this._meshInstancesSet.clear();
                  for (let p = 0; p < t; p++) {
                    const _ = this.layerList[p];
                    _.passThrough ||
                      ((this._dirtyBlend =
                        u(
                          this._meshInstances,
                          this._meshInstancesSet,
                          _.opaqueMeshInstances
                        ) || this._dirtyBlend),
                      (this._dirtyBlend =
                        u(
                          this._meshInstances,
                          this._meshInstancesSet,
                          _.transparentMeshInstances
                        ) || this._dirtyBlend)),
                      (_._dirty = !1);
                  }
                  this._dirty = !1;
                }
                function y(p, _, m) {
                  for (let E = 0; E < _.length; )
                    _[E].transparent === m
                      ? (p.push(_[E]), (_[E] = _[_.length - 1]), _.length--)
                      : E++;
                }
                if (this._dirtyBlend) {
                  r |= c.Ei;
                  for (let p = 0; p < t; p++) {
                    const _ = this.layerList[p];
                    _.passThrough ||
                      (y(_.opaqueMeshInstances, _.transparentMeshInstances, !1),
                      y(_.transparentMeshInstances, _.opaqueMeshInstances, !0));
                  }
                  this._dirtyBlend = !1;
                }
                if (
                  (this._dirtyLights &&
                    ((r |= c.S9),
                    (this._dirtyLights = !1),
                    this.updateLights()),
                  r && this.updateShadowCasters(),
                  this._dirtyCameras || r & c.S9)
                ) {
                  (this._dirtyCameras = !1),
                    (r |= c.w7),
                    (this.cameras.length = 0);
                  for (let m = 0; m < t; m++) {
                    const E = this.layerList[m];
                    E._dirtyCameras = !1;
                    for (let v = 0; v < E.cameras.length; v++) {
                      const P = E.cameras[v];
                      this.cameras.indexOf(P) < 0 && this.cameras.push(P);
                    }
                  }
                  this.cameras.length > 1 && (0, g._)(this.cameras);
                  const p = [];
                  let _ = 0;
                  for (let m = 0; m < this.cameras.length; m++) {
                    const E = this.cameras[m];
                    p.length = 0;
                    let v = !0;
                    const P = _;
                    let I = null,
                      A = !1;
                    for (let B = 0; B < t; B++) {
                      const C = this.layerList[B],
                        w = this.subLayerEnabled[B];
                      if (
                        C &&
                        w &&
                        C.cameras.length > 0 &&
                        E.layers.indexOf(C.id) >= 0
                      ) {
                        p.push(C),
                          !A &&
                            C.id === E.disablePostEffectsLayer &&
                            ((A = !0), I && (I.triggerPostprocess = !0));
                        const k = C.cameras.indexOf(E);
                        k >= 0 &&
                          ((I = this.addRenderAction(
                            this._renderActions,
                            _,
                            C,
                            B,
                            k,
                            v,
                            A
                          )),
                          _++,
                          (v = !1));
                      }
                    }
                    P < _ &&
                      (this._renderActions[P].collectDirectionalLights(
                        p,
                        this._splitLights[c.WQ],
                        this._lights
                      ),
                      (I.lastCameraUse = !0)),
                      !A && I && (I.triggerPostprocess = !0),
                      E.renderTarget &&
                        E.postEffectsEnabled &&
                        this.propagateRenderTarget(P - 1, E);
                  }
                  for (let m = _; m < this._renderActions.length; m++)
                    this._renderActions[m].destroy();
                  this._renderActions.length = _;
                }
                return (
                  r & (c.w7 | c.S9 | c.GI) &&
                    e &&
                    this.allocateLightClusters(i),
                  r & (c.S9 | c.S9) && this._logRenderActions(),
                  r
                );
              }
              updateShadowCasters() {
                const i = this._lights.length;
                for (let t = 0; t < i; t++)
                  this._lightCompositionData[t].clearShadowCasters();
                const e = this.layerList.length;
                for (let t = 0; t < e; t++) {
                  const r = this.layerList[t];
                  if (!s.has(r)) {
                    s.add(r);
                    const u = r._lights;
                    for (let y = 0; y < u.length; y++)
                      if (u[y].castShadows) {
                        const p = this._lightsMap.get(u[y]);
                        this._lightCompositionData[p].addShadowCasters(
                          r.shadowCasters
                        );
                      }
                  }
                }
                s.clear();
              }
              updateLights() {
                (this._lights.length = 0), this._lightsMap.clear();
                const i = this.layerList.length;
                for (let t = 0; t < i; t++) {
                  const r = this.layerList[t];
                  if (!s.has(r)) {
                    s.add(r);
                    const u = r._lights;
                    for (let y = 0; y < u.length; y++) {
                      const p = u[y];
                      let _ = this._lightsMap.get(p);
                      if (_ === void 0) {
                        (_ = this._lights.length),
                          this._lightsMap.set(p, _),
                          this._lights.push(p);
                        let m = this._lightCompositionData[_];
                        m ||
                          ((m = new f()), (this._lightCompositionData[_] = m));
                      }
                    }
                  }
                  this._splitLightsArray(r), (r._dirtyLights = !1);
                }
                s.clear(), this._splitLightsArray(this);
                const e = this._lights.length;
                this._lightCompositionData.length = e;
              }
              findCompatibleCluster(i, e, t) {
                for (let r = 0; r < e; r++) {
                  const u = this._renderActions[r],
                    y = this.layerList[u.layerIndex];
                  if (
                    u.lightClusters !== t &&
                    (i === y ||
                      (u.lightClusters &&
                        T.equals(i._clusteredLightsSet, y._clusteredLightsSet)))
                  )
                    return u.lightClusters;
                }
                return null;
              }
              allocateLightClusters(i) {
                l.push(...this._worldClusters);
                const e = this.getEmptyWorldClusters(i);
                this._worldClusters.length = 0;
                const t = this._renderActions.length;
                for (let r = 0; r < t; r++) {
                  const u = this._renderActions[r],
                    y = this.layerList[u.layerIndex];
                  if (
                    ((u.lightClusters = null),
                    y.hasClusteredLights &&
                      (this.subLayerList[u.layerIndex]
                        ? y.transparentMeshInstances
                        : y.opaqueMeshInstances
                      ).length)
                  ) {
                    let m = this.findCompatibleCluster(y, r, e);
                    m ||
                      (l.length && (m = l.pop()),
                      m || (m = new h.P(i)),
                      (m.name = "Cluster-" + this._worldClusters.length),
                      this._worldClusters.push(m)),
                      (u.lightClusters = m);
                  }
                  u.lightClusters || (u.lightClusters = e);
                }
                l.forEach((r) => {
                  r.destroy();
                }),
                  (l.length = 0);
              }
              addRenderAction(i, e, t, r, u, y, p) {
                let _ = i[e];
                _ || (_ = i[e] = new d());
                let m = t.renderTarget;
                const E = t.cameras[u];
                E && E.renderTarget && t.id !== c.Pp && (m = E.renderTarget);
                let v = !1;
                for (let C = e - 1; C >= 0; C--)
                  if (i[C].camera === E && i[C].renderTarget === m) {
                    v = !0;
                    break;
                  }
                const P = y || !v;
                let I = P ? E.clearColorBuffer : !1,
                  A = P ? E.clearDepthBuffer : !1,
                  B = P ? E.clearStencilBuffer : !1;
                return (
                  I || (I = t.clearColorBuffer),
                  A || (A = t.clearDepthBuffer),
                  B || (B = t.clearStencilBuffer),
                  p && E.postEffectsEnabled && (m = null),
                  _.reset(),
                  (_.triggerPostprocess = !1),
                  (_.layerIndex = r),
                  (_.cameraIndex = u),
                  (_.camera = E),
                  (_.renderTarget = m),
                  (_.clearColor = I),
                  (_.clearDepth = A),
                  (_.clearStencil = B),
                  (_.firstCameraUse = y),
                  (_.lastCameraUse = !1),
                  _
                );
              }
              propagateRenderTarget(i, e) {
                for (let t = i; t >= 0; t--) {
                  const r = this._renderActions[t],
                    u = this.layerList[r.layerIndex];
                  if (r.renderTarget && u.id !== c.Pp) break;
                  if (u.id === c.Pp) continue;
                  const y = r == null ? void 0 : r.camera.camera;
                  if (
                    y &&
                    (!e.camera.rect.equals(y.rect) ||
                      !e.camera.scissorRect.equals(y.scissorRect))
                  )
                    break;
                  r.renderTarget = e.renderTarget;
                }
              }
              _logRenderActions() {}
              _isLayerAdded(i) {
                return this.layerIdMap.get(i.id) === i;
              }
              _isSublayerAdded(i, e) {
                for (let t = 0; t < this.layerList.length; t++)
                  if (this.layerList[t] === i && this.subLayerList[t] === e)
                    return !0;
                return !1;
              }
              push(i) {
                this._isLayerAdded(i) ||
                  (this.layerList.push(i),
                  this.layerList.push(i),
                  (this._opaqueOrder[i.id] = this.subLayerList.push(!1) - 1),
                  (this._transparentOrder[i.id] =
                    this.subLayerList.push(!0) - 1),
                  this.subLayerEnabled.push(!0),
                  this.subLayerEnabled.push(!0),
                  this._updateLayerMaps(),
                  (this._dirty = !0),
                  (this._dirtyLights = !0),
                  (this._dirtyCameras = !0),
                  this.fire("add", i));
              }
              insert(i, e) {
                if (this._isLayerAdded(i)) return;
                this.layerList.splice(e, 0, i, i),
                  this.subLayerList.splice(e, 0, !1, !0);
                const t = this.layerList.length;
                this._updateOpaqueOrder(e, t - 1),
                  this._updateTransparentOrder(e, t - 1),
                  this.subLayerEnabled.splice(e, 0, !0, !0),
                  this._updateLayerMaps(),
                  (this._dirty = !0),
                  (this._dirtyLights = !0),
                  (this._dirtyCameras = !0),
                  this.fire("add", i);
              }
              remove(i) {
                let e = this.layerList.indexOf(i);
                for (
                  delete this._opaqueOrder[e], delete this._transparentOrder[e];
                  e >= 0;

                )
                  this.layerList.splice(e, 1),
                    this.subLayerList.splice(e, 1),
                    this.subLayerEnabled.splice(e, 1),
                    (e = this.layerList.indexOf(i)),
                    (this._dirty = !0),
                    (this._dirtyLights = !0),
                    (this._dirtyCameras = !0),
                    this.fire("remove", i);
                const t = this.layerList.length;
                this._updateOpaqueOrder(0, t - 1),
                  this._updateTransparentOrder(0, t - 1),
                  this._updateLayerMaps();
              }
              pushOpaque(i) {
                this._isSublayerAdded(i, !1) ||
                  (this.layerList.push(i),
                  (this._opaqueOrder[i.id] = this.subLayerList.push(!1) - 1),
                  this.subLayerEnabled.push(!0),
                  this._updateLayerMaps(),
                  (this._dirty = !0),
                  (this._dirtyLights = !0),
                  (this._dirtyCameras = !0),
                  this.fire("add", i));
              }
              insertOpaque(i, e) {
                if (this._isSublayerAdded(i, !1)) return;
                this.layerList.splice(e, 0, i),
                  this.subLayerList.splice(e, 0, !1);
                const t = this.subLayerList.length;
                this._updateOpaqueOrder(e, t - 1),
                  this.subLayerEnabled.splice(e, 0, !0),
                  this._updateLayerMaps(),
                  (this._dirty = !0),
                  (this._dirtyLights = !0),
                  (this._dirtyCameras = !0),
                  this.fire("add", i);
              }
              removeOpaque(i) {
                for (let e = 0, t = this.layerList.length; e < t; e++)
                  if (this.layerList[e] === i && !this.subLayerList[e]) {
                    this.layerList.splice(e, 1),
                      this.subLayerList.splice(e, 1),
                      t--,
                      this._updateOpaqueOrder(e, t - 1),
                      this.subLayerEnabled.splice(e, 1),
                      (this._dirty = !0),
                      (this._dirtyLights = !0),
                      (this._dirtyCameras = !0),
                      this.layerList.indexOf(i) < 0 && this.fire("remove", i);
                    break;
                  }
                this._updateLayerMaps();
              }
              pushTransparent(i) {
                this._isSublayerAdded(i, !0) ||
                  (this.layerList.push(i),
                  (this._transparentOrder[i.id] =
                    this.subLayerList.push(!0) - 1),
                  this.subLayerEnabled.push(!0),
                  this._updateLayerMaps(),
                  (this._dirty = !0),
                  (this._dirtyLights = !0),
                  (this._dirtyCameras = !0),
                  this.fire("add", i));
              }
              insertTransparent(i, e) {
                if (this._isSublayerAdded(i, !0)) return;
                this.layerList.splice(e, 0, i),
                  this.subLayerList.splice(e, 0, !0);
                const t = this.subLayerList.length;
                this._updateTransparentOrder(e, t - 1),
                  this.subLayerEnabled.splice(e, 0, !0),
                  this._updateLayerMaps(),
                  (this._dirty = !0),
                  (this._dirtyLights = !0),
                  (this._dirtyCameras = !0),
                  this.fire("add", i);
              }
              removeTransparent(i) {
                for (let e = 0, t = this.layerList.length; e < t; e++)
                  if (this.layerList[e] === i && this.subLayerList[e]) {
                    this.layerList.splice(e, 1),
                      this.subLayerList.splice(e, 1),
                      t--,
                      this._updateTransparentOrder(e, t - 1),
                      this.subLayerEnabled.splice(e, 1),
                      (this._dirty = !0),
                      (this._dirtyLights = !0),
                      (this._dirtyCameras = !0),
                      this.layerList.indexOf(i) < 0 && this.fire("remove", i);
                    break;
                  }
                this._updateLayerMaps();
              }
              _getSublayerIndex(i, e) {
                let t = this.layerList.indexOf(i);
                return t < 0 ||
                  (this.subLayerList[t] !== e &&
                    ((t = this.layerList.indexOf(i, t + 1)),
                    t < 0 || this.subLayerList[t] !== e))
                  ? -1
                  : t;
              }
              getOpaqueIndex(i) {
                return this._getSublayerIndex(i, !1);
              }
              getTransparentIndex(i) {
                return this._getSublayerIndex(i, !0);
              }
              _updateLayerMaps() {
                this.layerIdMap.clear(), this.layerNameMap.clear();
                for (let i = 0; i < this.layerList.length; i++) {
                  const e = this.layerList[i];
                  this.layerIdMap.set(e.id, e),
                    this.layerNameMap.set(e.name, e);
                }
              }
              getLayerById(i) {
                var e;
                return (e = this.layerIdMap.get(i)) != null ? e : null;
              }
              getLayerByName(i) {
                var e;
                return (e = this.layerNameMap.get(i)) != null ? e : null;
              }
              _updateOpaqueOrder(i, e) {
                for (let t = i; t <= e; t++)
                  this.subLayerList[t] === !1 &&
                    (this._opaqueOrder[this.layerList[t].id] = t);
              }
              _updateTransparentOrder(i, e) {
                for (let t = i; t <= e; t++)
                  this.subLayerList[t] === !0 &&
                    (this._transparentOrder[this.layerList[t].id] = t);
              }
              _sortLayersDescending(i, e, t) {
                let r = -1,
                  u = -1;
                for (let y = 0, p = i.length; y < p; y++) {
                  const _ = i[y];
                  t.hasOwnProperty(_) && (r = Math.max(r, t[_]));
                }
                for (let y = 0, p = e.length; y < p; y++) {
                  const _ = e[y];
                  t.hasOwnProperty(_) && (u = Math.max(u, t[_]));
                }
                return r === -1 && u !== -1
                  ? 1
                  : u === -1 && r !== -1
                  ? -1
                  : u - r;
              }
              sortTransparentLayers(i, e) {
                return this._sortLayersDescending(i, e, this._transparentOrder);
              }
              sortOpaqueLayers(i, e) {
                return this._sortLayersDescending(i, e, this._opaqueOrder);
              }
            }
          },
          3114: (Se, W, a) => {
            "use strict";
            a.d(W, {
              $I: () => Ie,
              $U: () => T,
              $i: () => te,
              AM: () => U,
              Ar: () => q,
              Au: () => is,
              BN: () => je,
              BP: () => yt,
              Bp: () => at,
              C1: () => x,
              CH: () => qe,
              DD: () => hs,
              DZ: () => $e,
              EB: () => oe,
              Ei: () => ft,
              En: () => r,
              FB: () => ys,
              Fg: () => F,
              Fk: () => I,
              Fz: () => Tt,
              G: () => E,
              GI: () => Xs,
              GS: () => Re,
              Gh: () => rs,
              Gr: () => ts,
              HI: () => it,
              HJ: () => bt,
              Hc: () => ps,
              He: () => c,
              Ie: () => Oe,
              Is: () => st,
              J2: () => se,
              J7: () => N,
              JF: () => M,
              JN: () => me,
              Jb: () => vt,
              Jq: () => et,
              KE: () => t,
              KV: () => Xe,
              LH: () => R,
              Lf: () => ne,
              M: () => j,
              MU: () => Z,
              MV: () => zt,
              Mk: () => Ft,
              O1: () => gt,
              OE: () => ls,
              OL: () => Ot,
              ON: () => fs,
              Og: () => Rt,
              PH: () => we,
              Pk: () => Ze,
              Pp: () => P,
              Q7: () => B,
              Qr: () => Kt,
              Rx: () => y,
              S9: () => Zs,
              SD: () => u,
              SG: () => ks,
              Sh: () => l,
              Sm: () => Ye,
              T4: () => Ys,
              U2: () => zs,
              UG: () => mt,
              Uc: () => Le,
              Ug: () => ie,
              Uo: () => Qe,
              Us: () => Ws,
              Vf: () => be,
              Vy: () => Pe,
              WQ: () => C,
              WW: () => Fe,
              X1: () => Dt,
              X8: () => Gt,
              XD: () => $,
              XT: () => Mt,
              XV: () => ce,
              YV: () => i,
              Yi: () => Jt,
              Yk: () => f,
              _3: () => p,
              _f: () => jt,
              _r: () => Es,
              _u: () => xe,
              b0: () => He,
              b1: () => Be,
              b3: () => ae,
              b5: () => ht,
              bA: () => w,
              c8: () => De,
              ce: () => e,
              ch: () => h,
              d3: () => ge,
              e8: () => Ae,
              ei: () => Ke,
              ew: () => Et,
              gC: () => Qt,
              gN: () => lt,
              hz: () => Pt,
              i: () => b,
              iC: () => At,
              iW: () => pe,
              j9: () => Ve,
              jJ: () => H,
              jx: () => ue,
              kY: () => v,
              lA: () => g,
              lI: () => Ss,
              lR: () => k,
              lW: () => ct,
              ly: () => m,
              m8: () => ye,
              mZ: () => _e,
              mx: () => de,
              nE: () => Lt,
              oF: () => s,
              oJ: () => ws,
              oK: () => V,
              pF: () => ut,
              pI: () => X,
              pT: () => qt,
              pk: () => Q,
              pm: () => Ne,
              pr: () => ke,
              q4: () => fe,
              qT: () => G,
              rR: () => o,
              rX: () => z,
              sB: () => bs,
              sH: () => J,
              sz: () => L,
              tX: () => he,
              uk: () => Te,
              v5: () => ot,
              vt: () => A,
              w1: () => Yt,
              w7: () => We,
              wJ: () => Ns,
              wk: () => xt,
              xW: () => O,
              yC: () => ss,
              yd: () => Ee,
              yk: () => _,
              yl: () => n,
              yo: () => tt,
              yp: () => d,
              z0: () => K,
              zw: () => pt,
              zy: () => Y,
            });
            const x = 0,
              T = 1,
              g = 2,
              c = 3,
              d = 4,
              h = 5,
              f = 6,
              s = 7,
              l = 8,
              n = 9,
              o = 10,
              i = "none",
              e = "linear",
              t = "exp",
              r = "exp2",
              u = 0,
              y = 2,
              p = 0,
              _ = 1,
              m = 2,
              E = 15,
              v = 0,
              P = 1,
              I = 2,
              A = 3,
              B = 4,
              C = 0,
              w = 1,
              k = w,
              K = 2,
              te = 3,
              X = 0,
              $ = 1,
              ne = 2,
              Y = 3,
              Z = 0,
              ye = 1,
              pe = 0,
              O = 0,
              me = 1,
              N = 2,
              V = 3,
              L = 4,
              J = 5,
              ae = 6,
              R = {};
            (R[pe] = "PCF3"),
              (R[me] = "VSM8"),
              (R[N] = "VSM16"),
              (R[V] = "VSM32"),
              (R[L] = "PCF5"),
              (R[J] = "PCF1"),
              (R[ae] = "PCSS");
            const j = 0,
              se = 1,
              ce = 0,
              ie = 1,
              b = 2,
              M = 3,
              F = 0,
              z = 1,
              oe = 0,
              de = 1,
              ge = 0,
              Re = 1,
              Te = 2,
              Ne = 0,
              Le = 1,
              ke = 0,
              ht = 1,
              _e = 2,
              U = 0,
              H = 1,
              Ee = 0,
              G = 1,
              Q = "mul",
              q = "add",
              xe = "screen",
              be = "overlay",
              Pe = "min",
              we = "max",
              Oe = 0,
              $e = 1,
              gt = 2,
              qe = 3,
              Tt = 0,
              Mt = 1,
              Dt = 2,
              ut = 3,
              At = 4,
              xt = 0,
              jt = 1,
              Gt = 2,
              yt = 1,
              Ae = 2,
              Xe = 4,
              Ye = 8,
              it = 16,
              st = 32,
              He = 64,
              at = 128,
              Pt = 256,
              he = 512,
              fe = 1024,
              Ie = 2048,
              ue = 4096,
              De = 8192,
              et = 0,
              Ze = 1,
              Ve = 2,
              tt = 0,
              Be = 1,
              ot = 2,
              Qe = 0,
              mt = 1,
              je = 1,
              lt = 2,
              Et = 4,
              ct = 0,
              pt = 1,
              vt = 2,
              Fe = 3,
              Yt = 4,
              Ot = "forward",
              Rt = "debug_albedo",
              Kt = "debug_world_normal",
              Lt = "debug_opacity",
              Ft = "debug_specularity",
              Jt = "debug_gloss",
              zt = "debug_metalness",
              ss = "debug_ao",
              qt = "debug_emission",
              fs = "debug_lighting",
              ls = "debug_uv0",
              Es = 0,
              Ke = 1,
              hs = 2,
              is = 0,
              ys = 1,
              ps = 0,
              Ns = 1,
              zs = 2,
              bs = 0,
              Ws = 1,
              Ss = 2,
              ws = 3,
              ks = 4,
              Ys = 5,
              Xs = 1,
              Zs = 2,
              We = 4,
              ft = 8,
              bt = 0,
              ts = 1,
              Qt = 0,
              rs = 1;
          },
          7915: (Se, W, a) => {
            "use strict";
            a.d(W, { A: () => v });
            var x = a(5338),
              T = a(6660),
              g = a(4486),
              c = a(9758),
              d = a(6847),
              h = a(6556);
            const f = new c.y(),
              s = new h.A(),
              l = new d.D(),
              n = new d.D(),
              o = new h.A(),
              i = new h.A(),
              e = new c.y(),
              t = new d.D(),
              r = new h.A(),
              u = new c.y(),
              y = new d.D(),
              p = new d.D(),
              _ = new c.y(),
              m = new h.A(),
              E = new h.A();
            class v extends x.b {
              constructor(I = "Untitled") {
                super(),
                  (this.name = void 0),
                  (this.tags = new T.$(this)),
                  (this._labels = {}),
                  (this.localPosition = new h.A()),
                  (this.localRotation = new d.D()),
                  (this.localScale = new h.A(1, 1, 1)),
                  (this.localEulerAngles = new h.A()),
                  (this.position = new h.A()),
                  (this.rotation = new d.D()),
                  (this.eulerAngles = new h.A()),
                  (this._scale = null),
                  (this.localTransform = new c.y()),
                  (this._dirtyLocal = !1),
                  (this._aabbVer = 0),
                  (this._frozen = !1),
                  (this.worldTransform = new c.y()),
                  (this._dirtyWorld = !1),
                  (this._worldScaleSign = 0),
                  (this._normalMatrix = new g.T()),
                  (this._dirtyNormal = !0),
                  (this._right = null),
                  (this._up = null),
                  (this._forward = null),
                  (this._parent = null),
                  (this._children = []),
                  (this._graphDepth = 0),
                  (this._enabled = !0),
                  (this._enabledInHierarchy = !1),
                  (this.scaleCompensation = !1),
                  (this.name = I);
              }
              get right() {
                return (
                  this._right || (this._right = new h.A()),
                  this.getWorldTransform().getX(this._right).normalize()
                );
              }
              get up() {
                return (
                  this._up || (this._up = new h.A()),
                  this.getWorldTransform().getY(this._up).normalize()
                );
              }
              get forward() {
                return (
                  this._forward || (this._forward = new h.A()),
                  this.getWorldTransform()
                    .getZ(this._forward)
                    .normalize()
                    .mulScalar(-1)
                );
              }
              get normalMatrix() {
                const I = this._normalMatrix;
                return (
                  this._dirtyNormal &&
                    (this.getWorldTransform().invertTo3x3(I),
                    I.transpose(),
                    (this._dirtyNormal = !1)),
                  I
                );
              }
              set enabled(I) {
                if (this._enabled !== I) {
                  var A;
                  (this._enabled = I),
                    ((I && (A = this._parent) != null && A.enabled) || !I) &&
                      this._notifyHierarchyStateChanged(this, I);
                }
              }
              get enabled() {
                return this._enabled && this._enabledInHierarchy;
              }
              get parent() {
                return this._parent;
              }
              get path() {
                let I = this._parent;
                if (!I) return "";
                let A = this.name;
                for (; I && I._parent; )
                  (A = `${I.name}/${A}`), (I = I._parent);
                return A;
              }
              get root() {
                let I = this;
                for (; I._parent; ) I = I._parent;
                return I;
              }
              get children() {
                return this._children;
              }
              get graphDepth() {
                return this._graphDepth;
              }
              _notifyHierarchyStateChanged(I, A) {
                I._onHierarchyStateChanged(A);
                const B = I._children;
                for (let C = 0, w = B.length; C < w; C++)
                  B[C]._enabled && this._notifyHierarchyStateChanged(B[C], A);
              }
              _onHierarchyStateChanged(I) {
                (this._enabledInHierarchy = I),
                  I && !this._frozen && this._unfreezeParentToRoot();
              }
              _cloneInternal(I) {
                I.name = this.name;
                const A = this.tags._list;
                I.tags.clear();
                for (let B = 0; B < A.length; B++) I.tags.add(A[B]);
                (I._labels = Object.assign({}, this._labels)),
                  I.localPosition.copy(this.localPosition),
                  I.localRotation.copy(this.localRotation),
                  I.localScale.copy(this.localScale),
                  I.localEulerAngles.copy(this.localEulerAngles),
                  I.position.copy(this.position),
                  I.rotation.copy(this.rotation),
                  I.eulerAngles.copy(this.eulerAngles),
                  I.localTransform.copy(this.localTransform),
                  (I._dirtyLocal = this._dirtyLocal),
                  I.worldTransform.copy(this.worldTransform),
                  (I._dirtyWorld = this._dirtyWorld),
                  (I._dirtyNormal = this._dirtyNormal),
                  (I._aabbVer = this._aabbVer + 1),
                  (I._enabled = this._enabled),
                  (I.scaleCompensation = this.scaleCompensation),
                  (I._enabledInHierarchy = !1);
              }
              clone() {
                const I = new this.constructor();
                return this._cloneInternal(I), I;
              }
              copy(I) {
                return I._cloneInternal(this), this;
              }
              destroy() {
                this.remove();
                const I = this._children;
                for (; I.length; ) {
                  const A = I.pop();
                  (A._parent = null), A.destroy();
                }
                this.fire("destroy", this), this.off();
              }
              find(I, A) {
                let B,
                  C = [];
                const w = this._children.length;
                if (I instanceof Function) {
                  const k = I;
                  (B = k(this)), B && C.push(this);
                  for (let K = 0; K < w; K++) {
                    const te = this._children[K].find(k);
                    te.length && (C = C.concat(te));
                  }
                } else {
                  let k;
                  this[I] &&
                    (this[I] instanceof Function
                      ? (k = this[I]())
                      : (k = this[I]),
                    k === A && C.push(this));
                  for (let K = 0; K < w; ++K) {
                    const te = this._children[K].find(I, A);
                    te.length && (C = C.concat(te));
                  }
                }
                return C;
              }
              findOne(I, A) {
                const B = this._children.length;
                let C = null;
                if (I instanceof Function) {
                  const w = I;
                  if (((C = w(this)), C)) return this;
                  for (let k = 0; k < B; k++)
                    if (((C = this._children[k].findOne(w)), C)) return C;
                } else {
                  let w;
                  if (
                    this[I] &&
                    (this[I] instanceof Function
                      ? (w = this[I]())
                      : (w = this[I]),
                    w === A)
                  )
                    return this;
                  for (let k = 0; k < B; k++)
                    if (((C = this._children[k].findOne(I, A)), C !== null))
                      return C;
                }
                return null;
              }
              findByTag() {
                const I = arguments,
                  A = [],
                  B = (C, w) => {
                    w && C.tags.has(...I) && A.push(C);
                    for (let k = 0; k < C._children.length; k++)
                      B(C._children[k], !0);
                  };
                return B(this, !1), A;
              }
              findByName(I) {
                if (this.name === I) return this;
                for (let A = 0; A < this._children.length; A++) {
                  const B = this._children[A].findByName(I);
                  if (B !== null) return B;
                }
                return null;
              }
              findByPath(I) {
                const A = Array.isArray(I) ? I : I.split("/");
                let B = this;
                for (let C = 0, w = A.length; C < w; ++C)
                  if (((B = B.children.find((k) => k.name === A[C])), !B))
                    return null;
                return B;
              }
              forEach(I, A) {
                I.call(A, this);
                const B = this._children;
                for (let C = 0; C < B.length; C++) B[C].forEach(I, A);
              }
              isDescendantOf(I) {
                let A = this._parent;
                for (; A; ) {
                  if (A === I) return !0;
                  A = A._parent;
                }
                return !1;
              }
              isAncestorOf(I) {
                return I.isDescendantOf(this);
              }
              getEulerAngles() {
                return (
                  this.getWorldTransform().getEulerAngles(this.eulerAngles),
                  this.eulerAngles
                );
              }
              getLocalEulerAngles() {
                return (
                  this.localRotation.getEulerAngles(this.localEulerAngles),
                  this.localEulerAngles
                );
              }
              getLocalPosition() {
                return this.localPosition;
              }
              getLocalRotation() {
                return this.localRotation;
              }
              getLocalScale() {
                return this.localScale;
              }
              getLocalTransform() {
                return (
                  this._dirtyLocal &&
                    (this.localTransform.setTRS(
                      this.localPosition,
                      this.localRotation,
                      this.localScale
                    ),
                    (this._dirtyLocal = !1)),
                  this.localTransform
                );
              }
              getPosition() {
                return (
                  this.getWorldTransform().getTranslation(this.position),
                  this.position
                );
              }
              getRotation() {
                return (
                  this.rotation.setFromMat4(this.getWorldTransform()),
                  this.rotation
                );
              }
              getScale() {
                return (
                  this._scale || (this._scale = new h.A()),
                  this.getWorldTransform().getScale(this._scale)
                );
              }
              getWorldTransform() {
                return !this._dirtyLocal && !this._dirtyWorld
                  ? this.worldTransform
                  : (this._parent && this._parent.getWorldTransform(),
                    this._sync(),
                    this.worldTransform);
              }
              get worldScaleSign() {
                return (
                  this._worldScaleSign === 0 &&
                    (this._worldScaleSign = this.getWorldTransform().scaleSign),
                  this._worldScaleSign
                );
              }
              remove() {
                var I;
                (I = this._parent) == null || I.removeChild(this);
              }
              reparent(I, A) {
                this.remove(),
                  I && (A >= 0 ? I.insertChild(this, A) : I.addChild(this));
              }
              setLocalEulerAngles(I, A, B) {
                this.localRotation.setFromEulerAngles(I, A, B),
                  this._dirtyLocal || this._dirtifyLocal();
              }
              setLocalPosition(I, A, B) {
                I instanceof h.A
                  ? this.localPosition.copy(I)
                  : this.localPosition.set(I, A, B),
                  this._dirtyLocal || this._dirtifyLocal();
              }
              setLocalRotation(I, A, B, C) {
                I instanceof d.D
                  ? this.localRotation.copy(I)
                  : this.localRotation.set(I, A, B, C),
                  this._dirtyLocal || this._dirtifyLocal();
              }
              setLocalScale(I, A, B) {
                I instanceof h.A
                  ? this.localScale.copy(I)
                  : this.localScale.set(I, A, B),
                  this._dirtyLocal || this._dirtifyLocal();
              }
              _dirtifyLocal() {
                this._dirtyLocal ||
                  ((this._dirtyLocal = !0),
                  this._dirtyWorld || this._dirtifyWorld());
              }
              _unfreezeParentToRoot() {
                let I = this._parent;
                for (; I; ) (I._frozen = !1), (I = I._parent);
              }
              _dirtifyWorld() {
                this._dirtyWorld || this._unfreezeParentToRoot(),
                  this._dirtifyWorldInternal();
              }
              _dirtifyWorldInternal() {
                if (!this._dirtyWorld) {
                  (this._frozen = !1), (this._dirtyWorld = !0);
                  for (let I = 0; I < this._children.length; I++)
                    this._children[I]._dirtyWorld ||
                      this._children[I]._dirtifyWorldInternal();
                }
                (this._dirtyNormal = !0),
                  (this._worldScaleSign = 0),
                  this._aabbVer++;
              }
              setPosition(I, A, B) {
                I instanceof h.A ? r.copy(I) : r.set(I, A, B),
                  this._parent === null
                    ? this.localPosition.copy(r)
                    : (u.copy(this._parent.getWorldTransform()).invert(),
                      u.transformPoint(r, this.localPosition)),
                  this._dirtyLocal || this._dirtifyLocal();
              }
              setRotation(I, A, B, C) {
                if (
                  (I instanceof d.D ? y.copy(I) : y.set(I, A, B, C),
                  this._parent === null)
                )
                  this.localRotation.copy(y);
                else {
                  const w = this._parent.getRotation();
                  p.copy(w).invert(), this.localRotation.copy(p).mul(y);
                }
                this._dirtyLocal || this._dirtifyLocal();
              }
              setEulerAngles(I, A, B) {
                if (
                  (this.localRotation.setFromEulerAngles(I, A, B),
                  this._parent !== null)
                ) {
                  const C = this._parent.getRotation();
                  p.copy(C).invert(),
                    this.localRotation.mul2(p, this.localRotation);
                }
                this._dirtyLocal || this._dirtifyLocal();
              }
              addChild(I) {
                this._prepareInsertChild(I),
                  this._children.push(I),
                  this._onInsertChild(I);
              }
              addChildAndSaveTransform(I) {
                const A = I.getPosition(),
                  B = I.getRotation();
                this._prepareInsertChild(I),
                  I.setPosition(
                    e.copy(this.worldTransform).invert().transformPoint(A)
                  ),
                  I.setRotation(t.copy(this.getRotation()).invert().mul(B)),
                  this._children.push(I),
                  this._onInsertChild(I);
              }
              insertChild(I, A) {
                this._prepareInsertChild(I),
                  this._children.splice(A, 0, I),
                  this._onInsertChild(I);
              }
              _prepareInsertChild(I) {
                I.remove();
              }
              _fireOnHierarchy(I, A, B) {
                this.fire(I, B);
                for (let C = 0; C < this._children.length; C++)
                  this._children[C]._fireOnHierarchy(A, A, B);
              }
              _onInsertChild(I) {
                I._parent = this;
                const A = I._enabled && this.enabled;
                I._enabledInHierarchy !== A &&
                  ((I._enabledInHierarchy = A),
                  I._notifyHierarchyStateChanged(I, A)),
                  I._updateGraphDepth(),
                  I._dirtifyWorld(),
                  this._frozen && I._unfreezeParentToRoot(),
                  I._fireOnHierarchy("insert", "inserthierarchy", this),
                  this.fire && this.fire("childinsert", I);
              }
              _updateGraphDepth() {
                this._graphDepth = this._parent
                  ? this._parent._graphDepth + 1
                  : 0;
                for (let I = 0, A = this._children.length; I < A; I++)
                  this._children[I]._updateGraphDepth();
              }
              removeChild(I) {
                const A = this._children.indexOf(I);
                A !== -1 &&
                  (this._children.splice(A, 1),
                  (I._parent = null),
                  I._fireOnHierarchy("remove", "removehierarchy", this),
                  this.fire("childremove", I));
              }
              _sync() {
                if (
                  (this._dirtyLocal &&
                    (this.localTransform.setTRS(
                      this.localPosition,
                      this.localRotation,
                      this.localScale
                    ),
                    (this._dirtyLocal = !1)),
                  this._dirtyWorld)
                ) {
                  if (this._parent === null)
                    this.worldTransform.copy(this.localTransform);
                  else if (this.scaleCompensation) {
                    let I;
                    const A = this._parent;
                    let B = this.localScale,
                      C = A;
                    if (C) {
                      for (; C && C.scaleCompensation; ) C = C._parent;
                      C &&
                        ((C = C._parent),
                        C &&
                          ((I = C.worldTransform.getScale()),
                          o.mul2(I, this.localScale),
                          (B = o)));
                    }
                    n.setFromMat4(A.worldTransform),
                      l.mul2(n, this.localRotation);
                    let w = A.worldTransform;
                    A.scaleCompensation &&
                      (i.mul2(I, A.getLocalScale()),
                      f.setTRS(A.worldTransform.getTranslation(s), n, i),
                      (w = f)),
                      w.transformPoint(this.localPosition, s),
                      this.worldTransform.setTRS(s, l, B);
                  } else
                    this.worldTransform.mulAffine2(
                      this._parent.worldTransform,
                      this.localTransform
                    );
                  this._dirtyWorld = !1;
                }
              }
              syncHierarchy() {
                if (!this._enabled || this._frozen) return;
                (this._frozen = !0),
                  (this._dirtyLocal || this._dirtyWorld) && this._sync();
                const I = this._children;
                for (let A = 0, B = I.length; A < B; A++) I[A].syncHierarchy();
              }
              lookAt(I, A, B, C = 0, w = 1, k = 0) {
                if (I instanceof h.A)
                  m.copy(I), A instanceof h.A ? E.copy(A) : E.copy(h.A.UP);
                else {
                  if (B === void 0) return;
                  m.set(I, A, B), E.set(C, w, k);
                }
                _.setLookAt(this.getPosition(), m, E),
                  y.setFromMat4(_),
                  this.setRotation(y);
              }
              translate(I, A, B) {
                I instanceof h.A ? r.copy(I) : r.set(I, A, B),
                  r.add(this.getPosition()),
                  this.setPosition(r);
              }
              translateLocal(I, A, B) {
                I instanceof h.A ? r.copy(I) : r.set(I, A, B),
                  this.localRotation.transformVector(r, r),
                  this.localPosition.add(r),
                  this._dirtyLocal || this._dirtifyLocal();
              }
              rotate(I, A, B) {
                if ((y.setFromEulerAngles(I, A, B), this._parent === null))
                  this.localRotation.mul2(y, this.localRotation);
                else {
                  const C = this.getRotation(),
                    w = this._parent.getRotation();
                  p.copy(w).invert(),
                    y.mul2(p, y),
                    this.localRotation.mul2(y, C);
                }
                this._dirtyLocal || this._dirtifyLocal();
              }
              rotateLocal(I, A, B) {
                y.setFromEulerAngles(I, A, B),
                  this.localRotation.mul(y),
                  this._dirtyLocal || this._dirtifyLocal();
              }
            }
          },
          340: (Se, W, a) => {
            "use strict";
            a.d(W, { C: () => i });
            var x = a(6630),
              T = a(8869),
              g = a(732),
              c = a(7921);
            const d = !0,
              h = (e, t = 0) => 1 + Math.floor(Math.log2(Math.max(e, t))),
              f = (e) => e.extTextureHalfFloat && e.textureHalfFloatRenderable,
              s = (e) => e.extTextureFloat && e.textureFloatRenderable,
              l = (e) => (f(e) ? c.a7f : s(e) ? c.uC3 : c.jKI),
              n = (e) => c.jKI,
              o = (e, t, r, u) =>
                new T.x(e, {
                  name: `lighting-${t}`,
                  cubemap: !0,
                  width: t,
                  height: t,
                  format: r,
                  type: r === c.jKI ? c.kVJ : c.zZc,
                  addressU: c.uFb,
                  addressV: c.uFb,
                  fixCubemapSeams: d,
                  mipmaps: !!u,
                });
            class i {
              static generateSkyboxCubemap(t, r) {
                const u = t.device,
                  y = o(u, r || (t.cubemap ? t.width : t.width / 4), c.jKI, !1);
                return (0, g.Y)(t, y, { numSamples: 1024 }), y;
              }
              static generateLightingSource(t, r) {
                const u = t.device,
                  y = l(u),
                  p =
                    (r == null ? void 0 : r.target) ||
                    new T.x(u, {
                      name: "lighting-source",
                      cubemap: !0,
                      width: (r == null ? void 0 : r.size) || 128,
                      height: (r == null ? void 0 : r.size) || 128,
                      format: y,
                      type: y === c.jKI ? c.kVJ : c.zZc,
                      addressU: c.uFb,
                      addressV: c.uFb,
                      fixCubemapSeams: !1,
                      mipmaps: !0,
                    });
                return (0, g.Y)(t, p, { numSamples: t.mipmaps ? 1 : 1024 }), p;
              }
              static generateAtlas(t, r) {
                const u = t.device,
                  y = n(),
                  p =
                    (r == null ? void 0 : r.target) ||
                    new T.x(u, {
                      name: "envAtlas",
                      width: (r == null ? void 0 : r.size) || 512,
                      height: (r == null ? void 0 : r.size) || 512,
                      format: y,
                      type: c.kVJ,
                      projection: c.wfm,
                      addressU: c.uFb,
                      addressV: c.uFb,
                      mipmaps: !1,
                    }),
                  _ = p.width / 512,
                  m = new x.T(0, 0, 512 * _, 256 * _),
                  E = h(256) - h(4);
                for (let v = 0; v < E; ++v)
                  (0, g.Y)(t, p, { numSamples: 1, rect: m, seamPixels: _ }),
                    (m.x += m.w),
                    (m.y += m.w),
                    (m.z = Math.max(1, Math.floor(m.z * 0.5))),
                    (m.w = Math.max(1, Math.floor(m.w * 0.5)));
                m.set(0, 256 * _, 256 * _, 128 * _);
                for (let v = 1; v < 7; ++v)
                  (0, g.Y)(t, p, {
                    numSamples:
                      (r == null ? void 0 : r.numReflectionSamples) || 1024,
                    distribution:
                      (r == null ? void 0 : r.distribution) || "ggx",
                    specularPower: Math.max(1, 2048 >> (v * 2)),
                    rect: m,
                    seamPixels: _,
                  }),
                    (m.y += m.w),
                    (m.z = Math.max(1, Math.floor(m.z * 0.5))),
                    (m.w = Math.max(1, Math.floor(m.w * 0.5)));
                return (
                  m.set(128 * _, 384 * _, 64 * _, 32 * _),
                  (0, g.Y)(t, p, {
                    numSamples:
                      (r == null ? void 0 : r.numAmbientSamples) || 2048,
                    distribution: "lambert",
                    rect: m,
                    seamPixels: _,
                  }),
                  p
                );
              }
              static generatePrefilteredAtlas(t, r) {
                const u = t[0].device,
                  y = t[0].format,
                  p = t[0].type,
                  _ =
                    (r == null ? void 0 : r.target) ||
                    new T.x(u, {
                      name: "envPrefilteredAtlas",
                      width: (r == null ? void 0 : r.size) || 512,
                      height: (r == null ? void 0 : r.size) || 512,
                      format: y,
                      type: p,
                      projection: c.wfm,
                      addressU: c.uFb,
                      addressV: c.uFb,
                      mipmaps: !1,
                    }),
                  m = _.width / 512,
                  E = new x.T(0, 0, 512 * m, 256 * m),
                  v = h(512);
                for (let P = 0; P < v; ++P)
                  (0, g.Y)(t[0], _, { numSamples: 1, rect: E, seamPixels: m }),
                    (E.x += E.w),
                    (E.y += E.w),
                    (E.z = Math.max(1, Math.floor(E.z * 0.5))),
                    (E.w = Math.max(1, Math.floor(E.w * 0.5)));
                E.set(0, 256 * m, 256 * m, 128 * m);
                for (let P = 1; P < t.length; ++P)
                  (0, g.Y)(t[P], _, { numSamples: 1, rect: E, seamPixels: m }),
                    (E.y += E.w),
                    (E.z = Math.max(1, Math.floor(E.z * 0.5))),
                    (E.w = Math.max(1, Math.floor(E.w * 0.5)));
                return (
                  E.set(128 * m, 384 * m, 64 * m, 32 * m),
                  r != null && r.legacyAmbient
                    ? (0, g.Y)(t[5], _, {
                        numSamples: 1,
                        rect: E,
                        seamPixels: m,
                      })
                    : (0, g.Y)(t[0], _, {
                        numSamples: (r == null ? void 0 : r.numSamples) || 2048,
                        distribution: "lambert",
                        rect: E,
                        seamPixels: m,
                      }),
                  _
                );
              }
            }
          },
          963: (Se, W, a) => {
            "use strict";
            a.d(W, { _: () => T });
            class x {
              constructor() {
                this.cache = new Map();
              }
              destroy() {
                this.cache.forEach((c, d) => {
                  d.destroy();
                }),
                  this.cache.clear();
              }
              incRef(c) {
                const d = (this.cache.get(c) || 0) + 1;
                this.cache.set(c, d);
              }
              decRef(c) {
                if (c) {
                  let d = this.cache.get(c);
                  d &&
                    (d--,
                    d === 0
                      ? (this.cache.delete(c), c.destroy())
                      : this.cache.set(c, d));
                }
              }
            }
            class T {
              static incRef(c) {
                this.cache.incRef(c);
              }
              static decRef(c) {
                this.cache.decRef(c);
              }
              static destroy() {
                this.cache.destroy();
              }
            }
            T.cache = new x();
          },
          1741: (Se, W, a) => {
            "use strict";
            a.d(W, { c: () => d });
            var x = a(6630),
              T = a(8277),
              g = a(464);
            const c = new x.T();
            class d {
              constructor(f) {
                (this.device = f), (this.needsDepthBuffer = !1);
              }
              render(f, s, l) {}
              drawQuad(f, s, l) {
                let n;
                if (l) {
                  const o = f ? f.width : this.device.width,
                    i = f ? f.height : this.device.height;
                  n = c.set(l.x * o, l.y * i, l.z * o, l.w * i);
                }
                this.device.setBlendState(T.a.NOBLEND),
                  (0, g.H)(this.device, f, s, n);
              }
            }
            d.quadVertexShader = `
				attribute vec2 aPosition;
				varying vec2 vUv0;
				void main(void)
				{
						gl_Position = vec4(aPosition, 0.0, 1.0);
						vUv0 = getImageEffectUV((aPosition.xy + 1.0) * 0.5);
				}
		`;
          },
          464: (Se, W, a) => {
            "use strict";
            a.d(W, { H: () => f, d: () => s });
            var x = a(6630),
              T = a(7921),
              g = a(7013),
              c = a(2277),
              d = a(4354);
            const h = new x.T();
            function f(l, n, o, i, e) {
              l.setCullMode(T.OL2),
                l.setDepthState(g.b.NODEPTH),
                l.setStencilState(null, null);
              const t = new d._(o);
              i ||
                ((i = h),
                (i.x = 0),
                (i.y = 0),
                (i.z = n ? n.width : l.width),
                (i.w = n ? n.height : l.height));
              const r = new c.CD(l, () => {
                t.render(i, e);
              });
              if (
                (r.init(n),
                (r.colorOps.clear = !1),
                (r.depthStencilOps.clearDepth = !1),
                l.isWebGPU && n === null)
              ) {
                var u;
                ((u = n == null ? void 0 : n.samples) != null ? u : l.samples) >
                  1 && (r.colorOps.store = !0);
              }
              r.render(), t.destroy();
            }
            function s(l, n, o, i, e, t) {
              (i = i || l.getCopyShader()),
                l.constantTexSource.setValue(n),
                f(l, o, i, e, t);
            }
          },
          4354: (Se, W, a) => {
            "use strict";
            a.d(W, { _: () => n });
            var x = a(6630),
              T = a(7008),
              g = a(7921),
              c = a(1071),
              d = a(4051),
              h = a(9375);
            const f = { type: g.fmY, base: 0, count: 4, indexed: !1 },
              s = new x.T(),
              l = new x.T();
            class n {
              constructor(i) {
                (this.uniformBuffer = void 0), (this.bindGroup = void 0);
                const e = i.device;
                if (((this.shader = i), e.supportsUniformBuffers)) {
                  const t = new c.C();
                  this.shader = (0, h.$x)(i, t);
                  const r = this.shader.meshUniformBufferFormat;
                  r && (this.uniformBuffer = new d.M(e, r, !1));
                  const u = this.shader.meshBindGroupFormat;
                  this.bindGroup = new T.v(e, u, this.uniformBuffer);
                }
              }
              destroy() {
                var i, e;
                (i = this.uniformBuffer) == null || i.destroy(),
                  (this.uniformBuffer = null),
                  (e = this.bindGroup) == null || e.destroy(),
                  (this.bindGroup = null);
              }
              render(i, e) {
                const t = this.shader.device;
                if (i) {
                  var r;
                  s.set(t.vx, t.vy, t.vw, t.vh),
                    l.set(t.sx, t.sy, t.sw, t.sh),
                    (e = (r = e) != null ? r : i),
                    t.setViewport(i.x, i.y, i.z, i.w),
                    t.setScissor(e.x, e.y, e.z, e.w);
                }
                t.setVertexBuffer(t.quadVertexBuffer, 0);
                const u = this.shader;
                if ((t.setShader(u), t.supportsUniformBuffers)) {
                  var y;
                  const p = this.bindGroup;
                  (y = p.defaultUniformBuffer) == null || y.update(),
                    p.update(),
                    t.setBindGroup(g.Ak$, p);
                }
                t.draw(f),
                  i &&
                    (t.setViewport(s.x, s.y, s.z, s.w),
                    t.setScissor(l.x, l.y, l.z, l.w));
              }
            }
          },
          732: (Se, W, a) => {
            "use strict";
            a.d(W, { Y: () => Y });
            var x = a(14),
              T = a(6556),
              g = a(7921),
              c = a(7338),
              d = a(4738),
              h = a(3412),
              f = a(464),
              s = a(8869),
              l = a(7198),
              n = a(3200),
              o = a(192),
              i = a(9375),
              e = a(8277);
            const t = (Z) => {
                switch (Z) {
                  case g.BuW:
                    return "Cubemap";
                  case g.to1:
                    return "Octahedral";
                  default:
                    return "Equirect";
                }
              },
              r = (Z, ye, pe) => {
                if (Z <= 0)
                  (ye[pe + 0] = 0),
                    (ye[pe + 1] = 0),
                    (ye[pe + 2] = 0),
                    (ye[pe + 3] = 0);
                else if (Z >= 1)
                  (ye[pe + 0] = 255),
                    (ye[pe + 1] = 0),
                    (ye[pe + 2] = 0),
                    (ye[pe + 3] = 0);
                else {
                  let O = (1 * Z) % 1,
                    me = (255 * Z) % 1,
                    N = (65025 * Z) % 1;
                  const V = (16581375 * Z) % 1;
                  (O -= me / 255),
                    (me -= N / 255),
                    (N -= V / 255),
                    (ye[pe + 0] = Math.min(255, Math.floor(O * 256))),
                    (ye[pe + 1] = Math.min(255, Math.floor(me * 256))),
                    (ye[pe + 2] = Math.min(255, Math.floor(N * 256))),
                    (ye[pe + 3] = Math.min(255, Math.floor(V * 256)));
                }
              },
              u = (Z) => {
                const ye = Z.length,
                  pe = Math.min(ye, 512),
                  O = Math.ceil(ye / pe),
                  me = new Uint8Array(pe * O * 4);
                let N = 0;
                for (let V = 0; V < ye; V += 4)
                  r(Z[V + 0] * 0.5 + 0.5, me, N + 0),
                    r(Z[V + 1] * 0.5 + 0.5, me, N + 4),
                    r(Z[V + 2] * 0.5 + 0.5, me, N + 8),
                    r(Z[V + 3] / 8, me, N + 12),
                    (N += 16);
                return { width: pe, height: O, data: me };
              },
              y = (Z, ye, pe, O) => {
                const me = pe * 2 * Math.PI,
                  N = Math.pow(1 - ye, 1 / (O + 1)),
                  V = Math.sqrt(1 - N * N);
                Z.set(Math.cos(me) * V, Math.sin(me) * V, N).normalize();
              },
              p = (Z, ye, pe) => {
                const O = pe * 2 * Math.PI,
                  me = Math.sqrt(1 - ye),
                  N = Math.sqrt(ye);
                Z.set(Math.cos(O) * N, Math.sin(O) * N, me).normalize();
              },
              _ = (Z, ye, pe, O) => {
                const me = pe * 2 * Math.PI,
                  N = Math.sqrt((1 - ye) / (1 + (O * O - 1) * ye)),
                  V = Math.sqrt(1 - N * N);
                Z.set(Math.cos(me) * V, Math.sin(me) * V, N).normalize();
              },
              m = (Z, ye) => {
                const pe = Z * ye,
                  O = ye / (1 - Z * Z + pe * pe);
                return O * O * (1 / Math.PI);
              },
              E = (Z, ye) => {
                const pe = new T.A(),
                  O = [];
                for (let me = 0; me < Z; ++me)
                  y(pe, me / Z, x.M.radicalInverse(me), ye),
                    O.push(pe.x, pe.y, pe.z, 0);
                return O;
              },
              v = (Z, ye) => {
                const pe = ye / Z,
                  O = new T.A(),
                  me = [];
                for (let N = 0; N < Z; ++N) {
                  p(O, N / Z, x.M.radicalInverse(N));
                  const V = O.z / Math.PI,
                    L = 0.5 * Math.log2(pe / V);
                  me.push(O.x, O.y, O.z, L);
                }
                return me;
              },
              P = {
                16: { 2: 26, 8: 20, 32: 17, 128: 16, 512: 16 },
                32: { 2: 53, 8: 40, 32: 34, 128: 32, 512: 32 },
                128: { 2: 214, 8: 163, 32: 139, 128: 130, 512: 128 },
                1024: { 2: 1722, 8: 1310, 32: 1114, 128: 1041, 512: 1025 },
              },
              I = (Z, ye) => {
                const pe = P[Z];
                return (pe && pe[ye]) || Z;
              },
              A = (Z, ye, pe) => {
                const O = pe / Z,
                  me = 1 - Math.log2(ye) / 11,
                  N = me * me,
                  V = new T.A(),
                  L = new T.A(),
                  J = new T.A(0, 0, 1),
                  ae = [],
                  R = I(Z, ye);
                for (let j = 0; j < R; ++j) {
                  _(V, j / R, x.M.radicalInverse(j), N);
                  const se = V.z;
                  if (
                    (L.set(V.x, V.y, V.z)
                      .mulScalar(2 * se)
                      .sub(J),
                    L.z > 0)
                  ) {
                    const ce = m(Math.min(1, se), N) / 4 + 0.001,
                      ie = 0.5 * Math.log2(O / ce);
                    ae.push(L.x, L.y, L.z, ie);
                  }
                }
                for (; ae.length < Z * 4; ) ae.push(0, 0, 0, 0);
                return ae;
              },
              B = (Z, ye, pe) => {
                const O = u(pe);
                return new s.x(Z, {
                  name: ye,
                  width: O.width,
                  height: O.height,
                  mipmaps: !1,
                  minFilter: g.yib,
                  magFilter: g.yib,
                  levels: [O.data],
                });
              };
            class C {
              constructor(ye = !0) {
                (this.map = new Map()), (this.destroyContent = ye);
              }
              destroy() {
                this.destroyContent &&
                  this.map.forEach((ye, pe) => {
                    ye.destroy();
                  });
              }
              get(ye, pe) {
                if (!this.map.has(ye)) {
                  const O = pe();
                  return this.map.set(ye, O), O;
                }
                return this.map.get(ye);
              }
            }
            const w = new C(!1),
              k = new c.c(),
              K = (Z, ye, pe) =>
                k.get(Z, () => new C()).get(ye, () => B(Z, ye, w.get(ye, pe))),
              te = (Z, ye, pe) => {
                const O = `lambert-samples-${ye}-${pe}`;
                return K(Z, O, () => v(ye, pe));
              },
              X = (Z, ye, pe) => {
                const O = `phong-samples-${ye}-${pe}`;
                return K(Z, O, () => E(ye, pe));
              },
              $ = (Z, ye, pe, O) => {
                const me = `ggx-samples-${ye}-${pe}-${O}`;
                return K(Z, me, () => A(ye, pe, O));
              },
              ne = `
attribute vec2 vertex_position;

uniform vec4 uvMod;

varying vec2 vUv0;

void main(void) {
		gl_Position = vec4(vertex_position, 0.5, 1.0);
		vUv0 = getImageEffectUV((vertex_position.xy * 0.5 + 0.5) * uvMod.xy + uvMod.zw);
}
`;
            function Y(Z, ye, pe = {}) {
              var O;
              Z instanceof d.$ &&
                ((Z = arguments[1]),
                (ye = arguments[2]),
                (pe = {}),
                arguments[3] !== void 0 && (pe.specularPower = arguments[3]),
                arguments[4] !== void 0 && (pe.numSamples = arguments[4]));
              const me = {
                  none: "reproject",
                  lambert: "prefilterSamplesUnweighted",
                  phong: "prefilterSamplesUnweighted",
                  ggx: "prefilterSamples",
                },
                N = pe.hasOwnProperty("specularPower") ? pe.specularPower : 1,
                V = pe.hasOwnProperty("face") ? pe.face : null,
                L = pe.hasOwnProperty("distribution")
                  ? pe.distribution
                  : N === 1
                  ? "none"
                  : "phong",
                J = me[L] || "reproject",
                ae = J.startsWith("prefilterSamples"),
                R = l.a.decodeFunc(Z.encoding),
                j = l.a.encodeFunc(ye.encoding),
                se = `sample${t(Z.projection)}`,
                ce = `getDirection${t(ye.projection)}`,
                ie = pe.hasOwnProperty("numSamples") ? pe.numSamples : 1024,
                b = `${J}_${R}_${j}_${se}_${ce}_${ie}`,
                M = Z.device;
              let F = (0, o.N)(M).getCachedShader(b);
              if (!F) {
                const Le =
                  `#define PROCESS_FUNC ${J}
` +
                  (ae
                    ? `#define USE_SAMPLES_TEX
`
                    : "") +
                  (Z.cubemap
                    ? `#define CUBEMAP_SOURCE
`
                    : "") +
                  `#define DECODE_FUNC ${R}
#define ENCODE_FUNC ${j}
#define SOURCE_FUNC ${se}
#define TARGET_FUNC ${ce}
#define NUM_SAMPLES ${ie}
#define NUM_SAMPLES_SQRT ${Math.round(Math.sqrt(ie)).toFixed(1)}
`;
                F = (0, i.JM)(
                  M,
                  ne,
                  `${Le}
${n.n.reprojectPS}`,
                  b
                );
              }
              M.setBlendState(e.a.NOBLEND),
                M.scope
                  .resolve(Z.cubemap ? "sourceCube" : "sourceTex")
                  .setValue(Z);
              const oe = M.scope.resolve("params"),
                de = M.scope.resolve("params2"),
                ge = M.scope.resolve("uvMod");
              if ((O = pe) != null && O.seamPixels) {
                const Le = pe.seamPixels,
                  ke = pe.rect ? pe.rect.z : ye.width,
                  ht = pe.rect ? pe.rect.w : ye.height,
                  _e = ke - Le * 2,
                  U = ht - Le * 2;
                ge.setValue([
                  (_e + Le * 2) / _e,
                  (U + Le * 2) / U,
                  -Le / _e,
                  -Le / U,
                ]);
              } else ge.setValue([1, 1, 0, 0]);
              const Re = [
                  0,
                  N,
                  Z.fixCubemapSeams ? 1 / Z.width : 0,
                  ye.fixCubemapSeams ? 1 / ye.width : 0,
                ],
                Te = [
                  ye.width * ye.height * (ye.cubemap ? 6 : 1),
                  Z.width * Z.height * (Z.cubemap ? 6 : 1),
                ];
              if (ae) {
                const Le = Z.width * Z.height * (Z.cubemap ? 6 : 1),
                  ke =
                    L === "ggx"
                      ? $(M, ie, N, Le)
                      : L === "lambert"
                      ? te(M, ie, Le)
                      : X(M, ie, N);
                M.scope.resolve("samplesTex").setValue(ke),
                  M.scope
                    .resolve("samplesTexInverseSize")
                    .setValue([1 / ke.width, 1 / ke.height]);
              }
              for (let Le = 0; Le < (ye.cubemap ? 6 : 1); Le++)
                if (V === null || Le === V) {
                  var Ne;
                  const ke = new h.A({
                    colorBuffer: ye,
                    face: Le,
                    depth: !1,
                    flipY: M.isWebGPU,
                  });
                  (Re[0] = Le),
                    oe.setValue(Re),
                    de.setValue(Te),
                    (0, f.H)(M, ke, F, (Ne = pe) == null ? void 0 : Ne.rect),
                    ke.destroy();
                }
            }
          },
          7900: (Se, W, a) => {
            "use strict";
            a.d(W, { $: () => l });
            var x = a(7921),
              T = a(3412),
              g = a(8869),
              c = a(8277),
              d = a(3114),
              h = a(7934);
            const f = ["uSceneDepthMap", "uDepthMap"],
              s = ["uSceneColorMap", "texture_grabPass"];
            class l {
              constructor(o, i) {
                (this.scene = i),
                  (this.device = o),
                  (this.layer = null),
                  this.device.webgl2 || this.device.isWebGPU
                    ? this.initMainPath()
                    : this.initFallbackPath();
              }
              static requiresRenderPass(o, i) {
                return o.webgl2 || o.isWebGPU ? !1 : i.renderSceneDepthMap;
              }
              setupUniform(o, i, e) {
                (i ? f : s).forEach((r) => o.scope.resolve(r).setValue(e));
              }
              allocateTexture(o, i, e, t, r, u) {
                return new g.x(o, {
                  name: e,
                  format: t,
                  width: i ? i.colorBuffer.width : o.width,
                  height: i ? i.colorBuffer.height : o.height,
                  mipmaps: u,
                  minFilter: r ? x.yib : u ? x.Snx : x.I5X,
                  magFilter: r ? x.yib : x.I5X,
                  addressU: x.uFb,
                  addressV: x.uFb,
                });
              }
              getSourceColorFormat(o) {
                var i;
                return (i = o == null ? void 0 : o.format) != null
                  ? i
                  : this.device.framebufferFormat;
              }
              shouldReallocate(o, i, e) {
                if (e) {
                  const u = o == null ? void 0 : o.colorBuffer.format,
                    y = this.getSourceColorFormat(i);
                  if (u !== y) return !0;
                }
                const t = (i == null ? void 0 : i.width) || this.device.width,
                  r = (i == null ? void 0 : i.height) || this.device.height;
                return !o || t !== o.width || r !== o.height;
              }
              allocateRenderTarget(o, i, e, t, r, u, y) {
                const p = y ? f : s,
                  _ = this.allocateTexture(e, i, p[0], t, r, u);
                return (
                  o
                    ? (o.destroyFrameBuffers(),
                      r
                        ? (o._depthBuffer = _)
                        : ((o._colorBuffer = _), (o._colorBuffers = [_])))
                    : (o = new T.A({
                        name: "renderTargetSceneGrab",
                        colorBuffer: r ? null : _,
                        depthBuffer: r ? _ : null,
                        depth: !r,
                        stencil: e.supportsStencil,
                        autoResolve: !1,
                      })),
                  o
                );
              }
              releaseRenderTarget(o) {
                o && (o.destroyTextureBuffers(), o.destroy());
              }
              initMainPath() {
                const o = this.device,
                  i = this;
                this.layer = new h.m({
                  enabled: !1,
                  name: "Depth",
                  id: d.Pp,
                  onDisable: function () {
                    i.releaseRenderTarget(this.depthRenderTarget),
                      (this.depthRenderTarget = null),
                      i.releaseRenderTarget(this.colorRenderTarget),
                      (this.colorRenderTarget = null);
                  },
                  onPreRenderOpaque: function (e) {
                    const t = this.cameras[e];
                    if (t.renderSceneColorMap) {
                      var r;
                      if (
                        i.shouldReallocate(
                          this.colorRenderTarget,
                          (r = t.renderTarget) == null ? void 0 : r.colorBuffer,
                          !0
                        )
                      ) {
                        var u;
                        i.releaseRenderTarget(this.colorRenderTarget);
                        const E = i.getSourceColorFormat(
                          (u = t.renderTarget) == null ? void 0 : u.colorBuffer
                        );
                        this.colorRenderTarget = i.allocateRenderTarget(
                          this.colorRenderTarget,
                          t.renderTarget,
                          o,
                          E,
                          !1,
                          !0,
                          !1
                        );
                      }
                      const m = this.colorRenderTarget.colorBuffer;
                      o.isWebGPU
                        ? (o.copyRenderTarget(
                            t.renderTarget,
                            this.colorRenderTarget,
                            !0,
                            !1
                          ),
                          o.mipmapRenderer.generate(
                            this.colorRenderTarget.colorBuffer.impl
                          ))
                        : (o.copyRenderTarget(
                            o.renderTarget,
                            this.colorRenderTarget,
                            !0,
                            !1
                          ),
                          o.activeTexture(o.maxCombinedTextures - 1),
                          o.bindTexture(m),
                          o.gl.generateMipmap(m.impl._glTarget)),
                        i.setupUniform(o, !1, m);
                    }
                    if (t.renderSceneDepthMap) {
                      var y;
                      let m = !0,
                        E = x.sUt;
                      if (o.isWebGPU) {
                        var p, _;
                        ((p =
                          (_ = t.renderTarget) == null ? void 0 : _.samples) !=
                        null
                          ? p
                          : o.samples) > 1 && ((E = x.DYM), (m = !1));
                      }
                      i.shouldReallocate(
                        this.depthRenderTarget,
                        (y = t.renderTarget) == null ? void 0 : y.depthBuffer
                      ) &&
                        (i.releaseRenderTarget(this.depthRenderTarget),
                        (this.depthRenderTarget = i.allocateRenderTarget(
                          this.depthRenderTarget,
                          t.renderTarget,
                          o,
                          E,
                          m,
                          !1,
                          !0
                        ))),
                        o.copyRenderTarget(
                          o.renderTarget,
                          this.depthRenderTarget,
                          !1,
                          !0
                        ),
                        i.setupUniform(
                          o,
                          !0,
                          m
                            ? this.depthRenderTarget.depthBuffer
                            : this.depthRenderTarget.colorBuffer
                        );
                    }
                  },
                  onPostRenderOpaque: function (e) {},
                });
              }
              initFallbackPath() {
                const o = this,
                  i = this.device,
                  e = this.scene;
                this.layer = new h.m({
                  enabled: !1,
                  name: "Depth",
                  id: d.Pp,
                  shaderPass: d.Jb,
                  onEnable: function () {
                    (this.depthRenderTarget = new T.A({
                      name: "depthRenderTarget-webgl1",
                      depth: !0,
                      stencil: i.supportsStencil,
                      autoResolve: !1,
                      graphicsDevice: i,
                    })),
                      (this.renderTarget = this.depthRenderTarget);
                  },
                  onDisable: function () {
                    this.depthRenderTarget.destroyTextureBuffers(),
                      (this.renderTarget = null),
                      o.releaseRenderTarget(this.colorRenderTarget),
                      (this.colorRenderTarget = null);
                  },
                  onPostCull: function (t) {
                    const r = this.cameras[t];
                    if (r.renderSceneDepthMap) {
                      var u, y;
                      if (
                        !(
                          (u = this.depthRenderTarget) != null && u.colorBuffer
                        ) ||
                        o.shouldReallocate(
                          this.depthRenderTarget,
                          (y = r.renderTarget) == null ? void 0 : y.depthBuffer
                        )
                      ) {
                        var p;
                        (p = this.depthRenderTarget) == null ||
                          p.destroyTextureBuffers(),
                          (this.depthRenderTarget = o.allocateRenderTarget(
                            this.depthRenderTarget,
                            r.renderTarget,
                            i,
                            x.jKI,
                            !1,
                            !1,
                            !0
                          )),
                          (this.renderTarget = this.depthRenderTarget);
                      }
                      const _ = this.instances.visibleOpaque[t],
                        m = _.list,
                        E = e.layers,
                        v = E.subLayerEnabled,
                        P = E.subLayerList,
                        I = E.getLayerById(d.kY).renderTarget;
                      let A = 0;
                      const B = E.layerList;
                      for (let C = 0; C < B.length; C++) {
                        const w = B[C];
                        if (w === this) break;
                        if (w.renderTarget !== I || !w.enabled || !v[C])
                          continue;
                        const k = w.cameras.indexOf(r);
                        if (k < 0) continue;
                        let te = P[C]
                          ? w.instances.visibleTransparent[k]
                          : w.instances.visibleOpaque[k];
                        const X = te.length;
                        te = te.list;
                        for (let $ = 0; $ < X; $++) {
                          const ne = te[$];
                          ne.material &&
                            ne.material.depthWrite &&
                            !ne._noDepthDrawGl1 &&
                            ((m[A] = ne), A++);
                        }
                      }
                      _.length = A;
                    }
                  },
                  onPreRenderOpaque: function (t) {
                    const r = this.cameras[t];
                    if (r.renderSceneColorMap) {
                      var u;
                      if (
                        o.shouldReallocate(
                          this.colorRenderTarget,
                          (u = r.renderTarget) == null ? void 0 : u.colorBuffer
                        )
                      ) {
                        var y;
                        o.releaseRenderTarget(this.colorRenderTarget);
                        const m = o.getSourceColorFormat(
                          (y = r.renderTarget) == null ? void 0 : y.colorBuffer
                        );
                        this.colorRenderTarget = o.allocateRenderTarget(
                          this.colorRenderTarget,
                          r.renderTarget,
                          i,
                          m,
                          !1,
                          !1,
                          !1
                        );
                      }
                      const p = this.colorRenderTarget._colorBuffer;
                      p.impl._glTexture || p.impl.initialize(i, p),
                        i.bindTexture(p);
                      const _ = i.gl;
                      _.copyTexImage2D(
                        _.TEXTURE_2D,
                        0,
                        p.impl._glFormat,
                        0,
                        0,
                        p.width,
                        p.height,
                        0
                      ),
                        (p._needsUpload = !1),
                        (p._needsMipmapsUpload = !1),
                        o.setupUniform(i, !1, p);
                    }
                    r.renderSceneDepthMap &&
                      o.setupUniform(i, !0, this.depthRenderTarget.colorBuffer);
                  },
                  onDrawCall: function () {
                    i.setBlendState(c.a.NOBLEND);
                  },
                  onPostRenderOpaque: function (t) {
                    if (this.cameras[t].renderSceneDepthMap) {
                      const u = this.instances.visibleOpaque[t];
                      u.length = 0;
                    }
                  },
                });
              }
              patch(o) {
                (o.onEnable = this.layer.onEnable),
                  (o.onDisable = this.layer.onDisable),
                  (o.onPreRenderOpaque = this.layer.onPreRenderOpaque),
                  (o.onPostRenderOpaque = this.layer.onPostRenderOpaque),
                  (o.shaderPass = this.layer.shaderPass),
                  (o.onPostCull = this.layer.onPostCull),
                  (o.onDrawCall = this.layer.onDrawCall);
              }
            }
          },
          7934: (Se, W, a) => {
            "use strict";
            a.d(W, { m: () => t });
            var x = a(2752),
              T = a(3114),
              g = a(2737);
            function c(r, u) {
              return r.drawOrder - u.drawOrder;
            }
            function d(r, u) {
              const y = r._key[T.Uo],
                p = u._key[T.Uo];
              return y === p && r.mesh && u.mesh
                ? u.mesh.id - r.mesh.id
                : p - y;
            }
            function h(r, u) {
              return u.zdist - r.zdist;
            }
            function f(r, u) {
              return r.zdist - u.zdist;
            }
            const s = [null, c, d, h, f];
            function l(r, u) {
              return u.key - r.key;
            }
            let n = 0;
            const o = [];
            class i {
              constructor() {
                (this.list = []), (this.length = 0), (this.done = !1);
              }
            }
            class e {
              constructor() {
                (this.opaqueMeshInstances = []),
                  (this.transparentMeshInstances = []),
                  (this.shadowCasters = []),
                  (this.visibleOpaque = []),
                  (this.visibleTransparent = []);
              }
              prepare(u) {
                this.visibleOpaque[u] || (this.visibleOpaque[u] = new i()),
                  this.visibleTransparent[u] ||
                    (this.visibleTransparent[u] = new i()),
                  (this.visibleOpaque[u].done = !1),
                  (this.visibleTransparent[u].done = !1);
              }
              delete(u) {
                u < this.visibleOpaque.length &&
                  this.visibleOpaque.splice(u, 1),
                  u < this.visibleTransparent.length &&
                    this.visibleTransparent.splice(u, 1);
              }
            }
            class t {
              constructor(u = {}) {
                var y, p, _, m, E;
                u.id !== void 0
                  ? ((this.id = u.id), (n = Math.max(this.id + 1, n)))
                  : (this.id = n++),
                  (this.name = u.name),
                  (this._enabled = (y = u.enabled) != null ? y : !0),
                  (this._refCounter = this._enabled ? 1 : 0),
                  (this.opaqueSortMode =
                    (p = u.opaqueSortMode) != null ? p : T.lI),
                  (this.transparentSortMode =
                    (_ = u.transparentSortMode) != null ? _ : T.oJ),
                  u.renderTarget && (this.renderTarget = u.renderTarget),
                  (this.shaderPass = (m = u.shaderPass) != null ? m : T.lW),
                  (this.passThrough = (E = u.passThrough) != null ? E : !1),
                  (this._clearColorBuffer = !!u.clearColorBuffer),
                  (this._clearDepthBuffer = !!u.clearDepthBuffer),
                  (this._clearStencilBuffer = !!u.clearStencilBuffer),
                  (this.onPreCull = u.onPreCull),
                  (this.onPreRender = u.onPreRender),
                  (this.onPreRenderOpaque = u.onPreRenderOpaque),
                  (this.onPreRenderTransparent = u.onPreRenderTransparent),
                  (this.onPostCull = u.onPostCull),
                  (this.onPostRender = u.onPostRender),
                  (this.onPostRenderOpaque = u.onPostRenderOpaque),
                  (this.onPostRenderTransparent = u.onPostRenderTransparent),
                  (this.onDrawCall = u.onDrawCall),
                  (this.onEnable = u.onEnable),
                  (this.onDisable = u.onDisable),
                  this._enabled && this.onEnable && this.onEnable(),
                  (this.layerReference = u.layerReference),
                  (this.instances = u.layerReference
                    ? u.layerReference.instances
                    : new e()),
                  (this.opaqueMeshInstances =
                    this.instances.opaqueMeshInstances),
                  (this.transparentMeshInstances =
                    this.instances.transparentMeshInstances),
                  (this.shadowCasters = this.instances.shadowCasters),
                  (this.customSortCallback = null),
                  (this.customCalculateSortValues = null),
                  (this._lights = []),
                  (this._lightsSet = new Set()),
                  (this._clusteredLightsSet = new Set()),
                  (this._splitLights = [[], [], []]),
                  (this.cameras = []),
                  (this._dirty = !1),
                  (this._dirtyLights = !1),
                  (this._dirtyCameras = !1),
                  (this._lightHash = 0),
                  (this._lightHashDirty = !1),
                  (this._shaderVersion = -1),
                  (this._lightCube = null);
              }
              get hasClusteredLights() {
                return this._clusteredLightsSet.size > 0;
              }
              set enabled(u) {
                u !== this._enabled &&
                  ((this._enabled = u),
                  u
                    ? (this.incrementCounter(),
                      this.onEnable && this.onEnable())
                    : (this.decrementCounter(),
                      this.onDisable && this.onDisable()));
              }
              get enabled() {
                return this._enabled;
              }
              set clearColorBuffer(u) {
                (this._clearColorBuffer = u), (this._dirtyCameras = !0);
              }
              get clearColorBuffer() {
                return this._clearColorBuffer;
              }
              set clearDepthBuffer(u) {
                (this._clearDepthBuffer = u), (this._dirtyCameras = !0);
              }
              get clearDepthBuffer() {
                return this._clearDepthBuffer;
              }
              set clearStencilBuffer(u) {
                (this._clearStencilBuffer = u), (this._dirtyCameras = !0);
              }
              get clearStencilBuffer() {
                return this._clearStencilBuffer;
              }
              get clusteredLightsSet() {
                return this._clusteredLightsSet;
              }
              incrementCounter() {
                this._refCounter === 0 &&
                  ((this._enabled = !0), this.onEnable && this.onEnable()),
                  this._refCounter++;
              }
              decrementCounter() {
                if (this._refCounter === 1)
                  (this._enabled = !1), this.onDisable && this.onDisable();
                else if (this._refCounter === 0) return;
                this._refCounter--;
              }
              addMeshInstances(u, y) {
                const p = this._shaderVersion,
                  _ = this.shadowCasters;
                for (let m = 0; m < u.length; m++) {
                  const E = u[m],
                    v = E.material,
                    P =
                      v.blendType === T.He
                        ? this.opaqueMeshInstances
                        : this.transparentMeshInstances;
                  this.opaqueMeshInstances.indexOf(E) < 0 &&
                    this.transparentMeshInstances.indexOf(E) < 0 &&
                    P.push(E),
                    !y && E.castShadow && _.indexOf(E) < 0 && _.push(E),
                    !this.passThrough &&
                      p >= 0 &&
                      v._shaderVersion !== p &&
                      (v.getShaderVariant !== g.F.prototype.getShaderVariant &&
                        v.clearVariants(),
                      (v._shaderVersion = p));
                }
                this.passThrough || (this._dirty = !0);
              }
              removeMeshInstanceFromArray(u, y) {
                const p = y.indexOf(u);
                p >= 0 && y.splice(p, 1);
              }
              removeMeshInstances(u, y) {
                const p = this.opaqueMeshInstances,
                  _ = this.transparentMeshInstances,
                  m = this.shadowCasters;
                for (let E = 0; E < u.length; E++) {
                  const v = u[E];
                  if (
                    (this.removeMeshInstanceFromArray(v, p),
                    this.removeMeshInstanceFromArray(v, _),
                    !y)
                  ) {
                    const P = m.indexOf(v);
                    P >= 0 && m.splice(P, 1);
                  }
                }
                this._dirty = !0;
              }
              clearMeshInstances(u) {
                (this.opaqueMeshInstances.length === 0 &&
                  this.transparentMeshInstances.length === 0 &&
                  (u || this.shadowCasters.length === 0)) ||
                  ((this.opaqueMeshInstances.length = 0),
                  (this.transparentMeshInstances.length = 0),
                  u || (this.shadowCasters.length = 0),
                  this.passThrough || (this._dirty = !0));
              }
              addLight(u) {
                const y = u.light;
                this._lightsSet.has(y) ||
                  (this._lightsSet.add(y),
                  this._lights.push(y),
                  (this._dirtyLights = !0),
                  (this._lightHashDirty = !0)),
                  y.type !== T.WQ && this._clusteredLightsSet.add(y);
              }
              removeLight(u) {
                const y = u.light;
                this._lightsSet.has(y) &&
                  (this._lightsSet.delete(y),
                  this._lights.splice(this._lights.indexOf(y), 1),
                  (this._dirtyLights = !0),
                  (this._lightHashDirty = !0)),
                  y.type !== T.WQ && this._clusteredLightsSet.delete(y);
              }
              clearLights() {
                this._lightsSet.clear(),
                  this._clusteredLightsSet.clear(),
                  (this._lights.length = 0),
                  (this._dirtyLights = !0);
              }
              addShadowCasters(u) {
                const y = this.shadowCasters;
                for (let p = 0; p < u.length; p++) {
                  const _ = u[p];
                  _.castShadow && y.indexOf(_) < 0 && y.push(_);
                }
                this._dirtyLights = !0;
              }
              removeShadowCasters(u) {
                const y = this.shadowCasters;
                for (let p = 0; p < u.length; p++) {
                  const _ = y.indexOf(u[p]);
                  _ >= 0 && y.splice(_, 1);
                }
                this._dirtyLights = !0;
              }
              getLightHash(u) {
                if (this._lightHashDirty) {
                  (this._lightHashDirty = !1), (this._lightHash = 0);
                  const y = this._lights;
                  if (y.length > 0) {
                    y.sort(l);
                    for (let p = 0; p < y.length; p++)
                      (u && y[p].type !== T.WQ) || o.push(y[p].key);
                    o.length > 0 &&
                      ((this._lightHash = (0, x.A)(o)), (o.length = 0));
                  }
                }
                return this._lightHash;
              }
              addCamera(u) {
                this.cameras.indexOf(u) >= 0 ||
                  (this.cameras.push(u), (this._dirtyCameras = !0));
              }
              removeCamera(u) {
                const y = this.cameras.indexOf(u);
                y >= 0 &&
                  (this.cameras.splice(y, 1),
                  (this._dirtyCameras = !0),
                  this.instances.delete(y));
              }
              clearCameras() {
                (this.cameras.length = 0), (this._dirtyCameras = !0);
              }
              _calculateSortDistances(u, y, p, _) {
                for (let m = 0; m < y; m++) {
                  const E = u[m];
                  if (E.command || E.layer <= T.ly) continue;
                  if (E.calculateSortDistance) {
                    E.zdist = E.calculateSortDistance(E, p, _);
                    continue;
                  }
                  const v = E.aabb.center,
                    P = v.x - p.x,
                    I = v.y - p.y,
                    A = v.z - p.z;
                  E.zdist = P * _.x + I * _.y + A * _.z;
                }
              }
              _sortVisible(u, y, p) {
                const _ = this.instances,
                  m = u ? this.transparentSortMode : this.opaqueSortMode;
                if (m === T.sB) return;
                const E = u ? _.visibleTransparent[p] : _.visibleOpaque[p];
                if (m === T.T4) {
                  const v = y.getPosition(),
                    P = y.forward;
                  this.customCalculateSortValues &&
                    this.customCalculateSortValues(E.list, E.length, v, P),
                    E.list.length !== E.length && (E.list.length = E.length),
                    this.customSortCallback &&
                      E.list.sort(this.customSortCallback);
                } else {
                  if (m === T.oJ || m === T.SG) {
                    const v = y.getPosition(),
                      P = y.forward;
                    this._calculateSortDistances(E.list, E.length, v, P);
                  }
                  E.list.length !== E.length && (E.list.length = E.length),
                    E.list.sort(s[m]);
                }
              }
            }
          },
          8632: (Se, W, a) => {
            "use strict";
            a.d(W, { J: () => i, _: () => u });
            var x = a(4585),
              T = a(1367),
              g = a(9758),
              c = a(2978),
              d = a(6556),
              h = a(6630),
              f = a(3114),
              s = a(8400);
            const l = new d.A(),
              n = { bias: 0, normalBias: 0 },
              o = { r: 0, g: 1, b: 2, a: 3 },
              i = { directional: f.WQ, omni: f.bA, point: f.bA, spot: f.z0 },
              e = [
                [new h.T(0, 0, 1, 1)],
                [new h.T(0, 0, 0.5, 0.5), new h.T(0, 0.5, 0.5, 0.5)],
                [
                  new h.T(0, 0, 0.5, 0.5),
                  new h.T(0, 0.5, 0.5, 0.5),
                  new h.T(0.5, 0, 0.5, 0.5),
                ],
                [
                  new h.T(0, 0, 0.5, 0.5),
                  new h.T(0, 0.5, 0.5, 0.5),
                  new h.T(0.5, 0, 0.5, 0.5),
                  new h.T(0.5, 0.5, 0.5, 0.5),
                ],
              ];
            let t = 0;
            class r {
              constructor(p, _, m, E) {
                (this.light = E),
                  (this.camera = _),
                  (this.shadowCamera = s.b.createShadowCamera(
                    p,
                    E._shadowType,
                    E._type,
                    m
                  )),
                  (this.shadowMatrix = new g.y()),
                  (this.shadowViewport = new h.T(0, 0, 1, 1)),
                  (this.shadowScissor = new h.T(0, 0, 1, 1)),
                  (this.depthRangeCompensation = 0),
                  (this.projectionCompensation = 0),
                  (this.face = m),
                  (this.visibleCasters = []),
                  (this.viewBindGroups = []);
              }
              destroy() {
                this.viewBindGroups.forEach((p) => {
                  p.defaultUniformBuffer.destroy(), p.destroy();
                }),
                  (this.viewBindGroups.length = 0);
              }
              get shadowBuffer() {
                const p = this.shadowCamera.renderTarget;
                if (p) {
                  const _ = this.light;
                  return _._type === f.bA
                    ? p.colorBuffer
                    : _._isPcf && _.device.supportsDepthShadow
                    ? p.depthBuffer
                    : p.colorBuffer;
                }
                return null;
              }
            }
            class u {
              constructor(p) {
                (this.device = p),
                  (this.id = t++),
                  (this._type = f.WQ),
                  (this._color = new T.I(0.8, 0.8, 0.8)),
                  (this._intensity = 1),
                  (this._affectSpecularity = !0),
                  (this._luminance = 0),
                  (this._castShadows = !1),
                  (this._enabled = !1),
                  (this.mask = f.BN),
                  (this.isStatic = !1),
                  (this.key = 0),
                  (this.bakeDir = !0),
                  (this.bakeNumSamples = 1),
                  (this.bakeArea = 0),
                  (this.attenuationStart = 10),
                  (this.attenuationEnd = 10),
                  (this._falloffMode = f.MU),
                  (this._shadowType = f.iW),
                  (this._vsmBlurSize = 11),
                  (this.vsmBlurMode = f.J2),
                  (this.vsmBias = 0.0025),
                  (this._cookie = null),
                  (this.cookieIntensity = 1),
                  (this._cookieFalloff = !0),
                  (this._cookieChannel = "rgb"),
                  (this._cookieTransform = null),
                  (this._cookieTransformUniform = new Float32Array(4)),
                  (this._cookieOffset = null),
                  (this._cookieOffsetUniform = new Float32Array(2)),
                  (this._cookieTransformSet = !1),
                  (this._cookieOffsetSet = !1),
                  (this._innerConeAngle = 40),
                  (this._outerConeAngle = 45),
                  (this.cascades = null),
                  (this._shadowMatrixPalette = null),
                  (this._shadowCascadeDistances = null),
                  (this.numCascades = 1),
                  (this.cascadeDistribution = 0.5),
                  (this._shape = f.pI),
                  (this._finalColor = new Float32Array([0.8, 0.8, 0.8]));
                const _ = Math.pow(this._finalColor[0], 2.2);
                (this._linearFinalColor = new Float32Array([_, _, _])),
                  (this._position = new d.A(0, 0, 0)),
                  (this._direction = new d.A(0, 0, 0)),
                  (this._innerConeAngleCos = Math.cos(
                    (this._innerConeAngle * Math.PI) / 180
                  )),
                  this._updateOuterAngle(this._outerConeAngle),
                  (this._usePhysicalUnits = void 0),
                  (this._shadowMap = null),
                  (this._shadowRenderParams = []),
                  (this._shadowCameraParams = []),
                  (this.shadowDistance = 40),
                  (this._shadowResolution = 1024),
                  (this.shadowBias = -5e-4),
                  (this.shadowIntensity = 1),
                  (this._normalOffsetBias = 0),
                  (this.shadowUpdateMode = f.v5),
                  (this.shadowUpdateOverrides = null),
                  (this._penumbraSize = 1),
                  (this._isVsm = !1),
                  (this._isPcf = !0),
                  (this._cookieMatrix = null),
                  (this._atlasViewport = null),
                  (this.atlasViewportAllocated = !1),
                  (this.atlasVersion = 0),
                  (this.atlasSlotIndex = 0),
                  (this.atlasSlotUpdated = !1),
                  (this._scene = null),
                  (this._node = null),
                  (this._renderData = []),
                  (this.visibleThisFrame = !1),
                  (this.maxScreenSize = 0);
              }
              destroy() {
                this._destroyShadowMap(),
                  this.releaseRenderData(),
                  (this._renderData = null);
              }
              releaseRenderData() {
                if (this._renderData) {
                  for (let p = 0; p < this._renderData.length; p++)
                    this._renderData[p].destroy();
                  this._renderData.length = 0;
                }
              }
              set numCascades(p) {
                (!this.cascades || this.numCascades !== p) &&
                  ((this.cascades = e[p - 1]),
                  (this._shadowMatrixPalette = new Float32Array(64)),
                  (this._shadowCascadeDistances = new Float32Array(4)),
                  this._destroyShadowMap(),
                  this.updateKey());
              }
              get numCascades() {
                return this.cascades.length;
              }
              set shadowMap(p) {
                this._shadowMap !== p &&
                  (this._destroyShadowMap(), (this._shadowMap = p));
              }
              get shadowMap() {
                return this._shadowMap;
              }
              get numShadowFaces() {
                const p = this._type;
                return p === f.WQ ? this.numCascades : p === f.bA ? 6 : 1;
              }
              set type(p) {
                if (this._type === p) return;
                (this._type = p), this._destroyShadowMap(), this.updateKey();
                const _ = this._shadowType;
                (this._shadowType = null),
                  (this.shadowUpdateOverrides = null),
                  (this.shadowType = _);
              }
              get type() {
                return this._type;
              }
              set shape(p) {
                if (this._shape === p) return;
                (this._shape = p), this._destroyShadowMap(), this.updateKey();
                const _ = this._shadowType;
                (this._shadowType = null), (this.shadowType = _);
              }
              get shape() {
                return this._shape;
              }
              set usePhysicalUnits(p) {
                this._usePhysicalUnits !== p &&
                  ((this._usePhysicalUnits = p), this._updateFinalColor());
              }
              get usePhysicalUnits() {
                return this._usePhysicalUnits;
              }
              set shadowType(p) {
                if (this._shadowType === p) return;
                const _ = this.device;
                this._type === f.bA && p !== f.iW && p !== f.b3 && (p = f.iW);
                const m = _.supportsDepthShadow;
                p === f.sz && !m && (p = f.iW),
                  p === f.oK && !_.textureFloatRenderable && (p = f.J7),
                  p === f.J7 && !_.textureHalfFloatRenderable && (p = f.JN),
                  (this._isVsm = p >= f.JN && p <= f.oK),
                  (this._isPcf = p === f.sH || p === f.iW || p === f.sz),
                  (this._shadowType = p),
                  this._destroyShadowMap(),
                  this.updateKey();
              }
              get shadowType() {
                return this._shadowType;
              }
              set enabled(p) {
                this._enabled !== p &&
                  ((this._enabled = p), this.layersDirty());
              }
              get enabled() {
                return this._enabled;
              }
              set castShadows(p) {
                this._castShadows !== p &&
                  ((this._castShadows = p),
                  this._destroyShadowMap(),
                  this.layersDirty(),
                  this.updateKey());
              }
              get castShadows() {
                return (
                  this._castShadows && this.mask !== f.ew && this.mask !== 0
                );
              }
              set shadowResolution(p) {
                this._shadowResolution !== p &&
                  (this._type === f.bA
                    ? (p = Math.min(p, this.device.maxCubeMapSize))
                    : (p = Math.min(p, this.device.maxTextureSize)),
                  (this._shadowResolution = p),
                  this._destroyShadowMap());
              }
              get shadowResolution() {
                return this._shadowResolution;
              }
              set vsmBlurSize(p) {
                this._vsmBlurSize !== p &&
                  (p % 2 === 0 && p++, (this._vsmBlurSize = p));
              }
              get vsmBlurSize() {
                return this._vsmBlurSize;
              }
              set normalOffsetBias(p) {
                this._normalOffsetBias !== p &&
                  (((!this._normalOffsetBias && p) ||
                    (this._normalOffsetBias && !p)) &&
                    this.updateKey(),
                  (this._normalOffsetBias = p));
              }
              get normalOffsetBias() {
                return this._normalOffsetBias;
              }
              set falloffMode(p) {
                this._falloffMode !== p &&
                  ((this._falloffMode = p), this.updateKey());
              }
              get falloffMode() {
                return this._falloffMode;
              }
              set innerConeAngle(p) {
                this._innerConeAngle !== p &&
                  ((this._innerConeAngle = p),
                  (this._innerConeAngleCos = Math.cos((p * Math.PI) / 180)),
                  this._usePhysicalUnits && this._updateFinalColor());
              }
              get innerConeAngle() {
                return this._innerConeAngle;
              }
              set outerConeAngle(p) {
                this._outerConeAngle !== p &&
                  ((this._outerConeAngle = p),
                  this._updateOuterAngle(p),
                  this._usePhysicalUnits && this._updateFinalColor());
              }
              get outerConeAngle() {
                return this._outerConeAngle;
              }
              set penumbraSize(p) {
                this._penumbraSize = p;
              }
              get penumbraSize() {
                return this._penumbraSize;
              }
              _updateOuterAngle(p) {
                const _ = (p * Math.PI) / 180;
                (this._outerConeAngleCos = Math.cos(_)),
                  (this._outerConeAngleSin = Math.sin(_));
              }
              set intensity(p) {
                this._intensity !== p &&
                  ((this._intensity = p), this._updateFinalColor());
              }
              get intensity() {
                return this._intensity;
              }
              set affectSpecularity(p) {
                this._type === f.WQ &&
                  ((this._affectSpecularity = p), this.updateKey());
              }
              get affectSpecularity() {
                return this._affectSpecularity;
              }
              set luminance(p) {
                this._luminance !== p &&
                  ((this._luminance = p), this._updateFinalColor());
              }
              get luminance() {
                return this._luminance;
              }
              get cookieMatrix() {
                return (
                  this._cookieMatrix || (this._cookieMatrix = new g.y()),
                  this._cookieMatrix
                );
              }
              get atlasViewport() {
                return (
                  this._atlasViewport ||
                    (this._atlasViewport = new h.T(0, 0, 1, 1)),
                  this._atlasViewport
                );
              }
              set cookie(p) {
                this._cookie !== p && ((this._cookie = p), this.updateKey());
              }
              get cookie() {
                return this._cookie;
              }
              set cookieFalloff(p) {
                this._cookieFalloff !== p &&
                  ((this._cookieFalloff = p), this.updateKey());
              }
              get cookieFalloff() {
                return this._cookieFalloff;
              }
              set cookieChannel(p) {
                if (this._cookieChannel !== p) {
                  if (p.length < 3) {
                    const _ = p.charAt(p.length - 1),
                      m = 3 - p.length;
                    for (let E = 0; E < m; E++) p += _;
                  }
                  (this._cookieChannel = p), this.updateKey();
                }
              }
              get cookieChannel() {
                return this._cookieChannel;
              }
              set cookieTransform(p) {
                this._cookieTransform !== p &&
                  ((this._cookieTransform = p),
                  (this._cookieTransformSet = !!p),
                  p &&
                    !this._cookieOffset &&
                    ((this.cookieOffset = new c.S()),
                    (this._cookieOffsetSet = !1)),
                  this.updateKey());
              }
              get cookieTransform() {
                return this._cookieTransform;
              }
              set cookieOffset(p) {
                if (this._cookieOffset === p) return;
                !!(this._cookieTransformSet || p) && !p && this._cookieOffset
                  ? this._cookieOffset.set(0, 0)
                  : (this._cookieOffset = p),
                  (this._cookieOffsetSet = !!p),
                  p &&
                    !this._cookieTransform &&
                    ((this.cookieTransform = new h.T(1, 1, 0, 0)),
                    (this._cookieTransformSet = !1)),
                  this.updateKey();
              }
              get cookieOffset() {
                return this._cookieOffset;
              }
              beginFrame() {
                (this.visibleThisFrame = this._type === f.WQ && this._enabled),
                  (this.maxScreenSize = 0),
                  (this.atlasViewportAllocated = !1),
                  (this.atlasSlotUpdated = !1);
              }
              _destroyShadowMap() {
                if (
                  (this.releaseRenderData(),
                  this._shadowMap &&
                    (this._shadowMap.cached || this._shadowMap.destroy(),
                    (this._shadowMap = null)),
                  this.shadowUpdateMode === f.yo &&
                    (this.shadowUpdateMode = f.b1),
                  this.shadowUpdateOverrides)
                )
                  for (let p = 0; p < this.shadowUpdateOverrides.length; p++)
                    this.shadowUpdateOverrides[p] === f.yo &&
                      (this.shadowUpdateOverrides[p] = f.b1);
              }
              getRenderData(p, _) {
                for (let E = 0; E < this._renderData.length; E++) {
                  const v = this._renderData[E];
                  if (v.camera === p && v.face === _) return v;
                }
                const m = new r(this.device, p, _, this);
                return this._renderData.push(m), m;
              }
              clone() {
                const p = new u(this.device);
                return (
                  (p.type = this._type),
                  p.setColor(this._color),
                  (p.intensity = this._intensity),
                  (p.affectSpecularity = this._affectSpecularity),
                  (p.luminance = this._luminance),
                  (p.castShadows = this.castShadows),
                  (p._enabled = this._enabled),
                  (p.attenuationStart = this.attenuationStart),
                  (p.attenuationEnd = this.attenuationEnd),
                  (p.falloffMode = this._falloffMode),
                  (p.shadowType = this._shadowType),
                  (p.vsmBlurSize = this._vsmBlurSize),
                  (p.vsmBlurMode = this.vsmBlurMode),
                  (p.vsmBias = this.vsmBias),
                  (p.penumbraSize = this.penumbraSize),
                  (p.shadowUpdateMode = this.shadowUpdateMode),
                  (p.mask = this.mask),
                  this.shadowUpdateOverrides &&
                    (p.shadowUpdateOverrides =
                      this.shadowUpdateOverrides.slice()),
                  (p.innerConeAngle = this._innerConeAngle),
                  (p.outerConeAngle = this._outerConeAngle),
                  (p.numCascades = this.numCascades),
                  (p.cascadeDistribution = this.cascadeDistribution),
                  (p.shape = this._shape),
                  (p.shadowBias = this.shadowBias),
                  (p.normalOffsetBias = this._normalOffsetBias),
                  (p.shadowResolution = this._shadowResolution),
                  (p.shadowDistance = this.shadowDistance),
                  (p.shadowIntensity = this.shadowIntensity),
                  p
                );
              }
              static getLightUnitConversion(p, _ = Math.PI / 4, m = 0) {
                switch (p) {
                  case f.z0: {
                    const E = Math.cos(_),
                      v = Math.cos(m);
                    return 2 * Math.PI * (1 - v + (v - E) / 2);
                  }
                  case f.bA:
                    return 4 * Math.PI;
                  case f.WQ:
                    return 1;
                }
              }
              _getUniformBiasValues(p) {
                const _ = p.shadowCamera._farClip;
                switch (this._type) {
                  case f.bA:
                    (n.bias = this.shadowBias),
                      (n.normalBias = this._normalOffsetBias);
                    break;
                  case f.z0:
                    this._isVsm
                      ? (n.bias = -2e-4)
                      : ((n.bias = this.shadowBias * 20),
                        !this.device.webgl2 &&
                          this.device.extStandardDerivatives &&
                          (n.bias *= -100)),
                      (n.normalBias = this._isVsm
                        ? this.vsmBias / (this.attenuationEnd / 7)
                        : this._normalOffsetBias);
                    break;
                  case f.WQ:
                    this._isVsm
                      ? (n.bias = -2e-4)
                      : ((n.bias = (this.shadowBias / _) * 100),
                        !this.device.webgl2 &&
                          this.device.extStandardDerivatives &&
                          (n.bias *= -100)),
                      (n.normalBias = this._isVsm
                        ? this.vsmBias / (_ / 7)
                        : this._normalOffsetBias);
                    break;
                }
                return n;
              }
              getColor() {
                return this._color;
              }
              getBoundingSphere(p) {
                if (this._type === f.z0) {
                  const _ = this.attenuationEnd,
                    m = this._outerConeAngle,
                    E = this._outerConeAngleCos,
                    v = this._node;
                  l.copy(v.up),
                    m > 45
                      ? ((p.radius = _ * this._outerConeAngleSin),
                        l.mulScalar(-_ * E))
                      : ((p.radius = _ / (2 * E)), l.mulScalar(-p.radius)),
                    p.center.add2(v.getPosition(), l);
                } else
                  this._type === f.bA &&
                    ((p.center = this._node.getPosition()),
                    (p.radius = this.attenuationEnd));
              }
              getBoundingBox(p) {
                if (this._type === f.z0) {
                  const _ = this.attenuationEnd,
                    m = this._outerConeAngle,
                    E = this._node,
                    v = Math.abs(Math.sin(m * x.m.DEG_TO_RAD) * _);
                  p.center.set(0, -_ * 0.5, 0),
                    p.halfExtents.set(v, _ * 0.5, v),
                    p.setFromTransformedAabb(p, E.getWorldTransform(), !0);
                } else
                  this._type === f.bA &&
                    (p.center.copy(this._node.getPosition()),
                    p.halfExtents.set(
                      this.attenuationEnd,
                      this.attenuationEnd,
                      this.attenuationEnd
                    ));
              }
              _updateFinalColor() {
                const p = this._color,
                  _ = p.r,
                  m = p.g,
                  E = p.b;
                let v = this._intensity;
                this._usePhysicalUnits &&
                  (v =
                    this._luminance /
                    u.getLightUnitConversion(
                      this._type,
                      this._outerConeAngle * x.m.DEG_TO_RAD,
                      this._innerConeAngle * x.m.DEG_TO_RAD
                    ));
                const P = this._finalColor,
                  I = this._linearFinalColor;
                (P[0] = _ * v),
                  (P[1] = m * v),
                  (P[2] = E * v),
                  v >= 1
                    ? ((I[0] = Math.pow(_, 2.2) * v),
                      (I[1] = Math.pow(m, 2.2) * v),
                      (I[2] = Math.pow(E, 2.2) * v))
                    : ((I[0] = Math.pow(P[0], 2.2)),
                      (I[1] = Math.pow(P[1], 2.2)),
                      (I[2] = Math.pow(P[2], 2.2)));
              }
              setColor() {
                arguments.length === 1
                  ? this._color.set(
                      arguments[0].r,
                      arguments[0].g,
                      arguments[0].b
                    )
                  : arguments.length === 3 &&
                    this._color.set(arguments[0], arguments[1], arguments[2]),
                  this._updateFinalColor();
              }
              layersDirty() {
                var p;
                (p = this._scene) != null &&
                  p.layers &&
                  (this._scene.layers._dirtyLights = !0);
              }
              updateKey() {
                let p =
                  (this._type << 29) |
                  ((this._castShadows ? 1 : 0) << 28) |
                  (this._shadowType << 25) |
                  (this._falloffMode << 23) |
                  ((this._normalOffsetBias !== 0 ? 1 : 0) << 22) |
                  ((this._cookie ? 1 : 0) << 21) |
                  ((this._cookieFalloff ? 1 : 0) << 20) |
                  (o[this._cookieChannel.charAt(0)] << 18) |
                  ((this._cookieTransform ? 1 : 0) << 12) |
                  (this._shape << 10) |
                  ((this.numCascades - 1) << 8) |
                  ((this.affectSpecularity ? 1 : 0) << 7);
                this._cookieChannel.length === 3 &&
                  ((p |= o[this._cookieChannel.charAt(1)] << 16),
                  (p |= o[this._cookieChannel.charAt(2)] << 14)),
                  p !== this.key && this._scene !== null && this.layersDirty(),
                  (this.key = p);
              }
            }
          },
          4641: (Se, W, a) => {
            "use strict";
            a.d(W, { w: () => c });
            var x = a(4585),
              T = a(6556),
              g = a(3114);
            class c {
              constructor(h, f, s) {
                (this._areaLightsEnabled = !1),
                  (this._cells = new T.A(10, 3, 10)),
                  (this._maxLightsPerCell = 255),
                  (this._shadowsEnabled = !0),
                  (this._shadowType = g.iW),
                  (this._shadowAtlasResolution = 2048),
                  (this._cookiesEnabled = !1),
                  (this._cookieAtlasResolution = 2048),
                  (this.debugLayer = void 0),
                  (this.atlasSplit = null),
                  (this._supportsAreaLights = h),
                  (this._maxTextureSize = f),
                  (this._dirtyLightsFnc = s);
              }
              applySettings(h) {
                var f, s, l, n, o, i, e;
                (this.shadowsEnabled =
                  (f = h.lightingShadowsEnabled) != null
                    ? f
                    : this.shadowsEnabled),
                  (this.cookiesEnabled =
                    (s = h.lightingCookiesEnabled) != null
                      ? s
                      : this.cookiesEnabled),
                  (this.areaLightsEnabled =
                    (l = h.lightingAreaLightsEnabled) != null
                      ? l
                      : this.areaLightsEnabled),
                  (this.shadowAtlasResolution =
                    (n = h.lightingShadowAtlasResolution) != null
                      ? n
                      : this.shadowAtlasResolution),
                  (this.cookieAtlasResolution =
                    (o = h.lightingCookieAtlasResolution) != null
                      ? o
                      : this.cookieAtlasResolution),
                  (this.maxLightsPerCell =
                    (i = h.lightingMaxLightsPerCell) != null
                      ? i
                      : this.maxLightsPerCell),
                  (this.shadowType =
                    (e = h.lightingShadowType) != null ? e : this.shadowType),
                  h.lightingCells && (this.cell = new T.A(h.lightingCells));
              }
              set cells(h) {
                this._cells.copy(h);
              }
              get cells() {
                return this._cells;
              }
              set maxLightsPerCell(h) {
                this._maxLightsPerCell = x.m.clamp(h, 1, 255);
              }
              get maxLightsPerCell() {
                return this._maxLightsPerCell;
              }
              set cookieAtlasResolution(h) {
                this._cookieAtlasResolution = x.m.clamp(
                  h,
                  32,
                  this._maxTextureSize
                );
              }
              get cookieAtlasResolution() {
                return this._cookieAtlasResolution;
              }
              set shadowAtlasResolution(h) {
                this._shadowAtlasResolution = x.m.clamp(
                  h,
                  32,
                  this._maxTextureSize
                );
              }
              get shadowAtlasResolution() {
                return this._shadowAtlasResolution;
              }
              set shadowType(h) {
                this._shadowType !== h &&
                  ((this._shadowType = h), this._dirtyLightsFnc());
              }
              get shadowType() {
                return this._shadowType;
              }
              set cookiesEnabled(h) {
                this._cookiesEnabled !== h &&
                  ((this._cookiesEnabled = h), this._dirtyLightsFnc());
              }
              get cookiesEnabled() {
                return this._cookiesEnabled;
              }
              set areaLightsEnabled(h) {
                this._supportsAreaLights &&
                  this._areaLightsEnabled !== h &&
                  ((this._areaLightsEnabled = h), this._dirtyLightsFnc());
              }
              get areaLightsEnabled() {
                return this._areaLightsEnabled;
              }
              set shadowsEnabled(h) {
                this._shadowsEnabled !== h &&
                  ((this._shadowsEnabled = h), this._dirtyLightsFnc());
              }
              get shadowsEnabled() {
                return this._shadowsEnabled;
              }
            }
          },
          8902: (Se, W, a) => {
            "use strict";
            a.d(W, { Q: () => t });
            var x = a(6556),
              T = a(7921),
              g = a(1110),
              c = a(3114),
              d = a(8869),
              h = a(4279);
            const f = 1e-6,
              s = new x.A(),
              l = new Float32Array(6),
              n = new x.A(-0.5, 0, 0),
              o = new x.A(0, 0, 0.5),
              i = {
                FLAGS: 0,
                COLOR_A: 1,
                COLOR_B: 2,
                SPOT_ANGLES: 3,
                SHADOW_BIAS: 4,
                COOKIE_A: 5,
                COOKIE_B: 6,
                COUNT_ALWAYS: 7,
                POSITION_X: 7,
                POSITION_Y: 8,
                POSITION_Z: 9,
                RANGE: 10,
                SPOT_DIRECTION_X: 11,
                SPOT_DIRECTION_Y: 12,
                SPOT_DIRECTION_Z: 13,
                PROJ_MAT_00: 14,
                ATLAS_VIEWPORT_A: 14,
                PROJ_MAT_01: 15,
                ATLAS_VIEWPORT_B: 15,
                PROJ_MAT_02: 16,
                PROJ_MAT_03: 17,
                PROJ_MAT_10: 18,
                PROJ_MAT_11: 19,
                PROJ_MAT_12: 20,
                PROJ_MAT_13: 21,
                PROJ_MAT_20: 22,
                PROJ_MAT_21: 23,
                PROJ_MAT_22: 24,
                PROJ_MAT_23: 25,
                PROJ_MAT_30: 26,
                PROJ_MAT_31: 27,
                PROJ_MAT_32: 28,
                PROJ_MAT_33: 29,
                AREA_DATA_WIDTH_X: 30,
                AREA_DATA_WIDTH_Y: 31,
                AREA_DATA_WIDTH_Z: 32,
                AREA_DATA_HEIGHT_X: 33,
                AREA_DATA_HEIGHT_Y: 34,
                AREA_DATA_HEIGHT_Z: 35,
                COUNT: 36,
              },
              e = {
                POSITION_RANGE: 0,
                SPOT_DIRECTION: 1,
                PROJ_MAT_0: 2,
                ATLAS_VIEWPORT: 2,
                PROJ_MAT_1: 3,
                PROJ_MAT_2: 4,
                PROJ_MAT_3: 5,
                AREA_DATA_WIDTH: 6,
                AREA_DATA_HEIGHT: 7,
                COUNT: 8,
              };
            class t {
              static initShaderDefines() {
                const u =
                  t.lightTextureFormat === t.FORMAT_FLOAT ? "FLOAT" : "8BIT";
                t.shaderDefines = `
						
#define CLUSTER_TEXTURE_${u}
						${t.buildShaderDefines(i, "CLUSTER_TEXTURE_8_")}
						${t.buildShaderDefines(e, "CLUSTER_TEXTURE_F_")}
				`;
              }
              static buildShaderDefines(u, y) {
                let p = "";
                const _ = t.useTexelFetch ? "" : ".5";
                return (
                  Object.keys(u).forEach((m) => {
                    p += `
#define ${y}${m} ${u[m]}${_}`;
                  }),
                  p
                );
              }
              static init(u) {
                (t.lightTextureFormat =
                  u.extTextureFloat && u.maxTextures > 8
                    ? t.FORMAT_FLOAT
                    : t.FORMAT_8BIT),
                  (t.useTexelFetch = u.supportsTextureFetch),
                  t.initShaderDefines();
              }
              static createTexture(u, y, p, _, m) {
                return new d.x(u, {
                  name: m,
                  width: y,
                  height: p,
                  mipmaps: !1,
                  format: _,
                  addressU: T.uFb,
                  addressV: T.uFb,
                  type: T.zZc,
                  magFilter: T.yib,
                  minFilter: T.yib,
                  anisotropy: 1,
                });
              }
              constructor(u) {
                (this.device = u),
                  (this.cookiesEnabled = !1),
                  (this.shadowsEnabled = !1),
                  (this.areaLightsEnabled = !1),
                  (this.maxLights = 255);
                let y = i.COUNT_ALWAYS,
                  p = 0;
                t.lightTextureFormat === t.FORMAT_FLOAT
                  ? (p = e.COUNT)
                  : (y = i.COUNT),
                  (this.lights8 = new Uint8ClampedArray(
                    4 * y * this.maxLights
                  )),
                  (this.lightsTexture8 = t.createTexture(
                    this.device,
                    y,
                    this.maxLights,
                    T.jKI,
                    "LightsTexture8"
                  )),
                  (this._lightsTexture8Id =
                    this.device.scope.resolve("lightsTexture8")),
                  p
                    ? ((this.lightsFloat = new Float32Array(
                        4 * p * this.maxLights
                      )),
                      (this.lightsTextureFloat = t.createTexture(
                        this.device,
                        p,
                        this.maxLights,
                        T.uC3,
                        "LightsTextureFloat"
                      )),
                      (this._lightsTextureFloatId =
                        this.device.scope.resolve("lightsTextureFloat")))
                    : ((this.lightsFloat = null),
                      (this.lightsTextureFloat = null),
                      (this._lightsTextureFloatId = void 0)),
                  (this._lightsTextureInvSizeId = this.device.scope.resolve(
                    "lightsTextureInvSize"
                  )),
                  (this._lightsTextureInvSizeData = new Float32Array(4)),
                  (this._lightsTextureInvSizeData[0] = p
                    ? 1 / this.lightsTextureFloat.width
                    : 0),
                  (this._lightsTextureInvSizeData[1] = p
                    ? 1 / this.lightsTextureFloat.height
                    : 0),
                  (this._lightsTextureInvSizeData[2] =
                    1 / this.lightsTexture8.width),
                  (this._lightsTextureInvSizeData[3] =
                    1 / this.lightsTexture8.height),
                  (this.invMaxColorValue = 0),
                  (this.invMaxAttenuation = 0),
                  (this.boundsMin = new x.A()),
                  (this.boundsDelta = new x.A());
              }
              destroy() {
                this.lightsTexture8 &&
                  (this.lightsTexture8.destroy(), (this.lightsTexture8 = null)),
                  this.lightsTextureFloat &&
                    (this.lightsTextureFloat.destroy(),
                    (this.lightsTextureFloat = null));
              }
              setCompressionRanges(u, y) {
                (this.invMaxColorValue = 1 / y),
                  (this.invMaxAttenuation = 1 / u);
              }
              setBounds(u, y) {
                this.boundsMin.copy(u), this.boundsDelta.copy(y);
              }
              uploadTextures() {
                this.lightsTextureFloat &&
                  (this.lightsTextureFloat.lock().set(this.lightsFloat),
                  this.lightsTextureFloat.unlock()),
                  this.lightsTexture8.lock().set(this.lights8),
                  this.lightsTexture8.unlock();
              }
              updateUniforms() {
                this._lightsTexture8Id.setValue(this.lightsTexture8),
                  t.lightTextureFormat === t.FORMAT_FLOAT &&
                    this._lightsTextureFloatId.setValue(
                      this.lightsTextureFloat
                    ),
                  this._lightsTextureInvSizeId.setValue(
                    this._lightsTextureInvSizeData
                  );
              }
              getSpotDirection(u, y) {
                y._node.getWorldTransform().getY(u).mulScalar(-1),
                  u.normalize();
              }
              getLightAreaSizes(u) {
                const y = u._node.getWorldTransform();
                return (
                  y.transformVector(n, s),
                  (l[0] = s.x),
                  (l[1] = s.y),
                  (l[2] = s.z),
                  y.transformVector(o, s),
                  (l[3] = s.x),
                  (l[4] = s.y),
                  (l[5] = s.z),
                  l
                );
              }
              addLightDataFlags(u, y, p, _, m, E) {
                (u[y + 0] = _ ? 255 : 0),
                  (u[y + 1] = p._shape * 64),
                  (u[y + 2] = p._falloffMode * 255),
                  (u[y + 3] = m ? E * 255 : 0);
              }
              addLightDataColor(u, y, p, _, m) {
                const E = this.invMaxColorValue,
                  v = _ ? p._linearFinalColor : p._finalColor;
                g.b.float2Bytes(v[0] * E, u, y + 0, 2),
                  g.b.float2Bytes(v[1] * E, u, y + 2, 2),
                  g.b.float2Bytes(v[2] * E, u, y + 4, 2),
                  (u[y + 6] = m ? 255 : 0);
                const P = !!(p.mask & c.BN),
                  I = !!(p.mask & c.gN);
                u[y + 7] = P && I ? 127 : I ? 255 : 0;
              }
              addLightDataSpotAngles(u, y, p) {
                g.b.float2Bytes(
                  p._innerConeAngleCos * (0.5 - f) + 0.5,
                  u,
                  y + 0,
                  2
                ),
                  g.b.float2Bytes(
                    p._outerConeAngleCos * (0.5 - f) + 0.5,
                    u,
                    y + 2,
                    2
                  );
              }
              addLightDataShadowBias(u, y, p) {
                const _ = p.getRenderData(null, 0),
                  m = p._getUniformBiasValues(_);
                g.b.float2BytesRange(m.bias, u, y, -1, 20, 2),
                  g.b.float2Bytes(m.normalBias, u, y + 2, 2);
              }
              addLightDataPositionRange(u, y, p, _) {
                const m = s.sub2(_, this.boundsMin).div(this.boundsDelta);
                g.b.float2Bytes(m.x, u, y + 0, 4),
                  g.b.float2Bytes(m.y, u, y + 4, 4),
                  g.b.float2Bytes(m.z, u, y + 8, 4),
                  g.b.float2Bytes(
                    p.attenuationEnd * this.invMaxAttenuation,
                    u,
                    y + 12,
                    4
                  );
              }
              addLightDataSpotDirection(u, y, p) {
                this.getSpotDirection(s, p),
                  g.b.float2Bytes(s.x * (0.5 - f) + 0.5, u, y + 0, 4),
                  g.b.float2Bytes(s.y * (0.5 - f) + 0.5, u, y + 4, 4),
                  g.b.float2Bytes(s.z * (0.5 - f) + 0.5, u, y + 8, 4);
              }
              addLightDataLightProjMatrix(u, y, p) {
                const _ = p.data;
                for (let m = 0; m < 12; m++)
                  g.b.float2BytesRange(_[m], u, y + 4 * m, -2, 2, 4);
                for (let m = 12; m < 16; m++)
                  g.b.float2MantissaExponent(_[m], u, y + 4 * m, 4);
              }
              addLightDataCookies(u, y, p) {
                const _ = p._cookieChannel === "rgb";
                if (
                  ((u[y + 0] = Math.floor(p.cookieIntensity * 255)),
                  (u[y + 1] = _ ? 255 : 0),
                  !_)
                ) {
                  const m = p._cookieChannel;
                  (u[y + 4] = m === "rrr" ? 255 : 0),
                    (u[y + 5] = m === "ggg" ? 255 : 0),
                    (u[y + 6] = m === "bbb" ? 255 : 0),
                    (u[y + 7] = m === "aaa" ? 255 : 0);
                }
              }
              addLightAtlasViewport(u, y, p) {
                g.b.float2Bytes(p.x, u, y + 0, 2),
                  g.b.float2Bytes(p.y, u, y + 2, 2),
                  g.b.float2Bytes(p.z / 3, u, y + 4, 2);
              }
              addLightAreaSizes(u, y, p) {
                const _ = this.getLightAreaSizes(p);
                for (let m = 0; m < 6; m++)
                  g.b.float2MantissaExponent(_[m], u, y + 4 * m, 4);
              }
              addLightData(u, y, p) {
                const _ = u._type === c.z0,
                  m = u.atlasViewportAllocated,
                  E = this.cookiesEnabled && !!u._cookie && m,
                  v = this.areaLightsEnabled && u.shape !== c.pI,
                  P = this.shadowsEnabled && u.castShadows && m,
                  I = u._node.getPosition();
                let A = null,
                  B = null;
                _
                  ? P
                    ? (A = u.getRenderData(null, 0).shadowMatrix)
                    : E && (A = h.i.evalSpotCookieMatrix(u))
                  : (P || E) && (B = u.atlasViewport);
                const C = this.lights8,
                  w = y * this.lightsTexture8.width * 4;
                if (
                  (this.addLightDataFlags(
                    C,
                    w + 4 * i.FLAGS,
                    u,
                    _,
                    P,
                    u.shadowIntensity
                  ),
                  this.addLightDataColor(C, w + 4 * i.COLOR_A, u, p, E),
                  _ && this.addLightDataSpotAngles(C, w + 4 * i.SPOT_ANGLES, u),
                  u.castShadows &&
                    this.addLightDataShadowBias(C, w + 4 * i.SHADOW_BIAS, u),
                  E && this.addLightDataCookies(C, w + 4 * i.COOKIE_A, u),
                  t.lightTextureFormat === t.FORMAT_FLOAT)
                ) {
                  const k = this.lightsFloat,
                    K = y * this.lightsTextureFloat.width * 4;
                  if (
                    ((k[K + 4 * e.POSITION_RANGE + 0] = I.x),
                    (k[K + 4 * e.POSITION_RANGE + 1] = I.y),
                    (k[K + 4 * e.POSITION_RANGE + 2] = I.z),
                    (k[K + 4 * e.POSITION_RANGE + 3] = u.attenuationEnd),
                    _ &&
                      (this.getSpotDirection(s, u),
                      (k[K + 4 * e.SPOT_DIRECTION + 0] = s.x),
                      (k[K + 4 * e.SPOT_DIRECTION + 1] = s.y),
                      (k[K + 4 * e.SPOT_DIRECTION + 2] = s.z)),
                    A)
                  ) {
                    const te = A.data;
                    for (let X = 0; X < 16; X++)
                      k[K + 4 * e.PROJ_MAT_0 + X] = te[X];
                  }
                  if (
                    (B &&
                      ((k[K + 4 * e.ATLAS_VIEWPORT + 0] = B.x),
                      (k[K + 4 * e.ATLAS_VIEWPORT + 1] = B.y),
                      (k[K + 4 * e.ATLAS_VIEWPORT + 2] = B.z / 3)),
                    v)
                  ) {
                    const te = this.getLightAreaSizes(u);
                    (k[K + 4 * e.AREA_DATA_WIDTH + 0] = te[0]),
                      (k[K + 4 * e.AREA_DATA_WIDTH + 1] = te[1]),
                      (k[K + 4 * e.AREA_DATA_WIDTH + 2] = te[2]),
                      (k[K + 4 * e.AREA_DATA_HEIGHT + 0] = te[3]),
                      (k[K + 4 * e.AREA_DATA_HEIGHT + 1] = te[4]),
                      (k[K + 4 * e.AREA_DATA_HEIGHT + 2] = te[5]);
                  }
                } else
                  this.addLightDataPositionRange(C, w + 4 * i.POSITION_X, u, I),
                    _ &&
                      this.addLightDataSpotDirection(
                        C,
                        w + 4 * i.SPOT_DIRECTION_X,
                        u
                      ),
                    A &&
                      this.addLightDataLightProjMatrix(
                        C,
                        w + 4 * i.PROJ_MAT_00,
                        A
                      ),
                    B &&
                      this.addLightAtlasViewport(
                        C,
                        w + 4 * i.ATLAS_VIEWPORT_A,
                        B
                      ),
                    v &&
                      this.addLightAreaSizes(C, w + 4 * i.AREA_DATA_WIDTH_X, u);
              }
            }
            (t.FORMAT_FLOAT = 0),
              (t.FORMAT_8BIT = 1),
              (t.lightTextureFormat = t.FORMAT_8BIT),
              (t.useTexelFetch = !1),
              (t.shaderDefines = "");
          },
          349: (Se, W, a) => {
            "use strict";
            a.d(W, { P: () => e });
            var x = a(6556),
              T = a(4585),
              g = a(3148),
              c = a(7921),
              d = a(3114),
              h = a(8902);
            const f = new x.A(),
              s = new x.A(),
              l = new x.A(),
              n = new g.k(),
              o = 1e-6;
            class i {
              constructor() {
                (this.light = null),
                  (this.min = new x.A()),
                  (this.max = new x.A());
              }
            }
            class e {
              constructor(r) {
                (this.clusterTexture = void 0),
                  (this.device = r),
                  (this.name = "Untitled"),
                  (this.reportCount = 0),
                  (this.boundsMin = new x.A()),
                  (this.boundsMax = new x.A()),
                  (this.boundsDelta = new x.A()),
                  (this._cells = new x.A(1, 1, 1)),
                  (this._cellsLimit = new x.A()),
                  (this.cells = this._cells),
                  (this.maxCellLightCount = 4),
                  (this._maxAttenuation = 0),
                  (this._maxColorValue = 0),
                  (this._usedLights = []),
                  this._usedLights.push(new i()),
                  (this.lightsBuffer = new h.Q(r)),
                  this.registerUniforms(r);
              }
              set maxCellLightCount(r) {
                r !== this._maxCellLightCount &&
                  ((this._maxCellLightCount = r), (this._cellsDirty = !0));
              }
              get maxCellLightCount() {
                return this._maxCellLightCount;
              }
              set cells(r) {
                f.copy(r).floor(),
                  this._cells.equals(f) ||
                    (this._cells.copy(f),
                    this._cellsLimit.copy(f).sub(x.A.ONE),
                    (this._cellsDirty = !0));
              }
              get cells() {
                return this._cells;
              }
              destroy() {
                this.lightsBuffer.destroy(), this.releaseClusterTexture();
              }
              releaseClusterTexture() {
                this.clusterTexture &&
                  (this.clusterTexture.destroy(), (this.clusterTexture = null));
              }
              registerUniforms(r) {
                (this._clusterSkipId = r.scope.resolve("clusterSkip")),
                  (this._clusterMaxCellsId =
                    r.scope.resolve("clusterMaxCells")),
                  (this._clusterWorldTextureId = r.scope.resolve(
                    "clusterWorldTexture"
                  )),
                  (this._clusterTextureSizeId =
                    r.scope.resolve("clusterTextureSize")),
                  (this._clusterTextureSizeData = new Float32Array(3)),
                  (this._clusterBoundsMinId =
                    r.scope.resolve("clusterBoundsMin")),
                  (this._clusterBoundsMinData = new Float32Array(3)),
                  (this._clusterBoundsDeltaId =
                    r.scope.resolve("clusterBoundsDelta")),
                  (this._clusterBoundsDeltaData = new Float32Array(3)),
                  (this._clusterCellsCountByBoundsSizeId = r.scope.resolve(
                    "clusterCellsCountByBoundsSize"
                  )),
                  (this._clusterCellsCountByBoundsSizeData = new Float32Array(
                    3
                  )),
                  (this._clusterCellsDotId =
                    r.scope.resolve("clusterCellsDot")),
                  (this._clusterCellsDotData = new Float32Array(3)),
                  (this._clusterCellsMaxId =
                    r.scope.resolve("clusterCellsMax")),
                  (this._clusterCellsMaxData = new Float32Array(3)),
                  (this._clusterCompressionLimit0Id = r.scope.resolve(
                    "clusterCompressionLimit0"
                  )),
                  (this._clusterCompressionLimit0Data = new Float32Array(2));
              }
              updateParams(r) {
                r &&
                  ((this.cells = r.cells),
                  (this.maxCellLightCount = r.maxLightsPerCell),
                  (this.lightsBuffer.cookiesEnabled = r.cookiesEnabled),
                  (this.lightsBuffer.shadowsEnabled = r.shadowsEnabled),
                  (this.lightsBuffer.areaLightsEnabled = r.areaLightsEnabled));
              }
              updateCells() {
                if (this._cellsDirty) {
                  this._cellsDirty = !1;
                  const r = this._cells.x,
                    u = this._cells.y,
                    y = this._cells.z,
                    p = r * u * y,
                    _ = this.maxCellLightCount * p;
                  let m = Math.ceil(Math.sqrt(_));
                  m = T.m.roundUp(m, this.maxCellLightCount);
                  const E = Math.ceil(_ / m);
                  (this._clusterCellsMaxData[0] = r),
                    (this._clusterCellsMaxData[1] = u),
                    (this._clusterCellsMaxData[2] = y),
                    (this._clusterCellsDotData[0] = this.maxCellLightCount),
                    (this._clusterCellsDotData[1] =
                      r * y * this.maxCellLightCount),
                    (this._clusterCellsDotData[2] = r * this.maxCellLightCount),
                    (this.clusters = new Uint8ClampedArray(_)),
                    (this.counts = new Int32Array(p)),
                    (this._clusterTextureSizeData[0] = m),
                    (this._clusterTextureSizeData[1] = 1 / m),
                    (this._clusterTextureSizeData[2] = 1 / E),
                    this.releaseClusterTexture(),
                    (this.clusterTexture = h.Q.createTexture(
                      this.device,
                      m,
                      E,
                      c.peA,
                      "ClusterTexture"
                    ));
                }
              }
              uploadTextures() {
                this.clusterTexture.lock().set(this.clusters),
                  this.clusterTexture.unlock(),
                  this.lightsBuffer.uploadTextures();
              }
              updateUniforms() {
                this._clusterSkipId.setValue(
                  this._usedLights.length > 1 ? 0 : 1
                ),
                  this.lightsBuffer.updateUniforms(),
                  this._clusterWorldTextureId.setValue(this.clusterTexture),
                  this._clusterMaxCellsId.setValue(this.maxCellLightCount);
                const r = this.boundsDelta;
                (this._clusterCellsCountByBoundsSizeData[0] =
                  this._cells.x / r.x),
                  (this._clusterCellsCountByBoundsSizeData[1] =
                    this._cells.y / r.y),
                  (this._clusterCellsCountByBoundsSizeData[2] =
                    this._cells.z / r.z),
                  this._clusterCellsCountByBoundsSizeId.setValue(
                    this._clusterCellsCountByBoundsSizeData
                  ),
                  (this._clusterBoundsMinData[0] = this.boundsMin.x),
                  (this._clusterBoundsMinData[1] = this.boundsMin.y),
                  (this._clusterBoundsMinData[2] = this.boundsMin.z),
                  (this._clusterBoundsDeltaData[0] = r.x),
                  (this._clusterBoundsDeltaData[1] = r.y),
                  (this._clusterBoundsDeltaData[2] = r.z),
                  (this._clusterCompressionLimit0Data[0] =
                    this._maxAttenuation),
                  (this._clusterCompressionLimit0Data[1] = this._maxColorValue),
                  this._clusterTextureSizeId.setValue(
                    this._clusterTextureSizeData
                  ),
                  this._clusterBoundsMinId.setValue(this._clusterBoundsMinData),
                  this._clusterBoundsDeltaId.setValue(
                    this._clusterBoundsDeltaData
                  ),
                  this._clusterCellsDotId.setValue(this._clusterCellsDotData),
                  this._clusterCellsMaxId.setValue(this._clusterCellsMaxData),
                  this._clusterCompressionLimit0Id.setValue(
                    this._clusterCompressionLimit0Data
                  );
              }
              evalLightCellMinMax(r, u, y) {
                u.copy(r.min),
                  u.sub(this.boundsMin),
                  u.div(this.boundsDelta),
                  u.mul2(u, this.cells),
                  u.floor(),
                  y.copy(r.max),
                  y.sub(this.boundsMin),
                  y.div(this.boundsDelta),
                  y.mul2(y, this.cells),
                  y.ceil(),
                  u.max(x.A.ZERO),
                  y.min(this._cellsLimit);
              }
              collectLights(r) {
                const u = this.lightsBuffer.maxLights,
                  y = this._usedLights;
                let p = 1;
                r.forEach((_) => {
                  const m = !!(_.mask & (d.BN | d.gN)),
                    E = _.type === d.z0 && _._outerConeAngle === 0;
                  if (
                    _.enabled &&
                    _.type !== d.WQ &&
                    _.visibleThisFrame &&
                    _.intensity > 0 &&
                    m &&
                    !E &&
                    p < u
                  ) {
                    let v;
                    p < y.length ? (v = y[p]) : ((v = new i()), y.push(v)),
                      (v.light = _),
                      _.getBoundingBox(n),
                      v.min.copy(n.getMin()),
                      v.max.copy(n.getMax()),
                      p++;
                  }
                }),
                  (y.length = p);
              }
              evaluateBounds() {
                const r = this._usedLights,
                  u = this.boundsMin,
                  y = this.boundsMax;
                if (r.length > 1) {
                  u.copy(r[1].min), y.copy(r[1].max);
                  for (let p = 2; p < r.length; p++)
                    u.min(r[p].min), y.max(r[p].max);
                } else u.set(0, 0, 0), y.set(1, 1, 1);
                this.boundsDelta.sub2(y, u),
                  this.lightsBuffer.setBounds(u, this.boundsDelta);
              }
              evaluateCompressionLimits(r) {
                let u = 0,
                  y = 0;
                const p = this._usedLights;
                for (let _ = 1; _ < p.length; _++) {
                  const m = p[_].light;
                  u = Math.max(m.attenuationEnd, u);
                  const E = r ? m._linearFinalColor : m._finalColor;
                  (y = Math.max(E[0], y)),
                    (y = Math.max(E[1], y)),
                    (y = Math.max(E[2], y));
                }
                (this._maxAttenuation = u + o),
                  (this._maxColorValue = y + o),
                  this.lightsBuffer.setCompressionRanges(
                    this._maxAttenuation,
                    this._maxColorValue
                  );
              }
              updateClusters(r) {
                this.counts.fill(0), this.clusters.fill(0);
                const u = this._cells.x,
                  y = this._cells.z,
                  p = this.counts,
                  _ = this._maxCellLightCount,
                  m = this.clusters,
                  E = this.maxCellLightCount,
                  v = this._usedLights;
                for (let P = 1; P < v.length; P++) {
                  const I = v[P],
                    A = I.light;
                  this.lightsBuffer.addLightData(A, P, r),
                    this.evalLightCellMinMax(I, s, l);
                  const B = s.x,
                    C = l.x,
                    w = s.y,
                    k = l.y,
                    K = s.z,
                    te = l.z;
                  for (let X = B; X <= C; X++)
                    for (let $ = K; $ <= te; $++)
                      for (let ne = w; ne <= k; ne++) {
                        const Y = X + u * ($ + ne * y),
                          Z = p[Y];
                        Z < _ && ((m[E * Y + Z] = P), (p[Y] = Z + 1));
                      }
                }
              }
              update(r, u, y) {
                this.updateParams(y),
                  this.updateCells(),
                  this.collectLights(r),
                  this.evaluateBounds(),
                  this.evaluateCompressionLimits(u),
                  this.updateClusters(u),
                  this.uploadTextures();
              }
              activate() {
                this.updateUniforms();
              }
            }
          },
          5752: (Se, W, a) => {
            "use strict";
            a.d(W, { K: () => i });
            var x = a(1367),
              T = a(1071),
              g = a(3114),
              c = a(192),
              d = a(7921),
              h = a(3862),
              f = a(3200),
              s = a(1585),
              l = a(2172);
            const n = {
              generateKey: function (e) {
                let t = "basic";
                return (
                  e.fog && (t += "_fog"),
                  e.alphaTest && (t += "_atst"),
                  e.vertexColors && (t += "_vcol"),
                  e.diffuseMap && (t += "_diff"),
                  e.skin && (t += "_skin"),
                  e.screenSpace && (t += "_ss"),
                  e.useInstancing && (t += "_inst"),
                  e.useMorphPosition && (t += "_morphp"),
                  e.useMorphNormal && (t += "_morphn"),
                  e.useMorphTextureBased && (t += "_morpht"),
                  (t += "_" + e.pass),
                  t
                );
              },
              createShaderDefinition: function (e, t) {
                const r = { vertex_position: d.Q5v };
                t.skin &&
                  ((r.vertex_boneWeights = d.d1j),
                  (r.vertex_boneIndices = d.MgX)),
                  t.vertexColors && (r.vertex_color = d.wD$),
                  t.diffuseMap && (r.vertex_texCoord0 = d.$fY);
                const y = s.T.get(e).getByIndex(t.pass).shaderDefines;
                let p = y;
                (p += f.n.transformDeclVS),
                  t.skin
                    ? ((p += (0, l.oY)(e)), (p += f.n.transformSkinnedVS))
                    : (p += f.n.transformVS),
                  t.vertexColors &&
                    ((p += `attribute vec4 vertex_color;
`),
                    (p += `varying vec4 vColor;
`)),
                  t.diffuseMap &&
                    ((p += `attribute vec2 vertex_texCoord0;
`),
                    (p += `varying vec2 vUv0;
`)),
                  t.pass === g.Jb &&
                    ((p += `varying float vDepth;
`),
                    (p += `#ifndef VIEWMATRIX
`),
                    (p += `#define VIEWMATRIX
`),
                    (p += `uniform mat4 matrix_view;
`),
                    (p += `#endif
`),
                    (p += `#ifndef CAMERAPLANES
`),
                    (p += `#define CAMERAPLANES
`),
                    (p += `uniform vec4 camera_params;

`),
                    (p += `#endif
`)),
                  (p += (0, l.a7)()),
                  (p += `   gl_Position = getPosition();
`),
                  t.pass === g.Jb &&
                    (p += `    vDepth = -(matrix_view * vec4(getWorldPosition(),1.0)).z * camera_params.x;
`),
                  t.vertexColors &&
                    (p += `    vColor = vertex_color;
`),
                  t.diffuseMap &&
                    (p += `    vUv0 = vertex_texCoord0;
`),
                  (p += (0, l.ut)());
                let _ = y;
                return (
                  t.vertexColors
                    ? (_ += `varying vec4 vColor;
`)
                    : (_ += `uniform vec4 uColor;
`),
                  t.diffuseMap &&
                    ((_ += `varying vec2 vUv0;
`),
                    (_ += `uniform sampler2D texture_diffuseMap;
`)),
                  t.fog && (_ += (0, l.aJ)(t.fog)),
                  t.alphaTest && (_ += f.n.alphaTestPS),
                  t.pass === g.Jb &&
                    ((_ += `varying float vDepth;
`),
                    (_ += f.n.packDepthPS)),
                  (_ += (0, l.a7)()),
                  t.vertexColors
                    ? (_ += `    gl_FragColor = vColor;
`)
                    : (_ += `    gl_FragColor = uColor;
`),
                  t.diffuseMap &&
                    (_ += `    gl_FragColor *= texture2D(texture_diffuseMap, vUv0);
`),
                  t.alphaTest &&
                    (_ += `   alphaTest(gl_FragColor.a);
`),
                  t.pass !== g.WW &&
                    (t.pass === g.Jb
                      ? (_ += `    gl_FragColor = packFloat(vDepth);
`)
                      : t.fog &&
                        (_ += `   glFragColor.rgb = addFog(gl_FragColor.rgb);
`)),
                  (_ += (0, l.ut)()),
                  h.x.createDefinition(e, {
                    name: "BasicShader",
                    attributes: r,
                    vertexCode: p,
                    fragmentCode: _,
                  })
                );
              },
            };
            var o = a(2737);
            class i extends o.F {
              constructor(...t) {
                super(...t),
                  (this.color = new x.I(1, 1, 1, 1)),
                  (this.colorUniform = new Float32Array(4)),
                  (this.colorMap = null),
                  (this.vertexColors = !1);
              }
              copy(t) {
                return (
                  super.copy(t),
                  this.color.copy(t.color),
                  (this.colorMap = t.colorMap),
                  (this.vertexColors = t.vertexColors),
                  this
                );
              }
              updateUniforms(t, r) {
                this.clearParameters(),
                  (this.colorUniform[0] = this.color.r),
                  (this.colorUniform[1] = this.color.g),
                  (this.colorUniform[2] = this.color.b),
                  (this.colorUniform[3] = this.color.a),
                  this.setParameter("uColor", this.colorUniform),
                  this.colorMap &&
                    this.setParameter("texture_diffuseMap", this.colorMap);
              }
              getShaderVariant(t, r, u, y, p, _, m, E, v) {
                const P = {
                    skin: u && (u & g.e8) !== 0,
                    screenSpace: u && (u & g.hz) !== 0,
                    useInstancing: u && (u & g.Is) !== 0,
                    useMorphPosition: u && (u & g.q4) !== 0,
                    useMorphNormal: u && (u & g.$I) !== 0,
                    useMorphTextureBased: u && (u & g.jx) !== 0,
                    alphaTest: this.alphaTest > 0,
                    vertexColors: this.vertexColors,
                    diffuseMap: !!this.colorMap,
                    pass: p,
                  },
                  I = new T.C(m, E, v),
                  A = (0, c.N)(t);
                return (
                  A.register("basic", n),
                  A.getProgram("basic", P, I, this.userId)
                );
              }
            }
          },
          9373: (Se, W, a) => {
            "use strict";
            a.d(W, { U: () => g, l: () => c });
            var x = a(7338);
            const T = new x.c();
            function g(d) {
              return T.get(d);
            }
            function c(d, h) {
              T.get(d, () => h);
            }
          },
          5928: (Se, W, a) => {
            "use strict";
            a.d(W, { Q: () => T });
            var x = a(3114);
            class T {
              static update(c, d, h, f, s, l) {
                T.updateSharedOptions(c, d, h, f, s),
                  T.updateMaterialOptions(c, d),
                  T.updateEnvOptions(c, d, h),
                  T.updateLightingOptions(c, d, f, l),
                  s === x.zw && ((c.gamma = x.CH), (c.toneMap = x.Fz));
              }
              static updateSharedOptions(c, d, h, f, s) {
                (c.chunks = d.chunks),
                  (c.pass = s),
                  (c.alphaTest = d.alphaTest > 0),
                  (c.blendType = d.blendType),
                  (c.screenSpace = f && (f & x.hz) !== 0),
                  (c.skin = f && (f & x.e8) !== 0),
                  (c.useInstancing = f && (f & x.Is) !== 0),
                  (c.useMorphPosition = f && (f & x.q4) !== 0),
                  (c.useMorphNormal = f && (f & x.$I) !== 0),
                  (c.useMorphTextureBased = f && (f & x.jx) !== 0),
                  (c.hasTangents = f && (f & x.tX) !== 0),
                  (c.nineSlicedMode = d.nineSlicedMode || x._r),
                  d.useLighting && h.clusteredLightingEnabled
                    ? ((c.clusteredLightingEnabled = !0),
                      (c.clusteredLightingCookiesEnabled =
                        h.lighting.cookiesEnabled),
                      (c.clusteredLightingShadowsEnabled =
                        h.lighting.shadowsEnabled),
                      (c.clusteredLightingShadowType = h.lighting.shadowType),
                      (c.clusteredLightingAreaLightsEnabled =
                        h.lighting.areaLightsEnabled))
                    : ((c.clusteredLightingEnabled = !1),
                      (c.clusteredLightingCookiesEnabled = !1),
                      (c.clusteredLightingShadowsEnabled = !1),
                      (c.clusteredLightingAreaLightsEnabled = !1));
              }
              static updateMaterialOptions(c, d) {
                (c.useAmbientTint = !1),
                  (c.separateAmbient = !1),
                  (c.customFragmentShader = null),
                  (c.pixelSnap = d.pixelSnap),
                  (c.shadingModel = d.shadingModel),
                  (c.ambientSH = d.ambientSH),
                  (c.fastTbn = d.fastTbn),
                  (c.twoSidedLighting = d.twoSidedLighting),
                  (c.occludeDirect = d.occludeDirect),
                  (c.occludeSpecular = d.occludeSpecular),
                  (c.occludeSpecularFloat = d.occludeSpecularIntensity !== 1),
                  (c.useMsdf = !1),
                  (c.msdfTextAttribute = !1),
                  (c.alphaToCoverage = d.alphaToCoverage),
                  (c.opacityFadesSpecular = d.opacityFadesSpecular),
                  (c.cubeMapProjection = x.AM),
                  (c.conserveEnergy =
                    d.conserveEnergy && d.shadingModel === x.qT),
                  (c.useSpecular = d.hasSpecular),
                  (c.useSpecularityFactor = d.hasSpecularityFactor),
                  (c.enableGGXSpecular = d.ggxSpecular),
                  (c.fresnelModel = d.fresnelModel),
                  (c.useRefraction = d.hasRefraction),
                  (c.useClearCoat = d.hasClearCoat),
                  (c.useSheen = d.hasSheen),
                  (c.useIridescence = d.hasIrridescence),
                  (c.useMetalness = d.hasMetalness),
                  (c.useDynamicRefraction = d.dynamicRefraction),
                  (c.vertexColors = !1),
                  (c.lightMapEnabled = d.hasLighting),
                  (c.dirLightMapEnabled = d.dirLightMap),
                  (c.useHeights = d.hasHeights),
                  (c.useNormals = d.hasNormals),
                  (c.useClearCoatNormals = d.hasClearCoatNormals),
                  (c.useAo = d.hasAo),
                  (c.diffuseMapEnabled = d.hasDiffuseMap);
              }
              static updateEnvOptions(c, d, h) {
                (c.fog = d.useFog ? h.fog : "none"),
                  (c.gamma = d.useGammaTonemap ? h.gammaCorrection : x.Ie),
                  (c.toneMap = d.useGammaTonemap ? h.toneMapping : -1),
                  (c.fixSeams = !1),
                  d.useSkybox && h.envAtlas && h.skybox
                    ? ((c.reflectionSource = "envAtlasHQ"),
                      (c.reflectionEncoding = h.envAtlas.encoding),
                      (c.reflectionCubemapEncoding = h.skybox.encoding))
                    : d.useSkybox && h.envAtlas
                    ? ((c.reflectionSource = "envAtlas"),
                      (c.reflectionEncoding = h.envAtlas.encoding))
                    : d.useSkybox && h.skybox
                    ? ((c.reflectionSource = "cubeMap"),
                      (c.reflectionEncoding = h.skybox.encoding))
                    : ((c.reflectionSource = null),
                      (c.reflectionEncoding = null)),
                  d.ambientSH
                    ? ((c.ambientSource = "ambientSH"),
                      (c.ambientEncoding = null))
                    : c.reflectionSource && h.envAtlas
                    ? ((c.ambientSource = "envAtlas"),
                      (c.ambientEncoding = h.envAtlas.encoding))
                    : ((c.ambientSource = "constant"),
                      (c.ambientEncoding = null));
                const f = !!c.reflectionSource;
                (c.skyboxIntensity =
                  f && (h.skyboxIntensity !== 1 || h.physicalUnits)),
                  (c.useCubeMapRotation = f && h._skyboxRotationShaderInclude);
              }
              static updateLightingOptions(c, d, h, f) {
                if (((c.lightMapWithoutAmbient = !1), d.useLighting)) {
                  const s = [],
                    l = h ? h >> 16 : x.BN;
                  (c.lightMaskDynamic = !!(l & x.BN)),
                    (c.lightMapWithoutAmbient = !1),
                    f &&
                      (T.collectLights(x.WQ, f[x.WQ], s, l),
                      T.collectLights(x.bA, f[x.bA], s, l),
                      T.collectLights(x.z0, f[x.z0], s, l)),
                    (c.lights = s);
                } else c.lights = [];
                (c.lights.length === 0 || h & x.BP) && (c.noShadow = !0);
              }
              static collectLights(c, d, h, f) {
                for (let s = 0; s < d.length; s++) {
                  const l = d[s];
                  if (l.enabled && l.mask & f) {
                    if (c !== x.WQ && l.isStatic) continue;
                    h.push(l);
                  }
                }
              }
            }
          },
          2737: (Se, W, a) => {
            "use strict";
            a.d(W, { F: () => n });
            var x = a(7921),
              T = a(8277),
              g = a(7013),
              c = a(1071),
              d = a(3114),
              h = a(9375),
              f = a(9373);
            const s = [];
            (s[d.C1] = { src: x.NdT, dst: x.NdT, op: x.b4e }),
              (s[d.He] = { src: x.NdT, dst: x.rqb, op: x.cn$ }),
              (s[d.lA] = { src: x._HM, dst: x.Hiv, op: x.cn$ }),
              (s[d.yp] = { src: x.NdT, dst: x.Hiv, op: x.cn$ }),
              (s[d.$U] = { src: x.NdT, dst: x.NdT, op: x.cn$ }),
              (s[d.Yk] = { src: x._HM, dst: x.NdT, op: x.cn$ }),
              (s[d.oF] = { src: x.CZC, dst: x.RR1, op: x.cn$ }),
              (s[d.Sh] = { src: x.PDh, dst: x.NdT, op: x.cn$ }),
              (s[d.ch] = { src: x.CZC, dst: x.rqb, op: x.cn$ }),
              (s[d.yl] = { src: x.NdT, dst: x.NdT, op: x.xJm }),
              (s[d.rR] = { src: x.NdT, dst: x.NdT, op: x.uAW });
            let l = 0;
            class n {
              constructor() {
                (this._shader = null),
                  (this.meshInstances = []),
                  (this.name = "Untitled"),
                  (this.userId = ""),
                  (this.id = l++),
                  (this.variants = new Map()),
                  (this.parameters = {}),
                  (this.alphaTest = 0),
                  (this.alphaToCoverage = !1),
                  (this._blendState = new T.a()),
                  (this._depthState = new g.b()),
                  (this.cull = x.Ak1),
                  (this.stencilFront = null),
                  (this.stencilBack = null),
                  (this.depthBias = 0),
                  (this.slopeDepthBias = 0),
                  (this._shaderVersion = 0),
                  (this._scene = null),
                  (this._dirtyBlend = !1),
                  (this.dirty = !0);
              }
              set redWrite(i) {
                this._blendState.redWrite = i;
              }
              get redWrite() {
                return this._blendState.redWrite;
              }
              set greenWrite(i) {
                this._blendState.greenWrite = i;
              }
              get greenWrite() {
                return this._blendState.greenWrite;
              }
              set blueWrite(i) {
                this._blendState.blueWrite = i;
              }
              get blueWrite() {
                return this._blendState.blueWrite;
              }
              set alphaWrite(i) {
                this._blendState.alphaWrite = i;
              }
              get alphaWrite() {
                return this._blendState.alphaWrite;
              }
              set shader(i) {
                this._shader = i;
              }
              get shader() {
                return this._shader;
              }
              get transparent() {
                return this._blendState.blend;
              }
              _updateTransparency() {
                const i = this.transparent,
                  e = this.meshInstances;
                for (let t = 0; t < e.length; t++) e[t].transparent = i;
              }
              _markBlendDirty() {
                this._scene
                  ? (this._scene.layers._dirtyBlend = !0)
                  : (this._dirtyBlend = !0);
              }
              set blendState(i) {
                this._blendState.blend !== i.blend && this._markBlendDirty(),
                  this._blendState.copy(i),
                  this._updateTransparency();
              }
              get blendState() {
                return this._blendState;
              }
              set blendType(i) {
                const e = s[i];
                this._blendState.setColorBlend(e.op, e.src, e.dst),
                  this._blendState.setAlphaBlend(e.op, e.src, e.dst);
                const t = i !== d.He;
                this._blendState.blend !== t &&
                  ((this._blendState.blend = t),
                  this._updateTransparency(),
                  this._markBlendDirty()),
                  this._updateMeshInstanceKeys();
              }
              get blendType() {
                if (!this.transparent) return d.He;
                const {
                  colorOp: i,
                  colorSrcFactor: e,
                  colorDstFactor: t,
                  alphaOp: r,
                  alphaSrcFactor: u,
                  alphaDstFactor: y,
                } = this._blendState;
                for (let p = 0; p < s.length; p++) {
                  const _ = s[p];
                  if (
                    _.src === e &&
                    _.dst === t &&
                    _.op === i &&
                    _.src === u &&
                    _.dst === y &&
                    _.op === r
                  )
                    return p;
                }
                return d.lA;
              }
              set depthState(i) {
                this._depthState.copy(i);
              }
              get depthState() {
                return this._depthState;
              }
              set depthTest(i) {
                this._depthState.test = i;
              }
              get depthTest() {
                return this._depthState.test;
              }
              set depthFunc(i) {
                this._depthState.func = i;
              }
              get depthFunc() {
                return this._depthState.func;
              }
              set depthWrite(i) {
                this._depthState.write = i;
              }
              get depthWrite() {
                return this._depthState.write;
              }
              copy(i) {
                var e;
                return (
                  (this.name = i.name),
                  (this._shader = i._shader),
                  (this.alphaTest = i.alphaTest),
                  (this.alphaToCoverage = i.alphaToCoverage),
                  this._blendState.copy(i._blendState),
                  this._depthState.copy(i._depthState),
                  (this.cull = i.cull),
                  (this.depthBias = i.depthBias),
                  (this.slopeDepthBias = i.slopeDepthBias),
                  (this.stencilFront =
                    (e = i.stencilFront) == null ? void 0 : e.clone()),
                  i.stencilBack &&
                    (this.stencilBack =
                      i.stencilFront === i.stencilBack
                        ? this.stencilFront
                        : i.stencilBack.clone()),
                  this
                );
              }
              clone() {
                return new this.constructor().copy(this);
              }
              _updateMeshInstanceKeys() {
                const i = this.meshInstances;
                for (let e = 0; e < i.length; e++) i[e].updateKey();
              }
              updateUniforms(i, e) {}
              getShaderVariant(i, e, t, r, u, y, p, _, m) {
                const E = new c.C(p, _, m);
                return (0, h.$x)(this._shader, E);
              }
              update() {
                (this.dirty = !0), this._shader && (this._shader.failed = !1);
              }
              clearParameters() {
                this.parameters = {};
              }
              getParameters() {
                return this.parameters;
              }
              clearVariants() {
                this.variants.clear();
                const i = this.meshInstances,
                  e = i.length;
                for (let t = 0; t < e; t++) i[t].clearShaders();
              }
              getParameter(i) {
                return this.parameters[i];
              }
              setParameter(i, e) {
                if (e === void 0 && typeof i == "object") {
                  const r = i;
                  if (r.length) {
                    for (let u = 0; u < r.length; u++) this.setParameter(r[u]);
                    return;
                  }
                  (i = r.name), (e = r.value);
                }
                const t = this.parameters[i];
                t
                  ? (t.data = e)
                  : (this.parameters[i] = { scopeId: null, data: e });
              }
              deleteParameter(i) {
                this.parameters[i] && delete this.parameters[i];
              }
              setParameters(i, e) {
                const t = this.parameters;
                e === void 0 && (e = t);
                for (const r in e) {
                  const u = t[r];
                  u &&
                    (u.scopeId || (u.scopeId = i.scope.resolve(r)),
                    u.scopeId.setValue(u.data));
                }
              }
              destroy() {
                this.variants.clear(), (this._shader = null);
                for (let i = 0; i < this.meshInstances.length; i++) {
                  const e = this.meshInstances[i];
                  if ((e.clearShaders(), (e._material = null), e.mesh)) {
                    const t = (0, f.U)(e.mesh.device);
                    this !== t && (e.material = t);
                  }
                }
                this.meshInstances.length = 0;
              }
              addMeshInstanceRef(i) {
                this.meshInstances.push(i);
              }
              removeMeshInstanceRef(i) {
                const e = this.meshInstances,
                  t = e.indexOf(i);
                t !== -1 && e.splice(t, 1);
              }
            }
          },
          7474: (Se, W, a) => {
            "use strict";
            a.d(W, { J: () => T });
            var x = a(3054);
            class T {
              constructor() {
                (this.forceUv1 = !1),
                  (this.ambientTint = !1),
                  (this.diffuseTint = !1),
                  (this.specularTint = !1),
                  (this.metalnessTint = !1),
                  (this.glossTint = !1),
                  (this.emissiveTint = !1),
                  (this.opacityTint = !1),
                  (this.emissiveEncoding = "linear"),
                  (this.lightMapEncoding = "linear"),
                  (this.packedNormal = !1),
                  (this.glossInvert = !1),
                  (this.sheenGlossInvert = !1),
                  (this.clearCoatGlossInvert = !1),
                  (this.litOptions = new x.F());
              }
              get pass() {
                return this.litOptions.pass;
              }
            }
          },
          6672: (Se, W, a) => {
            "use strict";
            a.d(W, { Eh: () => c, Ft: () => d, Ru: () => g, v$: () => h });
            var x = a(9078);
            function T(f, s = !0, l = !0) {
              const n = {};
              return (
                (n[`${f}Map`] = "texture"),
                (n[`${f}MapTiling`] = "vec2"),
                (n[`${f}MapOffset`] = "vec2"),
                (n[`${f}MapRotation`] = "number"),
                (n[`${f}MapUv`] = "number"),
                s &&
                  ((n[`${f}MapChannel`] = "string"),
                  l &&
                    ((n[`${f}VertexColor`] = "boolean"),
                    (n[`${f}VertexColorChannel`] = "string"))),
                n
              );
            }
            const g = (0, x.g)(
                {
                  name: "string",
                  chunks: "chunks",
                  mappingFormat: "string",
                  _engine: "boolean",
                  ambient: "rgb",
                  ambientTint: "boolean",
                },
                T("ao"),
                T("aoDetail", !0, !1),
                {
                  aoDetailMode: "string",
                  diffuse: "rgb",
                  diffuseTint: "boolean",
                },
                T("diffuse"),
                T("diffuseDetail", !0, !1),
                {
                  diffuseDetailMode: "string",
                  specular: "rgb",
                  specularTint: "boolean",
                },
                T("specular"),
                {
                  occludeSpecular: "enum:occludeSpecular",
                  specularityFactor: "number",
                  specularityFactorTint: "boolean",
                },
                T("specularityFactor"),
                {
                  useMetalness: "boolean",
                  metalness: "number",
                  enableGGXSpecular: "boolean",
                  anisotropy: "number",
                  metalnessTint: "boolean",
                },
                T("metalness"),
                {
                  useMetalnessSpecularColor: "boolean",
                  conserveEnergy: "boolean",
                  shininess: "number",
                  gloss: "number",
                  glossInvert: "boolean",
                },
                T("gloss"),
                { clearCoat: "number" },
                T("clearCoat"),
                { clearCoatGloss: "number", clearCoatGlossInvert: "boolean" },
                T("clearCoatGloss"),
                { clearCoatBumpiness: "number" },
                T("clearCoatNormal", !1),
                { useSheen: "boolean", sheen: "rgb", sheenTint: "boolean" },
                T("sheen"),
                {
                  sheenGloss: "number",
                  sheenGlossTint: "boolean",
                  sheenGlossInvert: "boolean",
                },
                T("sheenGloss"),
                {
                  fresnelModel: "number",
                  emissive: "rgb",
                  emissiveTint: "boolean",
                },
                T("emissive"),
                { emissiveIntensity: "number" },
                T("normal", !1),
                { bumpiness: "number" },
                T("normalDetail", !1),
                { normalDetailMapBumpiness: "number" },
                T("height", !0, !1),
                {
                  heightMapFactor: "number",
                  alphaToCoverage: "boolean",
                  alphaTest: "number",
                  alphaFade: "number",
                  opacity: "number",
                },
                T("opacity"),
                {
                  opacityFadesSpecular: "boolean",
                  reflectivity: "number",
                  refraction: "number",
                  refractionTint: "boolean",
                },
                T("refraction"),
                {
                  refractionIndex: "number",
                  thickness: "number",
                  thicknessTint: "boolean",
                },
                T("thickness"),
                {
                  attenuation: "rgb",
                  attenuationDistance: "number",
                  useDynamicRefraction: "boolean",
                  sphereMap: "texture",
                  cubeMap: "cubemap",
                  cubeMapProjection: "number",
                  cubeMapProjectionBox: "boundingbox",
                  useIridescence: "boolean",
                  iridescence: "number",
                  iridescenceTint: "boolean",
                },
                T("iridescence"),
                {
                  iridescenceThicknessTint: "boolean",
                  iridescenceThicknessMin: "number",
                  iridescenceThicknessMax: "number",
                  iridescenceRefractionIndex: "number",
                },
                T("iridescenceThickness"),
                T("light"),
                {
                  depthTest: "boolean",
                  depthFunc: "enum:depthFunc",
                  depthWrite: "boolean",
                  depthBias: "number",
                  slopeDepthBias: "number",
                  cull: "enum:cull",
                  blendType: "enum:blendType",
                  shadingModel: "enum:shadingModel",
                  useFog: "boolean",
                  useLighting: "boolean",
                  useSkybox: "boolean",
                  useGammaTonemap: "boolean",
                  envAtlas: "texture",
                  twoSidedLighting: "boolean",
                }
              ),
              c = [];
            for (const f in g) g[f] === "texture" && c.push(f);
            const d = [];
            for (const f in g) g[f] === "cubemap" && d.push(f);
            const h = {
              aoMapVertexColor: "boolean",
              diffuseMapTint: "boolean",
              diffuseMapVertexColor: "boolean",
              emissiveMapTint: "boolean",
              emissiveMapVertexColor: "boolean",
              glossMapVertexColor: "boolean",
              metalnessMapVertexColor: "boolean",
              opacityMapVertexColor: "boolean",
              specularAntialias: "boolean",
              specularMapTint: "boolean",
              specularMapVertexColor: "boolean",
            };
          },
          8944: (Se, W, a) => {
            "use strict";
            a.d(W, { K: () => w });
            var x = a(1367),
              T = a(4585),
              g = a(2978),
              c = a(1071),
              d = a(3114),
              h = a(1585),
              f = a(340),
              s = a(192),
              l = a(1475),
              n = a(7790),
              o = a(7198),
              i = a(7474),
              e = a(4976);
            const t = [],
              r = (me) =>
                Object.keys(me)
                  .filter((N) => N !== "litOptions")
                  .sort(),
              u = {
                optionsContext: new i.J(),
                optionsContextMin: new i.J(),
                generateKey: function (me) {
                  let N;
                  return (
                    me === this.optionsContextMin
                      ? (this.propsMin || (this.propsMin = r(me)),
                        (N = this.propsMin))
                      : me === this.optionsContext
                      ? (this.props || (this.props = r(me)), (N = this.props))
                      : (N = r(me)),
                    `standard:
` +
                      N.map((L) => L + me[L]).join(`
`) +
                      e.W.generateKey(me.litOptions)
                  );
                },
                _getUvSourceExpression: function (me, N, V) {
                  const L = V[me],
                    J = V[N],
                    ae =
                      V.litOptions.pass === d.lW || V.litOptions.pass === d.zw;
                  let R;
                  return (
                    (ae && V.litOptions.nineSlicedMode === d.ei) ||
                    (ae && V.litOptions.nineSlicedMode === d.DD)
                      ? (R = "nineSlicedUv")
                      : (L === 0 ? (R = "vUv" + J) : (R = "vUV" + J + "_" + L),
                        V.heightMap &&
                          me !== "heightMapTransform" &&
                          (R += " + dUvOffset")),
                    R
                  );
                },
                _addMapDef: function (me, N) {
                  return N
                    ? `#define ${me}
`
                    : `#undef ${me}
`;
                },
                _addMapDefs: function (me, N, V, L, J) {
                  return (
                    this._addMapDef("MAPFLOAT", me) +
                    this._addMapDef("MAPCOLOR", N) +
                    this._addMapDef("MAPVERTEX", V) +
                    this._addMapDef("MAPTEXTURE", L) +
                    this._addMapDef("MAPINVERT", J)
                  );
                },
                _addMap: function (me, N, V, L, J, ae = null) {
                  const R = me + "Map",
                    j = R + "Uv",
                    se = R + "Identifier",
                    ce = R + "Transform",
                    ie = R + "Channel",
                    b = me + "VertexColorChannel",
                    M = me + "Tint",
                    F = me + "VertexColor",
                    z = me + "Mode",
                    oe = me + "Invert",
                    de = V[M],
                    ge = V[F],
                    Re = V[R],
                    Te = V[se],
                    Ne = V[z];
                  let Le = L[N];
                  if (Re) {
                    const U = this._getUvSourceExpression(ce, j, V);
                    if (
                      ((Le = Le.replace(/\$UV/g, U).replace(/\$CH/g, V[ie])),
                      J && Le.search(/\$SAMPLER/g) !== -1)
                    ) {
                      let H = "texture_" + R;
                      const Ee = J[Te];
                      Ee ? (H = Ee) : (J[Te] = H),
                        (Le = Le.replace(/\$SAMPLER/g, H));
                    }
                    if (
                      ae &&
                      (V[ie] === "aaa"
                        ? (Le = Le.replace(/\$DECODE/g, "passThrough"))
                        : (Le = Le.replace(
                            /\$DECODE/g,
                            o.a.decodeFunc(
                              !V.litOptions.gamma && ae === "srgb"
                                ? "linear"
                                : ae
                            )
                          )),
                      Le.indexOf("$texture2DSAMPLE"))
                    ) {
                      const H = {
                        linear: "texture2D",
                        srgb: "texture2DSRGB",
                        rgbm: "texture2DRGBM",
                        rgbe: "texture2DRGBE",
                      };
                      Le = Le.replace(
                        /\$texture2DSAMPLE/g,
                        H[ae] || "texture2D"
                      );
                    }
                  }
                  ge && (Le = Le.replace(/\$VC/g, V[b])),
                    Ne && (Le = Le.replace(/\$DETAILMODE/g, Ne));
                  const ke = !!(de & 1),
                    ht = !!(de & 2),
                    _e = !!V[oe];
                  return (
                    (Le = this._addMapDefs(ke, ht, ge, Re, _e) + Le),
                    Le.replace(/\$/g, "")
                  );
                },
                _correctChannel: function (me, N, V) {
                  if (V[me] > 0) {
                    if (V[me] < N.length) return N.substring(0, V[me]);
                    if (V[me] > N.length) {
                      let L = N;
                      const J = L.charAt(L.length - 1),
                        ae = V[me] - L.length;
                      for (let R = 0; R < ae; R++) L += J;
                      return L;
                    }
                    return N;
                  }
                },
                createShaderDefinition: function (me, N) {
                  const L = h.T.get(me).getByIndex(N.litOptions.pass).isForward,
                    J = new l.i(me, N.litOptions),
                    ae = [],
                    R = [],
                    j = [],
                    se = 2,
                    ce = {};
                  for (const oe in t) {
                    const de = oe + "Map";
                    if (N[oe + "VertexColor"]) {
                      const ge = oe + "VertexColorChannel";
                      N[ge] = this._correctChannel(oe, N[ge], t);
                    }
                    if (N[de]) {
                      const ge = de + "Channel",
                        Re = de + "Transform",
                        Te = de + "Uv";
                      (N[Te] = Math.min(N[Te], se - 1)),
                        (N[ge] = this._correctChannel(oe, N[ge], t));
                      const Ne = N[Te];
                      (ae[Ne] = !0),
                        (R[Ne] = R[Ne] || (N[de] && !N[Re])),
                        N[Re] && j.push({ name: oe, id: N[Re], uv: N[Te] });
                    }
                  }
                  N.forceUv1 &&
                    ((ae[1] = !0), (R[1] = R[1] !== void 0 ? R[1] : !0)),
                    J.generateVertexShader(ae, R, j),
                    N.litOptions.shadingModel === d.yd
                      ? ((N.litOptions.fresnelModel = 0),
                        (N.litOptions.ambientSH = !1))
                      : (N.litOptions.fresnelModel =
                          N.litOptions.fresnelModel === 0
                            ? d.Rx
                            : N.litOptions.fresnelModel);
                  const ie = new n.R(),
                    b = new n.R(),
                    M = new n.R(),
                    F = new n.R();
                  let z = "";
                  if (
                    (N.litOptions.nineSlicedMode === d.DD
                      ? ie.append("const float textureBias = -1000.0;")
                      : ie.append("uniform float textureBias;"),
                    L)
                  ) {
                    if (
                      (N.heightMap &&
                        (ie.append("vec2 dUvOffset;"),
                        b.append(
                          this._addMap("height", "parallaxPS", N, J.chunks, ce)
                        ),
                        M.append("getParallax();")),
                      N.litOptions.blendType !== d.He ||
                      N.litOptions.alphaTest ||
                      N.litOptions.alphaToCoverage
                        ? (ie.append("float dAlpha;"),
                          b.append(
                            this._addMap(
                              "opacity",
                              "opacityPS",
                              N,
                              J.chunks,
                              ce
                            )
                          ),
                          M.append("getOpacity();"),
                          F.append("litArgs_opacity = dAlpha;"),
                          N.litOptions.alphaTest &&
                            (b.append(J.chunks.alphaTestPS),
                            M.append("alphaTest(dAlpha);")))
                        : ie.append("float dAlpha = 1.0;"),
                      J.needsNormal)
                    ) {
                      if (
                        (N.normalMap || N.clearCoatNormalMap) &&
                        (b.append(
                          N.packedNormal
                            ? J.chunks.normalXYPS
                            : J.chunks.normalXYZPS
                        ),
                        !N.litOptions.hasTangents)
                      ) {
                        const oe = N.normalMap
                          ? "normalMap"
                          : "clearCoatNormalMap";
                        z = this._getUvSourceExpression(
                          `${oe}Transform`,
                          `${oe}Uv`,
                          N
                        );
                      }
                      ie.append("vec3 dNormalW;"),
                        b.append(
                          this._addMap(
                            "normalDetail",
                            "normalDetailMapPS",
                            N,
                            J.chunks,
                            ce
                          )
                        ),
                        b.append(
                          this._addMap("normal", "normalMapPS", N, J.chunks, ce)
                        ),
                        M.append("getNormal();"),
                        F.append("litArgs_worldNormal = dNormalW;");
                    }
                    if (
                      (J.needsSceneColor &&
                        ie.append("uniform sampler2D uSceneColorMap;"),
                      J.needsScreenSize &&
                        ie.append("uniform vec4 uScreenSize;"),
                      J.needsTransforms &&
                        (ie.append("uniform mat4 matrix_viewProjection;"),
                        ie.append("uniform mat4 matrix_model;")),
                      (N.diffuseDetail || N.aoDetail) &&
                        b.append(J.chunks.detailModesPS),
                      ie.append("vec3 dAlbedo;"),
                      N.diffuseDetail &&
                        b.append(
                          this._addMap(
                            "diffuseDetail",
                            "diffuseDetailMapPS",
                            N,
                            J.chunks,
                            ce,
                            N.diffuseDetailEncoding
                          )
                        ),
                      b.append(
                        this._addMap(
                          "diffuse",
                          "diffusePS",
                          N,
                          J.chunks,
                          ce,
                          N.diffuseEncoding
                        )
                      ),
                      M.append("getAlbedo();"),
                      F.append("litArgs_albedo = dAlbedo;"),
                      N.litOptions.useRefraction &&
                        (ie.append("float dTransmission;"),
                        b.append(
                          this._addMap(
                            "refraction",
                            "transmissionPS",
                            N,
                            J.chunks,
                            ce
                          )
                        ),
                        M.append("getRefraction();"),
                        F.append("litArgs_transmission = dTransmission;"),
                        ie.append("float dThickness;"),
                        b.append(
                          this._addMap(
                            "thickness",
                            "thicknessPS",
                            N,
                            J.chunks,
                            ce
                          )
                        ),
                        M.append("getThickness();"),
                        F.append("litArgs_thickness = dThickness;")),
                      N.litOptions.useIridescence &&
                        (ie.append("float dIridescence;"),
                        b.append(
                          this._addMap(
                            "iridescence",
                            "iridescencePS",
                            N,
                            J.chunks,
                            ce
                          )
                        ),
                        M.append("getIridescence();"),
                        F.append(
                          "litArgs_iridescence_intensity = dIridescence;"
                        ),
                        ie.append("float dIridescenceThickness;"),
                        b.append(
                          this._addMap(
                            "iridescenceThickness",
                            "iridescenceThicknessPS",
                            N,
                            J.chunks,
                            ce
                          )
                        ),
                        M.append("getIridescenceThickness();"),
                        F.append(
                          "litArgs_iridescence_thickness = dIridescenceThickness;"
                        )),
                      (J.lighting && N.litOptions.useSpecular) || J.reflections
                        ? (ie.append("vec3 dSpecularity;"),
                          ie.append("float dGlossiness;"),
                          N.litOptions.useSheen &&
                            (ie.append("vec3 sSpecularity;"),
                            b.append(
                              this._addMap(
                                "sheen",
                                "sheenPS",
                                N,
                                J.chunks,
                                ce,
                                N.sheenEncoding
                              )
                            ),
                            M.append("getSheen();"),
                            F.append(
                              "litArgs_sheen_specularity = sSpecularity;"
                            ),
                            ie.append("float sGlossiness;"),
                            b.append(
                              this._addMap(
                                "sheenGloss",
                                "sheenGlossPS",
                                N,
                                J.chunks,
                                ce
                              )
                            ),
                            M.append("getSheenGlossiness();"),
                            F.append("litArgs_sheen_gloss = sGlossiness;")),
                          N.litOptions.useMetalness &&
                            (ie.append("float dMetalness;"),
                            b.append(
                              this._addMap(
                                "metalness",
                                "metalnessPS",
                                N,
                                J.chunks,
                                ce
                              )
                            ),
                            M.append("getMetalness();"),
                            F.append("litArgs_metalness = dMetalness;"),
                            ie.append("float dIor;"),
                            b.append(
                              this._addMap("ior", "iorPS", N, J.chunks, ce)
                            ),
                            M.append("getIor();"),
                            F.append("litArgs_ior = dIor;")),
                          N.litOptions.useSpecularityFactor &&
                            (ie.append("float dSpecularityFactor;"),
                            b.append(
                              this._addMap(
                                "specularityFactor",
                                "specularityFactorPS",
                                N,
                                J.chunks,
                                ce
                              )
                            ),
                            M.append("getSpecularityFactor();"),
                            F.append(
                              "litArgs_specularityFactor = dSpecularityFactor;"
                            )),
                          N.useSpecularColor
                            ? b.append(
                                this._addMap(
                                  "specular",
                                  "specularPS",
                                  N,
                                  J.chunks,
                                  ce,
                                  N.specularEncoding
                                )
                              )
                            : b.append(
                                "void getSpecularity() { dSpecularity = vec3(1); }"
                              ),
                          b.append(
                            this._addMap("gloss", "glossPS", N, J.chunks, ce)
                          ),
                          M.append("getGlossiness();"),
                          M.append("getSpecularity();"),
                          F.append("litArgs_specularity = dSpecularity;"),
                          F.append("litArgs_gloss = dGlossiness;"))
                        : (ie.append("vec3 dSpecularity = vec3(0.0);"),
                          ie.append("float dGlossiness = 0.0;")),
                      N.aoDetail &&
                        b.append(
                          this._addMap(
                            "aoDetail",
                            "aoDetailMapPS",
                            N,
                            J.chunks,
                            ce
                          )
                        ),
                      (N.aoMap || N.aoVertexColor) &&
                        (ie.append("float dAo;"),
                        b.append(this._addMap("ao", "aoPS", N, J.chunks, ce)),
                        M.append("getAO();"),
                        F.append("litArgs_ao = dAo;")),
                      ie.append("vec3 dEmission;"),
                      b.append(
                        this._addMap(
                          "emissive",
                          "emissivePS",
                          N,
                          J.chunks,
                          ce,
                          N.emissiveEncoding
                        )
                      ),
                      M.append("getEmission();"),
                      F.append("litArgs_emission = dEmission;"),
                      N.litOptions.useClearCoat &&
                        (ie.append("float ccSpecularity;"),
                        ie.append("float ccGlossiness;"),
                        ie.append("vec3 ccNormalW;"),
                        b.append(
                          this._addMap(
                            "clearCoat",
                            "clearCoatPS",
                            N,
                            J.chunks,
                            ce
                          )
                        ),
                        b.append(
                          this._addMap(
                            "clearCoatGloss",
                            "clearCoatGlossPS",
                            N,
                            J.chunks,
                            ce
                          )
                        ),
                        b.append(
                          this._addMap(
                            "clearCoatNormal",
                            "clearCoatNormalPS",
                            N,
                            J.chunks,
                            ce
                          )
                        ),
                        M.append("getClearCoat();"),
                        M.append("getClearCoatGlossiness();"),
                        M.append("getClearCoatNormal();"),
                        F.append(
                          "litArgs_clearcoat_specularity = ccSpecularity;"
                        ),
                        F.append("litArgs_clearcoat_gloss = ccGlossiness;"),
                        F.append("litArgs_clearcoat_worldNormal = ccNormalW;")),
                      N.lightMap || N.lightVertexColor)
                    ) {
                      const oe = N.dirLightMap && N.litOptions.useSpecular,
                        de = oe ? "lightmapDirPS" : "lightmapSinglePS";
                      ie.append("vec3 dLightmap;"),
                        oe && ie.append("vec3 dLightmapDir;"),
                        b.append(
                          this._addMap(
                            "light",
                            de,
                            N,
                            J.chunks,
                            ce,
                            N.lightMapEncoding
                          )
                        ),
                        M.append("getLightMap();"),
                        F.append("litArgs_lightmap = dLightmap;"),
                        oe && F.append("litArgs_lightmapDir = dLightmapDir;");
                    }
                    (b.code.indexOf("texture2DSRGB") !== -1 ||
                      b.code.indexOf("texture2DRGBM") !== -1 ||
                      b.code.indexOf("texture2DRGBE") !== -1) &&
                      b.prepend(J.chunks.textureSamplePS);
                  } else
                    N.litOptions.alphaTest &&
                      (ie.append("float dAlpha;"),
                      b.append(
                        this._addMap("opacity", "opacityPS", N, J.chunks, ce)
                      ),
                      b.append(J.chunks.alphaTestPS),
                      M.append("getOpacity();"),
                      M.append("alphaTest(dAlpha);"),
                      F.append("litArgs_opacity = dAlpha;"));
                  ie.append(J.chunks.litShaderArgsPS),
                    b.append(`void evaluateFrontend() { 
${M.code}
${F.code}
 }
`),
                    (M.code = "evaluateFrontend();");
                  for (const oe in ce)
                    ie.append(`uniform sampler2D ${ce[oe]};`);
                  return (
                    (M.code = `
${M.code
  .split(
    `
`
  )
  .map((oe) => `    ${oe}`).join(`
`)}

`),
                    J.generateFragmentShader(ie.code, b.code, M.code, z),
                    J.getDefinition()
                  );
                },
              };
            var y = a(2737),
              p = a(7921),
              _ = a(5928);
            const m = (me, N) => {
                if (me.length !== N.length) return !1;
                for (let V = 0; V < me.length; ++V)
                  if (me[V] !== N[V]) return !1;
                return !0;
              },
              E = (me) => me.r !== 1 || me.g !== 1 || me.b !== 1,
              v = (me) => me.r !== 0 || me.g !== 0 || me.b !== 0;
            class P {
              constructor() {
                this._mapXForms = null;
              }
              updateMinRef(N, V, L, J, ae, R) {
                this._updateSharedOptions(N, V, L, J, ae),
                  this._updateMinOptions(N, L),
                  this._updateUVOptions(N, L, J, !0);
              }
              updateRef(N, V, L, J, ae, R) {
                this._updateSharedOptions(N, V, L, J, ae),
                  this._updateEnvOptions(N, L, V),
                  this._updateMaterialOptions(N, L),
                  ae === d.zw &&
                    (N.litOptions.gamma && (N.litOptions.gamma = d.CH),
                    (N.litOptions.toneMap = d.Fz)),
                  (N.litOptions.hasTangents = J && (J & d.tX) !== 0),
                  this._updateLightOptions(N, V, L, J, R),
                  this._updateUVOptions(N, L, J, !1);
              }
              _updateSharedOptions(N, V, L, J, ae) {
                (N.forceUv1 = L.forceUv1),
                  (N.litOptions.chunks = L.chunks || {}),
                  (N.litOptions.pass = ae),
                  (N.litOptions.alphaTest = L.alphaTest > 0),
                  (N.litOptions.blendType = L.blendType),
                  (N.litOptions.screenSpace = J && (J & d.hz) !== 0),
                  (N.litOptions.skin = J && (J & d.e8) !== 0),
                  (N.litOptions.useInstancing = J && (J & d.Is) !== 0),
                  (N.litOptions.useMorphPosition = J && (J & d.q4) !== 0),
                  (N.litOptions.useMorphNormal = J && (J & d.$I) !== 0),
                  (N.litOptions.useMorphTextureBased = J && (J & d.jx) !== 0),
                  (N.litOptions.nineSlicedMode = L.nineSlicedMode || 0),
                  V.clusteredLightingEnabled && L.useLighting
                    ? ((N.litOptions.clusteredLightingEnabled = !0),
                      (N.litOptions.clusteredLightingCookiesEnabled =
                        V.lighting.cookiesEnabled),
                      (N.litOptions.clusteredLightingShadowsEnabled =
                        V.lighting.shadowsEnabled),
                      (N.litOptions.clusteredLightingShadowType =
                        V.lighting.shadowType),
                      (N.litOptions.clusteredLightingAreaLightsEnabled =
                        V.lighting.areaLightsEnabled))
                    : ((N.litOptions.clusteredLightingEnabled = !1),
                      (N.litOptions.clusteredLightingCookiesEnabled = !1),
                      (N.litOptions.clusteredLightingShadowsEnabled = !1),
                      (N.litOptions.clusteredLightingAreaLightsEnabled = !1));
              }
              _updateUVOptions(N, V, L, J) {
                let ae = !1,
                  R = !1,
                  j = !1;
                L &&
                  ((ae = (L & d.KV) !== 0),
                  (R = (L & d.Sm) !== 0),
                  (j = (L & d.HI) !== 0)),
                  (N.litOptions.vertexColors = !1),
                  (this._mapXForms = []);
                const se = {};
                for (const ce in t)
                  this._updateTexOptions(N, V, ce, ae, R, j, J, se);
                (this._mapXForms = null),
                  (N.litOptions.lightMapEnabled = N.lightMap),
                  (N.litOptions.dirLightMapEnabled = N.dirLightMap),
                  (N.litOptions.useHeights = N.heightMap),
                  (N.litOptions.useNormals = N.normalMap),
                  (N.litOptions.useClearCoatNormals = N.clearCoatNormalMap),
                  (N.litOptions.useAo = N.aoMap || N.aoVertexColor),
                  (N.litOptions.diffuseMapEnabled = N.diffuseMap);
              }
              _updateTexOptions(N, V, L, J, ae, R, j, se) {
                const ce = L === "opacity";
                if (!j || ce) {
                  const ie = L + "Map",
                    b = L + "VertexColor",
                    M = L + "VertexColorChannel",
                    F = ie + "Channel",
                    z = ie + "Transform",
                    oe = ie + "Uv",
                    de = ie + "Identifier";
                  if (
                    (L !== "light" &&
                      ((N[ie] = !1),
                      (N[de] = void 0),
                      (N[F] = ""),
                      (N[z] = 0),
                      (N[oe] = 0)),
                    (N[b] = !1),
                    (N[M] = ""),
                    ce &&
                      V.blendType === d.He &&
                      V.alphaTest === 0 &&
                      !V.alphaToCoverage)
                  )
                    return;
                  if (
                    (L !== "height" &&
                      V[b] &&
                      R &&
                      ((N[b] = V[b]),
                      (N[M] = V[M]),
                      (N.litOptions.vertexColors = !0)),
                    V[ie])
                  ) {
                    let ge = !0;
                    if (
                      (V[oe] === 0 && !J && (ge = !1),
                      V[oe] === 1 && !ae && (ge = !1),
                      ge)
                    ) {
                      const Re = V[ie].id;
                      let Te = se[Re];
                      Te === void 0 && ((se[Re] = L), (Te = L)),
                        (N[ie] = !!V[ie]),
                        (N[de] = Te),
                        (N[z] = this._getMapTransformID(
                          V.getUniform(z),
                          V[oe]
                        )),
                        (N[F] = V[F]),
                        (N[oe] = V[oe]);
                    }
                  }
                }
              }
              _updateMinOptions(N, V) {
                (N.opacityTint = V.opacity !== 1 && V.blendType !== d.He),
                  (N.litOptions.lights = []);
              }
              _updateMaterialOptions(N, V) {
                var L, J, ae, R;
                const j =
                    (V.diffuseTint ||
                      (!V.diffuseMap && !V.diffuseVertexColor)) &&
                    E(V.diffuse),
                  se = !!(
                    V.useMetalness ||
                    V.specularMap ||
                    V.sphereMap ||
                    V.cubeMap ||
                    v(V.specular) ||
                    (V.specularityFactor > 0 && V.useMetalness) ||
                    V.enableGGXSpecular ||
                    V.clearCoat > 0
                  ),
                  ce = !V.useMetalness || V.useMetalnessSpecularColor,
                  ie =
                    se &&
                    (V.specularTint ||
                      (!V.specularMap && !V.specularVertexColor)) &&
                    E(V.specular),
                  b =
                    se &&
                    V.useMetalnessSpecularColor &&
                    (V.specularityFactorTint ||
                      (V.specularityFactor < 1 && !V.specularityFactorMap)),
                  M = !V.emissiveMap || (E(V.emissive) && V.emissiveTint),
                  F = V.emissiveIntensity !== 1,
                  z = V.normalMap
                    ? V.normalMap.format === p.ZtC || V.normalMap.type === p.anS
                    : !1;
                (N.opacityTint =
                  V.opacity !== 1 && V.blendType !== d.He ? 1 : 0),
                  (N.ambientTint = V.ambientTint),
                  (N.diffuseTint = j ? 2 : 0),
                  (N.specularTint = ie ? 2 : 0),
                  (N.specularityFactorTint = b ? 1 : 0),
                  (N.metalnessTint = V.useMetalness && V.metalness < 1 ? 1 : 0),
                  (N.glossTint = 1),
                  (N.emissiveTint = (M ? 2 : 0) + (F ? 1 : 0)),
                  (N.diffuseEncoding =
                    (L = V.diffuseMap) == null ? void 0 : L.encoding),
                  (N.diffuseDetailEncoding =
                    (J = V.diffuseDetailMap) == null ? void 0 : J.encoding),
                  (N.emissiveEncoding =
                    (ae = V.emissiveMap) == null ? void 0 : ae.encoding),
                  (N.lightMapEncoding =
                    (R = V.lightMap) == null ? void 0 : R.encoding),
                  (N.packedNormal = z),
                  (N.refractionTint = V.refraction !== 1 ? 1 : 0),
                  (N.refractionIndexTint =
                    V.refractionIndex !== 0.6666666666666666 ? 1 : 0),
                  (N.thicknessTint =
                    V.useDynamicRefraction && V.thickness !== 1 ? 1 : 0),
                  (N.specularEncoding = V.specularEncoding || "linear"),
                  (N.sheenEncoding = V.sheenEncoding || "linear"),
                  (N.aoMapUv = V.aoUvSet),
                  (N.aoDetail = !!V.aoMap),
                  (N.diffuseDetail = !!V.diffuseMap),
                  (N.normalDetail = !!V.normalMap),
                  (N.diffuseDetailMode = V.diffuseDetailMode),
                  (N.aoDetailMode = V.aoDetailMode),
                  (N.clearCoatTint = V.clearCoat !== 1 ? 1 : 0),
                  (N.clearCoatGloss = !!V.clearCoatGloss),
                  (N.clearCoatGlossTint = V.clearCoatGloss !== 1 ? 1 : 0),
                  (N.iorTint =
                    V.refractionIndex !== 0.6666666666666666 ? 1 : 0),
                  (N.iridescenceTint = V.iridescence !== 1 ? 1 : 0),
                  (N.sheenTint = V.useSheen && E(V.sheen) ? 2 : 0),
                  (N.sheenGlossTint = 1),
                  (N.glossInvert = V.glossInvert),
                  (N.sheenGlossInvert = V.sheenGlossInvert),
                  (N.clearCoatGlossInvert = V.clearCoatGlossInvert),
                  (N.useSpecularColor = ce),
                  (N.litOptions.separateAmbient = !1),
                  (N.litOptions.useAmbientTint = V.ambientTint),
                  (N.litOptions.customFragmentShader = V.customFragmentShader),
                  (N.litOptions.pixelSnap = V.pixelSnap),
                  (N.litOptions.shadingModel = V.shadingModel),
                  (N.litOptions.ambientSH = !!V.ambientSH),
                  (N.litOptions.fastTbn = V.fastTbn),
                  (N.litOptions.twoSidedLighting = V.twoSidedLighting),
                  (N.litOptions.occludeSpecular = V.occludeSpecular),
                  (N.litOptions.occludeSpecularFloat =
                    V.occludeSpecularIntensity !== 1),
                  (N.litOptions.useMsdf = !!V.msdfMap),
                  (N.litOptions.msdfTextAttribute = !!V.msdfTextAttribute),
                  (N.litOptions.alphaToCoverage = V.alphaToCoverage),
                  (N.litOptions.opacityFadesSpecular = V.opacityFadesSpecular),
                  (N.litOptions.cubeMapProjection = V.cubeMapProjection),
                  (N.litOptions.occludeDirect = V.occludeDirect),
                  (N.litOptions.conserveEnergy =
                    V.conserveEnergy && V.shadingModel !== d.yd),
                  (N.litOptions.useSpecular = se),
                  (N.litOptions.useSpecularityFactor =
                    (b || !!V.specularityFactorMap) &&
                    V.useMetalnessSpecularColor),
                  (N.litOptions.enableGGXSpecular = V.enableGGXSpecular),
                  (N.litOptions.fresnelModel = V.fresnelModel),
                  (N.litOptions.useRefraction =
                    (V.refraction || !!V.refractionMap) &&
                    (V.useDynamicRefraction ||
                      !!N.litOptions.reflectionSource)),
                  (N.litOptions.useClearCoat = !!V.clearCoat),
                  (N.litOptions.useSheen = V.useSheen),
                  (N.litOptions.useIridescence =
                    V.useIridescence && V.iridescence !== 0),
                  (N.litOptions.useMetalness = V.useMetalness),
                  (N.litOptions.useDynamicRefraction = V.useDynamicRefraction);
              }
              _updateEnvOptions(N, V, L) {
                (N.litOptions.fog = V.useFog ? L.fog : "none"),
                  (N.litOptions.gamma = V.useGammaTonemap
                    ? L.gammaCorrection
                    : d.Ie),
                  (N.litOptions.toneMap = V.useGammaTonemap
                    ? L.toneMapping
                    : -1),
                  (N.litOptions.fixSeams = V.cubeMap
                    ? V.cubeMap.fixCubemapSeams
                    : !1);
                const J = V.shadingModel === d.yd;
                let ae = !1;
                if (
                  (V.envAtlas && V.cubeMap && !J
                    ? ((N.litOptions.reflectionSource = "envAtlasHQ"),
                      (N.litOptions.reflectionEncoding = V.envAtlas.encoding),
                      (N.litOptions.reflectionCubemapEncoding =
                        V.cubeMap.encoding))
                    : V.envAtlas && !J
                    ? ((N.litOptions.reflectionSource = "envAtlas"),
                      (N.litOptions.reflectionEncoding = V.envAtlas.encoding))
                    : V.cubeMap
                    ? ((N.litOptions.reflectionSource = "cubeMap"),
                      (N.litOptions.reflectionEncoding = V.cubeMap.encoding))
                    : V.sphereMap
                    ? ((N.litOptions.reflectionSource = "sphereMap"),
                      (N.litOptions.reflectionEncoding = V.sphereMap.encoding))
                    : V.useSkybox && L.envAtlas && L.skybox && !J
                    ? ((N.litOptions.reflectionSource = "envAtlasHQ"),
                      (N.litOptions.reflectionEncoding = L.envAtlas.encoding),
                      (N.litOptions.reflectionCubemapEncoding =
                        L.skybox.encoding),
                      (ae = !0))
                    : V.useSkybox && L.envAtlas && !J
                    ? ((N.litOptions.reflectionSource = "envAtlas"),
                      (N.litOptions.reflectionEncoding = L.envAtlas.encoding),
                      (ae = !0))
                    : V.useSkybox && L.skybox
                    ? ((N.litOptions.reflectionSource = "cubeMap"),
                      (N.litOptions.reflectionEncoding = L.skybox.encoding),
                      (ae = !0))
                    : ((N.litOptions.reflectionSource = null),
                      (N.litOptions.reflectionEncoding = null)),
                  V.ambientSH && !J)
                )
                  (N.litOptions.ambientSource = "ambientSH"),
                    (N.litOptions.ambientEncoding = null);
                else {
                  const R =
                    V.envAtlas ||
                    (V.useSkybox && L.envAtlas ? L.envAtlas : null);
                  R && !J
                    ? ((N.litOptions.ambientSource = "envAtlas"),
                      (N.litOptions.ambientEncoding = R.encoding))
                    : ((N.litOptions.ambientSource = "constant"),
                      (N.litOptions.ambientEncoding = null));
                }
                (N.litOptions.skyboxIntensity =
                  ae && (L.skyboxIntensity !== 1 || L.physicalUnits)),
                  (N.litOptions.useCubeMapRotation =
                    ae && L._skyboxRotationShaderInclude);
              }
              _updateLightOptions(N, V, L, J, ae) {
                if (
                  ((N.lightMap = !1),
                  (N.lightMapChannel = ""),
                  (N.lightMapUv = 0),
                  (N.lightMapTransform = 0),
                  (N.litOptions.lightMapWithoutAmbient = !1),
                  (N.dirLightMap = !1),
                  J &&
                    ((N.litOptions.noShadow = (J & d.BP) !== 0),
                    J & d.b0 &&
                      ((N.lightMapEncoding =
                        V.lightmapPixelFormat === p.jKI ? "rgbm" : "linear"),
                      (N.lightMap = !0),
                      (N.lightMapChannel = "rgb"),
                      (N.lightMapUv = 1),
                      (N.lightMapTransform = 0),
                      (N.litOptions.lightMapWithoutAmbient = !L.lightMap),
                      J & d.Bp && (N.dirLightMap = !0),
                      J & d.c8 && (N.litOptions.lightMapWithoutAmbient = !1))),
                  L.useLighting)
                ) {
                  const R = [],
                    j = J ? J >> 16 : d.BN;
                  (N.litOptions.lightMaskDynamic = !!(j & d.BN)),
                    ae &&
                      (_.Q.collectLights(d.WQ, ae[d.WQ], R, j),
                      _.Q.collectLights(d.bA, ae[d.bA], R, j),
                      _.Q.collectLights(d.z0, ae[d.z0], R, j)),
                    (N.litOptions.lights = R);
                } else N.litOptions.lights = [];
                N.litOptions.lights.length === 0 &&
                  (N.litOptions.noShadow = !0);
              }
              _getMapTransformID(N, V) {
                if (!N) return 0;
                let L = this._mapXForms[V];
                L || ((L = []), (this._mapXForms[V] = L));
                for (let J = 0; J < L.length; J++)
                  if (
                    m(L[J][0].value, N[0].value) &&
                    m(L[J][1].value, N[1].value)
                  )
                    return J + 1;
                return L.push(N);
              }
            }
            var I = a(6672);
            const A = {},
              B = {};
            let C = new Set();
            class w extends y.F {
              constructor() {
                super(),
                  (this._dirtyShader = !0),
                  (this._assetReferences = {}),
                  (this._activeParams = new Set()),
                  (this._activeLightingParams = new Set()),
                  (this.shaderOptBuilder = new P()),
                  this.reset();
              }
              reset() {
                Object.keys(A).forEach((N) => {
                  this[`_${N}`] = A[N].value();
                }),
                  (this._chunks = {}),
                  (this._uniformCache = {});
              }
              set shader(N) {}
              get shader() {
                return null;
              }
              set chunks(N) {
                (this._dirtyShader = !0), (this._chunks = N);
              }
              get chunks() {
                return (this._dirtyShader = !0), this._chunks;
              }
              copy(N) {
                super.copy(N),
                  Object.keys(A).forEach((V) => {
                    this[V] = N[V];
                  });
                for (const V in N._chunks)
                  N._chunks.hasOwnProperty(V) &&
                    (this._chunks[V] = N._chunks[V]);
                return this;
              }
              _setParameter(N, V) {
                C.add(N), this.setParameter(N, V);
              }
              _setParameters(N) {
                N.forEach((V) => {
                  this._setParameter(V.name, V.value);
                });
              }
              _processParameters(N) {
                const V = this[N];
                V.forEach((L) => {
                  C.has(L) || delete this.parameters[L];
                }),
                  (this[N] = C),
                  (C = V),
                  C.clear();
              }
              _updateMap(N) {
                const V = N + "Map",
                  L = this[V];
                if (L) {
                  this._setParameter("texture_" + V, L);
                  const J = V + "Transform",
                    ae = this.getUniform(J);
                  ae && this._setParameters(ae);
                }
              }
              _allocUniform(N, V) {
                let L = this._uniformCache[N];
                return L || ((L = V()), (this._uniformCache[N] = L)), L;
              }
              getUniform(N, V, L) {
                return B[N](this, V, L);
              }
              updateUniforms(N, V) {
                const L = (ae) => this.getUniform(ae, N, V);
                this._setParameter("material_ambient", L("ambient")),
                  (!this.diffuseMap || this.diffuseTint) &&
                    this._setParameter("material_diffuse", L("diffuse")),
                  this.useMetalness
                    ? ((!this.metalnessMap || this.metalness < 1) &&
                        this._setParameter(
                          "material_metalness",
                          this.metalness
                        ),
                      (!this.specularMap || this.specularTint) &&
                        this._setParameter("material_specular", L("specular")),
                      (!this.specularityFactorMap ||
                        this.specularityFactorTint) &&
                        this._setParameter(
                          "material_specularityFactor",
                          this.specularityFactor
                        ),
                      (!this.sheenMap || this.sheenTint) &&
                        this._setParameter("material_sheen", L("sheen")),
                      (!this.sheenGlossMap || this.sheenGlossTint) &&
                        this._setParameter(
                          "material_sheenGloss",
                          this.sheenGloss
                        ),
                      this._setParameter(
                        "material_refractionIndex",
                        this.refractionIndex
                      ))
                    : (!this.specularMap || this.specularTint) &&
                      this._setParameter("material_specular", L("specular")),
                  this.enableGGXSpecular &&
                    this._setParameter("material_anisotropy", this.anisotropy),
                  this.clearCoat > 0 &&
                    (this._setParameter("material_clearCoat", this.clearCoat),
                    this._setParameter(
                      "material_clearCoatGloss",
                      this.clearCoatGloss
                    ),
                    this._setParameter(
                      "material_clearCoatBumpiness",
                      this.clearCoatBumpiness
                    )),
                  this._setParameter("material_gloss", L("gloss")),
                  (!this.emissiveMap || this.emissiveTint) &&
                    this._setParameter("material_emissive", L("emissive")),
                  this.emissiveIntensity !== 1 &&
                    this._setParameter(
                      "material_emissiveIntensity",
                      this.emissiveIntensity
                    ),
                  this.refraction > 0 &&
                    this._setParameter("material_refraction", this.refraction),
                  this.useDynamicRefraction &&
                    (this._setParameter("material_thickness", this.thickness),
                    this._setParameter(
                      "material_attenuation",
                      L("attenuation")
                    ),
                    this._setParameter(
                      "material_invAttenuationDistance",
                      this.attenuationDistance === 0
                        ? 0
                        : 1 / this.attenuationDistance
                    )),
                  this.useIridescence &&
                    (this._setParameter(
                      "material_iridescence",
                      this.iridescence
                    ),
                    this._setParameter(
                      "material_iridescenceRefractionIndex",
                      this.iridescenceRefractionIndex
                    ),
                    this._setParameter(
                      "material_iridescenceThicknessMin",
                      this.iridescenceThicknessMin
                    ),
                    this._setParameter(
                      "material_iridescenceThicknessMax",
                      this.iridescenceThicknessMax
                    )),
                  this._setParameter("material_opacity", this.opacity),
                  this.opacityFadesSpecular === !1 &&
                    this._setParameter("material_alphaFade", this.alphaFade),
                  this.occludeSpecular &&
                    this._setParameter(
                      "material_occludeSpecularIntensity",
                      this.occludeSpecularIntensity
                    ),
                  this.cubeMapProjection === d.jJ &&
                    this._setParameter(L("cubeMapProjectionBox"));
                for (const ae in t) this._updateMap(ae);
                this.ambientSH &&
                  this._setParameter("ambientSH[0]", this.ambientSH),
                  this.normalMap &&
                    this._setParameter("material_bumpiness", this.bumpiness),
                  this.normalMap &&
                    this.normalDetailMap &&
                    this._setParameter(
                      "material_normalDetailMapBumpiness",
                      this.normalDetailMapBumpiness
                    ),
                  this.heightMap &&
                    this._setParameter(
                      "material_heightMapFactor",
                      L("heightMapFactor")
                    );
                const J = this.shadingModel === d.yd;
                this.envAtlas && this.cubeMap && !J
                  ? (this._setParameter("texture_envAtlas", this.envAtlas),
                    this._setParameter("texture_cubeMap", this.cubeMap))
                  : this.envAtlas && !J
                  ? this._setParameter("texture_envAtlas", this.envAtlas)
                  : this.cubeMap
                  ? this._setParameter("texture_cubeMap", this.cubeMap)
                  : this.sphereMap &&
                    this._setParameter("texture_sphereMap", this.sphereMap),
                  this._setParameter(
                    "material_reflectivity",
                    this.reflectivity
                  ),
                  this._processParameters("_activeParams"),
                  this._dirtyShader && this.clearVariants();
              }
              updateEnvUniforms(N, V) {
                const L = this.shadingModel === d.yd;
                !((this.envAtlas && !L) || this.cubeMap || this.sphereMap) &&
                  this.useSkybox &&
                  (V.envAtlas && V.skybox && !L
                    ? (this._setParameter("texture_envAtlas", V.envAtlas),
                      this._setParameter("texture_cubeMap", V.skybox))
                    : V.envAtlas && !L
                    ? this._setParameter("texture_envAtlas", V.envAtlas)
                    : V.skybox &&
                      this._setParameter("texture_cubeMap", V.skybox)),
                  this._processParameters("_activeLightingParams");
              }
              getShaderVariant(N, V, L, J, ae, R, j, se, ce) {
                this.updateEnvUniforms(N, V);
                const ie = h.T.get(N).getByIndex(ae),
                  b = ae === d.Jb || ae === d.WW || ie.isShadow;
                let M = b ? u.optionsContextMin : u.optionsContext;
                b
                  ? this.shaderOptBuilder.updateMinRef(M, V, this, L, ae, R)
                  : this.shaderOptBuilder.updateRef(M, V, this, L, ae, R),
                  this.onUpdateShader && (M = this.onUpdateShader(M));
                const F = new c.C(j, se, ce),
                  z = (0, s.N)(N);
                z.register("standard", u);
                const oe = z.getProgram("standard", M, F, this.userId);
                return (this._dirtyShader = !1), oe;
              }
              destroy() {
                for (const N in this._assetReferences)
                  this._assetReferences[N]._unbind();
                (this._assetReferences = null), super.destroy();
              }
            }
            (w.TEXTURE_PARAMETERS = I.Eh), (w.CUBEMAP_PARAMETERS = I.Ft);
            const k = (me, N) => {
                B[me] = N;
              },
              K = (me, N, V, L) => {
                Object.defineProperty(w.prototype, me, {
                  get:
                    L ||
                    function () {
                      return this[`_${me}`];
                    },
                  set: V,
                }),
                  (A[me] = { value: N });
              },
              te = (me) => {
                const N = `_${me.name}`,
                  V = me.dirtyShaderFunc || (() => !0),
                  L = function (ae) {
                    const R = this[N];
                    R !== ae &&
                      ((this._dirtyShader = this._dirtyShader || V(R, ae)),
                      (this[N] = ae));
                  };
                K(me.name, () => me.defaultValue, L, me.getterFunc);
              },
              X = (me) => {
                const N = `_${me.name}`,
                  V = me.dirtyShaderFunc || (() => !0),
                  L = function (ae) {
                    const R = this[N];
                    R.equals(ae) ||
                      ((this._dirtyShader = this._dirtyShader || V(R, ae)),
                      (this[N] = R.copy(ae)));
                  };
                K(me.name, () => me.defaultValue.clone(), L, me.getterFunc);
              },
              $ = (me) =>
                me.defaultValue && me.defaultValue.clone ? X(me) : te(me);
            function ne(me, N = "rgb", V = !0, L = 0) {
              (t[me] = N.length || -1),
                $({
                  name: `${me}Map`,
                  defaultValue: null,
                  dirtyShaderFunc: (se, ce) =>
                    !!se != !!ce ||
                    (se &&
                      (se.type !== ce.type ||
                        se.fixCubemapSeams !== ce.fixCubemapSeams ||
                        se.format !== ce.format)),
                }),
                $({ name: `${me}MapTiling`, defaultValue: new g.S(1, 1) }),
                $({ name: `${me}MapOffset`, defaultValue: new g.S(0, 0) }),
                $({ name: `${me}MapRotation`, defaultValue: 0 }),
                $({ name: `${me}MapUv`, defaultValue: L }),
                N &&
                  ($({ name: `${me}MapChannel`, defaultValue: N }),
                  V &&
                    ($({ name: `${me}VertexColor`, defaultValue: !1 }),
                    $({ name: `${me}VertexColorChannel`, defaultValue: N })));
              const J = `${me}MapTiling`,
                ae = `${me}MapOffset`,
                R = `${me}MapRotation`,
                j = `${me}MapTransform`;
              k(j, (se, ce, ie) => {
                const b = se[J],
                  M = se[ae],
                  F = se[R];
                if (b.x === 1 && b.y === 1 && M.x === 0 && M.y === 0 && F === 0)
                  return null;
                const z = se._allocUniform(j, () => [
                    { name: `texture_${j}0`, value: new Float32Array(3) },
                    { name: `texture_${j}1`, value: new Float32Array(3) },
                  ]),
                  oe = Math.cos(F * T.m.DEG_TO_RAD),
                  de = Math.sin(F * T.m.DEG_TO_RAD),
                  ge = z[0].value;
                (ge[0] = oe * b.x), (ge[1] = -de * b.y), (ge[2] = M.x);
                const Re = z[1].value;
                return (
                  (Re[0] = de * b.x),
                  (Re[1] = oe * b.y),
                  (Re[2] = 1 - b.y - M.y),
                  z
                );
              });
            }
            function Y(me, N) {
              $({
                name: me,
                defaultValue: N,
                getterFunc: function () {
                  return (this._dirtyShader = !0), this[`_${me}`];
                },
              }),
                k(me, (V, L, J) => {
                  const ae = V._allocUniform(me, () => new Float32Array(3)),
                    R = V[me];
                  return (
                    V.useGammaTonemap && J.gammaCorrection
                      ? ((ae[0] = Math.pow(R.r, 2.2)),
                        (ae[1] = Math.pow(R.g, 2.2)),
                        (ae[2] = Math.pow(R.b, 2.2)))
                      : ((ae[0] = R.r), (ae[1] = R.g), (ae[2] = R.b)),
                    ae
                  );
                });
            }
            function Z(me, N, V) {
              $({
                name: me,
                defaultValue: N,
                dirtyShaderFunc: (L, J) =>
                  (L === 0 || L === 1) != (J === 0 || J === 1),
              }),
                k(me, V);
            }
            function ye(me, N) {
              $({
                name: me,
                defaultValue: null,
                dirtyShaderFunc: (V, L) => !!V == !!L,
              }),
                k(me, N);
            }
            function pe(me, N) {
              $({ name: me, defaultValue: N });
            }
            function O() {
              Y("ambient", new x.I(0.7, 0.7, 0.7)),
                Y("diffuse", new x.I(1, 1, 1)),
                Y("specular", new x.I(0, 0, 0)),
                Y("emissive", new x.I(0, 0, 0)),
                Y("sheen", new x.I(1, 1, 1)),
                Y("attenuation", new x.I(1, 1, 1)),
                Z("emissiveIntensity", 1),
                Z("specularityFactor", 1),
                Z("sheenGloss", 0),
                Z("gloss", 0.25, (L, J, ae) =>
                  L.shadingModel === d.yd ? Math.pow(2, L.gloss * 11) : L.gloss
                ),
                Z(
                  "heightMapFactor",
                  1,
                  (L, J, ae) => L.heightMapFactor * 0.025
                ),
                Z("opacity", 1),
                Z("alphaFade", 1),
                Z("alphaTest", 0),
                Z("bumpiness", 1),
                Z("normalDetailMapBumpiness", 1),
                Z("reflectivity", 1),
                Z("occludeSpecularIntensity", 1),
                Z("refraction", 0),
                Z("refractionIndex", 0.6666666666666666),
                Z("thickness", 0),
                Z("attenuationDistance", 0),
                Z("metalness", 1),
                Z("anisotropy", 0),
                Z("clearCoat", 0),
                Z("clearCoatGloss", 1),
                Z("clearCoatBumpiness", 1),
                Z("aoUvSet", 0, null),
                Z("iridescence", 0),
                Z("iridescenceRefractionIndex", 0.6666666666666666),
                Z("iridescenceThicknessMin", 0),
                Z("iridescenceThicknessMax", 0),
                ye("ambientSH"),
                ye("cubeMapProjectionBox", (L, J, ae) => {
                  const R = L._allocUniform("cubeMapProjectionBox", () => [
                      { name: "envBoxMin", value: new Float32Array(3) },
                      { name: "envBoxMax", value: new Float32Array(3) },
                    ]),
                    j = L.cubeMapProjectionBox.getMin(),
                    se = R[0].value;
                  (se[0] = j.x), (se[1] = j.y), (se[2] = j.z);
                  const ce = L.cubeMapProjectionBox.getMax(),
                    ie = R[1].value;
                  return (ie[0] = ce.x), (ie[1] = ce.y), (ie[2] = ce.z), R;
                }),
                pe("ambientTint", !1),
                pe("diffuseTint", !1),
                pe("specularTint", !1),
                pe("specularityFactorTint", !1),
                pe("emissiveTint", !1),
                pe("fastTbn", !1),
                pe("useMetalness", !1),
                pe("useMetalnessSpecularColor", !1),
                pe("useSheen", !1),
                pe("enableGGXSpecular", !1),
                pe("occludeDirect", !1),
                pe("normalizeNormalMap", !0),
                pe("conserveEnergy", !0),
                pe("opacityFadesSpecular", !0),
                pe("occludeSpecular", d._f),
                pe("shadingModel", d.qT),
                pe("fresnelModel", d.Rx),
                pe("useDynamicRefraction", !1),
                pe("cubeMapProjection", d.AM),
                pe("customFragmentShader", null),
                pe("useFog", !0),
                pe("useLighting", !0),
                pe("useGammaTonemap", !0),
                pe("useSkybox", !0),
                pe("forceUv1", !1),
                pe("pixelSnap", !1),
                pe("twoSidedLighting", !1),
                pe("nineSlicedMode", void 0),
                pe("msdfTextAttribute", !1),
                pe("useIridescence", !1),
                pe("glossInvert", !1),
                pe("sheenGlossInvert", !1),
                pe("clearCoatGlossInvert", !1),
                ne("diffuse"),
                ne("specular"),
                ne("emissive"),
                ne("thickness", "g"),
                ne("specularityFactor", "g"),
                ne("normal", ""),
                ne("metalness", "g"),
                ne("gloss", "g"),
                ne("opacity", "a"),
                ne("refraction", "g"),
                ne("height", "g", !1),
                ne("ao", "g"),
                ne("light", "rgb", !0, 1),
                ne("msdf", ""),
                ne("diffuseDetail", "rgb", !1),
                ne("normalDetail", ""),
                ne("aoDetail", "g", !1),
                ne("clearCoat", "g"),
                ne("clearCoatGloss", "g"),
                ne("clearCoatNormal", ""),
                ne("sheen", "rgb"),
                ne("sheenGloss", "g"),
                ne("iridescence", "g"),
                ne("iridescenceThickness", "g"),
                pe("diffuseDetailMode", d.pk),
                pe("aoDetailMode", d.pk),
                ye("cubeMap"),
                ye("sphereMap"),
                ye("envAtlas");
              const me = function () {
                  return this._prefilteredCubemaps;
                },
                N = function (J) {
                  const ae = this._prefilteredCubemaps;
                  J = J || [];
                  let R = !1,
                    j = !0;
                  for (let se = 0; se < 6; ++se) {
                    const ce = J[se] || null;
                    ae[se] !== ce && ((ae[se] = ce), (R = !0)),
                      (j = j && !!ae[se]);
                  }
                  R &&
                    (j
                      ? (this.envAtlas = f.C.generatePrefilteredAtlas(ae, {
                          target: this.envAtlas,
                        }))
                      : this.envAtlas &&
                        (this.envAtlas.destroy(), (this.envAtlas = null)),
                    (this._dirtyShader = !0));
                },
                V = [null, null, null, null, null, null];
              K("prefilteredCubemaps", () => V.slice(), N, me);
            }
            O();
          },
          8792: (Se, W, a) => {
            "use strict";
            a.d(W, { l: () => y, m: () => t });
            var x = a(3148),
              T = a(4633),
              g = a(7008),
              c = a(4051),
              d = a(3114),
              h = a(7915),
              f = a(9373),
              s = a(963);
            const l = new x.k(),
              n = new x.k(),
              o = new T.K(),
              i = new Set();
            class e {
              constructor(m) {
                (this.vertexBuffer = null), (this.count = m);
              }
            }
            class t {
              constructor(m, E, v) {
                (this._key = []),
                  (this._key[d.Uo] = p(m, E, !0, 0)),
                  (this.command = v);
              }
              set key(m) {
                this._key[d.Uo] = m;
              }
              get key() {
                return this._key[d.Uo];
              }
            }
            class r {
              constructor() {
                (this.shader = void 0), (this.bindGroup = null);
              }
              getBindGroup(m) {
                if (!this.bindGroup) {
                  const E = this.shader,
                    v = E.meshUniformBufferFormat,
                    P = new c.M(m, v, !1),
                    I = E.meshBindGroupFormat;
                  this.bindGroup = new g.v(m, I, P);
                }
                return this.bindGroup;
              }
              destroy() {
                const m = this.bindGroup;
                if (m) {
                  var E;
                  (E = m.defaultUniformBuffer) == null || E.destroy(),
                    m.destroy(),
                    (this.bindGroup = null);
                }
              }
            }
            class u {
              constructor() {
                this.shaderInstances = new Map();
              }
              destroy() {
                this.shaderInstances.forEach((m) => m.destroy()),
                  this.shaderInstances.clear();
              }
            }
            class y {
              constructor(m, E, v = null) {
                if (
                  ((this.visible = !0),
                  (this.castShadow = !1),
                  (this.transparent = !1),
                  (this._material = null),
                  (this._shaderCache = []),
                  m instanceof h.A)
                ) {
                  const P = m;
                  (m = E), (E = v), (v = P);
                }
                (this._key = [0, 0]),
                  (this.node = v),
                  (this._mesh = m),
                  m.incRefCount(),
                  (this.material = E),
                  (this._shaderDefs = d.BN << 16),
                  (this._shaderDefs |= m.vertexBuffer.format.hasUv0 ? d.KV : 0),
                  (this._shaderDefs |= m.vertexBuffer.format.hasUv1 ? d.Sm : 0),
                  (this._shaderDefs |= m.vertexBuffer.format.hasColor
                    ? d.HI
                    : 0),
                  (this._shaderDefs |= m.vertexBuffer.format.hasTangents
                    ? d.tX
                    : 0),
                  (this.layer = d.G),
                  (this._renderStyle = d.pr),
                  (this._receiveShadow = !0),
                  (this._screenSpace = !1),
                  (this._noDepthDrawGl1 = !1),
                  (this.cull = !0),
                  (this.pick = !0),
                  (this._updateAabb = !0),
                  (this._updateAabbFunc = null),
                  (this._calculateSortDistance = null),
                  this.updateKey(),
                  (this._skinInstance = null),
                  (this._morphInstance = null),
                  (this.instancingData = null),
                  (this._customAabb = null),
                  (this.aabb = new x.k()),
                  (this._aabbVer = -1),
                  (this.drawOrder = 0),
                  (this.visibleThisFrame = !1),
                  (this.isVisibleFunc = null),
                  (this.parameters = {}),
                  (this.stencilFront = null),
                  (this.stencilBack = null),
                  (this.flipFacesFactor = 1);
              }
              set renderStyle(m) {
                (this._renderStyle = m), this.mesh.prepareRenderState(m);
              }
              get renderStyle() {
                return this._renderStyle;
              }
              set mesh(m) {
                m !== this._mesh &&
                  (this._mesh && this._mesh.decRefCount(),
                  (this._mesh = m),
                  m && m.incRefCount());
              }
              get mesh() {
                return this._mesh;
              }
              set aabb(m) {
                this._aabb = m;
              }
              get aabb() {
                if (!this._updateAabb) return this._aabb;
                if (this._updateAabbFunc)
                  return this._updateAabbFunc(this._aabb);
                let m = this._customAabb,
                  E = !!m;
                if (!m) {
                  if (((m = l), this.skinInstance)) {
                    if (!this.mesh.boneAabb) {
                      const I = this._morphInstance
                        ? this._morphInstance.morph._targets
                        : null;
                      this.mesh._initBoneAabbs(I);
                    }
                    const v = this.mesh.boneUsed;
                    let P = !0;
                    for (let I = 0; I < this.mesh.boneAabb.length; I++)
                      v[I] &&
                        (n.setFromTransformedAabb(
                          this.mesh.boneAabb[I],
                          this.skinInstance.matrices[I]
                        ),
                        P
                          ? ((P = !1),
                            m.center.copy(n.center),
                            m.halfExtents.copy(n.halfExtents))
                          : m.add(n));
                    E = !0;
                  } else if (this.node._aabbVer !== this._aabbVer) {
                    if (
                      (this.mesh
                        ? (m.center.copy(this.mesh.aabb.center),
                          m.halfExtents.copy(this.mesh.aabb.halfExtents))
                        : (m.center.set(0, 0, 0), m.halfExtents.set(0, 0, 0)),
                      this.mesh && this.mesh.morph)
                    ) {
                      const v = this.mesh.morph.aabb;
                      m._expand(v.getMin(), v.getMax());
                    }
                    (E = !0), (this._aabbVer = this.node._aabbVer);
                  }
                }
                return (
                  E &&
                    this._aabb.setFromTransformedAabb(
                      m,
                      this.node.getWorldTransform()
                    ),
                  this._aabb
                );
              }
              clearShaders() {
                const m = this._shaderCache;
                for (let v = 0; v < m.length; v++) {
                  var E;
                  (E = m[v]) == null || E.destroy(), (m[v] = null);
                }
              }
              getShaderInstance(m, E, v, P, I, A) {
                let B,
                  C = this._shaderCache[m];
                if (
                  (C
                    ? (B = C.shaderInstances.get(E))
                    : ((C = new u()), (this._shaderCache[m] = C)),
                  !B)
                ) {
                  const w = this._material,
                    k = this._shaderDefs,
                    K = m + "_" + k + "_" + E;
                  if (
                    ((B = new r()), (B.shader = w.variants.get(K)), !B.shader)
                  ) {
                    const te = w.getShaderVariant(
                      this.mesh.device,
                      v,
                      k,
                      null,
                      m,
                      A,
                      P,
                      I,
                      this._mesh.vertexBuffer.format
                    );
                    w.variants.set(K, te), (B.shader = te);
                  }
                  C.shaderInstances.set(E, B);
                }
                return B;
              }
              set material(m) {
                this.clearShaders();
                const E = this._material;
                if (
                  (E && E.removeMeshInstanceRef(this), (this._material = m), m)
                ) {
                  m.addMeshInstanceRef(this),
                    (this.transparent = m.transparent),
                    this.updateKey();
                  const v = E && E.transparent;
                  if (m.transparent !== v) {
                    const P =
                      this._material._scene || (E == null ? void 0 : E._scene);
                    P ? (P.layers._dirtyBlend = !0) : (m._dirtyBlend = !0);
                  }
                }
              }
              get material() {
                return this._material;
              }
              set layer(m) {
                (this._layer = m), this.updateKey();
              }
              get layer() {
                return this._layer;
              }
              _updateShaderDefs(m) {
                m !== this._shaderDefs &&
                  ((this._shaderDefs = m), this.clearShaders());
              }
              set calculateSortDistance(m) {
                this._calculateSortDistance = m;
              }
              get calculateSortDistance() {
                return this._calculateSortDistance;
              }
              set receiveShadow(m) {
                this._receiveShadow !== m &&
                  ((this._receiveShadow = m),
                  this._updateShaderDefs(
                    m ? this._shaderDefs & ~d.BP : this._shaderDefs | d.BP
                  ));
              }
              get receiveShadow() {
                return this._receiveShadow;
              }
              set skinInstance(m) {
                (this._skinInstance = m),
                  this._updateShaderDefs(
                    m ? this._shaderDefs | d.e8 : this._shaderDefs & ~d.e8
                  ),
                  this._setupSkinUpdate();
              }
              get skinInstance() {
                return this._skinInstance;
              }
              set morphInstance(m) {
                var E;
                (E = this._morphInstance) == null || E.destroy(),
                  (this._morphInstance = m);
                let v = this._shaderDefs;
                (v = m && m.morph.useTextureMorph ? v | d.jx : v & ~d.jx),
                  (v = m && m.morph.morphPositions ? v | d.q4 : v & ~d.q4),
                  (v = m && m.morph.morphNormals ? v | d.$I : v & ~d.$I),
                  this._updateShaderDefs(v);
              }
              get morphInstance() {
                return this._morphInstance;
              }
              set screenSpace(m) {
                this._screenSpace !== m &&
                  ((this._screenSpace = m),
                  this._updateShaderDefs(
                    m ? this._shaderDefs | d.hz : this._shaderDefs & ~d.hz
                  ));
              }
              get screenSpace() {
                return this._screenSpace;
              }
              set key(m) {
                this._key[d.Uo] = m;
              }
              get key() {
                return this._key[d.Uo];
              }
              set mask(m) {
                const E = this._shaderDefs & 65535;
                this._updateShaderDefs(E | (m << 16));
              }
              get mask() {
                return this._shaderDefs >> 16;
              }
              set instancingCount(m) {
                this.instancingData && (this.instancingData.count = m);
              }
              get instancingCount() {
                return this.instancingData ? this.instancingData.count : 0;
              }
              destroy() {
                var m, E;
                const v = this.mesh;
                v && ((this.mesh = null), v.refCount < 1 && v.destroy()),
                  this.setRealtimeLightmap(y.lightmapParamNames[0], null),
                  this.setRealtimeLightmap(y.lightmapParamNames[1], null),
                  (m = this._skinInstance) == null || m.destroy(),
                  (this._skinInstance = null),
                  (E = this.morphInstance) == null || E.destroy(),
                  (this.morphInstance = null),
                  this.clearShaders(),
                  (this.material = null);
              }
              static _prepareRenderStyleForArray(m, E) {
                if (m) {
                  for (let v = 0; v < m.length; v++) {
                    m[v]._renderStyle = E;
                    const P = m[v].mesh;
                    i.has(P) || (i.add(P), P.prepareRenderState(E));
                  }
                  i.clear();
                }
              }
              _isVisible(m) {
                return this.visible
                  ? this.isVisibleFunc
                    ? this.isVisibleFunc(m)
                    : ((o.center = this.aabb.center),
                      (o.radius = this._aabb.halfExtents.length()),
                      m.frustum.containsSphere(o))
                  : !1;
              }
              updateKey() {
                const m = this.material;
                this._key[d.Uo] = p(
                  this.layer,
                  m.alphaToCoverage || m.alphaTest ? d.lA : m.blendType,
                  !1,
                  m.id
                );
              }
              setInstancing(m) {
                m
                  ? ((this.instancingData = new e(m.numVertices)),
                    (this.instancingData.vertexBuffer = m),
                    (m.format.instancing = !0),
                    (this.cull = !1))
                  : ((this.instancingData = null), (this.cull = !0)),
                  this._updateShaderDefs(
                    m ? this._shaderDefs | d.Is : this._shaderDefs & ~d.Is
                  );
              }
              ensureMaterial(m) {
                this.material || (this.material = (0, f.U)(m));
              }
              clearParameters() {
                this.parameters = {};
              }
              getParameters() {
                return this.parameters;
              }
              getParameter(m) {
                return this.parameters[m];
              }
              setParameter(m, E, v = -262141) {
                if (E === void 0 && typeof m == "object") {
                  const I = m;
                  if (I.length) {
                    for (let A = 0; A < I.length; A++) this.setParameter(I[A]);
                    return;
                  }
                  (m = I.name), (E = I.value);
                }
                const P = this.parameters[m];
                P
                  ? ((P.data = E), (P.passFlags = v))
                  : (this.parameters[m] = {
                      scopeId: null,
                      data: E,
                      passFlags: v,
                    });
              }
              setRealtimeLightmap(m, E) {
                const v = this.getParameter(m);
                v !== E &&
                  (v && s._.decRef(v.data),
                  E
                    ? (s._.incRef(E), this.setParameter(m, E))
                    : this.deleteParameter(m));
              }
              deleteParameter(m) {
                this.parameters[m] && delete this.parameters[m];
              }
              setParameters(m, E) {
                const v = this.parameters;
                for (const P in v) {
                  const I = v[P];
                  I.passFlags & E &&
                    (I.scopeId || (I.scopeId = m.scope.resolve(P)),
                    I.scopeId.setValue(I.data));
                }
              }
              setLightmapped(m) {
                m
                  ? (this.mask = (this.mask | d.gN) & ~(d.BN | d.ew))
                  : (this.setRealtimeLightmap(y.lightmapParamNames[0], null),
                    this.setRealtimeLightmap(y.lightmapParamNames[1], null),
                    (this._shaderDefs &= ~(d.b0 | d.Bp | d.c8)),
                    (this.mask = (this.mask | d.BN) & ~(d.gN | d.ew)));
              }
              setCustomAabb(m) {
                m
                  ? this._customAabb
                    ? this._customAabb.copy(m)
                    : (this._customAabb = m.clone())
                  : ((this._customAabb = null), (this._aabbVer = -1)),
                  this._setupSkinUpdate();
              }
              _setupSkinUpdate() {
                this._skinInstance &&
                  (this._skinInstance._updateBeforeCull = !this._customAabb);
              }
            }
            y.lightmapParamNames = ["texture_lightMap", "texture_dirLightMap"];
            function p(_, m, E, v) {
              return (
                ((_ & 15) << 27) |
                ((m === d.He ? 1 : 0) << 26) |
                ((E ? 1 : 0) << 25) |
                ((v & 33554431) << 0)
              );
            }
          },
          7678: (Se, W, a) => {
            "use strict";
            a.d(W, { K: () => t });
            var x = a(6602),
              T = a(6556),
              g = a(3148),
              c = a(7921),
              d = a(9459),
              h = a(6615),
              f = a(8385),
              s = a(6938),
              l = a(7982),
              n = a(3114);
            let o = 0;
            class i {
              constructor() {
                this.initDefaults();
              }
              initDefaults() {
                (this.recreate = !1),
                  (this.verticesUsage = c.dxy),
                  (this.indicesUsage = c.dxy),
                  (this.maxVertices = 0),
                  (this.maxIndices = 0),
                  (this.vertexCount = 0),
                  (this.indexCount = 0),
                  (this.vertexStreamsUpdated = !1),
                  (this.indexStreamUpdated = !1),
                  (this.vertexStreamDictionary = {}),
                  (this.indices = null);
              }
              _changeVertexCount(u, y) {
                this.vertexCount || (this.vertexCount = u);
              }
            }
            (i.DEFAULT_COMPONENTS_POSITION = 3),
              (i.DEFAULT_COMPONENTS_NORMAL = 3),
              (i.DEFAULT_COMPONENTS_UV = 2),
              (i.DEFAULT_COMPONENTS_COLORS = 4);
            class e {
              constructor(u, y, p, _) {
                (this.data = u),
                  (this.componentCount = y),
                  (this.dataType = p),
                  (this.dataTypeNormalize = _);
              }
            }
            class t extends x.M {
              constructor(u) {
                super(),
                  (this.id = o++),
                  (this.device = u || l.j.get()),
                  (this.vertexBuffer = null),
                  (this.indexBuffer = [null]),
                  (this.primitive = [{ type: 0, base: 0, count: 0 }]),
                  (this.skin = null),
                  (this._morph = null),
                  (this._geometryData = null),
                  (this._aabb = new g.k()),
                  (this.boneAabb = null);
              }
              set morph(u) {
                u !== this._morph &&
                  (this._morph && this._morph.decRefCount(),
                  (this._morph = u),
                  u && u.incRefCount());
              }
              get morph() {
                return this._morph;
              }
              set aabb(u) {
                this._aabb = u;
              }
              get aabb() {
                return this._aabb;
              }
              destroy() {
                const u = this.morph;
                u && ((this.morph = null), u.refCount < 1 && u.destroy()),
                  this.vertexBuffer &&
                    (this.vertexBuffer.destroy(), (this.vertexBuffer = null));
                for (let y = 0; y < this.indexBuffer.length; y++)
                  this._destroyIndexBuffer(y);
                (this.indexBuffer.length = 0), (this._geometryData = null);
              }
              _destroyIndexBuffer(u) {
                this.indexBuffer[u] &&
                  (this.indexBuffer[u].destroy(), (this.indexBuffer[u] = null));
              }
              _initBoneAabbs(u) {
                (this.boneAabb = []), (this.boneUsed = []);
                let y, p, _, m, E;
                const v = [],
                  P = [],
                  I = this.boneUsed,
                  A = this.skin.boneNames.length;
                let B, C, w;
                for (let Y = 0; Y < A; Y++)
                  (v[Y] = new T.A(
                    Number.MAX_VALUE,
                    Number.MAX_VALUE,
                    Number.MAX_VALUE
                  )),
                    (P[Y] = new T.A(
                      -Number.MAX_VALUE,
                      -Number.MAX_VALUE,
                      -Number.MAX_VALUE
                    ));
                const k = new s.O(this.vertexBuffer),
                  K = k.element[c.Q5v],
                  te = k.element[c.d1j],
                  X = k.element[c.MgX],
                  $ = this.vertexBuffer.numVertices;
                for (let Y = 0; Y < $; Y++) {
                  for (let Z = 0; Z < 4; Z++)
                    if (te.array[te.index + Z] > 0) {
                      const pe = X.array[X.index + Z];
                      if (
                        ((I[pe] = !0),
                        (y = K.array[K.index]),
                        (p = K.array[K.index + 1]),
                        (_ = K.array[K.index + 2]),
                        (m = P[pe]),
                        (E = v[pe]),
                        E.x > y && (E.x = y),
                        E.y > p && (E.y = p),
                        E.z > _ && (E.z = _),
                        m.x < y && (m.x = y),
                        m.y < p && (m.y = p),
                        m.z < _ && (m.z = _),
                        u)
                      ) {
                        let O = (B = y),
                          me = (C = p),
                          N = (w = _);
                        for (let V = 0; V < u.length; V++) {
                          const L = u[V],
                            J = L.deltaPositions[Y * 3],
                            ae = L.deltaPositions[Y * 3 + 1],
                            R = L.deltaPositions[Y * 3 + 2];
                          J < 0 ? (O += J) : (B += J),
                            ae < 0 ? (me += ae) : (C += ae),
                            R < 0 ? (N += R) : (w += R);
                        }
                        E.x > O && (E.x = O),
                          E.y > me && (E.y = me),
                          E.z > N && (E.z = N),
                          m.x < B && (m.x = B),
                          m.y < C && (m.y = C),
                          m.z < w && (m.z = w);
                      }
                    }
                  k.next();
                }
                const ne = this.vertexBuffer
                  .getFormat()
                  .elements.find((Y) => Y.name === c.Q5v);
                if (ne && ne.normalize) {
                  const Y = (() => {
                    switch (ne.dataType) {
                      case c.NPC:
                        return (Z) => Math.max(Z / 127, -1);
                      case c.vyI:
                        return (Z) => Z / 255;
                      case c.S81:
                        return (Z) => Math.max(Z / 32767, -1);
                      case c.Spw:
                        return (Z) => Z / 65535;
                      default:
                        return (Z) => Z;
                    }
                  })();
                  for (let Z = 0; Z < A; Z++)
                    if (I[Z]) {
                      const ye = v[Z],
                        pe = P[Z];
                      ye.set(Y(ye.x), Y(ye.y), Y(ye.z)),
                        pe.set(Y(pe.x), Y(pe.y), Y(pe.z));
                    }
                }
                for (let Y = 0; Y < A; Y++) {
                  const Z = new g.k();
                  Z.setMinMax(v[Y], P[Y]), this.boneAabb.push(Z);
                }
              }
              _initGeometryData() {
                this._geometryData ||
                  ((this._geometryData = new i()),
                  this.vertexBuffer &&
                    ((this._geometryData.vertexCount =
                      this.vertexBuffer.numVertices),
                    (this._geometryData.maxVertices =
                      this.vertexBuffer.numVertices)),
                  this.indexBuffer.length > 0 &&
                    this.indexBuffer[0] &&
                    ((this._geometryData.indexCount =
                      this.indexBuffer[0].numIndices),
                    (this._geometryData.maxIndices =
                      this.indexBuffer[0].numIndices)));
              }
              clear(u, y, p = 0, _ = 0) {
                this._initGeometryData(),
                  this._geometryData.initDefaults(),
                  (this._geometryData.recreate = !0),
                  (this._geometryData.maxVertices = p),
                  (this._geometryData.maxIndices = _),
                  (this._geometryData.verticesUsage = u ? c.dxy : c.AHc),
                  (this._geometryData.indicesUsage = y ? c.dxy : c.AHc);
              }
              setVertexStream(u, y, p, _, m = c.r8O, E = !1) {
                this._initGeometryData();
                const v = _ || y.length / p;
                this._geometryData._changeVertexCount(v, u),
                  (this._geometryData.vertexStreamsUpdated = !0),
                  (this._geometryData.vertexStreamDictionary[u] = new e(
                    y,
                    p,
                    m,
                    E
                  ));
              }
              getVertexStream(u, y) {
                let p = 0,
                  _ = !1;
                if (this._geometryData) {
                  const m = this._geometryData.vertexStreamDictionary[u];
                  m &&
                    ((_ = !0),
                    (p = this._geometryData.vertexCount),
                    ArrayBuffer.isView(y)
                      ? y.set(m.data)
                      : ((y.length = 0), y.push(m.data)));
                }
                return (
                  _ ||
                    (this.vertexBuffer &&
                      (p = new s.O(this.vertexBuffer).readData(u, y))),
                  p
                );
              }
              setPositions(u, y = i.DEFAULT_COMPONENTS_POSITION, p) {
                this.setVertexStream(c.Q5v, u, y, p, c.r8O, !1);
              }
              setNormals(u, y = i.DEFAULT_COMPONENTS_NORMAL, p) {
                this.setVertexStream(c.SA$, u, y, p, c.r8O, !1);
              }
              setUvs(u, y, p = i.DEFAULT_COMPONENTS_UV, _) {
                this.setVertexStream(c.Pd9 + u, y, p, _, c.r8O, !1);
              }
              setColors(u, y = i.DEFAULT_COMPONENTS_COLORS, p) {
                this.setVertexStream(c.wD$, u, y, p, c.r8O, !1);
              }
              setColors32(u, y) {
                this.setVertexStream(
                  c.wD$,
                  u,
                  i.DEFAULT_COMPONENTS_COLORS,
                  y,
                  c.vyI,
                  !0
                );
              }
              setIndices(u, y) {
                this._initGeometryData(),
                  (this._geometryData.indexStreamUpdated = !0),
                  (this._geometryData.indices = u),
                  (this._geometryData.indexCount = y || u.length);
              }
              getPositions(u) {
                return this.getVertexStream(c.Q5v, u);
              }
              getNormals(u) {
                return this.getVertexStream(c.SA$, u);
              }
              getUvs(u, y) {
                return this.getVertexStream(c.Pd9 + u, y);
              }
              getColors(u) {
                return this.getVertexStream(c.wD$, u);
              }
              getIndices(u) {
                let y = 0;
                if (this._geometryData && this._geometryData.indices) {
                  const p = this._geometryData.indices;
                  (y = this._geometryData.indexCount),
                    ArrayBuffer.isView(u)
                      ? u.set(p)
                      : ((u.length = 0), u.push(p));
                } else
                  this.indexBuffer.length > 0 &&
                    this.indexBuffer[0] &&
                    (y = this.indexBuffer[0].readData(u));
                return y;
              }
              update(u = c.LAy, y = !0) {
                if (this._geometryData) {
                  if (y) {
                    const m = this._geometryData.vertexStreamDictionary[c.Q5v];
                    m &&
                      m.componentCount === 3 &&
                      this._aabb.compute(
                        m.data,
                        this._geometryData.vertexCount
                      );
                  }
                  let p = this._geometryData.recreate;
                  this._geometryData.vertexCount >
                    this._geometryData.maxVertices &&
                    ((p = !0),
                    (this._geometryData.maxVertices =
                      this._geometryData.vertexCount)),
                    p &&
                      this.vertexBuffer &&
                      (this.vertexBuffer.destroy(), (this.vertexBuffer = null));
                  let _ = this._geometryData.recreate;
                  this._geometryData.indexCount >
                    this._geometryData.maxIndices &&
                    ((_ = !0),
                    (this._geometryData.maxIndices =
                      this._geometryData.indexCount)),
                    _ &&
                      this.indexBuffer.length > 0 &&
                      this.indexBuffer[0] &&
                      (this.indexBuffer[0].destroy(),
                      (this.indexBuffer[0] = null)),
                    this._geometryData.vertexStreamsUpdated &&
                      this._updateVertexBuffer(),
                    this._geometryData.indexStreamUpdated &&
                      this._updateIndexBuffer(),
                    (this.primitive[0].type = u),
                    this.indexBuffer.length > 0 && this.indexBuffer[0]
                      ? this._geometryData.indexStreamUpdated &&
                        ((this.primitive[0].count =
                          this._geometryData.indexCount),
                        (this.primitive[0].indexed = !0))
                      : this._geometryData.vertexStreamsUpdated &&
                        ((this.primitive[0].count =
                          this._geometryData.vertexCount),
                        (this.primitive[0].indexed = !1)),
                    (this._geometryData.vertexCount = 0),
                    (this._geometryData.indexCount = 0),
                    (this._geometryData.vertexStreamsUpdated = !1),
                    (this._geometryData.indexStreamUpdated = !1),
                    (this._geometryData.recreate = !1),
                    this.updateRenderStates();
                }
              }
              _buildVertexFormat(u) {
                const y = [];
                for (const p in this._geometryData.vertexStreamDictionary) {
                  const _ = this._geometryData.vertexStreamDictionary[p];
                  y.push({
                    semantic: p,
                    components: _.componentCount,
                    type: _.dataType,
                    normalize: _.dataTypeNormalize,
                  });
                }
                return new f.g(this.device, y, u);
              }
              _updateVertexBuffer() {
                if (!this.vertexBuffer) {
                  const p = this._geometryData.maxVertices,
                    _ = this._buildVertexFormat(p);
                  this.vertexBuffer = new h.o(
                    this.device,
                    _,
                    p,
                    this._geometryData.verticesUsage
                  );
                }
                const u = new s.O(this.vertexBuffer),
                  y = this._geometryData.vertexCount;
                for (const p in this._geometryData.vertexStreamDictionary) {
                  const _ = this._geometryData.vertexStreamDictionary[p];
                  u.writeData(p, _.data, y),
                    delete this._geometryData.vertexStreamDictionary[p];
                }
                u.end();
              }
              _updateIndexBuffer() {
                if (this.indexBuffer.length <= 0 || !this.indexBuffer[0]) {
                  const y =
                    this._geometryData.maxVertices > 65535 ? c.qCh : c.q0F;
                  this.indexBuffer[0] = new d.G(
                    this.device,
                    y,
                    this._geometryData.maxIndices,
                    this._geometryData.indicesUsage
                  );
                }
                const u = this._geometryData.indices;
                u &&
                  (this.indexBuffer[0].writeData(
                    u,
                    this._geometryData.indexCount
                  ),
                  (this._geometryData.indices = null));
              }
              prepareRenderState(u) {
                u === n.b5
                  ? this.generateWireframe()
                  : u === n.mZ &&
                    (this.primitive[n.mZ] = {
                      type: c.KtK,
                      base: 0,
                      count: this.vertexBuffer
                        ? this.vertexBuffer.numVertices
                        : 0,
                      indexed: !1,
                    });
              }
              updateRenderStates() {
                this.primitive[n.mZ] && this.prepareRenderState(n.mZ),
                  this.primitive[n.b5] && this.prepareRenderState(n.b5);
              }
              generateWireframe() {
                this._destroyIndexBuffer(n.b5);
                const u = this.vertexBuffer.numVertices,
                  y = [];
                let p;
                if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
                  const E = [
                      [0, 1],
                      [1, 2],
                      [2, 0],
                    ],
                    v = this.primitive[n.pr].base,
                    P = this.primitive[n.pr].count,
                    I = this.indexBuffer[n.pr],
                    A = new c.kRF[I.format](I.storage),
                    B = new Set();
                  for (let C = v; C < v + P; C += 3)
                    for (let w = 0; w < 3; w++) {
                      const k = A[C + E[w][0]],
                        K = A[C + E[w][1]],
                        te = k > K ? K * u + k : k * u + K;
                      B.has(te) || (B.add(te), y.push(k, K));
                    }
                  p = I.format;
                } else {
                  for (let E = 0; E < u; E += 3)
                    y.push(E, E + 1, E + 1, E + 2, E + 2, E);
                  p = y.length > 65535 ? c.qCh : c.q0F;
                }
                const _ = new d.G(this.vertexBuffer.device, p, y.length);
                new c.kRF[_.format](_.storage).set(y),
                  _.unlock(),
                  (this.primitive[n.b5] = {
                    type: c.Y7R,
                    base: 0,
                    count: y.length,
                    indexed: !0,
                  }),
                  (this.indexBuffer[n.b5] = _);
              }
            }
          },
          9915: (Se, W, a) => {
            "use strict";
            a.d(W, { H: () => d });
            var x = a(3114),
              T = a(8792),
              g = a(1259),
              c = a(8691);
            class d {
              constructor() {
                (this.graph = null),
                  (this.meshInstances = []),
                  (this.skinInstances = []),
                  (this.morphInstances = []),
                  (this.cameras = []),
                  (this.lights = []),
                  (this._shadersVersion = 0),
                  (this._immutable = !1);
              }
              getGraph() {
                return this.graph;
              }
              setGraph(f) {
                this.graph = f;
              }
              getCameras() {
                return this.cameras;
              }
              setCameras(f) {
                this.cameras = f;
              }
              getLights() {
                return this.lights;
              }
              setLights(f) {
                this.lights = f;
              }
              getMaterials() {
                const f = [];
                for (let s = 0; s < this.meshInstances.length; s++) {
                  const l = this.meshInstances[s];
                  f.indexOf(l.material) === -1 && f.push(l.material);
                }
                return f;
              }
              clone() {
                const f = [],
                  s = [],
                  n = (function r(u) {
                    const y = u.clone();
                    f.push(u), s.push(y);
                    for (let p = 0; p < u._children.length; p++)
                      y.addChild(r(u._children[p]));
                    return y;
                  })(this.graph),
                  o = [],
                  i = [],
                  e = [];
                for (let r = 0; r < this.skinInstances.length; r++) {
                  const u = this.skinInstances[r].skin,
                    y = new c.u(u),
                    p = [];
                  for (let _ = 0; _ < u.boneNames.length; _++) {
                    const m = u.boneNames[_],
                      E = n.findByName(m);
                    p.push(E);
                  }
                  (y.bones = p), i.push(y);
                }
                for (let r = 0; r < this.morphInstances.length; r++) {
                  const u = this.morphInstances[r].morph,
                    y = new g.w(u);
                  e.push(y);
                }
                for (let r = 0; r < this.meshInstances.length; r++) {
                  const u = this.meshInstances[r],
                    y = f.indexOf(u.node),
                    p = new T.l(u.mesh, u.material, s[y]);
                  if (u.skinInstance) {
                    const _ = this.skinInstances.indexOf(u.skinInstance);
                    p.skinInstance = i[_];
                  }
                  if (u.morphInstance) {
                    const _ = this.morphInstances.indexOf(u.morphInstance);
                    p.morphInstance = e[_];
                  }
                  o.push(p);
                }
                const t = new d();
                return (
                  (t.graph = n),
                  (t.meshInstances = o),
                  (t.skinInstances = i),
                  (t.morphInstances = e),
                  t.getGraph().syncHierarchy(),
                  t
                );
              }
              destroy() {
                const f = this.meshInstances;
                for (let s = 0; s < f.length; s++) f[s].destroy();
                this.meshInstances.length = 0;
              }
              generateWireframe() {
                T.l._prepareRenderStyleForArray(this.meshInstances, x.b5);
              }
            }
          },
          1259: (Se, W, a) => {
            "use strict";
            a.d(W, { w: () => s });
            var x = a(7921),
              T = a(464),
              g = a(3412),
              c = a(9375),
              d = a(8277);
            const h = `
		attribute vec2 vertex_position;
		varying vec2 uv0;
		void main(void) {
				gl_Position = vec4(vertex_position, 0.5, 1.0);
				uv0 = vertex_position.xy * 0.5 + 0.5;
		}
		`,
              f = new d.a(!0, x.cn$, x.NdT, x.NdT);
            class s {
              constructor(n) {
                (this.morph = n),
                  n.incRefCount(),
                  (this.device = n.device),
                  (this._weights = []),
                  (this._weightMap = new Map());
                for (let o = 0; o < n._targets.length; o++) {
                  const i = n._targets[o];
                  i.name && this._weightMap.set(i.name, o),
                    this.setWeight(o, i.defaultWeight);
                }
                if (((this._activeTargets = []), n.useTextureMorph)) {
                  (this.shaderCache = {}),
                    (this.maxSubmitCount = this.device.maxTextures),
                    (this._shaderMorphWeights = new Float32Array(
                      this.maxSubmitCount
                    ));
                  const o = (i, e) => (
                    (this[e] = n._createTexture(i, n._renderTextureFormat)),
                    new g.A({ colorBuffer: this[e], depth: !1 })
                  );
                  n.morphPositions &&
                    (this.rtPositions = o("MorphRTPos", "texturePositions")),
                    n.morphNormals &&
                      (this.rtNormals = o("MorphRTNrm", "textureNormals")),
                    (this._textureParams = new Float32Array([
                      n.morphTextureWidth,
                      n.morphTextureHeight,
                      1 / n.morphTextureWidth,
                      1 / n.morphTextureHeight,
                    ]));
                  for (let i = 0; i < this.maxSubmitCount; i++)
                    this["morphBlendTex" + i] = this.device.scope.resolve(
                      "morphBlendTex" + i
                    );
                  (this.morphFactor =
                    this.device.scope.resolve("morphFactor[0]")),
                    (this.zeroTextures = !1);
                } else
                  (this.maxSubmitCount = 8),
                    (this._shaderMorphWeights = new Float32Array(
                      this.maxSubmitCount
                    )),
                    (this._shaderMorphWeightsA = new Float32Array(
                      this._shaderMorphWeights.buffer,
                      0,
                      4
                    )),
                    (this._shaderMorphWeightsB = new Float32Array(
                      this._shaderMorphWeights.buffer,
                      16,
                      4
                    )),
                    (this._activeVertexBuffers = new Array(
                      this.maxSubmitCount
                    ));
              }
              destroy() {
                this.shader = null;
                const n = this.morph;
                n &&
                  ((this.morph = null),
                  n.decRefCount(),
                  n.refCount < 1 && n.destroy()),
                  this.rtPositions &&
                    (this.rtPositions.destroy(), (this.rtPositions = null)),
                  this.texturePositions &&
                    (this.texturePositions.destroy(),
                    (this.texturePositions = null)),
                  this.rtNormals &&
                    (this.rtNormals.destroy(), (this.rtNormals = null)),
                  this.textureNormals &&
                    (this.textureNormals.destroy(),
                    (this.textureNormals = null));
              }
              clone() {
                return new s(this.morph);
              }
              _getWeightIndex(n) {
                return typeof n == "string" ? this._weightMap.get(n) : n;
              }
              getWeight(n) {
                const o = this._getWeightIndex(n);
                return this._weights[o];
              }
              setWeight(n, o) {
                const i = this._getWeightIndex(n);
                (this._weights[i] = o), (this._dirty = !0);
              }
              _getFragmentShader(n) {
                let o = "";
                n > 0 &&
                  (o +=
                    `varying vec2 uv0;
uniform highp float morphFactor[` +
                    n +
                    `];
`);
                for (let i = 0; i < n; i++)
                  o +=
                    "uniform highp sampler2D morphBlendTex" +
                    i +
                    `;
`;
                o += `void main (void) {
    highp vec4 color = vec4(0, 0, 0, 1);
`;
                for (let i = 0; i < n; i++)
                  o +=
                    "    color.xyz += morphFactor[" +
                    i +
                    "] * texture2D(morphBlendTex" +
                    i +
                    `, uv0).xyz;
`;
                return (
                  (o += `    gl_FragColor = color;
}
`),
                  o
                );
              }
              _getShader(n) {
                let o = this.shaderCache[n];
                if (!o) {
                  const i = this._getFragmentShader(n);
                  (o = (0, c.JM)(this.device, h, i, "textureMorph" + n)),
                    (this.shaderCache[n] = o);
                }
                return o;
              }
              _updateTextureRenderTarget(n, o) {
                const i = this.device,
                  e = (y, p) => {
                    this.morphFactor.setValue(this._shaderMorphWeights),
                      i.setBlendState(p ? f : d.a.NOBLEND);
                    const _ = this._getShader(y);
                    (0, T.H)(i, n, _);
                  };
                let t = 0,
                  r = !1;
                const u = this._activeTargets.length;
                for (let y = 0; y < u; y++) {
                  const p = this._activeTargets[y],
                    _ = p.target[o];
                  _ &&
                    (this["morphBlendTex" + t].setValue(_),
                    (this._shaderMorphWeights[t] = p.weight),
                    t++,
                    t >= this.maxSubmitCount && (e(t, r), (t = 0), (r = !0)));
                }
                (t > 0 || (u === 0 && !this.zeroTextures)) && e(t, r);
              }
              _updateTextureMorph() {
                this.device,
                  (this._activeTargets.length > 0 || !this.zeroTextures) &&
                    (this.rtPositions &&
                      this._updateTextureRenderTarget(
                        this.rtPositions,
                        "texturePositions"
                      ),
                    this.rtNormals &&
                      this._updateTextureRenderTarget(
                        this.rtNormals,
                        "textureNormals"
                      ),
                    (this.zeroTextures = this._activeTargets.length === 0));
              }
              _updateVertexMorph() {
                const n = this.maxSubmitCount;
                for (let e = 0; e < n; e++)
                  (this._shaderMorphWeights[e] = 0),
                    (this._activeVertexBuffers[e] = null);
                let o = 0,
                  i = this.morph.morphPositions ? 4 : 0;
                for (let e = 0; e < this._activeTargets.length; e++) {
                  const t = this._activeTargets[e].target;
                  t._vertexBufferPositions &&
                    ((this._activeVertexBuffers[o] = t._vertexBufferPositions),
                    (this._shaderMorphWeights[o] =
                      this._activeTargets[e].weight),
                    o++),
                    t._vertexBufferNormals &&
                      ((this._activeVertexBuffers[i] = t._vertexBufferNormals),
                      (this._shaderMorphWeights[i] =
                        this._activeTargets[e].weight),
                      i++);
                }
              }
              update() {
                this._dirty = !1;
                const n = this.morph._targets;
                let o = 0;
                const i = 1e-5;
                for (let t = 0; t < n.length; t++) {
                  const r = Math.abs(this.getWeight(t));
                  if (r > i) {
                    this._activeTargets.length <= o &&
                      (this._activeTargets[o] = {});
                    const u = this._activeTargets[o++];
                    (u.absWeight = r),
                      (u.weight = this.getWeight(t)),
                      (u.target = n[t]);
                  }
                }
                this._activeTargets.length = o;
                const e = this.morph.maxActiveTargets;
                this._activeTargets.length > e &&
                  (this._activeTargets.sort(function (t, r) {
                    return t.absWeight < r.absWeight
                      ? 1
                      : r.absWeight < t.absWeight
                      ? -1
                      : 0;
                  }),
                  (this._activeTargets.length = e)),
                  this.morph.useTextureMorph
                    ? this._updateTextureMorph()
                    : this._updateVertexMorph();
              }
            }
          },
          7551: (Se, W, a) => {
            "use strict";
            a.d(W, { Y: () => d });
            var x = a(3148),
              T = a(7921),
              g = a(6615),
              c = a(8385);
            class d {
              constructor(f) {
                (this.used = !1),
                  arguments.length === 2 && (f = arguments[1]),
                  (this.options = f),
                  (this._name = f.name),
                  (this._defaultWeight = f.defaultWeight || 0),
                  (this._aabb = f.aabb),
                  (this.deltaPositions = f.deltaPositions);
              }
              destroy() {
                var f, s, l, n;
                (f = this._vertexBufferPositions) == null || f.destroy(),
                  (this._vertexBufferPositions = null),
                  (s = this._vertexBufferNormals) == null || s.destroy(),
                  (this._vertexBufferNormals = null),
                  (l = this.texturePositions) == null || l.destroy(),
                  (this.texturePositions = null),
                  (n = this.textureNormals) == null || n.destroy(),
                  (this.textureNormals = null);
              }
              get name() {
                return this._name;
              }
              get defaultWeight() {
                return this._defaultWeight;
              }
              get aabb() {
                return (
                  this._aabb ||
                    ((this._aabb = new x.k()),
                    this.deltaPositions &&
                      this._aabb.compute(this.deltaPositions)),
                  this._aabb
                );
              }
              get morphPositions() {
                return !!this._vertexBufferPositions || !!this.texturePositions;
              }
              get morphNormals() {
                return !!this._vertexBufferNormals || !!this.textureNormals;
              }
              clone() {
                return new d(this.options);
              }
              _postInit() {
                this.options.preserveData || (this.options = null),
                  (this.used = !0);
              }
              _initVertexBuffers(f) {
                const s = this.options;
                (this._vertexBufferPositions = this._createVertexBuffer(
                  f,
                  s.deltaPositions,
                  s.deltaPositionsType
                )),
                  (this._vertexBufferNormals = this._createVertexBuffer(
                    f,
                    s.deltaNormals,
                    s.deltaNormalsType
                  )),
                  this._vertexBufferPositions &&
                    (this.deltaPositions = this._vertexBufferPositions.lock());
              }
              _createVertexBuffer(f, s, l = T.r8O) {
                if (s) {
                  const n = [{ semantic: T.CNh, components: 3, type: l }];
                  return new g.o(f, new c.g(f, n), s.length / 3, T.dxy, s);
                }
                return null;
              }
              _setTexture(f, s) {
                this[f] = s;
              }
            }
          },
          3823: (Se, W, a) => {
            "use strict";
            a.d(W, { _: () => n });
            var x = a(6602),
              T = a(6556),
              g = a(1110),
              c = a(3148),
              d = a(8869),
              h = a(6615),
              f = a(8385),
              s = a(7921),
              l = a(7982);
            class n extends x.M {
              constructor(i, e, { preferHighPrecision: t = !1 } = {}) {
                super(),
                  (this._aabb = void 0),
                  (this.preferHighPrecision = void 0),
                  (this.device = e || l.j.get()),
                  (this.preferHighPrecision = t),
                  (this._targets = i.slice());
                const r = this.device;
                if (r.supportsMorphTargetTexturesCore) {
                  const u =
                      r.extTextureHalfFloat && r.textureHalfFloatRenderable
                        ? s.a7f
                        : void 0,
                    y =
                      r.extTextureFloat && r.textureFloatRenderable
                        ? s.uC3
                        : void 0;
                  this._renderTextureFormat = this.preferHighPrecision
                    ? y != null
                      ? y
                      : u
                    : u != null
                    ? u
                    : y;
                  const p =
                      r.extTextureHalfFloat && r.textureHalfFloatUpdatable
                        ? s.a7f
                        : void 0,
                    _ = r.extTextureFloat ? s.lN5 : void 0;
                  (this._textureFormat = this.preferHighPrecision
                    ? _ != null
                      ? _
                      : p
                    : p != null
                    ? p
                    : _),
                    this._renderTextureFormat !== void 0 &&
                      this._textureFormat !== void 0 &&
                      (this._useTextureMorph = !0);
                }
                this._init(), this._updateMorphFlags();
              }
              get aabb() {
                if (!this._aabb) {
                  const i = new T.A(),
                    e = new T.A();
                  for (let t = 0; t < this._targets.length; t++) {
                    const r = this._targets[t].aabb;
                    i.min(r.getMin()), e.max(r.getMax());
                  }
                  (this._aabb = new c.k()), this._aabb.setMinMax(i, e);
                }
                return this._aabb;
              }
              get morphPositions() {
                return this._morphPositions;
              }
              get morphNormals() {
                return this._morphNormals;
              }
              get maxActiveTargets() {
                return this._useTextureMorph
                  ? this._targets.length
                  : this._morphPositions && this._morphNormals
                  ? 4
                  : 8;
              }
              get useTextureMorph() {
                return this._useTextureMorph;
              }
              _init() {
                if (
                  (this._useTextureMorph &&
                    (this._useTextureMorph = this._initTextureBased()),
                  !this._useTextureMorph)
                )
                  for (let i = 0; i < this._targets.length; i++)
                    this._targets[i]._initVertexBuffers(this.device);
                for (let i = 0; i < this._targets.length; i++)
                  this._targets[i]._postInit();
              }
              _findSparseSet(i, e, t, r) {
                let u = 1;
                const y = i[0].length;
                for (let p = 0; p < y; p += 3) {
                  let _ = !1;
                  for (let m = 0; m < i.length; m++) {
                    const E = i[m];
                    if (E[p] !== 0 || E[p + 1] !== 0 || E[p + 2] !== 0) {
                      _ = !0;
                      break;
                    }
                  }
                  _ ? (e.push(u + r), t.push(p / 3), u++) : e.push(0 + r);
                }
                return u;
              }
              _initTextureBased() {
                const i = this.device.isWebGPU,
                  e = i ? 0 : 0.2,
                  t = [],
                  r = [];
                for (let C = 0; C < this._targets.length; C++) {
                  const w = this._targets[C];
                  w.options.deltaPositions &&
                    (t.push(w.options.deltaPositions),
                    r.push({ target: w, name: "texturePositions" })),
                    w.options.deltaNormals &&
                      (t.push(w.options.deltaNormals),
                      r.push({ target: w, name: "textureNormals" }));
                }
                const u = [],
                  y = [],
                  p = this._findSparseSet(t, u, y, e),
                  _ = Math.min(this.device.maxTextureSize, 4096);
                let m = Math.ceil(Math.sqrt(p));
                m = Math.min(m, _);
                const E = Math.ceil(p / m);
                if (E > _) return !1;
                (this.morphTextureWidth = m), (this.morphTextureHeight = E);
                let v = !1,
                  P = 3;
                const I = g.b.float2Half;
                this._textureFormat === s.a7f && ((v = !0), (P = 4));
                const A = [];
                for (let C = 0; C < t.length; C++)
                  A.push(
                    this._createTexture("MorphTarget", this._textureFormat)
                  );
                for (let C = 0; C < t.length; C++) {
                  const w = t[C],
                    k = A[C],
                    K = k.lock();
                  if (v)
                    for (let X = 0; X < y.length; X++) {
                      const $ = y[X] * 3,
                        ne = X * P + P;
                      (K[ne] = I(w[$])),
                        (K[ne + 1] = I(w[$ + 1])),
                        (K[ne + 2] = I(w[$ + 2]));
                    }
                  else
                    for (let X = 0; X < y.length; X++) {
                      const $ = y[X] * 3,
                        ne = X * P + P;
                      (K[ne] = w[$]),
                        (K[ne + 1] = w[$ + 1]),
                        (K[ne + 2] = w[$ + 2]);
                    }
                  k.unlock(), r[C].target._setTexture(r[C].name, k);
                }
                const B = [
                  { semantic: s.s36, components: 1, type: i ? s.$GK : s.r8O },
                ];
                return (
                  (this.vertexBufferIds = new h.o(
                    this.device,
                    new f.g(this.device, B, u.length),
                    u.length,
                    s.dxy,
                    i ? new Uint32Array(u) : new Float32Array(u)
                  )),
                  !0
                );
              }
              destroy() {
                var i;
                (i = this.vertexBufferIds) == null || i.destroy(),
                  (this.vertexBufferIds = null);
                for (let e = 0; e < this._targets.length; e++)
                  this._targets[e].destroy();
                this._targets.length = 0;
              }
              get targets() {
                return this._targets;
              }
              _updateMorphFlags() {
                (this._morphPositions = !1), (this._morphNormals = !1);
                for (let i = 0; i < this._targets.length; i++) {
                  const e = this._targets[i];
                  e.morphPositions && (this._morphPositions = !0),
                    e.morphNormals && (this._morphNormals = !0);
                }
              }
              _createTexture(i, e) {
                return new d.x(this.device, {
                  width: this.morphTextureWidth,
                  height: this.morphTextureHeight,
                  format: e,
                  cubemap: !1,
                  mipmaps: !1,
                  minFilter: s.yib,
                  magFilter: s.yib,
                  addressU: s.uFb,
                  addressV: s.uFb,
                  name: i,
                });
              }
            }
          },
          3241: (Se, W, a) => {
            "use strict";
            a.d(W, { V: () => Gt });
            var x = a(429),
              T = a(1239),
              g = a(9758),
              c = a(4585),
              d = a(6847),
              h = a(6556),
              f = a(3148),
              s = a(7921),
              l = a(7338),
              n = a(9459),
              o = a(3412),
              i = a(8869),
              e = a(6615),
              t = a(8385),
              r = a(1071),
              u = a(3114),
              y = a(7678),
              p = a(8792),
              _ = a(2737),
              m = a(192),
              E = a(9375),
              v = a(3200),
              P = a(3862),
              I = a(2172);
            const A = {
              generateKey: function (yt) {
                let Ae = "particle";
                for (const Xe in yt) yt.hasOwnProperty(Xe) && (Ae += yt[Xe]);
                return Ae;
              },
              _animTex: function (yt) {
                let Ae = "";
                return (
                  (Ae += yt.animTexLoop
                    ? v.n.particleAnimFrameLoopVS
                    : v.n.particleAnimFrameClampVS),
                  (Ae += v.n.particleAnimTexVS),
                  Ae
                );
              },
              createShaderDefinition: function (yt, Ae) {
                const Xe = `#define PARTICLE_${Ae.useCpu ? "CPU" : "GPU"}
`;
                let Ye =
                    `#define PARTICLE
` + Xe,
                  it =
                    `#define VERTEXSHADER
` + Xe;
                Ae.mesh &&
                  (it += `#define USE_MESH
`),
                  Ae.localSpace &&
                    (it += `#define LOCAL_SPACE
`),
                  Ae.screenSpace &&
                    (it += `#define SCREEN_SPACE
`),
                  Ae.animTex &&
                    (it += `
uniform vec2 animTexTilesParams;
`),
                  Ae.animTex &&
                    (it += `
uniform vec4 animTexParams;
`),
                  Ae.animTex &&
                    (it += `
uniform vec2 animTexIndexParams;
`),
                  Ae.normal === 2 &&
                    (it += `
varying mat3 ParticleMat;
`),
                  Ae.normal === 1 &&
                    (it += `
varying vec3 Normal;
`),
                  Ae.soft &&
                    (it += `
varying float vDepth;
`);
                const st = Ae.customFace
                  ? v.n.particle_customFaceVS
                  : v.n.particle_billboardVS;
                return (
                  Ae.useCpu
                    ? (Ae.soft > 0 && (it += v.n.screenDepthPS),
                      (it += v.n.particle_cpuVS),
                      Ae.localSpace && (it += v.n.particle_localShiftVS),
                      Ae.animTex && (it += this._animTex(Ae)),
                      Ae.alignToMotion && (it += v.n.particle_pointAlongVS),
                      (it += Ae.mesh ? v.n.particle_meshVS : st),
                      Ae.normal === 1 && (it += v.n.particle_normalVS),
                      Ae.normal === 2 && (it += v.n.particle_TBNVS),
                      Ae.stretch > 0 && (it += v.n.particle_stretchVS),
                      (it += v.n.particle_cpu_endVS),
                      Ae.soft > 0 && (it += v.n.particle_softVS))
                    : ((it += v.n.particle_initVS),
                      (it += Ae.pack8
                        ? v.n.particleInputRgba8PS
                        : v.n.particleInputFloatPS),
                      Ae.soft > 0 && (it += v.n.screenDepthPS),
                      (it += v.n.particleVS),
                      Ae.localSpace && (it += v.n.particle_localShiftVS),
                      Ae.animTex && (it += this._animTex(Ae)),
                      Ae.wrap && (it += v.n.particle_wrapVS),
                      Ae.alignToMotion && (it += v.n.particle_pointAlongVS),
                      (it += Ae.mesh ? v.n.particle_meshVS : st),
                      Ae.normal === 1 && (it += v.n.particle_normalVS),
                      Ae.normal === 2 && (it += v.n.particle_TBNVS),
                      Ae.stretch > 0 && (it += v.n.particle_stretchVS),
                      (it += v.n.particle_endVS),
                      Ae.soft > 0 && (it += v.n.particle_softVS)),
                  (it += `}
`),
                  Ae.normal > 0 &&
                    (Ae.normal === 1
                      ? (Ye += `
varying vec3 Normal;
`)
                      : Ae.normal === 2 &&
                        (Ye += `
varying mat3 ParticleMat;
`),
                    (Ye += `
uniform vec3 lightCube[6];
`)),
                  Ae.soft &&
                    (Ye += `
varying float vDepth;
`),
                  Ae.normal === 0 && Ae.fog === "none" && (Ae.srgb = !1),
                  (Ye += v.n.decodePS),
                  (Ye += (0, I.li)(Ae.gamma)),
                  (Ye += (0, I.ph)(Ae.toneMap)),
                  Ae.fog === "linear"
                    ? (Ye += v.n.fogLinearPS)
                    : Ae.fog === "exp"
                    ? (Ye += v.n.fogExpPS)
                    : Ae.fog === "exp2"
                    ? (Ye += v.n.fogExp2PS)
                    : (Ye += v.n.fogNonePS),
                  Ae.normal === 2 &&
                    (Ye += `
uniform sampler2D normalMap;
`),
                  Ae.soft > 0 && (Ye += v.n.screenDepthPS),
                  (Ye += v.n.particlePS),
                  Ae.soft > 0 && (Ye += v.n.particle_softPS),
                  Ae.normal === 1 &&
                    (Ye += `
vec3 normal = Normal;
`),
                  Ae.normal === 2 && (Ye += v.n.particle_normalMapPS),
                  Ae.normal > 0 &&
                    (Ye += Ae.halflambert
                      ? v.n.particle_halflambertPS
                      : v.n.particle_lambertPS),
                  Ae.normal > 0 && (Ye += v.n.particle_lightingPS),
                  Ae.blend === u.lA
                    ? (Ye += v.n.particle_blendNormalPS)
                    : Ae.blend === u.$U
                    ? (Ye += v.n.particle_blendAddPS)
                    : Ae.blend === u.ch && (Ye += v.n.particle_blendMultiplyPS),
                  (Ye += v.n.particle_endPS),
                  P.x.createDefinition(yt, {
                    name: "ParticleShader",
                    vertexCode: it,
                    fragmentCode: Ye,
                  })
                );
              },
            };
            let B,
              C = 1;
            const w = 4,
              k = new g.y(),
              K = new g.y(),
              te = new h.A(),
              X = new h.A(),
              $ = new h.A(),
              ne = new h.A(),
              Y = new h.A(),
              Z = new h.A(),
              ye = new h.A(),
              pe = new h.A(),
              O = new h.A(),
              me = new h.A(),
              N = new h.A(),
              V = new h.A(),
              L = new h.A();
            function J(yt) {
              return yt - Math.floor(yt);
            }
            function ae(yt) {
              return Math.max(Math.min(yt, 1), 0);
            }
            function R(yt, Ae) {
              return yt - Ae * Math.floor(yt / Ae);
            }
            function j(yt) {
              let Ae = J(yt),
                Xe = J(255 * yt),
                Ye = J(65025 * yt),
                it = J(160581375 * yt);
              return (
                (Ae -= Xe / 255),
                (Xe -= Ye / 255),
                (Ye -= it / 255),
                (it -= it / 255),
                [Ae, Xe, Ye, it]
              );
            }
            function se(yt) {
              let Ae = J(yt),
                Xe = J(255 * yt);
              return (Ae -= Xe / 255), (Xe -= Xe / 255), [Ae, Xe];
            }
            class ce {
              constructor(Ae) {
                this._emitter = Ae;
              }
              calcSpawnPosition(Ae, Xe, Ye, it, st) {
                const He = this._emitter,
                  at = Math.random(),
                  Pt = Math.random(),
                  he = Math.random(),
                  fe = Math.random();
                if (
                  (He.useCpu &&
                    ((Ae[st * w + 0 + He.numParticlesPot * 2 * w] = at),
                    (Ae[st * w + 1 + He.numParticlesPot * 2 * w] = Pt),
                    (Ae[st * w + 2 + He.numParticlesPot * 2 * w] = he)),
                  (X.x = at - 0.5),
                  (X.y = Pt - 0.5),
                  (X.z = he - 0.5),
                  He.emitterShape === u.EB)
                ) {
                  const De = Math.max(
                      Math.abs(X.x),
                      Math.max(Math.abs(X.y), Math.abs(X.z))
                    ),
                    et = De + (0.5 - De) * Ye[0],
                    Ze = De + (0.5 - De) * Ye[1],
                    Ve = De + (0.5 - De) * Ye[2];
                  (X.x =
                    et * (De === Math.abs(X.x) ? Math.sign(X.x) : 2 * X.x)),
                    (X.y =
                      Ze * (De === Math.abs(X.y) ? Math.sign(X.y) : 2 * X.y)),
                    (X.z =
                      Ve * (De === Math.abs(X.z) ? Math.sign(X.z) : 2 * X.z)),
                    He.localSpace
                      ? te.copy(Xe.transformPoint(X))
                      : te.copy(it).add(Xe.transformPoint(X));
                } else {
                  X.normalize();
                  const De =
                      He.emitterRadius === 0
                        ? 0
                        : He.emitterRadiusInner / He.emitterRadius,
                    et = fe * (1 - De) + De;
                  He.localSpace
                    ? te.copy(X.mulScalar(et * He.emitterRadius))
                    : te.copy(it).add(X.mulScalar(et * He.emitterRadius));
                }
                let ue = -c.m.lerp(He.rate, He.rate2, at) * st;
                if (He.pack8) {
                  const De =
                      (te.x - He.worldBounds.center.x) / He.worldBoundsSize.x +
                      0.5,
                    et =
                      (te.y - He.worldBounds.center.y) / He.worldBoundsSize.y +
                      0.5,
                    Ze =
                      (te.z - He.worldBounds.center.z) / He.worldBoundsSize.z +
                      0.5;
                  let Ve = c.m.lerp(
                    He.startAngle * c.m.DEG_TO_RAD,
                    He.startAngle2 * c.m.DEG_TO_RAD,
                    at
                  );
                  Ve = (Ve % (Math.PI * 2)) / (Math.PI * 2);
                  const tt = se(De);
                  (Ae[st * w] = tt[0]), (Ae[st * w + 1] = tt[1]);
                  const Be = se(et);
                  (Ae[st * w + 2] = Be[0]), (Ae[st * w + 3] = Be[1]);
                  const ot = se(Ze);
                  (Ae[st * w + 0 + He.numParticlesPot * w] = ot[0]),
                    (Ae[st * w + 1 + He.numParticlesPot * w] = ot[1]);
                  const Qe = se(Ve);
                  (Ae[st * w + 2 + He.numParticlesPot * w] = Qe[0]),
                    (Ae[st * w + 3 + He.numParticlesPot * w] = Qe[1]);
                  const mt = 1;
                  Ae[st * w + 3 + He.numParticlesPot * w * 2] = mt;
                  const je = Math.max(
                      He.lifetime,
                      (He.numParticles - 1) * Math.max(He.rate, He.rate2)
                    ),
                    lt = He.lifetime + 1;
                  ue = (ue + je) / (je + lt);
                  const Et = j(ue);
                  (Ae[st * w + 0 + He.numParticlesPot * w * 3] = Et[0]),
                    (Ae[st * w + 1 + He.numParticlesPot * w * 3] = Et[1]),
                    (Ae[st * w + 2 + He.numParticlesPot * w * 3] = Et[2]),
                    (Ae[st * w + 3 + He.numParticlesPot * w * 3] = Et[3]);
                } else
                  (Ae[st * w] = te.x),
                    (Ae[st * w + 1] = te.y),
                    (Ae[st * w + 2] = te.z),
                    (Ae[st * w + 3] = c.m.lerp(
                      He.startAngle * c.m.DEG_TO_RAD,
                      He.startAngle2 * c.m.DEG_TO_RAD,
                      at
                    )),
                    (Ae[st * w + 3 + He.numParticlesPot * w] = ue);
              }
              update(Ae, Xe, Ye, it, st, He, at, Pt) {
                let he, fe, Ie;
                const ue = this._emitter;
                if (ue.meshInstance.node) {
                  const ct = ue.meshInstance.node.worldTransform;
                  for (let pt = 0; pt < 12; pt++) k.data[pt] = ct.data[pt];
                  K.copy(k),
                    K.invert(),
                    (B = ue.meshInstance.node.localScale),
                    (C = Math.max(Math.max(B.x, B.y), B.z));
                }
                He =
                  ue.meshInstance.node === null || ue.localSpace
                    ? h.A.ZERO
                    : ue.meshInstance.node.getPosition();
                const De = ue.camera ? ue.camera._node.getPosition() : h.A.ZERO,
                  et = ue.useMesh ? 17 : 15;
                let Ze, Ve, tt, Be, ot, Qe, mt, je, lt;
                const Et = ue.precision - 1;
                for (let ct = 0; ct < ue.numParticles; ct++) {
                  const pt = Math.floor(
                      ue.vbCPU[
                        ct * ue.numParticleVerts * (ue.useMesh ? 6 : 4) + 3
                      ]
                    ),
                    vt = Ye[pt * w + 0 + ue.numParticlesPot * 2 * w];
                  ($.x = vt),
                    ($.y = Ye[pt * w + 1 + ue.numParticlesPot * 2 * w]),
                    ($.z = Ye[pt * w + 2 + ue.numParticlesPot * 2 * w]);
                  const Fe = ue.rate + (ue.rate2 - ue.rate) * vt,
                    Yt = ue.lifetime;
                  let Ot = Ye[pt * w + 3 + ue.numParticlesPot * w] + at;
                  const Rt = ae(Ot / Yt);
                  let Kt = 0,
                    Lt = 0;
                  const Ft = 0;
                  (Ot - at <= 0 || Ot >= Yt) &&
                    this.calcSpawnPosition(Ye, it, st, He, pt);
                  let zt = Ot > 0 && Ot < Yt;
                  zt &&
                    ((Ie = Rt * Et),
                    (Ze = Math.floor(Ie)),
                    (Ve = Math.ceil(Ie)),
                    (Ie %= 1),
                    (he = ue.qRotSpeed[Ze]),
                    (fe = ue.qRotSpeed[Ve]),
                    (tt = he + (fe - he) * Ie),
                    (he = ue.qRotSpeed2[Ze]),
                    (fe = ue.qRotSpeed2[Ve]),
                    (Be = he + (fe - he) * Ie),
                    (he = ue.qScale[Ze]),
                    (fe = ue.qScale[Ve]),
                    (Kt = he + (fe - he) * Ie),
                    (he = ue.qScale2[Ze]),
                    (fe = ue.qScale2[Ve]),
                    (ot = he + (fe - he) * Ie),
                    (he = ue.qAlpha[Ze]),
                    (fe = ue.qAlpha[Ve]),
                    (Qe = he + (fe - he) * Ie),
                    (he = ue.qAlpha2[Ze]),
                    (fe = ue.qAlpha2[Ve]),
                    (mt = he + (fe - he) * Ie),
                    (he = ue.qRadialSpeed[Ze]),
                    (fe = ue.qRadialSpeed[Ve]),
                    (je = he + (fe - he) * Ie),
                    (he = ue.qRadialSpeed2[Ze]),
                    (fe = ue.qRadialSpeed2[Ve]),
                    (lt = he + (fe - he) * Ie),
                    (je += (lt - je) * ((vt * 100) % 1)),
                    (ne.x = Ye[pt * w]),
                    (ne.y = Ye[pt * w + 1]),
                    (ne.z = Ye[pt * w + 2]),
                    ue.localSpace ? O.copy(ne) : O.copy(ne).sub(He),
                    O.normalize().mulScalar(je),
                    (Ze *= 3),
                    (Ve *= 3),
                    (he = ue.qLocalVelocity[Ze]),
                    (fe = ue.qLocalVelocity[Ve]),
                    (Z.x = he + (fe - he) * Ie),
                    (he = ue.qLocalVelocity[Ze + 1]),
                    (fe = ue.qLocalVelocity[Ve + 1]),
                    (Z.y = he + (fe - he) * Ie),
                    (he = ue.qLocalVelocity[Ze + 2]),
                    (fe = ue.qLocalVelocity[Ve + 2]),
                    (Z.z = he + (fe - he) * Ie),
                    (he = ue.qLocalVelocity2[Ze]),
                    (fe = ue.qLocalVelocity2[Ve]),
                    (pe.x = he + (fe - he) * Ie),
                    (he = ue.qLocalVelocity2[Ze + 1]),
                    (fe = ue.qLocalVelocity2[Ve + 1]),
                    (pe.y = he + (fe - he) * Ie),
                    (he = ue.qLocalVelocity2[Ze + 2]),
                    (fe = ue.qLocalVelocity2[Ve + 2]),
                    (pe.z = he + (fe - he) * Ie),
                    (he = ue.qVelocity[Ze]),
                    (fe = ue.qVelocity[Ve]),
                    (Y.x = he + (fe - he) * Ie),
                    (he = ue.qVelocity[Ze + 1]),
                    (fe = ue.qVelocity[Ve + 1]),
                    (Y.y = he + (fe - he) * Ie),
                    (he = ue.qVelocity[Ze + 2]),
                    (fe = ue.qVelocity[Ve + 2]),
                    (Y.z = he + (fe - he) * Ie),
                    (he = ue.qVelocity2[Ze]),
                    (fe = ue.qVelocity2[Ve]),
                    (ye.x = he + (fe - he) * Ie),
                    (he = ue.qVelocity2[Ze + 1]),
                    (fe = ue.qVelocity2[Ve + 1]),
                    (ye.y = he + (fe - he) * Ie),
                    (he = ue.qVelocity2[Ze + 2]),
                    (fe = ue.qVelocity2[Ve + 2]),
                    (ye.z = he + (fe - he) * Ie),
                    (Z.x += (pe.x - Z.x) * $.x),
                    (Z.y += (pe.y - Z.y) * $.y),
                    (Z.z += (pe.z - Z.z) * $.z),
                    ue.initialVelocity > 0 &&
                      (ue.emitterShape === u.mx
                        ? (X.copy($).mulScalar(2).sub(h.A.ONE).normalize(),
                          Z.add(X.mulScalar(ue.initialVelocity)))
                        : Z.add(h.A.FORWARD.mulScalar(ue.initialVelocity))),
                    (Y.x += (ye.x - Y.x) * $.x),
                    (Y.y += (ye.y - Y.y) * $.y),
                    (Y.z += (ye.z - Y.z) * $.z),
                    (tt += (Be - tt) * $.y),
                    (Kt = (Kt + (ot - Kt) * ((vt * 1e4) % 1)) * C),
                    (Lt = (mt - Qe) * ((vt * 1e3) % 1)),
                    ue.meshInstance.node &&
                      (ue.localSpace
                        ? ((Z.x /= B.x), (Z.y /= B.y), (Z.z /= B.z))
                        : k.transformPoint(Z, Z)),
                    ue.localSpace
                      ? (K.transformPoint(Y, Y), Z.add(Y).add(O))
                      : (Z.add(Y.mul(B)), Z.add(O.mul(B))),
                    V.copy(Z),
                    me.copy(ne).add(Z.mulScalar(at)),
                    N.copy(me),
                    (Ye[pt * w] = N.x),
                    (Ye[pt * w + 1] = N.y),
                    (Ye[pt * w + 2] = N.z),
                    (Ye[pt * w + 3] += tt * at),
                    ue.wrap &&
                      ue.wrapBounds &&
                      (ue.localSpace || N.sub(He),
                      (N.x = R(N.x, ue.wrapBounds.x) - ue.wrapBounds.x * 0.5),
                      (N.y = R(N.y, ue.wrapBounds.y) - ue.wrapBounds.y * 0.5),
                      (N.z = R(N.z, ue.wrapBounds.z) - ue.wrapBounds.z * 0.5),
                      ue.localSpace || N.add(He)),
                    ue.sort > 0 &&
                      (ue.sort === 1
                        ? (L.copy(N).sub(De),
                          (ue.particleDistance[pt] = -(
                            L.x * L.x +
                            L.y * L.y +
                            L.z * L.z
                          )))
                        : ue.sort === 2
                        ? (ue.particleDistance[pt] = Ot)
                        : ue.sort === 3 && (ue.particleDistance[pt] = -Ot))),
                    Pt
                      ? Ot < 0 &&
                        (Ye[pt * w + 3 + ue.numParticlesPot * 2 * w] = -1)
                      : (Ot >= Yt &&
                          ((Ot -= Math.max(Yt, (ue.numParticles - 1) * Fe)),
                          (Ye[pt * w + 3 + ue.numParticlesPot * 2 * w] = ue.loop
                            ? 1
                            : -1)),
                        Ot < 0 &&
                          ue.loop &&
                          (Ye[pt * w + 3 + ue.numParticlesPot * 2 * w] = 1)),
                    Ye[pt * w + 3 + ue.numParticlesPot * 2 * w] < 0 &&
                      (zt = !1),
                    (Ye[pt * w + 3 + ue.numParticlesPot * w] = Ot);
                  for (let ss = 0; ss < ue.numParticleVerts; ss++) {
                    const qt =
                      (ct * ue.numParticleVerts + ss) * (ue.useMesh ? 6 : 4);
                    let fs = ue.vbCPU[qt],
                      ls = ue.vbCPU[qt + 1],
                      Es = ue.vbCPU[qt + 2];
                    zt || (fs = ls = Es = 0);
                    const Ke = ct * ue.numParticleVerts * et + ss * et;
                    (Ae[Ke] = N.x),
                      (Ae[Ke + 1] = N.y),
                      (Ae[Ke + 2] = N.z),
                      (Ae[Ke + 3] = Rt),
                      (Ae[Ke + 4] = ue.alignToMotion ? Ft : Ye[pt * w + 3]),
                      (Ae[Ke + 5] = Kt),
                      (Ae[Ke + 6] = Lt),
                      (Ae[Ke + 7] = V.x),
                      (Ae[Ke + 8] = fs),
                      (Ae[Ke + 9] = ls),
                      (Ae[Ke + 10] = Es),
                      (Ae[Ke + 11] = V.y),
                      (Ae[Ke + 12] = pt),
                      (Ae[Ke + 13] = V.z),
                      (Ae[Ke + 14] = ue.vbCPU[qt + 3]),
                      ue.useMesh &&
                        ((Ae[Ke + 15] = ue.vbCPU[qt + 4]),
                        (Ae[Ke + 16] = ue.vbCPU[qt + 5]));
                  }
                }
                if (ue.sort > u.XV && ue.camera) {
                  const ct = ue.useMesh ? 6 : 4,
                    pt = ue.particleDistance;
                  for (let vt = 0; vt < ue.numParticles; vt++)
                    (Xe[vt][0] = vt),
                      (Xe[vt][1] =
                        pt[
                          Math.floor(
                            ue.vbCPU[vt * ue.numParticleVerts * ct + 3]
                          )
                        ]);
                  ue.vbOld.set(ue.vbCPU),
                    Xe.sort(function (vt, Fe) {
                      return vt[1] - Fe[1];
                    });
                  for (let vt = 0; vt < ue.numParticles; vt++) {
                    const Fe = Xe[vt][0] * ue.numParticleVerts * ct,
                      Yt = vt * ue.numParticleVerts * ct;
                    for (let Ot = 0; Ot < ue.numParticleVerts * ct; Ot++)
                      ue.vbCPU[Yt + Ot] = ue.vbOld[Fe + Ot];
                  }
                }
              }
            }
            var ie = a(4486),
              b = a(8277),
              M = a(7013),
              F = a(464);
            const z = new ie.T(),
              oe = new ie.T(),
              de = new ie.T();
            class ge {
              constructor(Ae, Xe) {
                (this._emitter = Ae),
                  (this.frameRandomUniform = new Float32Array(3)),
                  (this.emitterPosUniform = new Float32Array(3)),
                  (this.emitterScaleUniform = new Float32Array([1, 1, 1])),
                  (this.worldBoundsMulUniform = new Float32Array(3)),
                  (this.worldBoundsAddUniform = new Float32Array(3)),
                  (this.inBoundsSizeUniform = new Float32Array(3)),
                  (this.inBoundsCenterUniform = new Float32Array(3)),
                  (this.constantParticleTexIN =
                    Xe.scope.resolve("particleTexIN")),
                  (this.constantParticleTexOUT =
                    Xe.scope.resolve("particleTexOUT")),
                  (this.constantEmitterPos = Xe.scope.resolve("emitterPos")),
                  (this.constantEmitterScale =
                    Xe.scope.resolve("emitterScale")),
                  (this.constantSpawnBounds = Xe.scope.resolve("spawnBounds")),
                  (this.constantSpawnPosInnerRatio =
                    Xe.scope.resolve("spawnPosInnerRatio")),
                  (this.constantSpawnBoundsSphere =
                    Xe.scope.resolve("spawnBoundsSphere")),
                  (this.constantSpawnBoundsSphereInnerRatio = Xe.scope.resolve(
                    "spawnBoundsSphereInnerRatio"
                  )),
                  (this.constantInitialVelocity =
                    Xe.scope.resolve("initialVelocity")),
                  (this.constantFrameRandom = Xe.scope.resolve("frameRandom")),
                  (this.constantDelta = Xe.scope.resolve("delta")),
                  (this.constantRate = Xe.scope.resolve("rate")),
                  (this.constantRateDiv = Xe.scope.resolve("rateDiv")),
                  (this.constantLifetime = Xe.scope.resolve("lifetime")),
                  (this.constantGraphSampleSize =
                    Xe.scope.resolve("graphSampleSize")),
                  (this.constantGraphNumSamples =
                    Xe.scope.resolve("graphNumSamples")),
                  (this.constantInternalTex0 =
                    Xe.scope.resolve("internalTex0")),
                  (this.constantInternalTex1 =
                    Xe.scope.resolve("internalTex1")),
                  (this.constantInternalTex2 =
                    Xe.scope.resolve("internalTex2")),
                  (this.constantInternalTex3 =
                    Xe.scope.resolve("internalTex3")),
                  (this.constantEmitterMatrix =
                    Xe.scope.resolve("emitterMatrix")),
                  (this.constantEmitterMatrixInv =
                    Xe.scope.resolve("emitterMatrixInv")),
                  (this.constantNumParticles =
                    Xe.scope.resolve("numParticles")),
                  (this.constantNumParticlesPot =
                    Xe.scope.resolve("numParticlesPot")),
                  (this.constantLocalVelocityDivMult = Xe.scope.resolve(
                    "localVelocityDivMult"
                  )),
                  (this.constantVelocityDivMult =
                    Xe.scope.resolve("velocityDivMult")),
                  (this.constantRotSpeedDivMult =
                    Xe.scope.resolve("rotSpeedDivMult")),
                  (this.constantSeed = Xe.scope.resolve("seed")),
                  (this.constantStartAngle = Xe.scope.resolve("startAngle")),
                  (this.constantStartAngle2 = Xe.scope.resolve("startAngle2")),
                  (this.constantOutBoundsMul =
                    Xe.scope.resolve("outBoundsMul")),
                  (this.constantOutBoundsAdd =
                    Xe.scope.resolve("outBoundsAdd")),
                  (this.constantInBoundsSize =
                    Xe.scope.resolve("inBoundsSize")),
                  (this.constantInBoundsCenter =
                    Xe.scope.resolve("inBoundsCenter")),
                  (this.constantMaxVel = Xe.scope.resolve("maxVel")),
                  (this.constantFaceTangent = Xe.scope.resolve("faceTangent")),
                  (this.constantFaceBinorm = Xe.scope.resolve("faceBinorm"));
              }
              _setInputBounds() {
                (this.inBoundsSizeUniform[0] =
                  this._emitter.prevWorldBoundsSize.x),
                  (this.inBoundsSizeUniform[1] =
                    this._emitter.prevWorldBoundsSize.y),
                  (this.inBoundsSizeUniform[2] =
                    this._emitter.prevWorldBoundsSize.z),
                  this.constantInBoundsSize.setValue(this.inBoundsSizeUniform),
                  (this.inBoundsCenterUniform[0] =
                    this._emitter.prevWorldBoundsCenter.x),
                  (this.inBoundsCenterUniform[1] =
                    this._emitter.prevWorldBoundsCenter.y),
                  (this.inBoundsCenterUniform[2] =
                    this._emitter.prevWorldBoundsCenter.z),
                  this.constantInBoundsCenter.setValue(
                    this.inBoundsCenterUniform
                  );
              }
              randomize() {
                (this.frameRandomUniform[0] = Math.random()),
                  (this.frameRandomUniform[1] = Math.random()),
                  (this.frameRandomUniform[2] = Math.random());
              }
              update(Ae, Xe, Ye, it, st) {
                const He = this._emitter;
                Ae.setBlendState(b.a.NOBLEND),
                  Ae.setDepthState(M.b.NODEPTH),
                  Ae.setCullMode(s.OL2),
                  this.randomize(),
                  this.constantGraphSampleSize.setValue(1 / He.precision),
                  this.constantGraphNumSamples.setValue(He.precision),
                  this.constantNumParticles.setValue(He.numParticles),
                  this.constantNumParticlesPot.setValue(He.numParticlesPot),
                  this.constantInternalTex0.setValue(He.internalTex0),
                  this.constantInternalTex1.setValue(He.internalTex1),
                  this.constantInternalTex2.setValue(He.internalTex2),
                  this.constantInternalTex3.setValue(He.internalTex3);
                const at = He.meshInstance.node,
                  Pt = at === null ? h.A.ONE : at.localScale;
                if (He.pack8) {
                  (this.worldBoundsMulUniform[0] = He.worldBoundsMul.x),
                    (this.worldBoundsMulUniform[1] = He.worldBoundsMul.y),
                    (this.worldBoundsMulUniform[2] = He.worldBoundsMul.z),
                    this.constantOutBoundsMul.setValue(
                      this.worldBoundsMulUniform
                    ),
                    (this.worldBoundsAddUniform[0] = He.worldBoundsAdd.x),
                    (this.worldBoundsAddUniform[1] = He.worldBoundsAdd.y),
                    (this.worldBoundsAddUniform[2] = He.worldBoundsAdd.z),
                    this.constantOutBoundsAdd.setValue(
                      this.worldBoundsAddUniform
                    ),
                    this._setInputBounds();
                  let De = He.maxVel * Math.max(Math.max(Pt.x, Pt.y), Pt.z);
                  (De = Math.max(De, 1)), this.constantMaxVel.setValue(De);
                }
                const he =
                    at === null || He.localSpace ? h.A.ZERO : at.getPosition(),
                  fe = at === null ? g.y.IDENTITY : at.getWorldTransform();
                He.emitterShape === u.EB
                  ? (z.setFromMat4(Xe),
                    this.constantSpawnBounds.setValue(z.data),
                    this.constantSpawnPosInnerRatio.setValue(Ye))
                  : (this.constantSpawnBoundsSphere.setValue(He.emitterRadius),
                    this.constantSpawnBoundsSphereInnerRatio.setValue(
                      He.emitterRadius === 0
                        ? 0
                        : He.emitterRadiusInner / He.emitterRadius
                    )),
                  this.constantInitialVelocity.setValue(He.initialVelocity),
                  oe.setFromMat4(fe),
                  fe.invertTo3x3(de),
                  (this.emitterPosUniform[0] = he.x),
                  (this.emitterPosUniform[1] = he.y),
                  (this.emitterPosUniform[2] = he.z),
                  this.constantEmitterPos.setValue(this.emitterPosUniform),
                  this.constantFrameRandom.setValue(this.frameRandomUniform),
                  this.constantDelta.setValue(it),
                  this.constantRate.setValue(He.rate),
                  this.constantRateDiv.setValue(He.rate2 - He.rate),
                  this.constantStartAngle.setValue(
                    He.startAngle * c.m.DEG_TO_RAD
                  ),
                  this.constantStartAngle2.setValue(
                    He.startAngle2 * c.m.DEG_TO_RAD
                  ),
                  this.constantSeed.setValue(He.seed),
                  this.constantLifetime.setValue(He.lifetime),
                  (this.emitterScaleUniform[0] = Pt.x),
                  (this.emitterScaleUniform[1] = Pt.y),
                  (this.emitterScaleUniform[2] = Pt.z),
                  this.constantEmitterScale.setValue(this.emitterScaleUniform),
                  this.constantEmitterMatrix.setValue(oe.data),
                  this.constantEmitterMatrixInv.setValue(de.data),
                  this.constantLocalVelocityDivMult.setValue(
                    He.localVelocityUMax
                  ),
                  this.constantVelocityDivMult.setValue(He.velocityUMax),
                  this.constantRotSpeedDivMult.setValue(He.rotSpeedUMax[0]);
                let Ie = He.swapTex ? He.particleTexOUT : He.particleTexIN;
                Ie = He.beenReset ? He.particleTexStart : Ie;
                const ue = He.swapTex ? He.particleTexIN : He.particleTexOUT;
                this.constantParticleTexIN.setValue(Ie),
                  (0, F.H)(
                    Ae,
                    He.swapTex ? He.rtParticleTexIN : He.rtParticleTexOUT,
                    st
                      ? He.shaderParticleUpdateOnStop
                      : He.loop
                      ? He.shaderParticleUpdateRespawn
                      : He.shaderParticleUpdateNoRespawn
                  ),
                  He.material.setParameter("particleTexOUT", Ie),
                  He.material.setParameter("particleTexIN", ue),
                  (He.beenReset = !1),
                  (He.swapTex = !He.swapTex),
                  He.prevWorldBoundsSize.copy(He.worldBoundsSize),
                  He.prevWorldBoundsCenter.copy(He.worldBounds.center),
                  He.pack8 && this._setInputBounds();
              }
            }
            const Re = [
              [-1, -1],
              [1, -1],
              [1, 1],
              [-1, 1],
            ];
            function Te(yt, Ae, Xe, Ye, it = s.uC3, st, He) {
              let at = s.yib;
              He && it === s.jKI && (at = s.I5X);
              const Pt = new i.x(yt, {
                  width: Ae,
                  height: Xe,
                  format: it,
                  cubemap: !1,
                  mipmaps: !1,
                  minFilter: at,
                  magFilter: at,
                  addressU: s.uFb,
                  addressV: s.uFb,
                  name: "ParticleSystemTexture",
                }),
                he = Pt.lock();
              if (it === s.jKI) {
                const fe = new Uint8Array(Ye.length);
                for (let Ie = 0; Ie < Ye.length; Ie++)
                  fe[Ie] = Ye[Ie] * st * 255;
                Ye = fe;
              }
              return he.set(Ye), Pt.unlock(), Pt;
            }
            function Ne(yt) {
              return Math.max(Math.min(yt, 1), 0);
            }
            const Le = new x.H([0, 0, 1, 0]),
              ke = new x.H([0, 1, 1, 1]),
              ht = new T.e([0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0]),
              _e = new T.e([0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1]);
            let U = 2;
            const H = 4,
              Ee = new Float32Array(3),
              G = new g.y(),
              Q = new h.A(),
              q = new h.A(),
              xe = new h.A();
            let be, Pe;
            function we(yt, Ae) {
              Pe[yt] !== void 0 && Pe[yt] !== null
                ? (be[yt] = Pe[yt])
                : (be[yt] = Ae);
            }
            function Oe(yt, Ae, Xe) {
              return (
                (((yt * 255) << 16) | ((Ae * 255) << 8) | (Xe * 255)) / 16777216
              );
            }
            function $e(yt, Ae) {
              const Xe = yt.length / 3,
                Ye = new Array(Xe * 4);
              for (let it = 0; it < Xe; it++)
                (Ye[it * 4] = yt[it * 3]),
                  (Ye[it * 4 + 1] = yt[it * 3 + 1]),
                  (Ye[it * 4 + 2] = yt[it * 3 + 2]),
                  (Ye[it * 4 + 3] = Oe(
                    Ae[it * 3],
                    Ae[it * 3 + 1],
                    Ae[it * 3 + 2]
                  ));
              return Ye;
            }
            function gt(yt, Ae) {
              const Xe = new Array(Ae.length * 4);
              for (let Ye = 0; Ye < Ae.length; Ye++)
                (Xe[Ye * 4] = yt[Ye * 3]),
                  (Xe[Ye * 4 + 1] = yt[Ye * 3 + 1]),
                  (Xe[Ye * 4 + 2] = yt[Ye * 3 + 2]),
                  (Xe[Ye * 4 + 3] = Ae[Ye]);
              return Xe;
            }
            function qe(yt, Ae, Xe, Ye, it) {
              const st = new Array(yt.length * 4);
              for (let He = 0; He < yt.length; He++)
                (st[He * 4] = yt[He]),
                  (st[He * 4 + 1] = Ae[He]),
                  (st[He * 4 + 2] = 0),
                  (st[He * 4 + 3] = Oe(Xe[He], Ye[He], it[He]));
              return st;
            }
            function Tt(yt, Ae) {
              const Xe = new Array(yt.length * 4);
              for (let Ye = 0; Ye < yt.length; Ye++)
                (Xe[Ye * 4] = yt[Ye]),
                  (Xe[Ye * 4 + 1] = Ae[Ye]),
                  (Xe[Ye * 4 + 2] = 0),
                  (Xe[Ye * 4 + 3] = 0);
              return Xe;
            }
            function Mt(yt) {
              const Ae =
                Math.max(yt.rate, yt.rate2) * yt.numParticles + yt.lifetime;
              return Date.now() + Ae * 1e3;
            }
            function Dt(yt, Ae) {
              const Xe = new Float32Array(yt.length);
              for (let Ye = 0; Ye < yt.length; Ye++) Xe[Ye] = yt[Ye] - Ae[Ye];
              return Xe;
            }
            function ut(yt, Ae) {
              const Xe = Ae.length,
                Ye = yt.length / Xe;
              for (let it = 0; it < Ye; it++)
                for (let st = 0; st < Xe; st++) {
                  const He = Math.abs(yt[it * Xe + st]);
                  Ae[st] = Math.max(Ae[st], He);
                }
            }
            function At(yt, Ae) {
              const Xe = Ae.length,
                Ye = yt.length / Xe;
              for (let it = 0; it < Ye; it++)
                for (let st = 0; st < Xe; st++)
                  (yt[it * Xe + st] /= Ae[st] === 0 ? 1 : Ae[st]),
                    (yt[it * Xe + st] *= 0.5),
                    (yt[it * Xe + st] += 0.5);
            }
            function xt(yt, Ae, Xe) {
              const Ye = Dt(Ae, yt);
              return ut(Ye, Xe), At(Ye, Xe), Ye;
            }
            const jt = new l.c();
            class Gt {
              constructor(Ae, Xe) {
                this.graphicsDevice = Ae;
                const Ye = Ae,
                  it = 32;
                (this.precision = it),
                  (this._addTimeTime = 0),
                  (be = this),
                  (Pe = Xe),
                  we("numParticles", 1),
                  this.numParticles > Ae.maxTextureSize &&
                    (this.numParticles = Ae.maxTextureSize),
                  we("rate", 1),
                  we("rate2", this.rate),
                  we("lifetime", 50),
                  we("emitterExtents", new h.A(0, 0, 0)),
                  we("emitterExtentsInner", new h.A(0, 0, 0)),
                  we("emitterRadius", 0),
                  we("emitterRadiusInner", 0),
                  we("emitterShape", u.EB),
                  we("initialVelocity", 1),
                  we("wrap", !1),
                  we("localSpace", !1),
                  we("screenSpace", !1),
                  we("wrapBounds", null),
                  we("colorMap", this.defaultParamTexture),
                  we("normalMap", null),
                  we("loop", !0),
                  we("preWarm", !1),
                  we("sort", u.XV),
                  we("mode", u.Fg),
                  we("scene", null),
                  we("lighting", !1),
                  we("halfLambert", !1),
                  we("intensity", 1),
                  we("stretch", 0),
                  we("alignToMotion", !1),
                  we("depthSoftening", 0),
                  we("mesh", null),
                  we("particleNormal", new h.A(0, 1, 0)),
                  we("orientation", u.d3),
                  we("depthWrite", !1),
                  we("noFog", !1),
                  we("blendType", u.lA),
                  we("node", null),
                  we("startAngle", 0),
                  we("startAngle2", this.startAngle),
                  we("animTilesX", 1),
                  we("animTilesY", 1),
                  we("animStartFrame", 0),
                  we("animNumFrames", 1),
                  we("animNumAnimations", 1),
                  we("animIndex", 0),
                  we("randomizeAnimIndex", !1),
                  we("animSpeed", 1),
                  we("animLoop", !0),
                  (this._gpuUpdater = new ge(this, Ye)),
                  (this._cpuUpdater = new ce(this)),
                  (this.constantLightCube = Ye.scope.resolve("lightCube[0]")),
                  (this.emitterPosUniform = new Float32Array(3)),
                  (this.wrapBoundsUniform = new Float32Array(3)),
                  (this.emitterScaleUniform = new Float32Array([1, 1, 1])),
                  we("colorGraph", _e),
                  we("colorGraph2", this.colorGraph),
                  we("scaleGraph", ke),
                  we("scaleGraph2", this.scaleGraph),
                  we("alphaGraph", ke),
                  we("alphaGraph2", this.alphaGraph),
                  we("localVelocityGraph", ht),
                  we("localVelocityGraph2", this.localVelocityGraph),
                  we("velocityGraph", ht),
                  we("velocityGraph2", this.velocityGraph),
                  we("rotationSpeedGraph", Le),
                  we("rotationSpeedGraph2", this.rotationSpeedGraph),
                  we("radialSpeedGraph", Le),
                  we("radialSpeedGraph2", this.radialSpeedGraph),
                  (this.lightCube = new Float32Array(18)),
                  (this.lightCubeDir = new Array(6)),
                  (this.lightCubeDir[0] = new h.A(-1, 0, 0)),
                  (this.lightCubeDir[1] = new h.A(1, 0, 0)),
                  (this.lightCubeDir[2] = new h.A(0, -1, 0)),
                  (this.lightCubeDir[3] = new h.A(0, 1, 0)),
                  (this.lightCubeDir[4] = new h.A(0, 0, -1)),
                  (this.lightCubeDir[5] = new h.A(0, 0, 1)),
                  (this.animTilesParams = new Float32Array(2)),
                  (this.animParams = new Float32Array(4)),
                  (this.animIndexParams = new Float32Array(2)),
                  (this.internalTex0 = null),
                  (this.internalTex1 = null),
                  (this.internalTex2 = null),
                  (this.colorParam = null),
                  (this.vbToSort = null),
                  (this.vbOld = null),
                  (this.particleDistance = null),
                  (this.camera = null),
                  (this.swapTex = !1),
                  (this.useMesh = !0),
                  (this.useCpu = !Ae.supportsGpuParticles),
                  (this.pack8 = !0),
                  (this.localBounds = new f.k()),
                  (this.worldBoundsNoTrail = new f.k()),
                  (this.worldBoundsTrail = [new f.k(), new f.k()]),
                  (this.worldBounds = new f.k()),
                  (this.worldBoundsSize = new h.A()),
                  (this.prevWorldBoundsSize = new h.A()),
                  (this.prevWorldBoundsCenter = new h.A()),
                  (this.prevEmitterExtents = this.emitterExtents),
                  (this.prevEmitterRadius = this.emitterRadius),
                  (this.worldBoundsMul = new h.A()),
                  (this.worldBoundsAdd = new h.A()),
                  (this.timeToSwitchBounds = 0),
                  (this.shaderParticleUpdateRespawn = null),
                  (this.shaderParticleUpdateNoRespawn = null),
                  (this.shaderParticleUpdateOnStop = null),
                  (this.numParticleVerts = 0),
                  (this.numParticleIndices = 0),
                  (this.material = null),
                  (this.meshInstance = null),
                  (this.drawOrder = 0),
                  (this.seed = Math.random()),
                  (this.fixedTimeStep = 0.016666666666666666),
                  (this.maxSubSteps = 10),
                  (this.simTime = 0),
                  (this.simTimeTotal = 0),
                  (this.beenReset = !1),
                  (this._layer = null),
                  this.rebuild();
              }
              get defaultParamTexture() {
                return jt.get(this.graphicsDevice, () => {
                  const Ye = new Float32Array(1024);
                  for (let st = 0; st < 16; st++)
                    for (let He = 0; He < 16; He++) {
                      const at = He + 1 - 8.5,
                        Pt = st + 1 - 8.5,
                        he = Ne(
                          1 - Ne(Math.sqrt(at * at + Pt * Pt) / 16) - 0.5
                        ),
                        fe = st * 16 + He;
                      (Ye[fe * 4] = 1),
                        (Ye[fe * 4 + 1] = 1),
                        (Ye[fe * 4 + 2] = 1),
                        (Ye[fe * 4 + 3] = he);
                    }
                  const it = Te(this.graphicsDevice, 16, 16, Ye, s.jKI, 1, !0);
                  return (it.minFilter = s.I5X), (it.magFilter = s.I5X), it;
                });
              }
              onChangeCamera() {
                this.regenShader(), this.resetMaterial();
              }
              calculateBoundsMad() {
                (this.worldBoundsMul.x = 1 / this.worldBoundsSize.x),
                  (this.worldBoundsMul.y = 1 / this.worldBoundsSize.y),
                  (this.worldBoundsMul.z = 1 / this.worldBoundsSize.z),
                  this.worldBoundsAdd
                    .copy(this.worldBounds.center)
                    .mul(this.worldBoundsMul)
                    .mulScalar(-1),
                  (this.worldBoundsAdd.x += 0.5),
                  (this.worldBoundsAdd.y += 0.5),
                  (this.worldBoundsAdd.z += 0.5);
              }
              calculateWorldBounds() {
                if (!this.node) return;
                if (
                  (this.prevWorldBoundsSize.copy(this.worldBoundsSize),
                  this.prevWorldBoundsCenter.copy(this.worldBounds.center),
                  !this.useCpu)
                ) {
                  let Ye = !1;
                  this.emitterShape === u.EB
                    ? (Ye = !this.emitterExtents.equals(
                        this.prevEmitterExtents
                      ))
                    : (Ye = this.emitterRadius !== this.prevEmitterRadius),
                    Ye && this.calculateLocalBounds();
                }
                const Ae = this.node.getWorldTransform();
                this.localSpace
                  ? this.worldBoundsNoTrail.copy(this.localBounds)
                  : this.worldBoundsNoTrail.setFromTransformedAabb(
                      this.localBounds,
                      Ae
                    ),
                  this.worldBoundsTrail[0].add(this.worldBoundsNoTrail),
                  this.worldBoundsTrail[1].add(this.worldBoundsNoTrail);
                const Xe = this.simTimeTotal;
                Xe >= this.timeToSwitchBounds &&
                  (this.worldBoundsTrail[0].copy(this.worldBoundsTrail[1]),
                  this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail),
                  (this.timeToSwitchBounds = Xe + this.lifetime)),
                  this.worldBounds.copy(this.worldBoundsTrail[0]),
                  this.worldBoundsSize
                    .copy(this.worldBounds.halfExtents)
                    .mulScalar(2),
                  this.localSpace
                    ? (this.meshInstance.aabb.setFromTransformedAabb(
                        this.worldBounds,
                        Ae
                      ),
                      this.meshInstance.mesh.aabb.setFromTransformedAabb(
                        this.worldBounds,
                        Ae
                      ))
                    : (this.meshInstance.aabb.copy(this.worldBounds),
                      this.meshInstance.mesh.aabb.copy(this.worldBounds)),
                  (this.meshInstance._aabbVer = 1 - this.meshInstance._aabbVer),
                  this.pack8 && this.calculateBoundsMad();
              }
              resetWorldBounds() {
                this.node &&
                  (this.worldBoundsNoTrail.setFromTransformedAabb(
                    this.localBounds,
                    this.localSpace
                      ? g.y.IDENTITY
                      : this.node.getWorldTransform()
                  ),
                  this.worldBoundsTrail[0].copy(this.worldBoundsNoTrail),
                  this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail),
                  this.worldBounds.copy(this.worldBoundsTrail[0]),
                  this.worldBoundsSize
                    .copy(this.worldBounds.halfExtents)
                    .mulScalar(2),
                  this.prevWorldBoundsSize.copy(this.worldBoundsSize),
                  this.prevWorldBoundsCenter.copy(this.worldBounds.center),
                  (this.simTimeTotal = 0),
                  (this.timeToSwitchBounds = 0));
              }
              calculateLocalBounds() {
                let Ae = Number.MAX_VALUE,
                  Xe = Number.MAX_VALUE,
                  Ye = Number.MAX_VALUE,
                  it = -Number.MAX_VALUE,
                  st = -Number.MAX_VALUE,
                  He = -Number.MAX_VALUE,
                  at = 0,
                  Pt = 0;
                const he = this.lifetime / this.precision,
                  fe = [this.qVelocity, this.qVelocity2],
                  Ie = [this.qLocalVelocity, this.qLocalVelocity2],
                  ue = [0, 0],
                  De = [0, 0],
                  et = [0, 0],
                  Ze = [0, 0],
                  Ve = [0, 0];
                let tt, Be, ot;
                for (let mt = 0; mt < this.precision + 1; mt++) {
                  const je = Math.min(mt, this.precision - 1);
                  for (let lt = 0; lt < 2; lt++)
                    (tt = Ie[lt][je * 3 + 0] * he + ue[lt]),
                      (Be = Ie[lt][je * 3 + 1] * he + De[lt]),
                      (ot = Ie[lt][je * 3 + 2] * he + et[lt]),
                      (Ae = Math.min(tt, Ae)),
                      (Xe = Math.min(Be, Xe)),
                      (Ye = Math.min(ot, Ye)),
                      (it = Math.max(tt, it)),
                      (st = Math.max(Be, st)),
                      (He = Math.max(ot, He)),
                      (ue[lt] = tt),
                      (De[lt] = Be),
                      (et[lt] = ot);
                  for (let lt = 0; lt < 2; lt++)
                    Ve[lt] +=
                      he *
                      Math.sqrt(
                        fe[lt][je * 3 + 0] * fe[lt][je * 3 + 0] +
                          fe[lt][je * 3 + 1] * fe[lt][je * 3 + 1] +
                          fe[lt][je * 3 + 2] * fe[lt][je * 3 + 2]
                      );
                  (Ze[0] += this.qRadialSpeed[je] * he),
                    (Ze[1] += this.qRadialSpeed2[je] * he),
                    (at = Math.max(
                      at,
                      Math.max(Math.abs(Ze[0]), Math.abs(Ze[1]))
                    )),
                    (Pt = Math.max(Pt, this.qScale[je]));
                }
                this.emitterShape === u.EB
                  ? ((tt = this.emitterExtents.x * 0.5),
                    (Be = this.emitterExtents.y * 0.5),
                    (ot = this.emitterExtents.z * 0.5))
                  : ((tt = this.emitterRadius),
                    (Be = this.emitterRadius),
                    (ot = this.emitterRadius));
                const Qe = Math.max(Ve[0], Ve[1]);
                (q.x = Ae - Pt - tt - at - Qe),
                  (q.y = Xe - Pt - Be - at - Qe),
                  (q.z = Ye - Pt - ot - at - Qe),
                  (xe.x = it + Pt + tt + at + Qe),
                  (xe.y = st + Pt + Be + at + Qe),
                  (xe.z = He + Pt + ot + at + Qe),
                  this.localBounds.setMinMax(q, xe);
              }
              rebuild() {
                const Ae = this.graphicsDevice;
                this.colorMap === null &&
                  (this.colorMap = this.defaultParamTexture),
                  (this.spawnBounds =
                    this.emitterShape === u.EB
                      ? this.emitterExtents
                      : this.emitterRadius),
                  (this.useCpu =
                    this.useCpu ||
                    this.sort > u.XV ||
                    Ae.maxVertexTextures <= 1 ||
                    Ae.fragmentUniformsCount < 64 ||
                    Ae.forceCpuParticles ||
                    !Ae.extTextureFloat),
                  this._destroyResources(),
                  (this.pack8 =
                    (this.pack8 || !Ae.textureFloatRenderable) && !this.useCpu),
                  (U = this.useCpu || this.pack8 ? 4 : 2),
                  (this.useMesh = !1),
                  this.mesh &&
                    (this.numParticles * this.mesh.vertexBuffer.numVertices >
                      65535 ||
                      (this.useMesh = !0)),
                  (this.numParticlesPot = c.m.nextPowerOfTwo(
                    this.numParticles
                  )),
                  this.rebuildGraphs(),
                  this.calculateLocalBounds(),
                  this.resetWorldBounds(),
                  this.node &&
                    (this.worldBounds.setFromTransformedAabb(
                      this.localBounds,
                      this.localSpace
                        ? g.y.IDENTITY
                        : this.node.getWorldTransform()
                    ),
                    this.worldBoundsTrail[0].copy(this.worldBounds),
                    this.worldBoundsTrail[1].copy(this.worldBounds),
                    this.worldBoundsSize
                      .copy(this.worldBounds.halfExtents)
                      .mulScalar(2),
                    this.prevWorldBoundsSize.copy(this.worldBoundsSize),
                    this.prevWorldBoundsCenter.copy(this.worldBounds.center),
                    this.pack8 && this.calculateBoundsMad()),
                  (this.vbToSort = new Array(this.numParticles));
                for (let fe = 0; fe < this.numParticles; fe++)
                  this.vbToSort[fe] = [0, 0];
                (this.particleDistance = new Float32Array(this.numParticles)),
                  this._gpuUpdater.randomize(),
                  (this.particleTex = new Float32Array(
                    this.numParticlesPot * U * H
                  ));
                const Xe =
                  this.node === null || this.localSpace
                    ? h.A.ZERO
                    : this.node.getPosition();
                this.emitterShape === u.EB &&
                  (this.node === null || this.localSpace
                    ? G.setTRS(h.A.ZERO, d.D.IDENTITY, this.spawnBounds)
                    : G.setTRS(
                        h.A.ZERO,
                        this.node.getRotation(),
                        Q.copy(this.spawnBounds).mul(this.node.localScale)
                      ),
                  (Ee[0] =
                    this.emitterExtents.x !== 0
                      ? this.emitterExtentsInner.x / this.emitterExtents.x
                      : 0),
                  (Ee[1] =
                    this.emitterExtents.y !== 0
                      ? this.emitterExtentsInner.y / this.emitterExtents.y
                      : 0),
                  (Ee[2] =
                    this.emitterExtents.z !== 0
                      ? this.emitterExtentsInner.z / this.emitterExtents.z
                      : 0));
                for (let fe = 0; fe < this.numParticles; fe++)
                  this._cpuUpdater.calcSpawnPosition(
                    this.particleTex,
                    G,
                    Ee,
                    Xe,
                    fe
                  ),
                    this.useCpu &&
                      (this.particleTex[
                        fe * H + 3 + this.numParticlesPot * 2 * H
                      ] = 1);
                this.particleTexStart = new Float32Array(
                  this.numParticlesPot * U * H
                );
                for (let fe = 0; fe < this.particleTexStart.length; fe++)
                  this.particleTexStart[fe] = this.particleTex[fe];
                this.useCpu ||
                  (this.pack8
                    ? ((this.particleTexIN = Te(
                        Ae,
                        this.numParticlesPot,
                        U,
                        this.particleTex,
                        s.jKI,
                        1,
                        !1
                      )),
                      (this.particleTexOUT = Te(
                        Ae,
                        this.numParticlesPot,
                        U,
                        this.particleTex,
                        s.jKI,
                        1,
                        !1
                      )),
                      (this.particleTexStart = Te(
                        Ae,
                        this.numParticlesPot,
                        U,
                        this.particleTexStart,
                        s.jKI,
                        1,
                        !1
                      )))
                    : ((this.particleTexIN = Te(
                        Ae,
                        this.numParticlesPot,
                        U,
                        this.particleTex
                      )),
                      (this.particleTexOUT = Te(
                        Ae,
                        this.numParticlesPot,
                        U,
                        this.particleTex
                      )),
                      (this.particleTexStart = Te(
                        Ae,
                        this.numParticlesPot,
                        U,
                        this.particleTexStart
                      ))),
                  (this.rtParticleTexIN = new o.A({
                    colorBuffer: this.particleTexIN,
                    depth: !1,
                  })),
                  (this.rtParticleTexOUT = new o.A({
                    colorBuffer: this.particleTexOUT,
                    depth: !1,
                  })),
                  (this.swapTex = !1));
                const Ye =
                    (this.localSpace
                      ? `#define LOCAL_SPACE
`
                      : "") +
                    v.n.particleUpdaterInitPS +
                    (this.pack8
                      ? v.n.particleInputRgba8PS + v.n.particleOutputRgba8PS
                      : v.n.particleInputFloatPS + v.n.particleOutputFloatPS) +
                    (this.emitterShape === u.EB
                      ? v.n.particleUpdaterAABBPS
                      : v.n.particleUpdaterSpherePS) +
                    v.n.particleUpdaterStartPS,
                  it =
                    Ye +
                    v.n.particleUpdaterRespawnPS +
                    v.n.particleUpdaterEndPS,
                  st =
                    Ye +
                    v.n.particleUpdaterNoRespawnPS +
                    v.n.particleUpdaterEndPS,
                  He =
                    Ye + v.n.particleUpdaterOnStopPS + v.n.particleUpdaterEndPS,
                  at = this.emitterShape + "" + this.pack8 + this.localSpace;
                (this.shaderParticleUpdateRespawn = (0, E.JM)(
                  Ae,
                  v.n.fullscreenQuadVS,
                  it,
                  "fsQuad0" + at
                )),
                  (this.shaderParticleUpdateNoRespawn = (0, E.JM)(
                    Ae,
                    v.n.fullscreenQuadVS,
                    st,
                    "fsQuad1" + at
                  )),
                  (this.shaderParticleUpdateOnStop = (0, E.JM)(
                    Ae,
                    v.n.fullscreenQuadVS,
                    He,
                    "fsQuad2" + at
                  )),
                  (this.numParticleVerts = this.useMesh
                    ? this.mesh.vertexBuffer.numVertices
                    : 4),
                  (this.numParticleIndices = this.useMesh
                    ? this.mesh.indexBuffer[0].numIndices
                    : 6),
                  this._allocate(this.numParticles);
                const Pt = new y.K(Ae);
                (Pt.vertexBuffer = this.vertexBuffer),
                  (Pt.indexBuffer[0] = this.indexBuffer),
                  (Pt.primitive[0].type = s.LAy),
                  (Pt.primitive[0].base = 0),
                  (Pt.primitive[0].count =
                    this.numParticles * this.numParticleIndices),
                  (Pt.primitive[0].indexed = !0),
                  (this.material = new _.F()),
                  (this.material.name = this.node.name),
                  (this.material.cull = s.OL2),
                  (this.material.alphaWrite = !1),
                  (this.material.blendType = this.blendType),
                  (this.material.depthWrite = this.depthWrite),
                  (this.material.emitter = this),
                  this.regenShader(),
                  this.resetMaterial();
                const he = this.meshInstance ? this.meshInstance.visible : !0;
                (this.meshInstance = new p.l(Pt, this.material, this.node)),
                  (this.meshInstance.pick = !1),
                  this.meshInstance.updateKey(),
                  (this.meshInstance.cull = !0),
                  (this.meshInstance._noDepthDrawGl1 = !0),
                  this.localSpace
                    ? this.meshInstance.aabb.setFromTransformedAabb(
                        this.worldBounds,
                        this.node.getWorldTransform()
                      )
                    : this.meshInstance.aabb.copy(this.worldBounds),
                  (this.meshInstance._updateAabb = !1),
                  (this.meshInstance.visible = he),
                  this._initializeTextures(),
                  this.resetTime(),
                  this.addTime(0, !1),
                  this.preWarm && this.prewarm(this.lifetime);
              }
              _isAnimated() {
                return (
                  this.animNumFrames >= 1 &&
                  (this.animTilesX > 1 || this.animTilesY > 1) &&
                  ((this.colorMap &&
                    this.colorMap !== this.defaultParamTexture) ||
                    this.normalMap)
                );
              }
              rebuildGraphs() {
                const Ae = this.precision,
                  Xe = this.graphicsDevice;
                (this.qLocalVelocity = this.localVelocityGraph.quantize(Ae)),
                  (this.qVelocity = this.velocityGraph.quantize(Ae)),
                  (this.qColor = this.colorGraph.quantizeClamped(Ae, 0, 1)),
                  (this.qRotSpeed = this.rotationSpeedGraph.quantize(Ae)),
                  (this.qScale = this.scaleGraph.quantize(Ae)),
                  (this.qAlpha = this.alphaGraph.quantize(Ae)),
                  (this.qRadialSpeed = this.radialSpeedGraph.quantize(Ae)),
                  (this.qLocalVelocity2 =
                    this.localVelocityGraph2.quantize(Ae)),
                  (this.qVelocity2 = this.velocityGraph2.quantize(Ae)),
                  (this.qColor2 = this.colorGraph2.quantizeClamped(Ae, 0, 1)),
                  (this.qRotSpeed2 = this.rotationSpeedGraph2.quantize(Ae)),
                  (this.qScale2 = this.scaleGraph2.quantize(Ae)),
                  (this.qAlpha2 = this.alphaGraph2.quantize(Ae)),
                  (this.qRadialSpeed2 = this.radialSpeedGraph2.quantize(Ae));
                for (let Ye = 0; Ye < Ae; Ye++)
                  (this.qRotSpeed[Ye] *= c.m.DEG_TO_RAD),
                    (this.qRotSpeed2[Ye] *= c.m.DEG_TO_RAD);
                if (
                  ((this.localVelocityUMax = new Float32Array(3)),
                  (this.velocityUMax = new Float32Array(3)),
                  (this.colorUMax = new Float32Array(3)),
                  (this.rotSpeedUMax = [0]),
                  (this.scaleUMax = [0]),
                  (this.alphaUMax = [0]),
                  (this.radialSpeedUMax = [0]),
                  (this.qLocalVelocityDiv = xt(
                    this.qLocalVelocity,
                    this.qLocalVelocity2,
                    this.localVelocityUMax
                  )),
                  (this.qVelocityDiv = xt(
                    this.qVelocity,
                    this.qVelocity2,
                    this.velocityUMax
                  )),
                  (this.qColorDiv = xt(
                    this.qColor,
                    this.qColor2,
                    this.colorUMax
                  )),
                  (this.qRotSpeedDiv = xt(
                    this.qRotSpeed,
                    this.qRotSpeed2,
                    this.rotSpeedUMax
                  )),
                  (this.qScaleDiv = xt(
                    this.qScale,
                    this.qScale2,
                    this.scaleUMax
                  )),
                  (this.qAlphaDiv = xt(
                    this.qAlpha,
                    this.qAlpha2,
                    this.alphaUMax
                  )),
                  (this.qRadialSpeedDiv = xt(
                    this.qRadialSpeed,
                    this.qRadialSpeed2,
                    this.radialSpeedUMax
                  )),
                  this.pack8)
                ) {
                  const Ye = [0, 0, 0];
                  ut(this.qVelocity, Ye);
                  const it = [0, 0, 0];
                  ut(this.qVelocity2, it);
                  const st = [0, 0, 0];
                  ut(this.qLocalVelocity, st);
                  const He = [0, 0, 0];
                  ut(this.qLocalVelocity2, He);
                  const at = [0];
                  ut(this.qRadialSpeed, at);
                  const Pt = [0];
                  ut(this.qRadialSpeed2, Pt);
                  let he = Math.max(Ye[0], it[0]);
                  (he = Math.max(he, Ye[1])),
                    (he = Math.max(he, it[1])),
                    (he = Math.max(he, Ye[2])),
                    (he = Math.max(he, it[2]));
                  let fe = Math.max(st[0], He[0]);
                  (fe = Math.max(fe, st[1])),
                    (fe = Math.max(fe, He[1])),
                    (fe = Math.max(fe, st[2])),
                    (fe = Math.max(fe, He[2]));
                  const Ie = Math.max(at[0], Pt[0]);
                  this.maxVel = he + fe + Ie;
                }
                this.useCpu ||
                  ((this.internalTex0 = Te(
                    Xe,
                    Ae,
                    1,
                    $e(this.qLocalVelocity, this.qLocalVelocityDiv)
                  )),
                  (this.internalTex1 = Te(
                    Xe,
                    Ae,
                    1,
                    $e(this.qVelocity, this.qVelocityDiv)
                  )),
                  (this.internalTex2 = Te(
                    Xe,
                    Ae,
                    1,
                    qe(
                      this.qRotSpeed,
                      this.qScale,
                      this.qScaleDiv,
                      this.qRotSpeedDiv,
                      this.qAlphaDiv
                    )
                  )),
                  (this.internalTex3 = Te(
                    Xe,
                    Ae,
                    1,
                    Tt(this.qRadialSpeed, this.qRadialSpeedDiv)
                  ))),
                  (this.colorParam = Te(
                    Xe,
                    Ae,
                    1,
                    gt(this.qColor, this.qAlpha),
                    s.jKI,
                    1,
                    !0
                  ));
              }
              _initializeTextures() {
                this.colorMap &&
                  (this.material.setParameter("colorMap", this.colorMap),
                  this.lighting &&
                    this.normalMap &&
                    this.material.setParameter("normalMap", this.normalMap));
              }
              regenShader() {
                const Ae = (0, m.N)(this.graphicsDevice);
                Ae.register("particle", A);
                const Xe = this.normalMap !== null;
                (this.normalOption = 0),
                  this.lighting && (this.normalOption = Xe ? 2 : 1),
                  (this.material.getShaderVariant = function (
                    Ye,
                    it,
                    st,
                    He,
                    at,
                    Pt,
                    he,
                    fe
                  ) {
                    this.emitter.scene &&
                      this.emitter.camera !==
                        this.emitter.scene._activeCamera &&
                      ((this.emitter.camera = this.emitter.scene._activeCamera),
                      this.emitter.onChangeCamera());
                    const Ie = this.emitter.inTools,
                      ue = new r.C(he, fe);
                    return Ae.getProgram(
                      "particle",
                      {
                        pass: u.lW,
                        useCpu: this.emitter.useCpu,
                        normal: this.emitter.normalOption,
                        halflambert: this.emitter.halfLambert,
                        stretch: this.emitter.stretch,
                        alignToMotion: this.emitter.alignToMotion,
                        soft: this.emitter.depthSoftening,
                        mesh: this.emitter.useMesh,
                        gamma: this.emitter.scene
                          ? this.emitter.scene.gammaCorrection
                          : 0,
                        toneMap: this.emitter.scene
                          ? this.emitter.scene.toneMapping
                          : 0,
                        fog:
                          this.emitter.scene && !this.emitter.noFog
                            ? this.emitter.scene.fog
                            : "none",
                        wrap: this.emitter.wrap && this.emitter.wrapBounds,
                        localSpace: this.emitter.localSpace,
                        screenSpace: Ie ? !1 : this.emitter.screenSpace,
                        blend: this.blendType,
                        animTex: this.emitter._isAnimated(),
                        animTexLoop: this.emitter.animLoop,
                        pack8: this.emitter.pack8,
                        customFace: this.emitter.orientation !== u.d3,
                      },
                      ue
                    );
                  }),
                  (this.material.shader = this.material.getShaderVariant());
              }
              resetMaterial() {
                const Ae = this.material;
                Ae.setParameter("stretch", this.stretch),
                  this._isAnimated() &&
                    (Ae.setParameter(
                      "animTexTilesParams",
                      this.animTilesParams
                    ),
                    Ae.setParameter("animTexParams", this.animParams),
                    Ae.setParameter(
                      "animTexIndexParams",
                      this.animIndexParams
                    )),
                  Ae.setParameter("colorMult", this.intensity),
                  this.useCpu ||
                    (Ae.setParameter("internalTex0", this.internalTex0),
                    Ae.setParameter("internalTex1", this.internalTex1),
                    Ae.setParameter("internalTex2", this.internalTex2),
                    Ae.setParameter("internalTex3", this.internalTex3)),
                  Ae.setParameter("colorParam", this.colorParam),
                  Ae.setParameter("numParticles", this.numParticles),
                  Ae.setParameter("numParticlesPot", this.numParticlesPot),
                  Ae.setParameter("lifetime", this.lifetime),
                  Ae.setParameter("rate", this.rate),
                  Ae.setParameter("rateDiv", this.rate2 - this.rate),
                  Ae.setParameter("seed", this.seed),
                  Ae.setParameter("scaleDivMult", this.scaleUMax[0]),
                  Ae.setParameter("alphaDivMult", this.alphaUMax[0]),
                  Ae.setParameter(
                    "radialSpeedDivMult",
                    this.radialSpeedUMax[0]
                  ),
                  Ae.setParameter("graphNumSamples", this.precision),
                  Ae.setParameter("graphSampleSize", 1 / this.precision),
                  Ae.setParameter("emitterScale", new Float32Array([1, 1, 1])),
                  this.pack8 &&
                    (this._gpuUpdater._setInputBounds(),
                    Ae.setParameter(
                      "inBoundsSize",
                      this._gpuUpdater.inBoundsSizeUniform
                    ),
                    Ae.setParameter(
                      "inBoundsCenter",
                      this._gpuUpdater.inBoundsCenterUniform
                    ),
                    Ae.setParameter("maxVel", this.maxVel)),
                  this.wrap &&
                    this.wrapBounds &&
                    ((this.wrapBoundsUniform[0] = this.wrapBounds.x),
                    (this.wrapBoundsUniform[1] = this.wrapBounds.y),
                    (this.wrapBoundsUniform[2] = this.wrapBounds.z),
                    Ae.setParameter("wrapBounds", this.wrapBoundsUniform)),
                  this.colorMap && Ae.setParameter("colorMap", this.colorMap),
                  this.lighting &&
                    this.normalMap &&
                    Ae.setParameter("normalMap", this.normalMap),
                  this.depthSoftening > 0 &&
                    Ae.setParameter(
                      "softening",
                      1 / (this.depthSoftening * this.depthSoftening * 100)
                    ),
                  this.stretch > 0 && (Ae.cull = s.OL2),
                  this._compParticleFaceParams();
              }
              _compParticleFaceParams() {
                let Ae, Xe;
                if (this.orientation === u.d3)
                  (Ae = new Float32Array([1, 0, 0])),
                    (Xe = new Float32Array([0, 0, 1]));
                else {
                  let Ye;
                  this.orientation === u.GS
                    ? (Ye = this.particleNormal.normalize())
                    : (Ye = (
                        this.node === null
                          ? g.y.IDENTITY
                          : this.node.getWorldTransform()
                      )
                        .transformVector(this.particleNormal)
                        .normalize());
                  const it = new h.A(1, 0, 0);
                  Math.abs(it.dot(Ye)) === 1 && it.set(0, 0, 1);
                  const st = new h.A().cross(Ye, it).normalize();
                  it.cross(st, Ye).normalize(),
                    (Ae = new Float32Array([it.x, it.y, it.z])),
                    (Xe = new Float32Array([st.x, st.y, st.z]));
                }
                this.material.setParameter("faceTangent", Ae),
                  this.material.setParameter("faceBinorm", Xe);
              }
              _allocate(Ae) {
                const Xe = Ae * this.numParticleVerts,
                  Ye = Ae * this.numParticleIndices;
                if (
                  this.vertexBuffer === void 0 ||
                  this.vertexBuffer.getNumVertices() !== Xe
                ) {
                  if (this.useCpu) {
                    const fe = [
                        { semantic: s.CNh, components: 4, type: s.r8O },
                        { semantic: s.x5T, components: 4, type: s.r8O },
                        { semantic: s.PBu, components: 4, type: s.r8O },
                        { semantic: s.PFm, components: 1, type: s.r8O },
                        {
                          semantic: s.LFx,
                          components: this.useMesh ? 4 : 2,
                          type: s.r8O,
                        },
                      ],
                      Ie = new t.g(this.graphicsDevice, fe);
                    (this.vertexBuffer = new e.o(
                      this.graphicsDevice,
                      Ie,
                      Xe,
                      s.AHc
                    )),
                      (this.indexBuffer = new n.G(
                        this.graphicsDevice,
                        s.q0F,
                        Ye
                      ));
                  } else {
                    const fe = [
                      { semantic: s.CNh, components: 4, type: s.r8O },
                    ];
                    this.useMesh &&
                      fe.push({ semantic: s.x5T, components: 2, type: s.r8O });
                    const Ie = new t.g(this.graphicsDevice, fe);
                    (this.vertexBuffer = new e.o(
                      this.graphicsDevice,
                      Ie,
                      Xe,
                      s.AHc
                    )),
                      (this.indexBuffer = new n.G(
                        this.graphicsDevice,
                        s.q0F,
                        Ye
                      ));
                  }
                  const it = new Float32Array(this.vertexBuffer.lock());
                  let st, He, at;
                  if (this.useMesh) {
                    (st = new Float32Array(this.mesh.vertexBuffer.lock())),
                      (He = st.length / this.mesh.vertexBuffer.numVertices);
                    for (
                      let fe = 0;
                      fe < this.mesh.vertexBuffer.format.elements.length;
                      fe++
                    )
                      if (
                        this.mesh.vertexBuffer.format.elements[fe].name ===
                        s.$fY
                      ) {
                        at =
                          this.mesh.vertexBuffer.format.elements[fe].offset / 4;
                        break;
                      }
                  }
                  for (let fe = 0; fe < Xe; fe++) {
                    const Ie = Math.floor(fe / this.numParticleVerts);
                    if (this.useMesh) {
                      const ue = fe % this.numParticleVerts;
                      (it[fe * 6] = st[ue * He]),
                        (it[fe * 6 + 1] = st[ue * He + 1]),
                        (it[fe * 6 + 2] = st[ue * He + 2]),
                        (it[fe * 6 + 3] = Ie),
                        (it[fe * 6 + 4] = st[ue * He + at + 0]),
                        (it[fe * 6 + 5] = 1 - st[ue * He + at + 1]);
                    } else {
                      const ue = fe % 4;
                      (it[fe * 4] = Re[ue][0]),
                        (it[fe * 4 + 1] = Re[ue][1]),
                        (it[fe * 4 + 2] = 0),
                        (it[fe * 4 + 3] = Ie);
                    }
                  }
                  this.useCpu &&
                    ((this.vbCPU = new Float32Array(it)),
                    (this.vbOld = new Float32Array(this.vbCPU.length))),
                    this.vertexBuffer.unlock(),
                    this.useMesh && this.mesh.vertexBuffer.unlock();
                  let Pt = 0;
                  const he = new Uint16Array(this.indexBuffer.lock());
                  this.useMesh &&
                    (st = new Uint16Array(this.mesh.indexBuffer[0].lock()));
                  for (let fe = 0; fe < Ae; fe++)
                    if (this.useMesh)
                      for (let Ie = 0; Ie < this.numParticleIndices; Ie++)
                        he[fe * this.numParticleIndices + Ie] =
                          st[Ie] + fe * this.numParticleVerts;
                    else {
                      const Ie = fe * 4;
                      (he[Pt++] = Ie),
                        (he[Pt++] = Ie + 1),
                        (he[Pt++] = Ie + 2),
                        (he[Pt++] = Ie),
                        (he[Pt++] = Ie + 2),
                        (he[Pt++] = Ie + 3);
                    }
                  this.indexBuffer.unlock(),
                    this.useMesh && this.mesh.indexBuffer[0].unlock();
                }
              }
              reset() {
                if (
                  ((this.beenReset = !0),
                  (this.seed = Math.random()),
                  this.material.setParameter("seed", this.seed),
                  this.useCpu)
                )
                  for (let Xe = 0; Xe < this.particleTexStart.length; Xe++)
                    this.particleTex[Xe] = this.particleTexStart[Xe];
                else this._initializeTextures();
                this.resetWorldBounds(), this.resetTime();
                const Ae = this.loop;
                (this.loop = !0),
                  this.addTime(0, !1),
                  (this.loop = Ae),
                  this.preWarm && this.prewarm(this.lifetime);
              }
              prewarm(Ae) {
                const Xe = Ae / this.lifetime,
                  Ye = Math.min(
                    Math.floor(Xe * this.precision),
                    this.precision
                  ),
                  it = Ae / Ye;
                for (let st = 0; st < Ye; st++) this.addTime(it, !1);
              }
              resetTime() {
                this.endTime = Mt(this);
              }
              finishFrame() {
                this.useCpu && this.vertexBuffer.unlock();
              }
              addTime(Ae, Xe) {
                const Ye = this.graphicsDevice;
                if (
                  ((this.simTimeTotal += Ae),
                  this.calculateWorldBounds(),
                  this._isAnimated())
                ) {
                  const He = this.animTilesParams;
                  (He[0] = 1 / this.animTilesX), (He[1] = 1 / this.animTilesY);
                  const at = this.animParams;
                  (at[0] = this.animStartFrame),
                    (at[1] = this.animNumFrames * this.animSpeed),
                    (at[2] = this.animNumFrames - 1),
                    (at[3] = this.animNumAnimations - 1);
                  const Pt = this.animIndexParams;
                  (Pt[0] = this.animIndex), (Pt[1] = this.randomizeAnimIndex);
                }
                this.scene &&
                  this.camera !== this.scene._activeCamera &&
                  ((this.camera = this.scene._activeCamera),
                  this.onChangeCamera()),
                  this.emitterShape === u.EB &&
                    ((Ee[0] =
                      this.emitterExtents.x !== 0
                        ? this.emitterExtentsInner.x / this.emitterExtents.x
                        : 0),
                    (Ee[1] =
                      this.emitterExtents.y !== 0
                        ? this.emitterExtentsInner.y / this.emitterExtents.y
                        : 0),
                    (Ee[2] =
                      this.emitterExtents.z !== 0
                        ? this.emitterExtentsInner.z / this.emitterExtents.z
                        : 0),
                    this.meshInstance.node === null
                      ? G.setTRS(h.A.ZERO, d.D.IDENTITY, this.emitterExtents)
                      : G.setTRS(
                          h.A.ZERO,
                          this.meshInstance.node.getRotation(),
                          Q.copy(this.emitterExtents).mul(
                            this.meshInstance.node.localScale
                          )
                        ));
                let it;
                const st =
                  this.meshInstance.node === null
                    ? h.A.ONE
                    : this.meshInstance.node.localScale;
                if (
                  ((this.emitterScaleUniform[0] = st.x),
                  (this.emitterScaleUniform[1] = st.y),
                  (this.emitterScaleUniform[2] = st.z),
                  this.material.setParameter(
                    "emitterScale",
                    this.emitterScaleUniform
                  ),
                  this.localSpace &&
                    this.meshInstance.node &&
                    ((it = this.meshInstance.node.getPosition()),
                    (this.emitterPosUniform[0] = it.x),
                    (this.emitterPosUniform[1] = it.y),
                    (this.emitterPosUniform[2] = it.z),
                    this.material.setParameter(
                      "emitterPos",
                      this.emitterPosUniform
                    )),
                  this._compParticleFaceParams(),
                  !this.useCpu)
                )
                  this._gpuUpdater.update(Ye, G, Ee, Ae, Xe);
                else {
                  const He = new Float32Array(this.vertexBuffer.lock());
                  this._cpuUpdater.update(
                    He,
                    this.vbToSort,
                    this.particleTex,
                    G,
                    Ee,
                    it,
                    Ae,
                    Xe
                  );
                }
                this.loop ||
                  (Date.now() > this.endTime &&
                    (this.onFinished && this.onFinished(),
                    (this.meshInstance.visible = !1))),
                  this.meshInstance &&
                    (this.meshInstance.drawOrder = this.drawOrder);
              }
              _destroyResources() {
                this.particleTexIN &&
                  (this.particleTexIN.destroy(), (this.particleTexIN = null)),
                  this.particleTexOUT &&
                    (this.particleTexOUT.destroy(),
                    (this.particleTexOUT = null)),
                  this.particleTexStart &&
                    this.particleTexStart.destroy &&
                    (this.particleTexStart.destroy(),
                    (this.particleTexStart = null)),
                  this.rtParticleTexIN &&
                    (this.rtParticleTexIN.destroy(),
                    (this.rtParticleTexIN = null)),
                  this.rtParticleTexOUT &&
                    (this.rtParticleTexOUT.destroy(),
                    (this.rtParticleTexOUT = null)),
                  this.internalTex0 &&
                    (this.internalTex0.destroy(), (this.internalTex0 = null)),
                  this.internalTex1 &&
                    (this.internalTex1.destroy(), (this.internalTex1 = null)),
                  this.internalTex2 &&
                    (this.internalTex2.destroy(), (this.internalTex2 = null)),
                  this.internalTex3 &&
                    (this.internalTex3.destroy(), (this.internalTex3 = null)),
                  this.colorParam &&
                    (this.colorParam.destroy(), (this.colorParam = null)),
                  this.vertexBuffer &&
                    (this.vertexBuffer.destroy(), (this.vertexBuffer = void 0)),
                  this.indexBuffer &&
                    (this.indexBuffer.destroy(), (this.indexBuffer = void 0)),
                  this.material &&
                    (this.material.destroy(), (this.material = null));
              }
              destroy() {
                (this.camera = null), this._destroyResources();
              }
            }
          },
          4611: (Se, W, a) => {
            "use strict";
            a.d(W, {
              $R: () => u,
              $r: () => _,
              $w: () => o,
              JL: () => t,
              Ns: () => n,
              VD: () => r,
              Y: () => e,
              bF: () => l,
              dO: () => p,
              hu: () => s,
              j6: () => y,
            });
            var x = a(2978),
              T = a(6556),
              g = a(7921),
              c = a(7678);
            const d = 4 / 64,
              h = 1 - d * 2,
              f = [];
            function s(m, E) {
              const v = E.length / 3,
                P = m.length / 3,
                I = new T.A(),
                A = new T.A(),
                B = new T.A(),
                C = new T.A(),
                w = new T.A(),
                k = new T.A(),
                K = [];
              for (let te = 0; te < m.length; te++) K[te] = 0;
              for (let te = 0; te < v; te++) {
                const X = E[te * 3],
                  $ = E[te * 3 + 1],
                  ne = E[te * 3 + 2];
                I.set(m[X * 3], m[X * 3 + 1], m[X * 3 + 2]),
                  A.set(m[$ * 3], m[$ * 3 + 1], m[$ * 3 + 2]),
                  B.set(m[ne * 3], m[ne * 3 + 1], m[ne * 3 + 2]),
                  C.sub2(A, I),
                  w.sub2(B, I),
                  k.cross(C, w).normalize(),
                  (K[X * 3] += k.x),
                  (K[X * 3 + 1] += k.y),
                  (K[X * 3 + 2] += k.z),
                  (K[$ * 3] += k.x),
                  (K[$ * 3 + 1] += k.y),
                  (K[$ * 3 + 2] += k.z),
                  (K[ne * 3] += k.x),
                  (K[ne * 3 + 1] += k.y),
                  (K[ne * 3 + 2] += k.z);
              }
              for (let te = 0; te < P; te++) {
                const X = K[te * 3],
                  $ = K[te * 3 + 1],
                  ne = K[te * 3 + 2],
                  Y = 1 / Math.sqrt(X * X + $ * $ + ne * ne);
                (K[te * 3] *= Y), (K[te * 3 + 1] *= Y), (K[te * 3 + 2] *= Y);
              }
              return K;
            }
            function l(m, E, v, P) {
              const I = P.length / 3,
                A = m.length / 3,
                B = new T.A(),
                C = new T.A(),
                w = new T.A(),
                k = new x.S(),
                K = new x.S(),
                te = new x.S(),
                X = new T.A(),
                $ = new T.A(),
                ne = new Float32Array(A * 3),
                Y = new Float32Array(A * 3),
                Z = [];
              for (let N = 0; N < I; N++) {
                const V = P[N * 3],
                  L = P[N * 3 + 1],
                  J = P[N * 3 + 2];
                B.set(m[V * 3], m[V * 3 + 1], m[V * 3 + 2]),
                  C.set(m[L * 3], m[L * 3 + 1], m[L * 3 + 2]),
                  w.set(m[J * 3], m[J * 3 + 1], m[J * 3 + 2]),
                  k.set(v[V * 2], v[V * 2 + 1]),
                  K.set(v[L * 2], v[L * 2 + 1]),
                  te.set(v[J * 2], v[J * 2 + 1]);
                const ae = C.x - B.x,
                  R = w.x - B.x,
                  j = C.y - B.y,
                  se = w.y - B.y,
                  ce = C.z - B.z,
                  ie = w.z - B.z,
                  b = K.x - k.x,
                  M = te.x - k.x,
                  F = K.y - k.y,
                  z = te.y - k.y,
                  oe = b * z - M * F;
                if (oe === 0) X.set(0, 1, 0), $.set(1, 0, 0);
                else {
                  const de = 1 / oe;
                  X.set(
                    (z * ae - F * R) * de,
                    (z * j - F * se) * de,
                    (z * ce - F * ie) * de
                  ),
                    $.set(
                      (b * R - M * ae) * de,
                      (b * se - M * j) * de,
                      (b * ie - M * ce) * de
                    );
                }
                (ne[V * 3 + 0] += X.x),
                  (ne[V * 3 + 1] += X.y),
                  (ne[V * 3 + 2] += X.z),
                  (ne[L * 3 + 0] += X.x),
                  (ne[L * 3 + 1] += X.y),
                  (ne[L * 3 + 2] += X.z),
                  (ne[J * 3 + 0] += X.x),
                  (ne[J * 3 + 1] += X.y),
                  (ne[J * 3 + 2] += X.z),
                  (Y[V * 3 + 0] += $.x),
                  (Y[V * 3 + 1] += $.y),
                  (Y[V * 3 + 2] += $.z),
                  (Y[L * 3 + 0] += $.x),
                  (Y[L * 3 + 1] += $.y),
                  (Y[L * 3 + 2] += $.z),
                  (Y[J * 3 + 0] += $.x),
                  (Y[J * 3 + 1] += $.y),
                  (Y[J * 3 + 2] += $.z);
              }
              const ye = new T.A(),
                pe = new T.A(),
                O = new T.A(),
                me = new T.A();
              for (let N = 0; N < A; N++) {
                O.set(E[N * 3], E[N * 3 + 1], E[N * 3 + 2]),
                  ye.set(ne[N * 3], ne[N * 3 + 1], ne[N * 3 + 2]),
                  pe.set(Y[N * 3], Y[N * 3 + 1], Y[N * 3 + 2]);
                const V = O.dot(ye);
                me.copy(O).mulScalar(V),
                  me.sub2(ye, me).normalize(),
                  (Z[N * 4] = me.x),
                  (Z[N * 4 + 1] = me.y),
                  (Z[N * 4 + 2] = me.z),
                  me.cross(O, ye),
                  (Z[N * 4 + 3] = me.dot(pe) < 0 ? -1 : 1);
              }
              return Z;
            }
            function n(m, E, v) {
              const P = new c.K(m);
              return (
                P.setPositions(E),
                v &&
                  (v.normals && P.setNormals(v.normals),
                  v.tangents && P.setVertexStream(g.ipN, v.tangents, 4),
                  v.colors && P.setColors32(v.colors),
                  v.uvs && P.setUvs(0, v.uvs),
                  v.uvs1 && P.setUvs(1, v.uvs1),
                  v.blendIndices &&
                    P.setVertexStream(
                      g.MgX,
                      v.blendIndices,
                      4,
                      v.blendIndices.length / 4,
                      g.vyI
                    ),
                  v.blendWeights && P.setVertexStream(g.d1j, v.blendWeights, 4),
                  v.indices && P.setIndices(v.indices)),
                P.update(),
                P
              );
            }
            function o(m, E = {}) {
              var v, P, I, A, B;
              const C = (v = E.tubeRadius) != null ? v : 0.2,
                w = (P = E.ringRadius) != null ? P : 0.3,
                k = (I = E.segments) != null ? I : 30,
                K = (A = E.sides) != null ? A : 20,
                te = (B = E.calculateTangents) != null ? B : !1,
                X = [],
                $ = [],
                ne = [],
                Y = [];
              for (let ye = 0; ye <= K; ye++)
                for (let pe = 0; pe <= k; pe++) {
                  const O =
                      Math.cos((2 * Math.PI * pe) / k) *
                      (w + C * Math.cos((2 * Math.PI * ye) / K)),
                    me = Math.sin((2 * Math.PI * ye) / K) * C,
                    N =
                      Math.sin((2 * Math.PI * pe) / k) *
                      (w + C * Math.cos((2 * Math.PI * ye) / K)),
                    V =
                      Math.cos((2 * Math.PI * pe) / k) *
                      Math.cos((2 * Math.PI * ye) / K),
                    L = Math.sin((2 * Math.PI * ye) / K),
                    J =
                      Math.sin((2 * Math.PI * pe) / k) *
                      Math.cos((2 * Math.PI * ye) / K),
                    ae = ye / K,
                    R = 1 - pe / k;
                  if (
                    (X.push(O, me, N),
                    $.push(V, L, J),
                    ne.push(ae, 1 - R),
                    ye < K && pe < k)
                  ) {
                    const j = ye * (k + 1) + pe,
                      se = (ye + 1) * (k + 1) + pe,
                      ce = ye * (k + 1) + (pe + 1),
                      ie = (ye + 1) * (k + 1) + (pe + 1);
                    Y.push(j, se, ce), Y.push(se, ie, ce);
                  }
                }
              const Z = { normals: $, uvs: ne, uvs1: ne, indices: Y };
              return te && (Z.tangents = l(X, $, ne, Y)), n(m, X, Z);
            }
            function i(m, E, v, P, I, A) {
              const B = new T.A(),
                C = new T.A(),
                w = new T.A(),
                k = new T.A(),
                K = new T.A(),
                te = new T.A(),
                X = [],
                $ = [],
                ne = [],
                Y = [],
                Z = [];
              let ye;
              if (v > 0)
                for (let pe = 0; pe <= P; pe++)
                  for (let O = 0; O <= I; O++) {
                    const me = (O / I) * 2 * Math.PI - Math.PI,
                      N = Math.sin(me),
                      V = Math.cos(me);
                    K.set(N * m, -v / 2, V * m),
                      k.set(N * E, v / 2, V * E),
                      B.lerp(K, k, pe / P),
                      C.sub2(k, K).normalize(),
                      te.set(V, 0, -N),
                      w.cross(te, C).normalize(),
                      X.push(B.x, B.y, B.z),
                      $.push(w.x, w.y, w.z);
                    let L = O / I,
                      J = pe / P;
                    ne.push(L, 1 - J);
                    const ae = J;
                    if (
                      ((J = L),
                      (L = ae),
                      (L = L * h + d),
                      (J = J * h + d),
                      (L /= 3),
                      Y.push(L, 1 - J),
                      pe < P && O < I)
                    ) {
                      const R = pe * (I + 1) + O,
                        j = pe * (I + 1) + (O + 1),
                        se = (pe + 1) * (I + 1) + O,
                        ce = (pe + 1) * (I + 1) + (O + 1);
                      Z.push(R, j, se), Z.push(j, ce, se);
                    }
                  }
              if (A) {
                const pe = Math.floor(I / 2),
                  O = I,
                  me = v / 2;
                for (let N = 0; N <= pe; N++) {
                  const V = (N * Math.PI * 0.5) / pe,
                    L = Math.sin(V),
                    J = Math.cos(V);
                  for (let ae = 0; ae <= O; ae++) {
                    const R = (ae * 2 * Math.PI) / O - Math.PI / 2,
                      j = Math.sin(R),
                      ce = Math.cos(R) * L,
                      ie = J,
                      b = j * L;
                    let M = 1 - ae / O,
                      F = 1 - N / pe;
                    X.push(ce * E, ie * E + me, b * E),
                      $.push(ce, ie, b),
                      ne.push(M, 1 - F),
                      (M = M * h + d),
                      (F = F * h + d),
                      (M /= 3),
                      (F /= 3),
                      (M += 0.3333333333333333),
                      Y.push(M, 1 - F);
                  }
                }
                ye = (P + 1) * (I + 1);
                for (let N = 0; N < pe; ++N)
                  for (let V = 0; V < O; ++V) {
                    const L = N * (O + 1) + V,
                      J = L + O + 1;
                    Z.push(ye + L + 1, ye + J, ye + L),
                      Z.push(ye + L + 1, ye + J + 1, ye + J);
                  }
                for (let N = 0; N <= pe; N++) {
                  const V = Math.PI * 0.5 + (N * Math.PI * 0.5) / pe,
                    L = Math.sin(V),
                    J = Math.cos(V);
                  for (let ae = 0; ae <= O; ae++) {
                    const R = (ae * 2 * Math.PI) / O - Math.PI / 2,
                      j = Math.sin(R),
                      ce = Math.cos(R) * L,
                      ie = J,
                      b = j * L;
                    let M = 1 - ae / O,
                      F = 1 - N / pe;
                    X.push(ce * E, ie * E - me, b * E),
                      $.push(ce, ie, b),
                      ne.push(M, 1 - F),
                      (M = M * h + d),
                      (F = F * h + d),
                      (M /= 3),
                      (F /= 3),
                      (M += 0.6666666666666666),
                      Y.push(M, 1 - F);
                  }
                }
                ye = (P + 1) * (I + 1) + (O + 1) * (pe + 1);
                for (let N = 0; N < pe; ++N)
                  for (let V = 0; V < O; ++V) {
                    const L = N * (O + 1) + V,
                      J = L + O + 1;
                    Z.push(ye + L + 1, ye + J, ye + L),
                      Z.push(ye + L + 1, ye + J + 1, ye + J);
                  }
              } else {
                if (((ye = (P + 1) * (I + 1)), m > 0))
                  for (let pe = 0; pe < I; pe++) {
                    const O = (pe / I) * 2 * Math.PI,
                      me = Math.sin(O),
                      N = -v / 2,
                      V = Math.cos(O);
                    let L = 1 - (me + 1) / 2,
                      J = (V + 1) / 2;
                    X.push(me * m, N, V * m),
                      $.push(0, -1, 0),
                      ne.push(L, 1 - J),
                      (L = L * h + d),
                      (J = J * h + d),
                      (L /= 3),
                      (J /= 3),
                      (L += 0.3333333333333333),
                      Y.push(L, 1 - J),
                      pe > 1 && Z.push(ye, ye + pe, ye + pe - 1);
                  }
                if (((ye += I), E > 0))
                  for (let pe = 0; pe < I; pe++) {
                    const O = (pe / I) * 2 * Math.PI,
                      me = Math.sin(O),
                      N = v / 2,
                      V = Math.cos(O);
                    let L = 1 - (me + 1) / 2,
                      J = (V + 1) / 2;
                    X.push(me * E, N, V * E),
                      $.push(0, 1, 0),
                      ne.push(L, 1 - J),
                      (L = L * h + d),
                      (J = J * h + d),
                      (L /= 3),
                      (J /= 3),
                      (L += 0.6666666666666666),
                      Y.push(L, 1 - J),
                      pe > 1 && Z.push(ye, ye + pe - 1, ye + pe);
                  }
              }
              return { positions: X, normals: $, uvs: ne, uvs1: Y, indices: Z };
            }
            function e(m, E = {}) {
              var v, P, I, A, B;
              const C = (v = E.radius) != null ? v : 0.5,
                w = (P = E.height) != null ? P : 1,
                k = (I = E.heightSegments) != null ? I : 5,
                K = (A = E.capSegments) != null ? A : 20,
                te = (B = E.calculateTangents) != null ? B : !1,
                X = i(C, C, w, k, K, !1);
              return (
                te &&
                  (X.tangents = l(X.positions, X.normals, X.uvs, X.indices)),
                n(m, X.positions, X)
              );
            }
            function t(m, E = {}) {
              var v, P, I, A, B;
              const C = (v = E.radius) != null ? v : 0.3,
                w = (P = E.height) != null ? P : 1,
                k = (I = E.heightSegments) != null ? I : 1,
                K = (A = E.sides) != null ? A : 20,
                te = (B = E.calculateTangents) != null ? B : !1,
                X = i(C, C, w - 2 * C, k, K, !0);
              return (
                te &&
                  (X.tangents = l(X.positions, X.normals, X.uvs, X.indices)),
                n(m, X.positions, X)
              );
            }
            function r(m, E = {}) {
              var v, P, I, A, B, C;
              const w = (v = E.baseRadius) != null ? v : 0.5,
                k = (P = E.peakRadius) != null ? P : 0,
                K = (I = E.height) != null ? I : 1,
                te = (A = E.heightSegments) != null ? A : 5,
                X = (B = E.capSegments) != null ? B : 18,
                $ = (C = E.calculateTangents) != null ? C : !1,
                ne = i(w, k, K, te, X, !1);
              return (
                $ &&
                  (ne.tangents = l(
                    ne.positions,
                    ne.normals,
                    ne.uvs,
                    ne.indices
                  )),
                n(m, ne.positions, ne)
              );
            }
            function u(m, E = {}) {
              var v, P, I, A;
              const B = (v = E.radius) != null ? v : 0.5,
                C = (P = E.latitudeBands) != null ? P : 16,
                w = (I = E.longitudeBands) != null ? I : 16,
                k = (A = E.calculateTangents) != null ? A : !1,
                K = [],
                te = [],
                X = [],
                $ = [];
              for (let Y = 0; Y <= C; Y++) {
                const Z = (Y * Math.PI) / C,
                  ye = Math.sin(Z),
                  pe = Math.cos(Z);
                for (let O = 0; O <= w; O++) {
                  const me = (O * 2 * Math.PI) / w - Math.PI / 2,
                    N = Math.sin(me),
                    L = Math.cos(me) * ye,
                    J = pe,
                    ae = N * ye,
                    R = 1 - O / w,
                    j = 1 - Y / C;
                  K.push(L * B, J * B, ae * B),
                    te.push(L, J, ae),
                    X.push(R, 1 - j);
                }
              }
              for (let Y = 0; Y < C; ++Y)
                for (let Z = 0; Z < w; ++Z) {
                  const ye = Y * (w + 1) + Z,
                    pe = ye + w + 1;
                  $.push(ye + 1, pe, ye), $.push(ye + 1, pe + 1, pe);
                }
              const ne = { normals: te, uvs: X, uvs1: X, indices: $ };
              return k && (ne.tangents = l(K, te, X, $)), n(m, K, ne);
            }
            function y(m, E = {}) {
              var v, P, I, A;
              const B = (v = E.halfExtents) != null ? v : new x.S(0.5, 0.5),
                C = (P = E.widthSegments) != null ? P : 5,
                w = (I = E.lengthSegments) != null ? I : 5,
                k = (A = E.calculateTangents) != null ? A : !1,
                K = [],
                te = [],
                X = [],
                $ = [];
              let ne = 0;
              for (let Z = 0; Z <= C; Z++)
                for (let ye = 0; ye <= w; ye++) {
                  const pe = -B.x + (2 * B.x * Z) / C,
                    O = 0,
                    me = -(-B.y + (2 * B.y * ye) / w),
                    N = Z / C,
                    V = ye / w;
                  K.push(pe, O, me),
                    te.push(0, 1, 0),
                    X.push(N, 1 - V),
                    Z < C &&
                      ye < w &&
                      ($.push(ne + w + 1, ne + 1, ne),
                      $.push(ne + w + 1, ne + w + 2, ne + 1)),
                    ne++;
                }
              const Y = { normals: te, uvs: X, uvs1: X, indices: $ };
              return k && (Y.tangents = l(K, te, X, $)), n(m, K, Y);
            }
            function p(m, E = {}) {
              var v, P, I, A, B;
              const C =
                  (v = E.halfExtents) != null ? v : new T.A(0.5, 0.5, 0.5),
                w = (P = E.widthSegments) != null ? P : 1,
                k = (I = E.lengthSegments) != null ? I : 1,
                K = (A = E.heightSegments) != null ? A : 1,
                te = (B = E.calculateTangents) != null ? B : !1,
                X = [
                  new T.A(-C.x, -C.y, C.z),
                  new T.A(C.x, -C.y, C.z),
                  new T.A(C.x, C.y, C.z),
                  new T.A(-C.x, C.y, C.z),
                  new T.A(C.x, -C.y, -C.z),
                  new T.A(-C.x, -C.y, -C.z),
                  new T.A(-C.x, C.y, -C.z),
                  new T.A(C.x, C.y, -C.z),
                ],
                $ = [
                  [0, 1, 3],
                  [4, 5, 7],
                  [3, 2, 6],
                  [1, 0, 4],
                  [1, 4, 2],
                  [5, 0, 6],
                ],
                ne = [
                  [0, 0, 1],
                  [0, 0, -1],
                  [0, 1, 0],
                  [0, -1, 0],
                  [1, 0, 0],
                  [-1, 0, 0],
                ],
                Y = { FRONT: 0, BACK: 1, TOP: 2, BOTTOM: 3, RIGHT: 4, LEFT: 5 },
                Z = [],
                ye = [],
                pe = [],
                O = [],
                me = [];
              let N = 0;
              const V = (J, ae, R) => {
                const j = new T.A(),
                  se = new T.A(),
                  ce = new T.A(),
                  ie = new T.A();
                for (let b = 0; b <= ae; b++)
                  for (let M = 0; M <= R; M++) {
                    j.lerp(X[$[J][0]], X[$[J][1]], b / ae),
                      se.lerp(X[$[J][0]], X[$[J][2]], M / R),
                      ce.sub2(se, X[$[J][0]]),
                      ie.add2(j, ce);
                    let F = b / ae,
                      z = M / R;
                    Z.push(ie.x, ie.y, ie.z),
                      ye.push(ne[J][0], ne[J][1], ne[J][2]),
                      pe.push(F, 1 - z),
                      (F = F * h + d),
                      (z = z * h + d),
                      (F /= 3),
                      (z /= 3),
                      (F += (J % 3) / 3),
                      (z += Math.floor(J / 3) / 3),
                      O.push(F, 1 - z),
                      b < ae &&
                        M < R &&
                        (me.push(N + R + 1, N + 1, N),
                        me.push(N + R + 1, N + R + 2, N + 1)),
                      N++;
                  }
              };
              V(Y.FRONT, w, K),
                V(Y.BACK, w, K),
                V(Y.TOP, w, k),
                V(Y.BOTTOM, w, k),
                V(Y.RIGHT, k, K),
                V(Y.LEFT, k, K);
              const L = { normals: ye, uvs: pe, uvs1: O, indices: me };
              return te && (L.tangents = l(Z, ye, pe, me)), n(m, Z, L);
            }
            function _(m, E) {
              let v = null;
              for (let P = 0; P < f.length; P++)
                f[P].type === E && f[P].device === m && (v = f[P].primData);
              if (!v) {
                let P, I;
                switch (E) {
                  case "box":
                    (P = p(m)),
                      (I = { x: 2, y: 2, z: 2, uv: 0.6666666666666666 });
                    break;
                  case "capsule":
                    (P = t(m, { radius: 0.5, height: 2 })),
                      (I = {
                        x: Math.PI * 2,
                        y: Math.PI,
                        z: Math.PI * 2,
                        uv: 0.5555555555555556,
                      });
                    break;
                  case "cone":
                    (P = r(m, { baseRadius: 0.5, peakRadius: 0, height: 1 })),
                      (I = {
                        x: 2.54,
                        y: 2.54,
                        z: 2.54,
                        uv: 0.4444444444444444,
                      });
                    break;
                  case "cylinder":
                    (P = e(m, { radius: 0.5, height: 1 })),
                      (I = {
                        x: Math.PI,
                        y: 1.58,
                        z: Math.PI,
                        uv: 0.5555555555555556,
                      });
                    break;
                  case "plane":
                    (P = y(m, {
                      halfExtents: new x.S(0.5, 0.5),
                      widthSegments: 1,
                      lengthSegments: 1,
                    })),
                      (I = { x: 0, y: 1, z: 0, uv: 1 });
                    break;
                  case "sphere":
                    (P = u(m, { radius: 0.5 })),
                      (I = { x: Math.PI, y: Math.PI, z: Math.PI, uv: 1 });
                    break;
                  case "torus":
                    (P = o(m, { tubeRadius: 0.2, ringRadius: 0.3 })),
                      (I = {
                        x: Math.PI * 0.5 * 0.5 - Math.PI * 0.1 * 0.1,
                        y: 0.4,
                        z: 0.4,
                        uv: 1,
                      });
                    break;
                  default:
                    throw new Error("Invalid primitive type: " + E);
                }
                P.incRefCount(),
                  (v = { mesh: P, area: I }),
                  f.push({ type: E, device: m, primData: v });
              }
              return v;
            }
          },
          6598: (Se, W, a) => {
            "use strict";
            a.d(W, { H: () => T });
            var x = a(5338);
            class T extends x.b {
              constructor() {
                super(), (this._meshes = null);
              }
              set meshes(c) {
                this.decRefMeshes(),
                  (this._meshes = c),
                  this.incRefMeshes(),
                  this.fire("set:meshes", c);
              }
              get meshes() {
                return this._meshes;
              }
              destroy() {
                this.meshes = null;
              }
              decRefMeshes() {
                if (this._meshes) {
                  const c = this._meshes.length;
                  for (let d = 0; d < c; d++) {
                    const h = this._meshes[d];
                    h &&
                      (h.decRefCount(),
                      h.refCount < 1 &&
                        (h.destroy(), (this._meshes[d] = null)));
                  }
                }
              }
              incRefMeshes() {
                if (this._meshes) {
                  const c = this._meshes.length;
                  for (let d = 0; d < c; d++)
                    this._meshes[d] && this._meshes[d].incRefCount();
                }
              }
            }
          },
          4210: (Se, W, a) => {
            "use strict";
            a.d(W, { g: () => H });
            var x = a(6556),
              T = a(1367),
              g = a(2277),
              c = a(3114),
              d = a(4486),
              h = a(9758),
              f = a(4633),
              s = a(2978),
              l = a(6630),
              n = a(3412),
              o = a(7921),
              i = a(464),
              e = a(8869),
              t = a(9375),
              r = a(4279),
              u = a(8277);
            const y = `
		attribute vec2 vertex_position;
		varying vec2 uv0;
		void main(void) {
				gl_Position = vec4(vertex_position, 0.5, 1.0);
				uv0 = vertex_position.xy * 0.5 + 0.5;
				#ifndef WEBGPU
						uv0.y = 1.0 - uv0.y;
				#endif
		}`,
              p = `
		varying vec2 uv0;
		uniform sampler2D blitTexture;
		void main(void) {
				gl_FragColor = texture2D(blitTexture, uv0);
		}`,
              _ = `
		varying vec2 uv0;
		uniform samplerCube blitTexture;
		uniform mat4 invViewProj;
		void main(void) {
				vec4 projPos = vec4(uv0 * 2.0 - 1.0, 0.5, 1.0);
				vec4 worldPos = invViewProj * projPos;
				gl_FragColor = textureCube(blitTexture, worldPos.xyz);
		}`,
              m = new l.T();
            class E {
              constructor(G, Q) {
                (this.device = G),
                  (this.lightTextureAtlas = Q),
                  (this.blitShader2d = null),
                  (this.blitShaderCube = null),
                  (this.blitTextureId = null),
                  (this.invViewProjId = null);
              }
              destroy() {}
              getShader(G, Q) {
                return (
                  this[G] ||
                    (this[G] = (0, t.JM)(
                      this.device,
                      y,
                      Q,
                      `cookie_renderer_${G}`
                    )),
                  this.blitTextureId ||
                    (this.blitTextureId =
                      this.device.scope.resolve("blitTexture")),
                  this.invViewProjId ||
                    (this.invViewProjId =
                      this.device.scope.resolve("invViewProj")),
                  this[G]
                );
              }
              get shader2d() {
                return this.getShader("blitShader2d", p);
              }
              get shaderCube() {
                return this.getShader("blitShaderCube", _);
              }
              static createTexture(G, Q) {
                return new e.x(G, {
                  name: "CookieAtlas",
                  width: Q,
                  height: Q,
                  format: o.jKI,
                  cubemap: !1,
                  mipmaps: !1,
                  minFilter: o.yib,
                  magFilter: o.yib,
                  addressU: o.uFb,
                  addressV: o.uFb,
                });
              }
              initInvViewProjMatrices() {
                if (!E._invViewProjMatrices) {
                  E._invViewProjMatrices = [];
                  for (let G = 0; G < 6; G++) {
                    const Q = r.i.create(null, c.bA, G),
                      q = Q.projectionMatrix,
                      xe = Q.node.getLocalTransform().clone().invert();
                    E._invViewProjMatrices[G] = new h.y().mul2(q, xe).invert();
                  }
                }
              }
              render(G, Q) {
                if (G.enabled && G.cookie && G.visibleThisFrame) {
                  const q = G.numShadowFaces,
                    xe = q > 1 ? this.shaderCube : this.shader2d,
                    be = this.device;
                  q > 1 && this.initInvViewProjMatrices(),
                    this.blitTextureId.setValue(G.cookie),
                    be.setBlendState(u.a.NOBLEND);
                  for (let Pe = 0; Pe < q; Pe++) {
                    if ((m.copy(G.atlasViewport), q > 1)) {
                      const we = m.z / 3,
                        Oe = this.lightTextureAtlas.cubeSlotsOffsets[Pe];
                      (m.x += we * Oe.x),
                        (m.y += we * Oe.y),
                        (m.z = we),
                        (m.w = we),
                        this.invViewProjId.setValue(
                          E._invViewProjMatrices[Pe].data
                        );
                    }
                    m.mulScalar(Q.colorBuffer.width), (0, i.H)(be, Q, xe, m);
                  }
                }
              }
            }
            E._invViewProjMatrices = null;
            class v {
              constructor(G, Q) {
                (this.texture = G),
                  (this.cached = !1),
                  (this.renderTargets = Q);
              }
              destroy() {
                this.texture && (this.texture.destroy(), (this.texture = null));
                const G = this.renderTargets;
                for (let Q = 0; Q < G.length; Q++) G[Q].destroy();
                this.renderTargets.length = 0;
              }
              static getShadowFormat(G, Q) {
                return Q === c.oK
                  ? o.uC3
                  : Q === c.J7
                  ? o.a7f
                  : Q === c.sz ||
                    ((Q === c.sH || Q === c.iW) && G.supportsDepthShadow)
                  ? o.EFh
                  : Q === c.b3 && (G.webgl2 || G.isWebGPU)
                  ? o.DYM
                  : o.jKI;
              }
              static getShadowFiltering(G, Q) {
                return (Q === c.sH || Q === c.iW || Q === c.b3) &&
                  !G.supportsDepthShadow
                  ? o.yib
                  : Q === c.oK
                  ? G.extTextureFloatLinear
                    ? o.I5X
                    : o.yib
                  : Q === c.J7
                  ? G.extTextureHalfFloatLinear
                    ? o.I5X
                    : o.yib
                  : o.I5X;
              }
              static create(G, Q) {
                let q = null;
                return (
                  Q._type === c.bA
                    ? (q = this.createCubemap(
                        G,
                        Q._shadowResolution,
                        Q._shadowType
                      ))
                    : (q = this.create2dMap(
                        G,
                        Q._shadowResolution,
                        Q._shadowType
                      )),
                  q
                );
              }
              static createAtlas(G, Q, q) {
                const xe = this.create2dMap(G, Q, q),
                  be = xe.renderTargets,
                  Pe = be[0];
                for (let we = 0; we < 5; we++) be.push(Pe);
                return xe;
              }
              static create2dMap(G, Q, q) {
                const xe = this.getShadowFormat(G, q),
                  be = this.getShadowFiltering(G, q),
                  Pe = new e.x(G, {
                    format: xe,
                    width: Q,
                    height: Q,
                    mipmaps: !1,
                    minFilter: be,
                    magFilter: be,
                    addressU: o.uFb,
                    addressV: o.uFb,
                    name: "ShadowMap2D",
                  });
                let we = null;
                return (
                  q === c.sz ||
                  ((q === c.sH || q === c.iW) && G.supportsDepthShadow)
                    ? ((Pe.compareOnRead = !0),
                      (Pe.compareFunc = o.n9),
                      (we = new n.A({ depthBuffer: Pe })))
                    : (we = new n.A({ colorBuffer: Pe, depth: !0 })),
                  G.isWebGPU && (we.flipY = !0),
                  new v(Pe, [we])
                );
              }
              static createCubemap(G, Q, q) {
                const xe =
                    q === c.b3 && (G.webgl2 || G.isWebGPU) ? o.DYM : o.jKI,
                  be = new e.x(G, {
                    format: xe,
                    width: Q,
                    height: Q,
                    cubemap: !0,
                    mipmaps: !1,
                    minFilter: o.yib,
                    magFilter: o.yib,
                    addressU: o.uFb,
                    addressV: o.uFb,
                    name: "ShadowMapCube",
                  }),
                  Pe = [];
                for (let we = 0; we < 6; we++) {
                  const Oe = new n.A({ colorBuffer: be, face: we, depth: !0 });
                  Pe.push(Oe);
                }
                return new v(be, Pe);
              }
            }
            const P = [],
              I = [],
              A = new l.T(),
              B = new l.T();
            class C {
              constructor(G) {
                (this.size = Math.floor(G.w * 1024)),
                  (this.used = !1),
                  (this.lightId = -1),
                  (this.rect = G);
              }
            }
            class w {
              constructor(G) {
                (this.device = G),
                  (this.version = 1),
                  (this.shadowAtlasResolution = 2048),
                  (this.shadowAtlas = null),
                  (this.shadowEdgePixels = 3),
                  (this.cookieAtlasResolution = 2048),
                  (this.cookieAtlas = null),
                  (this.cookieRenderTarget = null),
                  (this.slots = []),
                  (this.atlasSplit = []),
                  (this.cubeSlotsOffsets = [
                    new s.S(0, 0),
                    new s.S(0, 1),
                    new s.S(1, 0),
                    new s.S(1, 1),
                    new s.S(2, 0),
                    new s.S(2, 1),
                  ]),
                  (this.scissorVec = new l.T()),
                  this.allocateShadowAtlas(1),
                  this.allocateCookieAtlas(1),
                  this.allocateUniforms();
              }
              destroy() {
                this.destroyShadowAtlas(), this.destroyCookieAtlas();
              }
              destroyShadowAtlas() {
                this.shadowAtlas &&
                  (this.shadowAtlas.destroy(), (this.shadowAtlas = null));
              }
              destroyCookieAtlas() {
                this.cookieAtlas &&
                  (this.cookieAtlas.destroy(), (this.cookieAtlas = null)),
                  this.cookieRenderTarget &&
                    (this.cookieRenderTarget.destroy(),
                    (this.cookieRenderTarget = null));
              }
              allocateShadowAtlas(G) {
                if (!this.shadowAtlas || this.shadowAtlas.texture.width !== G) {
                  this.version++,
                    this.destroyShadowAtlas(),
                    (this.shadowAtlas = v.createAtlas(this.device, G, c.iW)),
                    (this.shadowAtlas.cached = !0);
                  const Q = 4 / this.shadowAtlasResolution;
                  this.scissorVec.set(Q, Q, -2 * Q, -2 * Q);
                }
              }
              allocateCookieAtlas(G) {
                (!this.cookieAtlas || this.cookieAtlas.width !== G) &&
                  (this.version++,
                  this.destroyCookieAtlas(),
                  (this.cookieAtlas = E.createTexture(this.device, G)),
                  (this.cookieRenderTarget = new n.A({
                    colorBuffer: this.cookieAtlas,
                    depth: !1,
                    flipY: !0,
                  })));
              }
              allocateUniforms() {
                (this._shadowAtlasTextureId =
                  this.device.scope.resolve("shadowAtlasTexture")),
                  (this._shadowAtlasParamsId =
                    this.device.scope.resolve("shadowAtlasParams")),
                  (this._shadowAtlasParams = new Float32Array(2)),
                  (this._cookieAtlasTextureId =
                    this.device.scope.resolve("cookieAtlasTexture"));
              }
              updateUniforms() {
                const Q = this.shadowAtlas.renderTargets[0],
                  xe =
                    (this.device.isWebGPU || this.device.webgl2) && !0
                      ? Q.depthBuffer
                      : Q.colorBuffer;
                this._shadowAtlasTextureId.setValue(xe),
                  (this._shadowAtlasParams[0] = this.shadowAtlasResolution),
                  (this._shadowAtlasParams[1] = this.shadowEdgePixels),
                  this._shadowAtlasParamsId.setValue(this._shadowAtlasParams),
                  this._cookieAtlasTextureId.setValue(this.cookieAtlas);
              }
              subdivide(G, Q) {
                let q = Q.atlasSplit;
                if (!q) {
                  const be = Math.ceil(Math.sqrt(G));
                  (q = I), (q[0] = be), (q.length = 1);
                }
                if (
                  !((be, Pe) =>
                    be.length === Pe.length &&
                    be.every((we, Oe) => we === Pe[Oe]))(q, this.atlasSplit)
                ) {
                  this.version++,
                    (this.slots.length = 0),
                    (this.atlasSplit.length = 0),
                    this.atlasSplit.push(...q);
                  const be = this.atlasSplit[0];
                  if (be > 1) {
                    const Pe = 1 / be;
                    for (let we = 0; we < be; we++)
                      for (let Oe = 0; Oe < be; Oe++) {
                        const $e = new l.T(we * Pe, Oe * Pe, Pe, Pe),
                          gt = this.atlasSplit[1 + we * be + Oe];
                        if (gt > 1)
                          for (let qe = 0; qe < gt; qe++)
                            for (let Tt = 0; Tt < gt; Tt++) {
                              const Mt = Pe / gt,
                                Dt = new l.T(
                                  $e.x + qe * Mt,
                                  $e.y + Tt * Mt,
                                  Mt,
                                  Mt
                                );
                              this.slots.push(new C(Dt));
                            }
                        else this.slots.push(new C($e));
                      }
                  } else this.slots.push(new C(new l.T(0, 0, 1, 1)));
                  this.slots.sort((Pe, we) => we.size - Pe.size);
                }
              }
              collectLights(G, Q, q) {
                const xe = q.cookiesEnabled,
                  be = q.shadowsEnabled;
                let Pe = !1,
                  we = !1;
                const Oe = P;
                Oe.length = 0;
                const $e = (gt) => {
                  for (let qe = 0; qe < gt.length; qe++) {
                    const Tt = gt[qe];
                    if (Tt.visibleThisFrame) {
                      const Mt = be && Tt.castShadows,
                        Dt = xe && !!Tt.cookie;
                      Pe || (Pe = Mt),
                        we || (we = Dt),
                        (Mt || Dt) && Oe.push(Tt);
                    }
                  }
                };
                return (
                  (xe || be) && ($e(G), $e(Q)),
                  Oe.sort((gt, qe) => qe.maxScreenSize - gt.maxScreenSize),
                  Pe && this.allocateShadowAtlas(this.shadowAtlasResolution),
                  we && this.allocateCookieAtlas(this.cookieAtlasResolution),
                  (Pe || we) && this.subdivide(Oe.length, q),
                  Oe
                );
              }
              setupSlot(G, Q) {
                G.atlasViewport.copy(Q);
                const q = G.numShadowFaces;
                for (let xe = 0; xe < q; xe++)
                  if (G.castShadows || G._cookie) {
                    if (
                      (A.copy(Q),
                      B.copy(Q),
                      G._type === c.z0 && A.add(this.scissorVec),
                      G._type === c.bA)
                    ) {
                      const be = A.z / 3,
                        Pe = this.cubeSlotsOffsets[xe];
                      (A.x += be * Pe.x),
                        (A.y += be * Pe.y),
                        (A.z = be),
                        (A.w = be),
                        B.copy(A);
                    }
                    if (G.castShadows) {
                      const be = G.getRenderData(null, xe);
                      be.shadowViewport.copy(A), be.shadowScissor.copy(B);
                    }
                  }
              }
              assignSlot(G, Q, q) {
                G.atlasViewportAllocated = !0;
                const xe = this.slots[Q];
                (xe.lightId = G.id),
                  (xe.used = !0),
                  q &&
                    ((G.atlasSlotUpdated = !0),
                    (G.atlasVersion = this.version),
                    (G.atlasSlotIndex = Q));
              }
              update(G, Q, q) {
                (this.shadowAtlasResolution = q.shadowAtlasResolution),
                  (this.cookieAtlasResolution = q.cookieAtlasResolution);
                const xe = this.collectLights(G, Q, q);
                if (xe.length > 0) {
                  const be = this.slots;
                  for (let Oe = 0; Oe < be.length; Oe++) be[Oe].used = !1;
                  const Pe = Math.min(xe.length, be.length);
                  for (let Oe = 0; Oe < Pe; Oe++) {
                    const $e = xe[Oe];
                    $e.castShadows && ($e._shadowMap = this.shadowAtlas);
                    const gt = be[$e.atlasSlotIndex];
                    if (
                      $e.atlasVersion === this.version &&
                      $e.id === (gt == null ? void 0 : gt.lightId)
                    ) {
                      const qe = be[$e.atlasSlotIndex];
                      qe.size === be[Oe].size &&
                        !qe.used &&
                        this.assignSlot($e, $e.atlasSlotIndex, !1);
                    }
                  }
                  let we = 0;
                  for (let Oe = 0; Oe < Pe; Oe++) {
                    for (; we < be.length && be[we].used; ) we++;
                    const $e = xe[Oe];
                    $e.atlasViewportAllocated || this.assignSlot($e, we, !0);
                    const gt = be[$e.atlasSlotIndex];
                    this.setupSlot($e, gt.rect);
                  }
                }
                this.updateUniforms();
              }
            }
            var k = a(2737),
              K = a(4051),
              te = a(7008),
              X = a(289),
              $ = a(2158);
            class ne {
              constructor() {
                this.cache = new Map();
              }
              destroy() {
                this.clear(), (this.cache = null);
              }
              clear() {
                this.cache.forEach((G) => {
                  G.forEach((Q) => {
                    Q.destroy();
                  });
                }),
                  this.cache.clear();
              }
              getKey(G) {
                const Q = G._type === c.bA,
                  q = G._shadowType,
                  xe = G._shadowResolution;
                return `${Q}-${q}-${xe}`;
              }
              get(G, Q) {
                const q = this.getKey(Q),
                  xe = this.cache.get(q);
                if (xe && xe.length) return xe.pop();
                const be = v.create(G, Q);
                return (be.cached = !0), be;
              }
              add(G, Q) {
                const q = this.getKey(G),
                  xe = this.cache.get(q);
                xe ? xe.push(Q) : this.cache.set(q, [Q]);
              }
            }
            var Y = a(4585);
            class Z {
              constructor(G, Q) {
                (this.shadowLights = []),
                  (this.renderer = void 0),
                  (this.shadowRenderer = void 0),
                  (this.device = void 0),
                  (this.renderer = G),
                  (this.shadowRenderer = Q),
                  (this.device = G.device);
              }
              cull(G, Q) {
                const q = this.renderer.scene.clusteredLightingEnabled;
                (G.visibleThisFrame = !0),
                  q ||
                    G._shadowMap ||
                    (G._shadowMap = v.create(this.device, G));
                const xe = G._type,
                  be = xe === c.z0 ? 1 : 6;
                for (let Pe = 0; Pe < be; Pe++) {
                  const we = G.getRenderData(null, Pe),
                    Oe = we.shadowCamera;
                  (Oe.nearClip = G.attenuationEnd / 1e3),
                    (Oe.farClip = G.attenuationEnd),
                    (we.depthRangeCompensation = Oe.farClip - Oe.nearClip);
                  const $e = Oe._node,
                    gt = G._node;
                  if (($e.setPosition(gt.getPosition()), xe === c.z0))
                    (Oe.fov = G._outerConeAngle * 2),
                      $e.setRotation(gt.getRotation()),
                      $e.rotateLocal(-90, 0, 0);
                  else if (xe === c.bA)
                    if (q) {
                      const Mt =
                        (2 /
                          ((this.shadowRenderer.lightTextureAtlas
                            .shadowAtlasResolution *
                            G.atlasViewport.z) /
                            3)) *
                        this.shadowRenderer.lightTextureAtlas.shadowEdgePixels;
                      Oe.fov = Math.atan(1 + Mt) * Y.m.RAD_TO_DEG * 2;
                    } else Oe.fov = 90;
                  this.renderer.updateCameraFrustum(Oe),
                    this.shadowRenderer.cullShadowCasters(
                      Q,
                      we.visibleCasters,
                      Oe
                    );
                }
              }
              prepareLights(G, Q) {
                let q;
                for (let xe = 0; xe < Q.length; xe++) {
                  const be = Q[xe];
                  if (
                    this.shadowRenderer.needsShadowRendering(be) &&
                    be.atlasViewportAllocated
                  ) {
                    G.push(be);
                    for (let Pe = 0; Pe < be.numShadowFaces; Pe++)
                      q = this.shadowRenderer.prepareFace(be, null, Pe);
                  }
                }
                return q;
              }
              prepareClusteredRenderPass(G, Q, q) {
                const xe = this.shadowLights,
                  be = this.prepareLights(xe, Q),
                  Pe = this.prepareLights(xe, q),
                  we = be != null ? be : Pe,
                  Oe = xe.length;
                Oe &&
                  (this.shadowRenderer.setupRenderPass(G, we, !1),
                  (G.execute = () => {
                    for (let $e = 0; $e < Oe; $e++) {
                      const gt = xe[$e];
                      for (let qe = 0; qe < gt.numShadowFaces; qe++)
                        this.shadowRenderer.renderFace(gt, null, qe, !0);
                    }
                    xe.length = 0;
                  }));
              }
              setupNonClusteredFaceRenderPass(G, Q, q, xe) {
                const be = this.shadowRenderer.prepareFace(Q, null, q),
                  Pe = new g.CD(this.device, () => {
                    this.shadowRenderer.renderFace(Q, null, q, !1);
                  });
                this.shadowRenderer.setupRenderPass(Pe, be, !0),
                  xe &&
                    (Pe.after = () => {
                      this.shadowRenderer.renderVsm(Q, be);
                    }),
                  G.addRenderPass(Pe);
              }
              buildNonClusteredRenderPasses(G, Q, q) {
                for (let xe = 0; xe < Q.length; xe++) {
                  const be = Q[xe];
                  this.shadowRenderer.needsShadowRendering(be) &&
                    this.setupNonClusteredFaceRenderPass(G, be, 0, !0);
                }
                for (let xe = 0; xe < q.length; xe++) {
                  const be = q[xe];
                  if (this.shadowRenderer.needsShadowRendering(be)) {
                    const Pe = be.numShadowFaces;
                    for (let we = 0; we < Pe; we++)
                      this.setupNonClusteredFaceRenderPass(G, be, we, !1);
                  }
                }
              }
            }
            var ye = a(3148);
            const pe = new ye.k(),
              O = new x.A(),
              me = new h.y(),
              N = [
                new x.A(),
                new x.A(),
                new x.A(),
                new x.A(),
                new x.A(),
                new x.A(),
                new x.A(),
                new x.A(),
              ],
              V = { min: 0, max: 0 };
            function L(Ee, G, Q) {
              (N[0].x = N[1].x = N[2].x = N[3].x = G.x),
                (N[1].y = N[3].y = N[7].y = N[5].y = G.y),
                (N[2].z = N[3].z = N[6].z = N[7].z = G.z),
                (N[4].x = N[5].x = N[6].x = N[7].x = Q.x),
                (N[0].y = N[2].y = N[4].y = N[6].y = Q.y),
                (N[0].z = N[1].z = N[4].z = N[5].z = Q.z);
              let q = 9999999999,
                xe = -9999999999;
              for (let be = 0; be < 8; ++be) {
                Ee.transformPoint(N[be], N[be]);
                const Pe = N[be].z;
                Pe < q && (q = Pe), Pe > xe && (xe = Pe);
              }
              return (V.min = q), (V.max = xe), V;
            }
            class J {
              constructor(G, Q) {
                (this.renderer = void 0),
                  (this.shadowRenderer = void 0),
                  (this.device = void 0),
                  (this.renderer = G),
                  (this.shadowRenderer = Q),
                  (this.device = G.device);
              }
              cull(G, Q, q) {
                (G.visibleThisFrame = !0),
                  G._shadowMap || (G._shadowMap = v.create(this.device, G));
                const xe = q._nearClip;
                this.generateSplitDistances(
                  G,
                  xe,
                  Math.min(q._farClip, G.shadowDistance)
                );
                const be = G.shadowUpdateOverrides;
                for (
                  let Pe = 0;
                  Pe < G.numCascades && (be == null ? void 0 : be[Pe]) !== c.yo;
                  Pe++
                ) {
                  const we = G.getRenderData(q, Pe),
                    Oe = we.shadowCamera;
                  (Oe.renderTarget = G._shadowMap.renderTargets[0]),
                    we.shadowViewport.copy(G.cascades[Pe]),
                    we.shadowScissor.copy(G.cascades[Pe]);
                  const $e = Oe._node,
                    gt = G._node;
                  $e.setPosition(gt.getPosition()),
                    $e.setRotation(gt.getRotation()),
                    $e.rotateLocal(-90, 0, 0);
                  const qe = Pe === 0 ? xe : G._shadowCascadeDistances[Pe - 1],
                    Tt = G._shadowCascadeDistances[Pe],
                    Mt = q.getFrustumCorners(qe, Tt);
                  O.set(0, 0, 0);
                  const Dt = q.node.getWorldTransform();
                  for (let he = 0; he < 8; he++)
                    Dt.transformPoint(Mt[he], Mt[he]), O.add(Mt[he]);
                  O.mulScalar(0.125);
                  let ut = 0;
                  for (let he = 0; he < 8; he++) {
                    const fe = Mt[he].sub(O).length();
                    fe > ut && (ut = fe);
                  }
                  const At = $e.right,
                    xt = $e.up,
                    jt = $e.forward,
                    Gt = (0.25 * G._shadowResolution) / ut,
                    yt = Math.ceil(O.dot(xt) * Gt) / Gt,
                    Ae = Math.ceil(O.dot(At) * Gt) / Gt,
                    Xe = xt.mulScalar(yt),
                    Ye = At.mulScalar(Ae),
                    it = O.dot(jt),
                    st = jt.mulScalar(it);
                  O.add2(Xe, Ye).add(st),
                    $e.setPosition(O),
                    $e.translateLocal(0, 0, 1e6),
                    (Oe.nearClip = 0.01),
                    (Oe.farClip = 2e6),
                    (Oe.orthoHeight = ut),
                    this.renderer.updateCameraFrustum(Oe),
                    this.shadowRenderer.cullShadowCasters(
                      Q,
                      we.visibleCasters,
                      Oe
                    );
                  let He = !0;
                  const at = we.visibleCasters;
                  for (let he = 0; he < at.length; he++) {
                    const fe = at[he];
                    He ? ((He = !1), pe.copy(fe.aabb)) : pe.add(fe.aabb);
                  }
                  me.copy($e.getWorldTransform()).invert();
                  const Pt = L(me, pe.getMin(), pe.getMax());
                  $e.translateLocal(0, 0, Pt.max + 0.1),
                    (Oe.farClip = Pt.max - Pt.min + 0.2),
                    (we.depthRangeCompensation = Oe.farClip),
                    (we.projectionCompensation = ut);
                }
              }
              generateSplitDistances(G, Q, q) {
                G._shadowCascadeDistances.fill(q);
                for (let xe = 1; xe < G.numCascades; xe++) {
                  const be = xe / G.numCascades,
                    Pe = Q + (q - Q) * be,
                    we = Q * Cs(q / Q, be),
                    Oe = Y.m.lerp(Pe, we, G.cascadeDistribution);
                  G._shadowCascadeDistances[xe - 1] = Oe;
                }
              }
              addLightRenderPasses(G, Q, q) {
                const xe = Q.numShadowFaces,
                  be = Q.shadowUpdateOverrides;
                let Pe = !0,
                  we;
                for (let $e = 0; $e < xe; $e++)
                  (be == null ? void 0 : be[$e]) === c.yo && (Pe = !1),
                    (we = this.shadowRenderer.prepareFace(Q, q, $e));
                const Oe = new g.CD(this.device, () => {
                  for (let $e = 0; $e < xe; $e++)
                    (be == null ? void 0 : be[$e]) !== c.yo &&
                      this.shadowRenderer.renderFace(Q, q, $e, !Pe),
                      (be == null ? void 0 : be[$e]) === c.b1 &&
                        (be[$e] = c.yo);
                });
                (Oe.after = () => {
                  this.shadowRenderer.renderVsm(Q, q);
                }),
                  this.shadowRenderer.setupRenderPass(Oe, we, Pe),
                  G.addRenderPass(Oe);
              }
              buildFrameGraph(G, Q, q) {
                const xe = Q.directionalLights;
                for (let be = 0; be < xe.length; be++) {
                  const Pe = xe[be];
                  this.shadowRenderer.needsShadowRendering(Pe) &&
                    this.addLightRenderPasses(G, Pe, q.camera);
                }
              }
            }
            var ae = a(8400);
            let R = 0;
            const j = [0, 0, 0, 0],
              se = new h.y(),
              ce = new h.y(),
              ie = new h.y(),
              b = new d.T(),
              M = new f.K(),
              F = new h.y().setScale(1, -1, 1),
              z = new h.y().set([
                1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0.5, 0, 0, 0, 0.5, 1,
              ]),
              oe = new h.y(),
              de = new h.y(),
              ge = new h.y(),
              Re = new h.y(),
              Te = new Set();
            class Ne {
              constructor(G) {
                (this.clustersDebugRendered = !1),
                  (this.device = G),
                  (this.scene = null),
                  (this.lightTextureAtlas = new w(G)),
                  (this.shadowMapCache = new ne()),
                  (this.shadowRenderer = new ae.b(
                    this,
                    this.lightTextureAtlas
                  )),
                  (this._shadowRendererLocal = new Z(
                    this,
                    this.shadowRenderer
                  )),
                  (this._shadowRendererDirectional = new J(
                    this,
                    this.shadowRenderer
                  )),
                  (this._cookieRenderer = new E(G, this.lightTextureAtlas)),
                  (this.viewUniformFormat = null),
                  (this.viewBindGroupFormat = null),
                  (this._skinTime = 0),
                  (this._morphTime = 0),
                  (this._cullTime = 0),
                  (this._shadowMapTime = 0),
                  (this._lightClustersTime = 0),
                  (this._layerCompositionUpdateTime = 0),
                  (this._shadowDrawCalls = 0),
                  (this._skinDrawCalls = 0),
                  (this._instancedDrawCalls = 0),
                  (this._shadowMapUpdates = 0),
                  (this._numDrawCallsCulled = 0),
                  (this._camerasRendered = 0),
                  (this._lightClusters = 0);
                const Q = G.scope;
                (this.boneTextureId = Q.resolve("texture_poseMap")),
                  (this.boneTextureSizeId = Q.resolve("texture_poseMapSize")),
                  (this.poseMatrixId = Q.resolve("matrix_pose[0]")),
                  (this.modelMatrixId = Q.resolve("matrix_model")),
                  (this.normalMatrixId = Q.resolve("matrix_normal")),
                  (this.viewInvId = Q.resolve("matrix_viewInverse")),
                  (this.viewPos = new Float32Array(3)),
                  (this.viewPosId = Q.resolve("view_position")),
                  (this.projId = Q.resolve("matrix_projection")),
                  (this.projSkyboxId = Q.resolve("matrix_projectionSkybox")),
                  (this.viewId = Q.resolve("matrix_view")),
                  (this.viewId3 = Q.resolve("matrix_view3")),
                  (this.viewProjId = Q.resolve("matrix_viewProjection")),
                  (this.flipYId = Q.resolve("projectionFlipY")),
                  (this.tbnBasis = Q.resolve("tbnBasis")),
                  (this.nearClipId = Q.resolve("camera_near")),
                  (this.farClipId = Q.resolve("camera_far")),
                  (this.cameraParams = new Float32Array(4)),
                  (this.cameraParamsId = Q.resolve("camera_params")),
                  (this.alphaTestId = Q.resolve("alpha_ref")),
                  (this.opacityMapId = Q.resolve("texture_opacityMap")),
                  (this.exposureId = Q.resolve("exposure")),
                  (this.twoSidedLightingNegScaleFactorId = Q.resolve(
                    "twoSidedLightingNegScaleFactor"
                  )),
                  this.twoSidedLightingNegScaleFactorId.setValue(0),
                  (this.morphWeightsA = Q.resolve("morph_weights_a")),
                  (this.morphWeightsB = Q.resolve("morph_weights_b")),
                  (this.morphPositionTex = Q.resolve("morphPositionTex")),
                  (this.morphNormalTex = Q.resolve("morphNormalTex")),
                  (this.morphTexParams = Q.resolve("morph_tex_params"));
              }
              destroy() {
                (this.shadowRenderer = null),
                  (this._shadowRendererLocal = null),
                  (this._shadowRendererDirectional = null),
                  this.shadowMapCache.destroy(),
                  (this.shadowMapCache = null),
                  this._cookieRenderer.destroy(),
                  (this._cookieRenderer = null),
                  this.lightTextureAtlas.destroy(),
                  (this.lightTextureAtlas = null);
              }
              sortCompare(G, Q) {
                if (G.layer === Q.layer) {
                  if (G.drawOrder && Q.drawOrder)
                    return G.drawOrder - Q.drawOrder;
                  if (G.zdist && Q.zdist) return Q.zdist - G.zdist;
                  if (G.zdist2 && Q.zdist2) return G.zdist2 - Q.zdist2;
                }
                return Q._key[c.Uo] - G._key[c.Uo];
              }
              sortCompareMesh(G, Q) {
                if (G.layer === Q.layer) {
                  if (G.drawOrder && Q.drawOrder)
                    return G.drawOrder - Q.drawOrder;
                  if (G.zdist && Q.zdist) return Q.zdist - G.zdist;
                }
                const q = G._key[c.Uo],
                  xe = Q._key[c.Uo];
                return q === xe && G.mesh && Q.mesh
                  ? Q.mesh.id - G.mesh.id
                  : xe - q;
              }
              sortCompareDepth(G, Q) {
                const q = G._key[c.UG],
                  xe = Q._key[c.UG];
                return q === xe && G.mesh && Q.mesh
                  ? Q.mesh.id - G.mesh.id
                  : xe - q;
              }
              setupViewport(G, Q) {
                const q = this.device,
                  xe = Q ? Q.width : q.width,
                  be = Q ? Q.height : q.height,
                  Pe = G.rect;
                let we = Math.floor(Pe.x * xe),
                  Oe = Math.floor(Pe.y * be),
                  $e = Math.floor(Pe.z * xe),
                  gt = Math.floor(Pe.w * be);
                if ((q.setViewport(we, Oe, $e, gt), G._scissorRectClear)) {
                  const qe = G.scissorRect;
                  (we = Math.floor(qe.x * xe)),
                    (Oe = Math.floor(qe.y * be)),
                    ($e = Math.floor(qe.z * xe)),
                    (gt = Math.floor(qe.w * be));
                }
                q.setScissor(we, Oe, $e, gt);
              }
              setCameraUniforms(G, Q) {
                const q = Q == null ? void 0 : Q.flipY;
                let xe = 1;
                if (G.xr && G.xr.session) {
                  let we;
                  const Oe = G._node.parent;
                  Oe && (we = Oe.getWorldTransform());
                  const $e = G.xr.views;
                  xe = $e.length;
                  for (let gt = 0; gt < xe; gt++) {
                    const qe = $e[gt];
                    Oe
                      ? (qe.viewInvOffMat.mul2(we, qe.viewInvMat),
                        qe.viewOffMat.copy(qe.viewInvOffMat).invert())
                      : (qe.viewInvOffMat.copy(qe.viewInvMat),
                        qe.viewOffMat.copy(qe.viewMat)),
                      qe.viewMat3.setFromMat4(qe.viewOffMat),
                      qe.projViewOffMat.mul2(qe.projMat, qe.viewOffMat),
                      (qe.position[0] = qe.viewInvOffMat.data[12]),
                      (qe.position[1] = qe.viewInvOffMat.data[13]),
                      (qe.position[2] = qe.viewInvOffMat.data[14]),
                      G.frustum.setFromMat4(qe.projViewOffMat);
                  }
                } else {
                  let we = G.projectionMatrix;
                  G.calculateProjection && G.calculateProjection(we, c.Hc);
                  let Oe = G.getProjectionMatrixSkybox();
                  if (
                    (q && ((we = oe.mul2(F, we)), (Oe = de.mul2(F, Oe))),
                    this.device.isWebGPU &&
                      ((we = ge.mul2(z, we)), (Oe = Re.mul2(z, Oe))),
                    this.projId.setValue(we.data),
                    this.projSkyboxId.setValue(Oe.data),
                    G.calculateTransform)
                  )
                    G.calculateTransform(ce, c.Hc);
                  else {
                    const $e = G._node.getPosition(),
                      gt = G._node.getRotation();
                    ce.setTRS($e, gt, x.A.ONE);
                  }
                  this.viewInvId.setValue(ce.data),
                    ie.copy(ce).invert(),
                    this.viewId.setValue(ie.data),
                    b.setFromMat4(ie),
                    this.viewId3.setValue(b.data),
                    se.mul2(we, ie),
                    this.viewProjId.setValue(se.data),
                    this.flipYId.setValue(q ? -1 : 1),
                    this.dispatchViewPos(G._node.getPosition()),
                    G.frustum.setFromMat4(se);
                }
                this.tbnBasis.setValue(q ? -1 : 1);
                const be = G._nearClip,
                  Pe = G._farClip;
                return (
                  this.nearClipId.setValue(be),
                  this.farClipId.setValue(Pe),
                  (this.cameraParams[0] = 1 / Pe),
                  (this.cameraParams[1] = Pe),
                  (this.cameraParams[2] = be),
                  (this.cameraParams[3] = G.projection === c.Uc ? 1 : 0),
                  this.cameraParamsId.setValue(this.cameraParams),
                  this.exposureId.setValue(
                    this.scene.physicalUnits
                      ? G.getExposure()
                      : this.scene.exposure
                  ),
                  xe
                );
              }
              clear(G, Q, q, xe) {
                const be =
                  ((Q != null ? Q : G._clearColorBuffer) ? o.Zzy : 0) |
                  ((q != null ? q : G._clearDepthBuffer) ? o.zk9 : 0) |
                  ((xe != null ? xe : G._clearStencilBuffer) ? o.$tA : 0);
                be &&
                  this.device.clear({
                    color: [
                      G._clearColor.r,
                      G._clearColor.g,
                      G._clearColor.b,
                      G._clearColor.a,
                    ],
                    depth: G._clearDepth,
                    stencil: G._clearStencil,
                    flags: be,
                  });
              }
              setCamera(G, Q, q, xe = null) {
                this.setCameraUniforms(G, Q), this.clearView(G, Q, q, !1);
              }
              clearView(G, Q, q, xe) {
                const be = this.device;
                if (
                  (be.setRenderTarget(Q),
                  be.updateBegin(),
                  xe &&
                    (be.setColorWrite(!0, !0, !0, !0), be.setDepthWrite(!0)),
                  this.setupViewport(G, Q),
                  q)
                ) {
                  const Pe = G._clearOptions;
                  be.clear(
                    Pe || {
                      color: [
                        G._clearColor.r,
                        G._clearColor.g,
                        G._clearColor.b,
                        G._clearColor.a,
                      ],
                      depth: G._clearDepth,
                      flags:
                        (G._clearColorBuffer ? o.Zzy : 0) |
                        (G._clearDepthBuffer ? o.zk9 : 0) |
                        (G._clearStencilBuffer ? o.$tA : 0),
                      stencil: G._clearStencil,
                    }
                  );
                }
              }
              setupCullMode(G, Q, q) {
                const xe = q.material;
                let be = o.OL2;
                if (G) {
                  let Pe = 1;
                  (xe.cull === o.TWf || xe.cull === o.Ak1) &&
                    (Pe = Q * q.flipFacesFactor * q.node.worldScaleSign),
                    Pe < 0
                      ? (be = xe.cull === o.TWf ? o.Ak1 : o.TWf)
                      : (be = xe.cull);
                }
                this.device.setCullMode(be),
                  be === o.OL2 &&
                    xe.cull === o.OL2 &&
                    this.twoSidedLightingNegScaleFactorId.setValue(
                      q.node.worldScaleSign
                    );
              }
              updateCameraFrustum(G) {
                if (G.xr && G.xr.views.length) {
                  const q = G.xr.views[0];
                  se.mul2(q.projMat, q.viewOffMat), G.frustum.setFromMat4(se);
                  return;
                }
                const Q = G.projectionMatrix;
                if (
                  (G.calculateProjection && G.calculateProjection(Q, c.Hc),
                  G.calculateTransform)
                )
                  G.calculateTransform(ce, c.Hc);
                else {
                  const q = G._node.getPosition(),
                    xe = G._node.getRotation();
                  ce.setTRS(q, xe, x.A.ONE), this.viewInvId.setValue(ce.data);
                }
                ie.copy(ce).invert(), se.mul2(Q, ie), G.frustum.setFromMat4(se);
              }
              setBaseConstants(G, Q) {
                G.setCullMode(Q.cull),
                  Q.opacityMap && this.opacityMapId.setValue(Q.opacityMap),
                  (Q.opacityMap || Q.alphaTest > 0) &&
                    this.alphaTestId.setValue(Q.alphaTest);
              }
              updateCpuSkinMatrices(G) {
                R++;
                const Q = G.length;
                if (Q !== 0)
                  for (let q = 0; q < Q; q++) {
                    const xe = G[q].skinInstance;
                    xe && (xe.updateMatrices(G[q].node, R), (xe._dirty = !0));
                  }
              }
              updateGpuSkinMatrices(G) {
                const Q = G.length;
                for (let q = 0; q < Q; q++) {
                  const xe = G[q];
                  if (xe.visibleThisFrame) {
                    const be = xe.skinInstance;
                    be &&
                      be._dirty &&
                      (be.updateMatrixPalette(xe.node, R), (be._dirty = !1));
                  }
                }
              }
              updateMorphing(G) {
                const Q = G.length;
                for (let q = 0; q < Q; q++) {
                  const xe = G[q],
                    be = xe.morphInstance;
                  be && be._dirty && xe.visibleThisFrame && be.update();
                }
              }
              gpuUpdate(G) {
                this.updateGpuSkinMatrices(G), this.updateMorphing(G);
              }
              setVertexBuffers(G, Q) {
                G.setVertexBuffer(Q.vertexBuffer);
              }
              setMorphing(G, Q) {
                if (Q)
                  if (Q.morph.useTextureMorph)
                    G.setVertexBuffer(Q.morph.vertexBufferIds),
                      this.morphPositionTex.setValue(Q.texturePositions),
                      this.morphNormalTex.setValue(Q.textureNormals),
                      this.morphTexParams.setValue(Q._textureParams);
                  else {
                    for (let q = 0; q < Q._activeVertexBuffers.length; q++) {
                      const xe = Q._activeVertexBuffers[q];
                      if (xe) {
                        const be = o.$eZ + (q + 8);
                        (xe.format.elements[0].name = be),
                          (xe.format.elements[0].scopeId = G.scope.resolve(be)),
                          xe.format.update(),
                          G.setVertexBuffer(xe);
                      }
                    }
                    this.morphWeightsA.setValue(Q._shaderMorphWeightsA),
                      this.morphWeightsB.setValue(Q._shaderMorphWeightsB);
                  }
              }
              setSkinning(G, Q) {
                if (Q.skinInstance)
                  if ((this._skinDrawCalls++, G.supportsBoneTextures)) {
                    const q = Q.skinInstance.boneTexture;
                    this.boneTextureId.setValue(q),
                      (j[0] = q.width),
                      (j[1] = q.height),
                      (j[2] = 1 / q.width),
                      (j[3] = 1 / q.height),
                      this.boneTextureSizeId.setValue(j);
                  } else
                    this.poseMatrixId.setValue(Q.skinInstance.matrixPalette);
              }
              dispatchViewPos(G) {
                const Q = this.viewPos;
                (Q[0] = G.x),
                  (Q[1] = G.y),
                  (Q[2] = G.z),
                  this.viewPosId.setValue(Q);
              }
              initViewBindGroupFormat(G) {
                if (
                  this.device.supportsUniformBuffers &&
                  !this.viewUniformFormat
                ) {
                  const Q = [
                    new X.M("matrix_viewProjection", o.EA4),
                    new X.M("cubeMapRotationMatrix", o.Si0),
                    new X.M("view_position", o.T73),
                    new X.M("skyboxIntensity", o.Cdl),
                    new X.M("exposure", o.Cdl),
                    new X.M("textureBias", o.Cdl),
                  ];
                  G &&
                    Q.push(
                      new X.M("clusterCellsCountByBoundsSize", o.T73),
                      new X.M("clusterTextureSize", o.T73),
                      new X.M("clusterBoundsMin", o.T73),
                      new X.M("clusterBoundsDelta", o.T73),
                      new X.M("clusterCellsDot", o.T73),
                      new X.M("clusterCellsMax", o.T73),
                      new X.M("clusterCompressionLimit0", o.d_l),
                      new X.M("shadowAtlasParams", o.d_l),
                      new X.M("clusterMaxCells", o.cNy),
                      new X.M("clusterSkip", o.Cdl)
                    ),
                    (this.viewUniformFormat = new X.f(this.device, Q));
                  const q = [new $.Q1(o.ASF, o.y4i | o.sxQ)],
                    xe = [
                      new $.sT("lightsTextureFloat", o.sxQ, o.He_, o.rT2),
                      new $.sT("lightsTexture8", o.sxQ, o.He_, o.rT2),
                      new $.sT("shadowAtlasTexture", o.sxQ, o.He_, o.g98),
                      new $.sT("cookieAtlasTexture", o.sxQ, o.He_, o.qUb),
                      new $.sT("areaLightsLutTex1", o.sxQ, o.He_, o.qUb),
                      new $.sT("areaLightsLutTex2", o.sxQ, o.He_, o.qUb),
                    ];
                  G &&
                    xe.push(
                      new $.sT("clusterWorldTexture", o.sxQ, o.He_, o.rT2)
                    ),
                    (this.viewBindGroupFormat = new $.WM(this.device, q, xe));
                }
              }
              setupViewUniformBuffers(G, Q, q, xe) {
                const be = this.device;
                for (; G.length < xe; ) {
                  const we = new K.M(be, Q, !1),
                    Oe = new te.v(be, q, we);
                  G.push(Oe);
                }
                const Pe = G[0];
                Pe.defaultUniformBuffer.update(),
                  Pe.update(),
                  be.setBindGroup(o.Qqf, Pe);
              }
              setupMeshUniformBuffers(G, Q) {
                const q = this.device;
                if (q.supportsUniformBuffers) {
                  this.modelMatrixId.setValue(Q.node.worldTransform.data),
                    this.normalMatrixId.setValue(Q.node.normalMatrix.data);
                  const xe = G.getBindGroup(q);
                  xe.defaultUniformBuffer.update(),
                    xe.update(),
                    q.setBindGroup(o.Ak$, xe);
                }
              }
              drawInstance(G, Q, q, xe, be) {
                const Pe = Q.instancingData;
                if (Pe)
                  Pe.count > 0 &&
                    (this._instancedDrawCalls++,
                    G.setVertexBuffer(Pe.vertexBuffer),
                    G.draw(q.primitive[xe], Pe.count));
                else {
                  const we = Q.node.worldTransform;
                  this.modelMatrixId.setValue(we.data),
                    be &&
                      this.normalMatrixId.setValue(Q.node.normalMatrix.data),
                    G.draw(q.primitive[xe]);
                }
              }
              drawInstance2(G, Q, q, xe) {
                const be = Q.instancingData;
                be
                  ? be.count > 0 &&
                    (this._instancedDrawCalls++,
                    G.draw(q.primitive[xe], be.count, !0))
                  : G.draw(q.primitive[xe], void 0, !0);
              }
              cull(G, Q, q) {
                let xe = 0;
                const be = Q.length;
                if (!G.frustumCulling) {
                  for (let Pe = 0; Pe < be; Pe++) {
                    const we = Q[Pe];
                    (!we.visible && !we.command) ||
                      ((q[xe] = we), xe++, (we.visibleThisFrame = !0));
                  }
                  return xe;
                }
                for (let Pe = 0; Pe < be; Pe++) {
                  const we = Q[Pe];
                  if (we.command)
                    (q[xe] = we), xe++, (we.visibleThisFrame = !0);
                  else {
                    if (!we.visible) continue;
                    let Oe = !0;
                    we.cull && (Oe = we._isVisible(G)),
                      Oe && ((q[xe] = we), xe++, (we.visibleThisFrame = !0));
                  }
                }
                return xe;
              }
              cullLights(G, Q) {
                const q = this.scene.clusteredLightingEnabled,
                  xe = this.scene.physicalUnits;
                for (let be = 0; be < Q.length; be++) {
                  const Pe = Q[be];
                  if (Pe.enabled)
                    if (Pe._type !== c.WQ)
                      if (
                        (Pe.getBoundingSphere(M), G.frustum.containsSphere(M))
                      ) {
                        (Pe.visibleThisFrame = !0), (Pe.usePhysicalUnits = xe);
                        const we = G.getScreenSize(M);
                        Pe.maxScreenSize = Math.max(Pe.maxScreenSize, we);
                      } else
                        q ||
                          (Pe.castShadows &&
                            !Pe.shadowMap &&
                            (Pe.visibleThisFrame = !0));
                    else Pe.usePhysicalUnits = this.scene.physicalUnits;
                }
              }
              cullShadowmaps(G) {
                const Q = this.scene.clusteredLightingEnabled;
                for (let xe = 0; xe < G._lights.length; xe++) {
                  const be = G._lights[xe];
                  if (
                    be._type !== c.WQ &&
                    (Q &&
                      be.atlasSlotUpdated &&
                      be.shadowUpdateMode === c.yo &&
                      (be.shadowUpdateMode = c.b1),
                    be.visibleThisFrame &&
                      be.castShadows &&
                      be.shadowUpdateMode !== c.yo)
                  ) {
                    const Pe = G._lightCompositionData[xe].shadowCastersList;
                    this._shadowRendererLocal.cull(be, Pe);
                  }
                }
                const q = G._renderActions;
                for (let xe = 0; xe < q.length; xe++) {
                  const be = q[xe],
                    Pe = be.directionalLightsIndices.length;
                  for (let we = 0; we < Pe; we++) {
                    const Oe = be.directionalLightsIndices[we],
                      $e = G._lights[Oe],
                      gt = G._lightCompositionData[Oe].shadowCastersList;
                    this._shadowRendererDirectional.cull(
                      $e,
                      gt,
                      be.camera.camera
                    );
                  }
                }
              }
              cullComposition(G) {
                const Q = G._renderActions;
                for (let q = 0; q < Q.length; q++) {
                  const xe = Q[q],
                    be = xe.layerIndex,
                    Pe = G.layerList[be];
                  if (!Pe.enabled || !G.subLayerEnabled[be]) continue;
                  const we = G.subLayerList[be],
                    Oe = xe.cameraIndex,
                    $e = Pe.cameras[Oe];
                  if ($e) {
                    $e.frameUpdate(xe.renderTarget),
                      xe.firstCameraUse &&
                        (this.updateCameraFrustum($e.camera),
                        this._camerasRendered++),
                      this.cullLights($e.camera, Pe._lights);
                    const gt = Pe.instances,
                      qe = we
                        ? gt.visibleTransparent[Oe]
                        : gt.visibleOpaque[Oe];
                    if (!qe.done) {
                      Pe.onPreCull && Pe.onPreCull(Oe);
                      const Tt = we
                        ? Pe.transparentMeshInstances
                        : Pe.opaqueMeshInstances;
                      (qe.length = this.cull($e.camera, Tt, qe.list)),
                        (qe.done = !0),
                        Pe.onPostCull && Pe.onPostCull(Oe);
                    }
                  }
                }
                this.scene.clusteredLightingEnabled &&
                  this.updateLightTextureAtlas(G),
                  this.cullShadowmaps(G);
              }
              updateShaders(G, Q) {
                const q = G.length;
                for (let xe = 0; xe < q; xe++) {
                  const be = G[xe].material;
                  if (
                    be &&
                    !Te.has(be) &&
                    (Te.add(be),
                    be.getShaderVariant !== k.F.prototype.getShaderVariant)
                  ) {
                    if (
                      Q &&
                      (!be.useLighting || (be.emitter && !be.emitter.lighting))
                    )
                      continue;
                    be.clearVariants();
                  }
                }
                Te.clear();
              }
              renderCookies(G) {
                const Q = this.lightTextureAtlas.cookieRenderTarget;
                for (let q = 0; q < G.length; q++) {
                  const xe = G[q];
                  xe.atlasViewportAllocated &&
                    xe.atlasSlotUpdated &&
                    this._cookieRenderer.render(xe, Q);
                }
              }
              beginFrame(G, Q) {
                const q = G._meshInstances,
                  xe = this.scene;
                if (xe.updateShaders || Q) {
                  const Oe = !xe.updateShaders && Q;
                  this.updateShaders(q, Oe),
                    (xe.updateShaders = !1),
                    xe._shaderVersion++;
                }
                this.updateCpuSkinMatrices(q);
                const be = q.length;
                for (let Oe = 0; Oe < be; Oe++) q[Oe].visibleThisFrame = !1;
                const Pe = G._lights,
                  we = Pe.length;
                for (let Oe = 0; Oe < we; Oe++) Pe[Oe].beginFrame();
              }
              updateLightTextureAtlas(G) {
                this.lightTextureAtlas.update(
                  G._splitLights[c.z0],
                  G._splitLights[c.bA],
                  this.scene.lighting
                );
              }
              updateClusters(G) {
                const Q = G.getEmptyWorldClusters(this.device),
                  q = G._renderActions;
                for (let xe = 0; xe < q.length; xe++) {
                  const be = q[xe],
                    Pe = be.lightClusters;
                  if (Pe && Pe !== Q && !Te.has(Pe)) {
                    Te.add(Pe);
                    const we = G.layerList[be.layerIndex];
                    Pe.update(
                      we.clusteredLightsSet,
                      this.scene.gammaCorrection,
                      this.scene.lighting
                    );
                  }
                }
                Te.clear();
              }
              updateLayerComposition(G, Q) {
                const q = G.layerList.length;
                for (let we = 0; we < q; we++)
                  G.layerList[we]._postRenderCounter = 0;
                const be = this.scene._shaderVersion;
                for (let we = 0; we < q; we++) {
                  const Oe = G.layerList[we];
                  (Oe._shaderVersion = be),
                    (Oe._preRenderCalledForCameras = 0),
                    (Oe._postRenderCalledForCameras = 0),
                    G.subLayerList[we]
                      ? (Oe._postRenderCounter |= 2)
                      : (Oe._postRenderCounter |= 1),
                    (Oe._postRenderCounterMax = Oe._postRenderCounter);
                  for (let gt = 0; gt < Oe.cameras.length; gt++)
                    Oe.instances.prepare(gt);
                }
                return G._update(this.device, Q);
              }
              frameUpdate() {
                (this.clustersDebugRendered = !1),
                  this.initViewBindGroupFormat(
                    this.scene.clusteredLightingEnabled
                  );
              }
            }
            var Le = a(7900);
            const ke = new T.I(254 / 255, 254 / 255, 254 / 255, 254 / 255),
              ht = {
                drawCalls: [],
                shaderInstances: [],
                isNewMaterial: [],
                lightMaskChanged: [],
                clear: function () {
                  (this.drawCalls.length = 0),
                    (this.shaderInstances.length = 0),
                    (this.isNewMaterial.length = 0),
                    (this.lightMaskChanged.length = 0);
                },
              };
            function _e(Ee) {
              const G = [];
              for (let Q = 0; Q < Ee; ++Q) {
                const q = Math.sqrt(Q + 0.5) / Math.sqrt(Ee);
                G.push(q);
              }
              return G;
            }
            function U(Ee) {
              const G = [];
              for (let Q = 0; Q < Ee; Q++) {
                const q = Q / Ee,
                  xe = Math.sqrt(1 - q * q);
                G.push(xe);
              }
              return G;
            }
            class H extends Ne {
              constructor(G) {
                super(G);
                const Q = this.device;
                (this._forwardDrawCalls = 0),
                  (this._materialSwitches = 0),
                  (this._depthMapTime = 0),
                  (this._forwardTime = 0),
                  (this._sortTime = 0);
                const q = Q.scope;
                (this.fogColorId = q.resolve("fog_color")),
                  (this.fogStartId = q.resolve("fog_start")),
                  (this.fogEndId = q.resolve("fog_end")),
                  (this.fogDensityId = q.resolve("fog_density")),
                  (this.ambientId = q.resolve("light_globalAmbient")),
                  (this.skyboxIntensityId = q.resolve("skyboxIntensity")),
                  (this.cubeMapRotationMatrixId = q.resolve(
                    "cubeMapRotationMatrix"
                  )),
                  (this.pcssDiskSamplesId = q.resolve("pcssDiskSamples[0]")),
                  (this.pcssSphereSamplesId = q.resolve(
                    "pcssSphereSamples[0]"
                  )),
                  (this.lightColorId = []),
                  (this.lightDir = []),
                  (this.lightDirId = []),
                  (this.lightShadowMapId = []),
                  (this.lightShadowMatrixId = []),
                  (this.lightShadowParamsId = []),
                  (this.lightShadowIntensity = []),
                  (this.lightRadiusId = []),
                  (this.lightPos = []),
                  (this.lightPosId = []),
                  (this.lightWidth = []),
                  (this.lightWidthId = []),
                  (this.lightHeight = []),
                  (this.lightHeightId = []),
                  (this.lightInAngleId = []),
                  (this.lightOutAngleId = []),
                  (this.lightCookieId = []),
                  (this.lightCookieIntId = []),
                  (this.lightCookieMatrixId = []),
                  (this.lightCookieOffsetId = []),
                  (this.lightShadowSearchAreaId = []),
                  (this.lightCameraParamsId = []),
                  (this.shadowMatrixPaletteId = []),
                  (this.shadowCascadeDistancesId = []),
                  (this.shadowCascadeCountId = []),
                  (this.screenSizeId = q.resolve("uScreenSize")),
                  (this._screenSize = new Float32Array(4)),
                  (this.fogColor = new Float32Array(3)),
                  (this.ambientColor = new Float32Array(3)),
                  (this.pcssDiskSamples = _e(16)),
                  (this.pcssSphereSamples = U(16));
              }
              destroy() {
                super.destroy();
              }
              dispatchGlobalLights(G) {
                if (
                  ((this.ambientColor[0] = G.ambientLight.r),
                  (this.ambientColor[1] = G.ambientLight.g),
                  (this.ambientColor[2] = G.ambientLight.b),
                  G.gammaCorrection)
                )
                  for (let Q = 0; Q < 3; Q++)
                    this.ambientColor[Q] = Math.pow(this.ambientColor[Q], 2.2);
                if (G.physicalUnits)
                  for (let Q = 0; Q < 3; Q++)
                    this.ambientColor[Q] *= G.ambientLuminance;
                this.ambientId.setValue(this.ambientColor),
                  this.skyboxIntensityId.setValue(
                    G.physicalUnits ? G.skyboxLuminance : G.skyboxIntensity
                  ),
                  this.cubeMapRotationMatrixId.setValue(
                    G._skyboxRotationMat3.data
                  );
              }
              _resolveLight(G, Q) {
                const q = "light" + Q;
                (this.lightColorId[Q] = G.resolve(q + "_color")),
                  (this.lightDir[Q] = new Float32Array(3)),
                  (this.lightDirId[Q] = G.resolve(q + "_direction")),
                  (this.lightShadowMapId[Q] = G.resolve(q + "_shadowMap")),
                  (this.lightShadowMatrixId[Q] = G.resolve(
                    q + "_shadowMatrix"
                  )),
                  (this.lightShadowParamsId[Q] = G.resolve(
                    q + "_shadowParams"
                  )),
                  (this.lightShadowIntensity[Q] = G.resolve(
                    q + "_shadowIntensity"
                  )),
                  (this.lightShadowSearchAreaId[Q] = G.resolve(
                    q + "_shadowSearchArea"
                  )),
                  (this.lightRadiusId[Q] = G.resolve(q + "_radius")),
                  (this.lightPos[Q] = new Float32Array(3)),
                  (this.lightPosId[Q] = G.resolve(q + "_position")),
                  (this.lightWidth[Q] = new Float32Array(3)),
                  (this.lightWidthId[Q] = G.resolve(q + "_halfWidth")),
                  (this.lightHeight[Q] = new Float32Array(3)),
                  (this.lightHeightId[Q] = G.resolve(q + "_halfHeight")),
                  (this.lightInAngleId[Q] = G.resolve(q + "_innerConeAngle")),
                  (this.lightOutAngleId[Q] = G.resolve(q + "_outerConeAngle")),
                  (this.lightCookieId[Q] = G.resolve(q + "_cookie")),
                  (this.lightCookieIntId[Q] = G.resolve(
                    q + "_cookieIntensity"
                  )),
                  (this.lightCookieMatrixId[Q] = G.resolve(
                    q + "_cookieMatrix"
                  )),
                  (this.lightCookieOffsetId[Q] = G.resolve(
                    q + "_cookieOffset"
                  )),
                  (this.lightCameraParamsId[Q] = G.resolve(
                    q + "_cameraParams"
                  )),
                  (this.shadowMatrixPaletteId[Q] = G.resolve(
                    q + "_shadowMatrixPalette[0]"
                  )),
                  (this.shadowCascadeDistancesId[Q] = G.resolve(
                    q + "_shadowCascadeDistances[0]"
                  )),
                  (this.shadowCascadeCountId[Q] = G.resolve(
                    q + "_shadowCascadeCount"
                  ));
              }
              setLTCDirectionalLight(G, Q, q, xe, be) {
                (this.lightPos[Q][0] = xe.x - q.x * be),
                  (this.lightPos[Q][1] = xe.y - q.y * be),
                  (this.lightPos[Q][2] = xe.z - q.z * be),
                  this.lightPosId[Q].setValue(this.lightPos[Q]);
                const Pe = G.transformVector(new x.A(-0.5, 0, 0));
                (this.lightWidth[Q][0] = Pe.x * be),
                  (this.lightWidth[Q][1] = Pe.y * be),
                  (this.lightWidth[Q][2] = Pe.z * be),
                  this.lightWidthId[Q].setValue(this.lightWidth[Q]);
                const we = G.transformVector(new x.A(0, 0, 0.5));
                (this.lightHeight[Q][0] = we.x * be),
                  (this.lightHeight[Q][1] = we.y * be),
                  (this.lightHeight[Q][2] = we.z * be),
                  this.lightHeightId[Q].setValue(this.lightHeight[Q]);
              }
              dispatchDirectLights(G, Q, q, xe) {
                let be = 0;
                const Pe = this.device.scope;
                for (let we = 0; we < G.length; we++) {
                  if (!(G[we].mask & q)) continue;
                  const Oe = G[we],
                    $e = Oe._node.getWorldTransform();
                  if (
                    (this.lightColorId[be] || this._resolveLight(Pe, be),
                    this.lightColorId[be].setValue(
                      Q.gammaCorrection ? Oe._linearFinalColor : Oe._finalColor
                    ),
                    $e.getY(Oe._direction).mulScalar(-1),
                    Oe._direction.normalize(),
                    (this.lightDir[be][0] = Oe._direction.x),
                    (this.lightDir[be][1] = Oe._direction.y),
                    (this.lightDir[be][2] = Oe._direction.z),
                    this.lightDirId[be].setValue(this.lightDir[be]),
                    Oe.shape !== c.pI &&
                      this.setLTCDirectionalLight(
                        $e,
                        be,
                        Oe._direction,
                        xe._node.getPosition(),
                        xe.farClip
                      ),
                    Oe.castShadows)
                  ) {
                    const gt = Oe.getRenderData(xe, 0),
                      qe = Oe._getUniformBiasValues(gt);
                    this.lightShadowMapId[be].setValue(gt.shadowBuffer),
                      this.lightShadowMatrixId[be].setValue(
                        gt.shadowMatrix.data
                      ),
                      this.shadowMatrixPaletteId[be].setValue(
                        Oe._shadowMatrixPalette
                      ),
                      this.shadowCascadeDistancesId[be].setValue(
                        Oe._shadowCascadeDistances
                      ),
                      this.shadowCascadeCountId[be].setValue(Oe.numCascades),
                      this.lightShadowIntensity[be].setValue(
                        Oe.shadowIntensity
                      );
                    const Tt = 50 / gt.projectionCompensation,
                      Mt =
                        1 /
                        (gt.shadowCamera.renderTarget.width / Oe.penumbraSize);
                    this.lightShadowSearchAreaId[be].setValue(Mt * Tt);
                    const Dt = Oe._shadowCameraParams;
                    (Dt.length = 4),
                      (Dt[0] = gt.depthRangeCompensation),
                      (Dt[1] = gt.shadowCamera._farClip),
                      (Dt[2] = gt.shadowCamera._nearClip),
                      (Dt[3] = 1),
                      this.lightCameraParamsId[be].setValue(Dt);
                    const ut = Oe._shadowRenderParams;
                    (ut.length = 4),
                      (ut[0] = Oe._shadowResolution),
                      (ut[1] = qe.normalBias),
                      (ut[2] = qe.bias),
                      (ut[3] = 0),
                      this.lightShadowParamsId[be].setValue(ut);
                  }
                  be++;
                }
                return be;
              }
              setLTCPositionalLight(G, Q) {
                const q = G.transformVector(new x.A(-0.5, 0, 0));
                (this.lightWidth[Q][0] = q.x),
                  (this.lightWidth[Q][1] = q.y),
                  (this.lightWidth[Q][2] = q.z),
                  this.lightWidthId[Q].setValue(this.lightWidth[Q]);
                const xe = G.transformVector(new x.A(0, 0, 0.5));
                (this.lightHeight[Q][0] = xe.x),
                  (this.lightHeight[Q][1] = xe.y),
                  (this.lightHeight[Q][2] = xe.z),
                  this.lightHeightId[Q].setValue(this.lightHeight[Q]);
              }
              dispatchOmniLight(G, Q, q, xe) {
                const be = q._node.getWorldTransform();
                if (
                  (this.lightColorId[xe] || this._resolveLight(Q, xe),
                  this.lightRadiusId[xe].setValue(q.attenuationEnd),
                  this.lightColorId[xe].setValue(
                    G.gammaCorrection ? q._linearFinalColor : q._finalColor
                  ),
                  be.getTranslation(q._position),
                  (this.lightPos[xe][0] = q._position.x),
                  (this.lightPos[xe][1] = q._position.y),
                  (this.lightPos[xe][2] = q._position.z),
                  this.lightPosId[xe].setValue(this.lightPos[xe]),
                  q.shape !== c.pI && this.setLTCPositionalLight(be, xe),
                  q.castShadows)
                ) {
                  const Pe = q.getRenderData(null, 0);
                  this.lightShadowMapId[xe].setValue(Pe.shadowBuffer);
                  const we = q._getUniformBiasValues(Pe),
                    Oe = q._shadowRenderParams;
                  (Oe.length = 4),
                    (Oe[0] = q._shadowResolution),
                    (Oe[1] = we.normalBias),
                    (Oe[2] = we.bias),
                    (Oe[3] = 1 / q.attenuationEnd),
                    this.lightShadowParamsId[xe].setValue(Oe),
                    this.lightShadowIntensity[xe].setValue(q.shadowIntensity);
                  const $e =
                    1 / (Pe.shadowCamera.renderTarget.width / q.penumbraSize);
                  this.lightShadowSearchAreaId[xe].setValue($e);
                  const gt = q._shadowCameraParams;
                  (gt.length = 4),
                    (gt[0] = Pe.depthRangeCompensation),
                    (gt[1] = Pe.shadowCamera._farClip),
                    (gt[2] = Pe.shadowCamera._nearClip),
                    (gt[3] = 0),
                    this.lightCameraParamsId[xe].setValue(gt);
                }
                q._cookie &&
                  (this.lightCookieId[xe].setValue(q._cookie),
                  this.lightShadowMatrixId[xe].setValue(be.data),
                  this.lightCookieIntId[xe].setValue(q.cookieIntensity));
              }
              dispatchSpotLight(G, Q, q, xe) {
                const be = q._node.getWorldTransform();
                if (
                  (this.lightColorId[xe] || this._resolveLight(Q, xe),
                  this.lightInAngleId[xe].setValue(q._innerConeAngleCos),
                  this.lightOutAngleId[xe].setValue(q._outerConeAngleCos),
                  this.lightRadiusId[xe].setValue(q.attenuationEnd),
                  this.lightColorId[xe].setValue(
                    G.gammaCorrection ? q._linearFinalColor : q._finalColor
                  ),
                  be.getTranslation(q._position),
                  (this.lightPos[xe][0] = q._position.x),
                  (this.lightPos[xe][1] = q._position.y),
                  (this.lightPos[xe][2] = q._position.z),
                  this.lightPosId[xe].setValue(this.lightPos[xe]),
                  q.shape !== c.pI && this.setLTCPositionalLight(be, xe),
                  be.getY(q._direction).mulScalar(-1),
                  q._direction.normalize(),
                  (this.lightDir[xe][0] = q._direction.x),
                  (this.lightDir[xe][1] = q._direction.y),
                  (this.lightDir[xe][2] = q._direction.z),
                  this.lightDirId[xe].setValue(this.lightDir[xe]),
                  q.castShadows)
                ) {
                  const Pe = q.getRenderData(null, 0);
                  this.lightShadowMapId[xe].setValue(Pe.shadowBuffer),
                    this.lightShadowMatrixId[xe].setValue(Pe.shadowMatrix.data);
                  const we = q._getUniformBiasValues(Pe),
                    Oe = q._shadowRenderParams;
                  (Oe.length = 4),
                    (Oe[0] = q._shadowResolution),
                    (Oe[1] = we.normalBias),
                    (Oe[2] = we.bias),
                    (Oe[3] = 1 / q.attenuationEnd),
                    this.lightShadowParamsId[xe].setValue(Oe),
                    this.lightShadowIntensity[xe].setValue(q.shadowIntensity);
                  const $e =
                      1 / (Pe.shadowCamera.renderTarget.width / q.penumbraSize),
                    gt = (Pe.shadowCamera._fov * Math.PI) / 180,
                    qe = 1 / Math.tan(gt / 2);
                  this.lightShadowSearchAreaId[xe].setValue($e * qe);
                  const Tt = q._shadowCameraParams;
                  (Tt.length = 4),
                    (Tt[0] = Pe.depthRangeCompensation),
                    (Tt[1] = Pe.shadowCamera._farClip),
                    (Tt[2] = Pe.shadowCamera._nearClip),
                    (Tt[3] = 0),
                    this.lightCameraParamsId[xe].setValue(Tt);
                }
                if (q._cookie) {
                  if (!q.castShadows) {
                    const Pe = r.i.evalSpotCookieMatrix(q);
                    this.lightShadowMatrixId[xe].setValue(Pe.data);
                  }
                  this.lightCookieId[xe].setValue(q._cookie),
                    this.lightCookieIntId[xe].setValue(q.cookieIntensity),
                    q._cookieTransform &&
                      ((q._cookieTransformUniform[0] = q._cookieTransform.x),
                      (q._cookieTransformUniform[1] = q._cookieTransform.y),
                      (q._cookieTransformUniform[2] = q._cookieTransform.z),
                      (q._cookieTransformUniform[3] = q._cookieTransform.w),
                      this.lightCookieMatrixId[xe].setValue(
                        q._cookieTransformUniform
                      ),
                      (q._cookieOffsetUniform[0] = q._cookieOffset.x),
                      (q._cookieOffsetUniform[1] = q._cookieOffset.y),
                      this.lightCookieOffsetId[xe].setValue(
                        q._cookieOffsetUniform
                      ));
                }
              }
              dispatchLocalLights(G, Q, q, xe) {
                let be = xe;
                const Pe = this.device.scope,
                  we = G[c.bA],
                  Oe = we.length;
                for (let qe = 0; qe < Oe; qe++) {
                  const Tt = we[qe];
                  Tt.mask & q && (this.dispatchOmniLight(Q, Pe, Tt, be), be++);
                }
                const $e = G[c.z0],
                  gt = $e.length;
                for (let qe = 0; qe < gt; qe++) {
                  const Tt = $e[qe];
                  Tt.mask & q && (this.dispatchSpotLight(Q, Pe, Tt, be), be++);
                }
              }
              renderForwardPrepareMaterials(G, Q, q, xe, be, Pe) {
                const we = (ut, At, xt, jt) => {
                  ht.drawCalls.push(ut),
                    ht.shaderInstances.push(At),
                    ht.isNewMaterial.push(xt),
                    ht.lightMaskChanged.push(jt);
                };
                ht.clear();
                const Oe = this.device,
                  $e = this.scene,
                  gt = $e.clusteredLightingEnabled,
                  qe = be ? be.getLightHash(gt) : 0;
                let Tt = null,
                  Mt,
                  Dt;
                for (let ut = 0; ut < q; ut++) {
                  const At = Q[ut];
                  if (At.command) we(At, null, !1, !1);
                  else {
                    At.ensureMaterial(Oe);
                    const xt = At.material,
                      jt = At._shaderDefs,
                      Gt = At.mask;
                    xt && xt === Tt && jt !== Mt && (Tt = null),
                      xt !== Tt &&
                        (this._materialSwitches++,
                        (xt._scene = $e),
                        xt.dirty &&
                          (xt.updateUniforms(Oe, $e), (xt.dirty = !1)),
                        xt._dirtyBlend && ($e.layers._dirtyBlend = !0));
                    const yt = At.getShaderInstance(
                      Pe,
                      qe,
                      $e,
                      this.viewUniformFormat,
                      this.viewBindGroupFormat,
                      xe
                    );
                    we(At, yt, xt !== Tt, !Tt || Gt !== Dt),
                      (Tt = xt),
                      (Mt = jt),
                      (Dt = Gt);
                  }
                }
                return Oe.endShaderBatch == null || Oe.endShaderBatch(), ht;
              }
              renderForwardInternal(G, Q, q, xe, be, Pe) {
                const we = this.device,
                  Oe = this.scene,
                  $e = 1 << xe,
                  gt = Pe ? -1 : 1,
                  qe = this.scene.clusteredLightingEnabled;
                let Tt = !1;
                const Mt = Q.drawCalls.length;
                for (let At = 0; At < Mt; At++) {
                  const xt = Q.drawCalls[At];
                  if (xt.command) xt.command();
                  else {
                    var Dt, ut;
                    const jt = Q.isNewMaterial[At],
                      Gt = Q.lightMaskChanged[At],
                      yt = Q.shaderInstances[At],
                      Ae = xt.material;
                    xt._shaderDefs;
                    const Xe = xt.mask;
                    if (jt) {
                      const at = yt.shader;
                      if (
                        (!at.failed && we.setShader(at), (Tt = at.failed), Tt)
                      )
                        break;
                      if ((Ae.setParameters(we), Gt)) {
                        const Pt = this.dispatchDirectLights(
                          q[c.WQ],
                          Oe,
                          Xe,
                          G
                        );
                        qe || this.dispatchLocalLights(q, Oe, Xe, Pt);
                      }
                      this.alphaTestId.setValue(Ae.alphaTest),
                        we.setBlendState(Ae.blendState),
                        we.setDepthState(Ae.depthState),
                        we.setAlphaToCoverage(Ae.alphaToCoverage),
                        Ae.depthBias || Ae.slopeDepthBias
                          ? (we.setDepthBias(!0),
                            we.setDepthBiasValues(
                              Ae.depthBias,
                              Ae.slopeDepthBias
                            ))
                          : we.setDepthBias(!1);
                    }
                    this.setupCullMode(G._cullFaces, gt, xt);
                    const Ye =
                        (Dt = xt.stencilFront) != null ? Dt : Ae.stencilFront,
                      it = (ut = xt.stencilBack) != null ? ut : Ae.stencilBack;
                    we.setStencilState(Ye, it);
                    const st = xt.mesh;
                    xt.setParameters(we, $e),
                      this.setVertexBuffers(we, st),
                      this.setMorphing(we, xt.morphInstance),
                      this.setSkinning(we, xt),
                      this.setupMeshUniformBuffers(yt, xt);
                    const He = xt.renderStyle;
                    if (
                      (we.setIndexBuffer(st.indexBuffer[He]),
                      be == null || be(xt, At),
                      G.xr && G.xr.session && G.xr.views.length)
                    ) {
                      const at = G.xr.views;
                      for (let Pt = 0; Pt < at.length; Pt++) {
                        const he = at[Pt];
                        we.setViewport(
                          he.viewport.x,
                          he.viewport.y,
                          he.viewport.z,
                          he.viewport.w
                        ),
                          this.projId.setValue(he.projMat.data),
                          this.projSkyboxId.setValue(he.projMat.data),
                          this.viewId.setValue(he.viewOffMat.data),
                          this.viewInvId.setValue(he.viewInvOffMat.data),
                          this.viewId3.setValue(he.viewMat3.data),
                          this.viewProjId.setValue(he.projViewOffMat.data),
                          this.viewPosId.setValue(he.position),
                          Pt === 0
                            ? this.drawInstance(we, xt, st, He, !0)
                            : this.drawInstance2(we, xt, st, He),
                          this._forwardDrawCalls++;
                      }
                    } else
                      this.drawInstance(we, xt, st, He, !0),
                        this._forwardDrawCalls++;
                    At < Mt - 1 &&
                      !Q.isNewMaterial[At + 1] &&
                      Ae.setParameters(we, xt.parameters);
                  }
                }
              }
              renderForward(G, Q, q, xe, be, Pe, we, Oe) {
                const $e = this.renderForwardPrepareMaterials(
                  G,
                  Q,
                  q,
                  xe,
                  we,
                  be
                );
                this.renderForwardInternal(G, $e, xe, be, Pe, Oe), ht.clear();
              }
              setSceneConstants() {
                const G = this.scene;
                if ((this.dispatchGlobalLights(G), G.fog !== c.YV)) {
                  if (
                    ((this.fogColor[0] = G.fogColor.r),
                    (this.fogColor[1] = G.fogColor.g),
                    (this.fogColor[2] = G.fogColor.b),
                    G.gammaCorrection)
                  )
                    for (let q = 0; q < 3; q++)
                      this.fogColor[q] = Math.pow(this.fogColor[q], 2.2);
                  this.fogColorId.setValue(this.fogColor),
                    G.fog === c.ce
                      ? (this.fogStartId.setValue(G.fogStart),
                        this.fogEndId.setValue(G.fogEnd))
                      : this.fogDensityId.setValue(G.fogDensity);
                }
                const Q = this.device;
                (this._screenSize[0] = Q.width),
                  (this._screenSize[1] = Q.height),
                  (this._screenSize[2] = 1 / Q.width),
                  (this._screenSize[3] = 1 / Q.height),
                  this.screenSizeId.setValue(this._screenSize),
                  this.pcssDiskSamplesId.setValue(this.pcssDiskSamples),
                  this.pcssSphereSamplesId.setValue(this.pcssSphereSamples);
              }
              updateLightStats(G, Q) {}
              buildFrameGraph(G, Q) {
                const q = this.scene.clusteredLightingEnabled;
                if ((G.reset(), this.update(Q), q)) {
                  {
                    const Oe = new g.CD(this.device, () => {
                      this.scene.lighting.cookiesEnabled &&
                        (this.renderCookies(Q._splitLights[c.z0]),
                        this.renderCookies(Q._splitLights[c.bA]));
                    });
                    (Oe.requiresCubemaps = !1), G.addRenderPass(Oe);
                  }
                  {
                    const Oe = new g.CD(this.device);
                    if (
                      ((Oe.requiresCubemaps = !1),
                      G.addRenderPass(Oe),
                      this.scene.lighting.shadowsEnabled)
                    ) {
                      const $e = Q._splitLights;
                      this._shadowRendererLocal.prepareClusteredRenderPass(
                        Oe,
                        $e[c.z0],
                        $e[c.bA]
                      );
                    }
                    Oe.after = () => {
                      this.updateClusters(Q);
                    };
                  }
                } else {
                  const Oe = Q._splitLights;
                  this._shadowRendererLocal.buildNonClusteredRenderPasses(
                    G,
                    Oe[c.z0],
                    Oe[c.bA]
                  );
                }
                let xe = 0,
                  be = !0,
                  Pe = null;
                const we = Q._renderActions;
                for (let Oe = xe; Oe < we.length; Oe++) {
                  const $e = we[Oe],
                    gt = Q.layerList[$e.layerIndex],
                    qe = gt.cameras[$e.cameraIndex];
                  if (!$e.isLayerEnabled(Q)) continue;
                  const Mt =
                    gt.id === c.Pp &&
                    (qe.renderSceneColorMap || qe.renderSceneDepthMap);
                  $e.hasDirectionalShadowLights &&
                    qe &&
                    this._shadowRendererDirectional.buildFrameGraph(G, $e, qe),
                    be && ((be = !1), (xe = Oe), (Pe = $e.renderTarget));
                  let Dt = Oe + 1;
                  for (; we[Dt] && !we[Dt].isLayerEnabled(Q); ) Dt++;
                  const ut = we[Dt],
                    xt =
                      (ut ? Q.layerList[ut.layerIndex].id === c.Pp : !1) &&
                      (qe.renderSceneColorMap || qe.renderSceneDepthMap);
                  if (
                    !ut ||
                    ut.renderTarget !== Pe ||
                    ut.hasDirectionalShadowLights ||
                    xt ||
                    Mt
                  ) {
                    if (
                      (this.addMainRenderPass(G, Q, Pe, xe, Oe, Mt),
                      $e.triggerPostprocess &&
                        qe != null &&
                        qe.onPostprocessing)
                    ) {
                      const jt = new g.CD(this.device, () => {
                        this.renderPassPostprocessing($e, Q);
                      });
                      (jt.requiresCubemaps = !1), G.addRenderPass(jt);
                    }
                    be = !0;
                  }
                }
              }
              addMainRenderPass(G, Q, q, xe, be, Pe) {
                const we = { start: xe, end: be },
                  Oe = new g.CD(this.device, () => {
                    this.renderPassRenderActions(Q, we);
                  }),
                  $e = Q._renderActions,
                  gt = $e[xe],
                  qe = $e[be],
                  Mt = Q.layerList[gt.layerIndex].cameras[gt.cameraIndex];
                Mt &&
                  (gt.firstCameraUse &&
                    Mt.onPreRender &&
                    (Oe.before = () => {
                      Mt.onPreRender();
                    }),
                  qe.lastCameraUse &&
                    Mt.onPostRender &&
                    (Oe.after = () => {
                      Mt.onPostRender();
                    }));
                const Dt = Pe && Le.$.requiresRenderPass(this.device, Mt);
                (!Pe || Dt) &&
                  (Oe.init(q),
                  (Oe.fullSizeClearRect = Mt.camera.fullSizeClearRect),
                  Dt
                    ? (Oe.setClearColor(ke), Oe.setClearDepth(1))
                    : Oe.fullSizeClearRect &&
                      (gt.clearColor && Oe.setClearColor(Mt.camera.clearColor),
                      gt.clearDepth && Oe.setClearDepth(Mt.camera.clearDepth),
                      gt.clearStencil &&
                        Oe.setClearStencil(Mt.camera.clearStencil))),
                  G.addRenderPass(Oe);
              }
              update(G) {
                this.frameUpdate(), this.shadowRenderer.frameUpdate();
                const Q = this.scene.clusteredLightingEnabled;
                this.scene._updateSky(this.device);
                const q = this.updateLayerComposition(G, Q),
                  xe = (q & c.S9) !== 0;
                this.updateLightStats(G, q),
                  this.beginFrame(G, xe),
                  this.setSceneConstants(),
                  this.cullComposition(G),
                  this.gpuUpdate(G._meshInstances);
              }
              renderPassPostprocessing(G, Q) {
                Q.layerList[G.layerIndex].cameras[
                  G.cameraIndex
                ].onPostprocessing();
              }
              renderPassRenderActions(G, Q) {
                const q = G._renderActions;
                for (let xe = Q.start; xe <= Q.end; xe++)
                  this.renderRenderAction(G, q[xe], xe === Q.start);
              }
              renderRenderAction(G, Q, q) {
                const xe = this.scene.clusteredLightingEnabled,
                  be = this.device,
                  Pe = Q.layerIndex,
                  we = G.layerList[Pe],
                  Oe = G.subLayerList[Pe],
                  $e = Q.cameraIndex,
                  gt = we.cameras[$e];
                if (Q.isLayerEnabled(G)) {
                  if (
                    (!Oe && we.onPreRenderOpaque
                      ? we.onPreRenderOpaque($e)
                      : Oe &&
                        we.onPreRenderTransparent &&
                        we.onPreRenderTransparent($e),
                    we._preRenderCalledForCameras & (1 << $e) ||
                      (we.onPreRender && we.onPreRender($e),
                      (we._preRenderCalledForCameras |= 1 << $e)),
                    gt)
                  ) {
                    var qe, Tt, Mt;
                    this.setupViewport(gt.camera, Q.renderTarget),
                      (!q || !gt.camera.fullSizeClearRect) &&
                        this.clear(
                          gt.camera,
                          Q.clearColor,
                          Q.clearDepth,
                          Q.clearStencil
                        ),
                      we._sortVisible(Oe, gt.camera.node, $e);
                    const Dt = we.instances,
                      ut = Oe
                        ? Dt.visibleTransparent[$e]
                        : Dt.visibleOpaque[$e];
                    this.scene.immediate.onPreRenderLayer(we, ut, Oe),
                      xe &&
                        Q.lightClusters &&
                        (Q.lightClusters.activate(),
                        !this.clustersDebugRendered &&
                          this.scene.lighting.debugLayer === we.id &&
                          (this.clustersDebugRendered = !0)),
                      (this.scene._activeCamera = gt.camera);
                    const At = this.setCameraUniforms(
                      gt.camera,
                      Q.renderTarget
                    );
                    be.supportsUniformBuffers &&
                      this.setupViewUniformBuffers(
                        Q.viewBindGroups,
                        this.viewUniformFormat,
                        this.viewBindGroupFormat,
                        At
                      );
                    const xt = !!(
                        gt.camera._flipFaces ^
                        (Q == null || (qe = Q.renderTarget) == null
                          ? void 0
                          : qe.flipY)
                      ),
                      jt =
                        (Tt =
                          (Mt = gt.camera.shaderPassInfo) == null
                            ? void 0
                            : Mt.index) != null
                          ? Tt
                          : we.shaderPass,
                      Gt = this._forwardDrawCalls;
                    this.renderForward(
                      gt.camera,
                      ut.list,
                      ut.length,
                      we._splitLights,
                      jt,
                      we.onDrawCall,
                      we,
                      xt
                    ),
                      (we._forwardDrawCalls += this._forwardDrawCalls - Gt),
                      be.setBlendState(u.a.NOBLEND),
                      be.setStencilState(null, null),
                      be.setAlphaToCoverage(!1),
                      be.setDepthBias(!1);
                  }
                  !Oe && we.onPostRenderOpaque
                    ? we.onPostRenderOpaque($e)
                    : Oe &&
                      we.onPostRenderTransparent &&
                      we.onPostRenderTransparent($e),
                    we.onPostRender &&
                      !(we._postRenderCalledForCameras & (1 << $e)) &&
                      ((we._postRenderCounter &= ~(Oe ? 2 : 1)),
                      we._postRenderCounter === 0 &&
                        (we.onPostRender($e),
                        (we._postRenderCalledForCameras |= 1 << $e),
                        (we._postRenderCounter = we._postRenderCounterMax)));
                }
              }
            }
          },
          4279: (Se, W, a) => {
            "use strict";
            a.d(W, { i: () => n });
            var x = a(6847),
              T = a(6556),
              g = a(9758),
              c = a(3114),
              d = a(6165),
              h = a(7915);
            const f = new g.y(),
              s = new g.y(),
              l = new g.y();
            class n {
              static create(i, e, t) {
                const r = new d.V();
                switch (
                  ((r.node = new h.A(i)),
                  (r.aspectRatio = 1),
                  (r.aspectRatioMode = c.Gr),
                  (r._scissorRectClear = !0),
                  e)
                ) {
                  case c.bA:
                    r.node.setRotation(n.pointLightRotations[t]),
                      (r.fov = 90),
                      (r.projection = c.pm);
                    break;
                  case c.z0:
                    r.projection = c.pm;
                    break;
                  case c.WQ:
                    r.projection = c.Uc;
                    break;
                }
                return r;
              }
              static evalSpotCookieMatrix(i) {
                let e = n._spotCookieCamera;
                e ||
                  ((e = n.create("SpotCookieCamera", c.z0)),
                  (n._spotCookieCamera = e)),
                  (e.fov = i._outerConeAngle * 2);
                const t = e._node;
                t.setPosition(i._node.getPosition()),
                  t.setRotation(i._node.getRotation()),
                  t.rotateLocal(-90, 0, 0),
                  f.setTRS(t.getPosition(), t.getRotation(), T.A.ONE).invert(),
                  s.mul2(e.projectionMatrix, f);
                const r = i.cookieMatrix,
                  u = i.atlasViewport;
                return l.setViewport(u.x, u.y, u.z, u.w), r.mul2(l, s), r;
              }
            }
            (n.pointLightRotations = [
              new x.D().setFromEulerAngles(0, 90, 180),
              new x.D().setFromEulerAngles(0, -90, 180),
              new x.D().setFromEulerAngles(90, 0, 0),
              new x.D().setFromEulerAngles(-90, 0, 0),
              new x.D().setFromEulerAngles(0, 180, 180),
              new x.D().setFromEulerAngles(0, 0, 180),
            ]),
              (n._spotCookieCamera = null);
          },
          8400: (Se, W, a) => {
            "use strict";
            a.d(W, { b: () => P });
            var x = a(1367),
              T = a(9758),
              g = a(6556),
              c = a(6630),
              d = a(7921),
              h = a(464),
              f = a(3114),
              s = a(1585),
              l = a(3200),
              n = a(9375),
              o = a(4279),
              i = a(289),
              e = a(2158),
              t = a(8277),
              r = a(7013);
            function u(I, A) {
              return Math.exp(-(I * I) / (2 * A * A));
            }
            function y(I) {
              const A = (I - 1) / 6,
                B = (I - 1) * 0.5,
                C = new Array(I);
              let w = 0;
              for (let k = 0; k < I; ++k) (C[k] = u(k - B, A)), (w += C[k]);
              for (let k = 0; k < I; ++k) C[k] /= w;
              return C;
            }
            const p = new T.y(),
              _ = new T.y(),
              m = new Float32Array(2),
              E = new c.T(1, 1, 0, 0),
              v = new T.y();
            class P {
              constructor(A, B) {
                (this.shadowPassCache = []),
                  (this.device = A.device),
                  (this.renderer = A),
                  (this.lightTextureAtlas = B);
                const C = this.device.scope;
                (this.polygonOffsetId = C.resolve("polygonOffset")),
                  (this.polygonOffset = new Float32Array(2)),
                  (this.sourceId = C.resolve("source")),
                  (this.pixelOffsetId = C.resolve("pixelOffset")),
                  (this.weightId = C.resolve("weight[0]")),
                  (this.blurVsmShaderCode = [
                    l.n.blurVSMPS,
                    `#define GAUSS
` + l.n.blurVSMPS,
                  ]);
                const w = `#define PACKED
`;
                (this.blurPackedVsmShaderCode = [
                  w + this.blurVsmShaderCode[0],
                  w + this.blurVsmShaderCode[1],
                ]),
                  (this.blurVsmShader = [{}, {}]),
                  (this.blurPackedVsmShader = [{}, {}]),
                  (this.blurVsmWeights = {}),
                  (this.shadowMapLightRadiusId = C.resolve("light_radius")),
                  (this.viewUniformFormat = null),
                  (this.viewBindGroupFormat = null),
                  (this.blendStateWrite = new t.a()),
                  (this.blendStateNoWrite = new t.a()),
                  this.blendStateNoWrite.setColorWrite(!1, !1, !1, !1);
              }
              static createShadowCamera(A, B, C, w) {
                const k = o.i.create("ShadowCamera", C, w);
                return (
                  B >= f.JN && B <= f.oK
                    ? (k.clearColor = new x.I(0, 0, 0, 0))
                    : (k.clearColor = new x.I(1, 1, 1, 1)),
                  (k.clearDepthBuffer = !0),
                  (k.clearStencilBuffer = !1),
                  k
                );
              }
              static setShadowCameraSettings(A, B, C, w, k) {
                let K =
                  C === f.sz ||
                  ((C === f.sH || C === f.iW) && B.supportsDepthShadow);
                w === f.bA && !k && (K = !1), (A.clearColorBuffer = !K);
              }
              cullShadowCasters(A, B, C) {
                let w = 0;
                const k = A.length;
                for (let K = 0; K < k; K++) {
                  const te = A[K];
                  te.castShadow &&
                    (!te.cull || te._isVisible(C)) &&
                    ((te.visibleThisFrame = !0), (B[w] = te), w++);
                }
                (B.length = w), B.sort(this.renderer.sortCompareDepth);
              }
              setupRenderState(A, B) {
                const C = this.renderer.scene.clusteredLightingEnabled;
                A.webgl2 || A.isWebGPU
                  ? B._type === f.bA && !C
                    ? A.setDepthBias(!1)
                    : (A.setDepthBias(!0),
                      A.setDepthBiasValues(
                        B.shadowBias * -1e3,
                        B.shadowBias * -1e3
                      ))
                  : A.extStandardDerivatives &&
                    (B._type === f.bA
                      ? ((this.polygonOffset[0] = 0),
                        (this.polygonOffset[1] = 0),
                        this.polygonOffsetId.setValue(this.polygonOffset))
                      : ((this.polygonOffset[0] = B.shadowBias * -1e3),
                        (this.polygonOffset[1] = B.shadowBias * -1e3),
                        this.polygonOffsetId.setValue(this.polygonOffset)));
                const w = A.webgl2 || A.isWebGPU,
                  k = C ? B._isPcf && w : B._isPcf && w && B._type !== f.bA;
                A.setBlendState(
                  k ? this.blendStateNoWrite : this.blendStateWrite
                ),
                  A.setDepthState(r.b.DEFAULT),
                  A.setStencilState(null, null);
              }
              restoreRenderState(A) {
                A.webgl2 || A.isWebGPU
                  ? A.setDepthBias(!1)
                  : A.extStandardDerivatives &&
                    ((this.polygonOffset[0] = 0),
                    (this.polygonOffset[1] = 0),
                    this.polygonOffsetId.setValue(this.polygonOffset));
              }
              dispatchUniforms(A, B, C, w) {
                const k = B._node;
                A._type !== f.WQ &&
                  (this.renderer.dispatchViewPos(k.getPosition()),
                  this.shadowMapLightRadiusId.setValue(A.attenuationEnd)),
                  p.setTRS(k.getPosition(), k.getRotation(), g.A.ONE).invert(),
                  _.mul2(B.projectionMatrix, p);
                const K = C.shadowViewport;
                (B.rect = K),
                  (B.scissorRect = C.shadowScissor),
                  v.setViewport(K.x, K.y, K.z, K.w),
                  C.shadowMatrix.mul2(v, _),
                  A._type === f.WQ &&
                    A._shadowMatrixPalette.set(C.shadowMatrix.data, w * 16);
              }
              getShadowPass(A) {
                var B;
                const C = A._type,
                  w = A._shadowType;
                let k = (B = this.shadowPassCache[C]) == null ? void 0 : B[w];
                if (!k) {
                  const K = `ShadowPass_${C}_${w}`;
                  (k = s.T.get(this.device).allocate(K, {
                    isShadow: !0,
                    lightType: C,
                    shadowType: w,
                  })),
                    this.shadowPassCache[C] || (this.shadowPassCache[C] = []),
                    (this.shadowPassCache[C][w] = k);
                }
                return k.index;
              }
              submitCasters(A, B) {
                const C = this.device,
                  w = this.renderer,
                  k = w.scene,
                  K = 1 << f.w1,
                  te = this.getShadowPass(B),
                  X = A.length;
                for (let $ = 0; $ < X; $++) {
                  const ne = A[$],
                    Y = ne.mesh;
                  ne.ensureMaterial(C);
                  const Z = ne.material;
                  w.setBaseConstants(C, Z),
                    w.setSkinning(C, ne),
                    Z.dirty && (Z.updateUniforms(C, k), (Z.dirty = !1)),
                    Z.chunks &&
                      (w.setupCullMode(!0, 1, ne),
                      Z.setParameters(C),
                      ne.setParameters(C, K));
                  const ye = ne.getShaderInstance(
                      te,
                      0,
                      k,
                      this.viewUniformFormat,
                      this.viewBindGroupFormat
                    ),
                    pe = ye.shader;
                  (ne._key[f.UG] = pe.id),
                    !pe.failed && C.setShader(pe),
                    w.setVertexBuffers(C, Y),
                    w.setMorphing(C, ne.morphInstance),
                    this.renderer.setupMeshUniformBuffers(ye, ne);
                  const O = ne.renderStyle;
                  C.setIndexBuffer(Y.indexBuffer[O]),
                    w.drawInstance(C, ne, Y, O),
                    w._shadowDrawCalls++;
                }
              }
              needsShadowRendering(A) {
                const B =
                  A.enabled &&
                  A.castShadows &&
                  A.shadowUpdateMode !== f.yo &&
                  A.visibleThisFrame;
                return (
                  A.shadowUpdateMode === f.b1 && (A.shadowUpdateMode = f.yo),
                  B && (this.renderer._shadowMapUpdates += A.numShadowFaces),
                  B
                );
              }
              getLightRenderData(A, B, C) {
                return A.getRenderData(A._type === f.WQ ? B : null, C);
              }
              setupRenderPass(A, B, C) {
                const w = B.renderTarget;
                A.init(w),
                  (A.depthStencilOps.clearDepthValue = 1),
                  (A.depthStencilOps.clearDepth = C),
                  w.depthBuffer
                    ? (A.depthStencilOps.storeDepth = !0)
                    : (A.colorOps.clearValue.copy(B.clearColor),
                      (A.colorOps.clear = C),
                      (A.depthStencilOps.storeDepth = !1)),
                  (A.requiresCubemaps = !1);
              }
              prepareFace(A, B, C) {
                const w = A._type,
                  k = A._shadowType,
                  K = this.renderer.scene.clusteredLightingEnabled,
                  X = this.getLightRenderData(A, B, C).shadowCamera;
                P.setShadowCameraSettings(X, this.device, k, w, K);
                const $ = w === f.WQ ? 0 : C;
                return (X.renderTarget = A._shadowMap.renderTargets[$]), X;
              }
              renderFace(A, B, C, w, k = !0) {
                const K = this.device,
                  te = this.getLightRenderData(A, B, C),
                  X = te.shadowCamera;
                this.dispatchUniforms(A, X, te, C);
                const $ = X.renderTarget,
                  ne = this.renderer;
                ne.setCameraUniforms(X, $),
                  K.supportsUniformBuffers &&
                    ne.setupViewUniformBuffers(
                      te.viewBindGroups,
                      this.viewUniformFormat,
                      this.viewBindGroupFormat,
                      1
                    ),
                  k
                    ? (ne.setupViewport(X, $), w && ne.clear(X))
                    : ne.clearView(X, $, !0, !1),
                  this.setupRenderState(K, A),
                  this.submitCasters(te.visibleCasters, A),
                  this.restoreRenderState(K);
              }
              render(A, B, C = !0) {
                if (this.needsShadowRendering(A)) {
                  const w = A.numShadowFaces;
                  for (let k = 0; k < w; k++)
                    this.prepareFace(A, B, k), this.renderFace(A, B, k, !0, C);
                  this.renderVsm(A, B);
                }
              }
              renderVsm(A, B) {
                A._isVsm &&
                  A._vsmBlurSize > 1 &&
                  (!this.renderer.scene.clusteredLightingEnabled ||
                    A._type === f.WQ) &&
                  this.applyVsmBlur(A, B);
              }
              getVsmBlurShader(A, B, C) {
                let w = (A ? this.blurPackedVsmShader : this.blurVsmShader)[B][
                  C
                ];
                if (!w) {
                  this.blurVsmWeights[C] = y(C);
                  const k = l.n.fullscreenQuadVS;
                  let K =
                    "#define SAMPLES " +
                    C +
                    `
`;
                  A
                    ? (K += this.blurPackedVsmShaderCode[B])
                    : (K += this.blurVsmShaderCode[B]);
                  const te = "blurVsm" + B + C + A;
                  (w = (0, n.JM)(this.device, k, K, te)),
                    A
                      ? (this.blurPackedVsmShader[B][C] = w)
                      : (this.blurVsmShader[B][C] = w);
                }
                return w;
              }
              applyVsmBlur(A, B) {
                const C = this.device;
                C.setBlendState(t.a.NOBLEND);
                const K = A.getRenderData(A._type === f.WQ ? B : null, 0)
                    .shadowCamera.renderTarget,
                  te = this.renderer.shadowMapCache.get(C, A),
                  X = te.renderTargets[0],
                  $ = A._shadowType === f.JN,
                  ne = A.vsmBlurMode,
                  Y = A._vsmBlurSize,
                  Z = this.getVsmBlurShader($, ne, Y);
                (E.z = A._shadowResolution - 2),
                  (E.w = E.z),
                  this.sourceId.setValue(K.colorBuffer),
                  (m[0] = 1 / A._shadowResolution),
                  (m[1] = 0),
                  this.pixelOffsetId.setValue(m),
                  ne === f.J2 && this.weightId.setValue(this.blurVsmWeights[Y]),
                  (0, h.H)(C, X, Z, null, E),
                  this.sourceId.setValue(X.colorBuffer),
                  (m[1] = m[0]),
                  (m[0] = 0),
                  this.pixelOffsetId.setValue(m),
                  (0, h.H)(C, K, Z, null, E),
                  this.renderer.shadowMapCache.add(A, te);
              }
              initViewBindGroupFormat() {
                this.device.supportsUniformBuffers &&
                  !this.viewUniformFormat &&
                  ((this.viewUniformFormat = new i.f(this.device, [
                    new i.M("matrix_viewProjection", d.EA4),
                  ])),
                  (this.viewBindGroupFormat = new e.WM(
                    this.device,
                    [new e.Q1(d.ASF, d.y4i | d.sxQ)],
                    []
                  )));
              }
              frameUpdate() {
                this.initViewBindGroupFormat();
              }
            }
          },
          7224: (Se, W, a) => {
            "use strict";
            a.d(W, { x: () => $ });
            var x = a(5338),
              T = a(1367),
              g = a(6556),
              c = a(6847),
              d = a(4585),
              h = a(4486),
              f = a(9758),
              s = a(7982),
              l = a(7921),
              n = a(3114),
              o = a(1071),
              i = a(4611),
              e = a(7915),
              t = a(2737),
              r = a(8792),
              u = a(192),
              y = a(3200),
              p = a(7198),
              _ = a(2172),
              m = a(3862);
            const E = {
              generateKey: function (ne) {
                return ne.type === "cubemap"
                  ? `skybox-${ne.type}-${ne.encoding}-${ne.useIntensity}-${ne.gamma}-${ne.toneMapping}-${ne.fixSeams}-${ne.mip}`
                  : `skybox-${ne.type}-${ne.encoding}-${ne.useIntensity}-${ne.gamma}-${ne.toneMapping}`;
              },
              createShaderDefinition: function (ne, Y) {
                let Z = "";
                if (Y.type === "cubemap") {
                  const ye = [128, 64, 16, 8, 4, 2];
                  (Z += Y.mip
                    ? y.n.fixCubemapSeamsStretchPS
                    : y.n.fixCubemapSeamsNonePS),
                    (Z += Y.useIntensity ? y.n.envMultiplyPS : y.n.envConstPS),
                    (Z += y.n.decodePS),
                    (Z += (0, _.li)(Y.gamma)),
                    (Z += (0, _.ph)(Y.toneMapping)),
                    (Z += y.n.skyboxHDRPS
                      .replace(/\$DECODE/g, p.a.decodeFunc(Y.encoding))
                      .replace(/\$FIXCONST/g, 1 - 1 / ye[Y.mip] + ""));
                } else
                  (Z += Y.useIntensity ? y.n.envMultiplyPS : y.n.envConstPS),
                    (Z += y.n.decodePS),
                    (Z += (0, _.li)(Y.gamma)),
                    (Z += (0, _.ph)(Y.toneMapping)),
                    (Z += y.n.sphericalPS),
                    (Z += y.n.envAtlasPS),
                    (Z += y.n.skyboxEnvPS.replace(
                      /\$DECODE/g,
                      p.a.decodeFunc(Y.encoding)
                    ));
                return m.x.createDefinition(ne, {
                  name: "SkyboxShader",
                  attributes: { aPosition: l.Q5v },
                  vertexCode: y.n.skyboxVS,
                  fragmentCode: Z,
                });
              },
            };
            class v {
              constructor(Y, Z, ye) {
                this.meshInstance = void 0;
                const pe = new t.F();
                (pe.getShaderVariant = function (me, N, V, L, J, ae, R, j) {
                  const se = {
                    pass: J,
                    encoding: ye.encoding,
                    useIntensity: Z.skyboxIntensity !== 1 || Z.physicalUnits,
                    gamma:
                      J === n.zw
                        ? Z.gammaCorrection
                          ? n.CH
                          : n.Ie
                        : Z.gammaCorrection,
                    toneMapping: J === n.zw ? n.Fz : Z.toneMapping,
                  };
                  ye.cubemap
                    ? ((se.type = "cubemap"),
                      (se.mip = ye.fixCubemapSeams ? Z.skyboxMip : 0),
                      (se.fixSeams = ye.fixCubemapSeams))
                    : (se.type = "envAtlas");
                  const ce = new o.C(R, j),
                    ie = (0, u.N)(Y);
                  return (
                    ie.register("skybox", E), ie.getProgram("skybox", se, ce)
                  );
                }),
                  ye.cubemap
                    ? pe.setParameter("texture_cubeMap", ye)
                    : (pe.setParameter("texture_envAtlas", ye),
                      pe.setParameter("mipLevel", Z._skyboxMip)),
                  (pe.cull = l.TWf),
                  (pe.depthWrite = !1);
                const O = Z.layers.getLayerById(n.Fk);
                if (O) {
                  const me = new e.A("Skybox"),
                    N = (0, i.dO)(Y),
                    V = new r.l(N, pe, me);
                  (this.meshInstance = V),
                    (V.cull = !1),
                    (V._noDepthDrawGl1 = !0),
                    (V.pick = !1),
                    O.addMeshInstances([V]),
                    (this.skyLayer = O);
                }
              }
              destroy() {
                this.meshInstance &&
                  (this.skyLayer &&
                    this.skyLayer.removeMeshInstances([this.meshInstance]),
                  this.meshInstance.destroy(),
                  (this.meshInstance = null));
              }
            }
            var P = a(4641),
              I = a(7678),
              A = a(5752),
              B = a(9375);
            const C = new e.A();
            (C.worldTransform = f.y.IDENTITY),
              (C._dirtyWorld = C._dirtyNormal = !1);
            class w {
              constructor(Y, Z, ye) {
                (this.material = Z),
                  (this.layer = ye),
                  (this.positions = []),
                  (this.colors = []),
                  (this.mesh = new I.K(Y)),
                  (this.meshInstance = null);
              }
              addLines(Y, Z) {
                const ye = this.positions,
                  pe = Y.length;
                for (let me = 0; me < pe; me++) {
                  const N = Y[me];
                  ye.push(N.x, N.y, N.z);
                }
                const O = this.colors;
                if (Z.length)
                  for (let me = 0; me < pe; me++) {
                    const N = Z[me];
                    O.push(N.r, N.g, N.b, N.a);
                  }
                else for (let me = 0; me < pe; me++) O.push(Z.r, Z.g, Z.b, Z.a);
              }
              addLinesArrays(Y, Z) {
                const ye = this.positions;
                for (let O = 0; O < Y.length; O += 3)
                  ye.push(Y[O], Y[O + 1], Y[O + 2]);
                const pe = this.colors;
                if (Z.length)
                  for (let O = 0; O < Z.length; O += 4)
                    pe.push(Z[O], Z[O + 1], Z[O + 2], Z[O + 3]);
                else {
                  const O = Y.length / 3;
                  for (let me = 0; me < O; me++) pe.push(Z.r, Z.g, Z.b, Z.a);
                }
              }
              onPreRender(Y, Z) {
                this.positions.length > 0 &&
                  this.material.transparent === Z &&
                  (this.mesh.setPositions(this.positions),
                  this.mesh.setColors(this.colors),
                  this.mesh.update(l.Y7R, !1),
                  this.meshInstance ||
                    (this.meshInstance = new r.l(this.mesh, this.material, C)),
                  (this.positions.length = 0),
                  (this.colors.length = 0),
                  Y.list.push(this.meshInstance),
                  Y.length++);
              }
            }
            class k {
              constructor(Y) {
                (this.device = Y), (this.map = new Map());
              }
              getBatch(Y, Z) {
                let ye = this.map.get(Y);
                return (
                  ye || ((ye = new w(this.device, Y, Z)), this.map.set(Y, ye)),
                  ye
                );
              }
              onPreRender(Y, Z) {
                this.map.forEach((ye) => {
                  ye.onPreRender(Y, Z);
                });
              }
            }
            const K = [];
            class te {
              constructor(Y) {
                (this.device = Y),
                  (this.quadMesh = null),
                  (this.textureShader = null),
                  (this.depthTextureShader = null),
                  (this.cubeLocalPos = null),
                  (this.cubeWorldPos = null),
                  (this.batchesMap = new Map()),
                  (this.allBatches = new Set()),
                  (this.updatedLayers = new Set()),
                  (this._materialDepth = null),
                  (this._materialNoDepth = null),
                  (this.layerMeshInstances = new Map());
              }
              createMaterial(Y) {
                const Z = new A.K();
                return (
                  (Z.vertexColors = !0),
                  (Z.blendType = n.lA),
                  (Z.depthTest = Y),
                  Z.update(),
                  Z
                );
              }
              get materialDepth() {
                return (
                  this._materialDepth ||
                    (this._materialDepth = this.createMaterial(!0)),
                  this._materialDepth
                );
              }
              get materialNoDepth() {
                return (
                  this._materialNoDepth ||
                    (this._materialNoDepth = this.createMaterial(!1)),
                  this._materialNoDepth
                );
              }
              getBatch(Y, Z) {
                let ye = this.batchesMap.get(Y);
                ye || ((ye = new k(this.device)), this.batchesMap.set(Y, ye)),
                  this.allBatches.add(ye);
                const pe = Z ? this.materialDepth : this.materialNoDepth;
                return ye.getBatch(pe, Y);
              }
              getShader(Y, Z) {
                if (!this[Y]) {
                  const ye = `
								attribute vec2 vertex_position;
								uniform mat4 matrix_model;
								varying vec2 uv0;
								void main(void) {
										gl_Position = matrix_model * vec4(vertex_position, 0, 1);
										uv0 = vertex_position.xy + 0.5;
								}
						`;
                  this[Y] = (0, B.JM)(this.device, ye, Z, `DebugShader:${Y}`);
                }
                return this[Y];
              }
              getTextureShader() {
                return this.getShader(
                  "textureShader",
                  `
						varying vec2 uv0;
						uniform sampler2D colorMap;
						void main (void) {
								gl_FragColor = vec4(texture2D(colorMap, uv0).xyz, 1);
						}
				`
                );
              }
              getUnfilterableTextureShader() {
                return this.getShader(
                  "textureShaderUnfilterable",
                  `
						varying vec2 uv0;
						uniform highp sampler2D colorMap;
						void main (void) {
								ivec2 uv = ivec2(uv0 * textureSize(colorMap, 0));
								gl_FragColor = vec4(texelFetch(colorMap, uv, 0).xyz, 1);
						}
				`
                );
              }
              getDepthTextureShader() {
                return this.getShader(
                  "depthTextureShader",
                  `
						${y.n.screenDepthPS}
						varying vec2 uv0;
						void main() {
								float depth = getLinearScreenDepth(uv0) * camera_params.x;
								gl_FragColor = vec4(vec3(depth), 1.0);
						}
				`
                );
              }
              getQuadMesh() {
                return (
                  this.quadMesh ||
                    ((this.quadMesh = new I.K(this.device)),
                    this.quadMesh.setPositions([
                      -0.5, -0.5, 0, 0.5, -0.5, 0, -0.5, 0.5, 0, 0.5, 0.5, 0,
                    ]),
                    this.quadMesh.update(l.fmY)),
                  this.quadMesh
                );
              }
              drawMesh(Y, Z, ye, pe, O) {
                if (!pe) {
                  const N = this.getGraphNode(Z);
                  pe = new r.l(ye, Y, N);
                }
                let me = this.layerMeshInstances.get(O);
                me || ((me = []), this.layerMeshInstances.set(O, me)),
                  me.push(pe);
              }
              drawWireAlignedBox(Y, Z, ye, pe, O) {
                K.push(
                  Y.x,
                  Y.y,
                  Y.z,
                  Y.x,
                  Z.y,
                  Y.z,
                  Y.x,
                  Z.y,
                  Y.z,
                  Z.x,
                  Z.y,
                  Y.z,
                  Z.x,
                  Z.y,
                  Y.z,
                  Z.x,
                  Y.y,
                  Y.z,
                  Z.x,
                  Y.y,
                  Y.z,
                  Y.x,
                  Y.y,
                  Y.z,
                  Y.x,
                  Y.y,
                  Z.z,
                  Y.x,
                  Z.y,
                  Z.z,
                  Y.x,
                  Z.y,
                  Z.z,
                  Z.x,
                  Z.y,
                  Z.z,
                  Z.x,
                  Z.y,
                  Z.z,
                  Z.x,
                  Y.y,
                  Z.z,
                  Z.x,
                  Y.y,
                  Z.z,
                  Y.x,
                  Y.y,
                  Z.z,
                  Y.x,
                  Y.y,
                  Y.z,
                  Y.x,
                  Y.y,
                  Z.z,
                  Y.x,
                  Z.y,
                  Y.z,
                  Y.x,
                  Z.y,
                  Z.z,
                  Z.x,
                  Z.y,
                  Y.z,
                  Z.x,
                  Z.y,
                  Z.z,
                  Z.x,
                  Y.y,
                  Y.z,
                  Z.x,
                  Y.y,
                  Z.z
                ),
                  this.getBatch(O, pe).addLinesArrays(K, ye),
                  (K.length = 0);
              }
              drawWireSphere(Y, Z, ye, pe, O, me) {
                const N = (2 * Math.PI) / pe;
                let V = 0;
                for (let J = 0; J < pe; J++) {
                  const ae = Math.sin(V),
                    R = Math.cos(V);
                  V += N;
                  const j = Math.sin(V),
                    se = Math.cos(V);
                  K.push(Y.x + Z * ae, Y.y, Y.z + Z * R),
                    K.push(Y.x + Z * j, Y.y, Y.z + Z * se),
                    K.push(Y.x + Z * ae, Y.y + Z * R, Y.z),
                    K.push(Y.x + Z * j, Y.y + Z * se, Y.z),
                    K.push(Y.x, Y.y + Z * ae, Y.z + Z * R),
                    K.push(Y.x, Y.y + Z * j, Y.z + Z * se);
                }
                this.getBatch(me, O).addLinesArrays(K, ye), (K.length = 0);
              }
              getGraphNode(Y) {
                const Z = new e.A("ImmediateDebug");
                return (
                  (Z.worldTransform = Y),
                  (Z._dirtyWorld = Z._dirtyNormal = !1),
                  Z
                );
              }
              onPreRenderLayer(Y, Z, ye) {
                if (
                  (this.batchesMap.forEach((pe, O) => {
                    O === Y && pe.onPreRender(Z, ye);
                  }),
                  !this.updatedLayers.has(Y))
                ) {
                  this.updatedLayers.add(Y);
                  const pe = this.layerMeshInstances.get(Y);
                  if (pe) {
                    for (let O = 0; O < pe.length; O++)
                      Z.list[Z.length + O] = pe[O];
                    (Z.length += pe.length), (pe.length = 0);
                  }
                }
              }
              onPostRender() {
                this.allBatches.clear(), this.updatedLayers.clear();
              }
            }
            var X = a(340);
            class $ extends x.b {
              constructor(Y) {
                super(),
                  (this.ambientBake = !1),
                  (this.ambientBakeOcclusionBrightness = 0),
                  (this.ambientBakeOcclusionContrast = 0),
                  (this.ambientLight = new T.I(0, 0, 0)),
                  (this.ambientLuminance = 0),
                  (this.exposure = 1),
                  (this.fogColor = new T.I(0, 0, 0)),
                  (this.fogDensity = 0),
                  (this.fogEnd = 1e3),
                  (this.fogStart = 1),
                  (this.lightmapSizeMultiplier = 1),
                  (this.lightmapMaxResolution = 2048),
                  (this.lightmapMode = n.FB),
                  (this.lightmapFilterEnabled = !1),
                  (this.lightmapHDR = !1),
                  (this.root = null),
                  (this.sky = null),
                  (this.physicalUnits = !1),
                  (this.device = Y || s.j.get()),
                  (this._gravity = new g.A(0, -9.8, 0)),
                  (this._layers = null),
                  (this._fog = n.YV),
                  (this._gammaCorrection = n.DZ),
                  (this._toneMapping = 0),
                  (this._skyboxCubeMap = null),
                  (this._prefilteredCubemaps = []),
                  (this._envAtlas = null),
                  (this._internalEnvAtlas = null),
                  (this._skyboxIntensity = 1),
                  (this._skyboxLuminance = 0),
                  (this._skyboxMip = 0),
                  (this._skyboxRotationShaderInclude = !1),
                  (this._skyboxRotation = new c.D()),
                  (this._skyboxRotationMat3 = new h.T()),
                  (this._skyboxRotationMat4 = new f.y()),
                  (this._ambientBakeNumSamples = 1),
                  (this._ambientBakeSpherePart = 0.4),
                  (this._lightmapFilterRange = 10),
                  (this._lightmapFilterSmoothness = 0.2),
                  (this._clusteredLightingEnabled = !0),
                  (this._lightingParams = new P.w(
                    this.device.supportsAreaLights,
                    this.device.maxTextureSize,
                    () => {
                      this._layers._dirtyLights = !0;
                    }
                  )),
                  (this._stats = {
                    meshInstances: 0,
                    lights: 0,
                    dynamicLights: 0,
                    bakedLights: 0,
                    updateShadersTime: 0,
                  }),
                  (this.updateShaders = !0),
                  (this._shaderVersion = 0),
                  (this._statsUpdated = !1),
                  (this.immediate = new te(this.device));
              }
              get defaultDrawLayer() {
                return this.layers.getLayerById(n.vt);
              }
              set ambientBakeNumSamples(Y) {
                this._ambientBakeNumSamples = d.m.clamp(Math.floor(Y), 1, 255);
              }
              get ambientBakeNumSamples() {
                return this._ambientBakeNumSamples;
              }
              set ambientBakeSpherePart(Y) {
                this._ambientBakeSpherePart = d.m.clamp(Y, 0.001, 1);
              }
              get ambientBakeSpherePart() {
                return this._ambientBakeSpherePart;
              }
              set clusteredLightingEnabled(Y) {
                if (!(this.device.isWebGPU && !Y)) {
                  if (!this._clusteredLightingEnabled && Y) {
                    console.error(
                      "Turning on disabled clustered lighting is not currently supported"
                    );
                    return;
                  }
                  this._clusteredLightingEnabled = Y;
                }
              }
              get clusteredLightingEnabled() {
                return this._clusteredLightingEnabled;
              }
              set drawCalls(Y) {}
              get drawCalls() {
                let Y = this.layers._meshInstances;
                return (
                  Y.length ||
                    (this.layers._update(
                      this.device,
                      this.clusteredLightingEnabled
                    ),
                    (Y = this.layers._meshInstances)),
                  Y
                );
              }
              set envAtlas(Y) {
                Y !== this._envAtlas &&
                  ((this._envAtlas = Y),
                  Y &&
                    ((Y.addressU = l.uFb),
                    (Y.addressV = l.uFb),
                    (Y.minFilter = l.I5X),
                    (Y.magFilter = l.I5X),
                    (Y.mipmaps = !1)),
                  (this._prefilteredCubemaps = []),
                  this._internalEnvAtlas &&
                    (this._internalEnvAtlas.destroy(),
                    (this._internalEnvAtlas = null)),
                  this._resetSky());
              }
              get envAtlas() {
                return this._envAtlas;
              }
              set fog(Y) {
                Y !== this._fog && ((this._fog = Y), (this.updateShaders = !0));
              }
              get fog() {
                return this._fog;
              }
              set gammaCorrection(Y) {
                Y !== this._gammaCorrection &&
                  ((this._gammaCorrection = Y), (this.updateShaders = !0));
              }
              get gammaCorrection() {
                return this._gammaCorrection;
              }
              set layers(Y) {
                const Z = this._layers;
                (this._layers = Y), this.fire("set:layers", Z, Y);
              }
              get layers() {
                return this._layers;
              }
              get lighting() {
                return this._lightingParams;
              }
              set lightmapFilterRange(Y) {
                this._lightmapFilterRange = Math.max(Y, 0.001);
              }
              get lightmapFilterRange() {
                return this._lightmapFilterRange;
              }
              set lightmapFilterSmoothness(Y) {
                this._lightmapFilterSmoothness = Math.max(Y, 0.001);
              }
              get lightmapFilterSmoothness() {
                return this._lightmapFilterSmoothness;
              }
              set prefilteredCubemaps(Y) {
                Y = Y || [];
                const Z = this._prefilteredCubemaps;
                (Z.length !== Y.length || Z.some((pe, O) => pe !== Y[O])) &&
                  (Y.length === 6 && Y.every((O) => !!O)
                    ? ((this._internalEnvAtlas = X.C.generatePrefilteredAtlas(
                        Y,
                        { target: this._internalEnvAtlas }
                      )),
                      (this._envAtlas = this._internalEnvAtlas))
                    : (this._internalEnvAtlas &&
                        (this._internalEnvAtlas.destroy(),
                        (this._internalEnvAtlas = null)),
                      (this._envAtlas = null)),
                  (this._prefilteredCubemaps = Y.slice()),
                  this._resetSky());
              }
              get prefilteredCubemaps() {
                return this._prefilteredCubemaps;
              }
              set skybox(Y) {
                Y !== this._skyboxCubeMap &&
                  ((this._skyboxCubeMap = Y), this._resetSky());
              }
              get skybox() {
                return this._skyboxCubeMap;
              }
              set skyboxIntensity(Y) {
                Y !== this._skyboxIntensity &&
                  ((this._skyboxIntensity = Y), this._resetSky());
              }
              get skyboxIntensity() {
                return this._skyboxIntensity;
              }
              set skyboxLuminance(Y) {
                Y !== this._skyboxLuminance &&
                  ((this._skyboxLuminance = Y), this._resetSky());
              }
              get skyboxLuminance() {
                return this._skyboxLuminance;
              }
              set skyboxMip(Y) {
                Y !== this._skyboxMip &&
                  ((this._skyboxMip = Y), this._resetSky());
              }
              get skyboxMip() {
                return this._skyboxMip;
              }
              set skyboxRotation(Y) {
                if (!this._skyboxRotation.equals(Y)) {
                  const Z = Y.equals(c.D.IDENTITY);
                  this._skyboxRotation.copy(Y),
                    Z
                      ? this._skyboxRotationMat3.setIdentity()
                      : (this._skyboxRotationMat4.setTRS(g.A.ZERO, Y, g.A.ONE),
                        this._skyboxRotationMat4.invertTo3x3(
                          this._skyboxRotationMat3
                        )),
                    !this._skyboxRotationShaderInclude &&
                      !Z &&
                      ((this._skyboxRotationShaderInclude = !0),
                      this._resetSky());
                }
              }
              get skyboxRotation() {
                return this._skyboxRotation;
              }
              set toneMapping(Y) {
                Y !== this._toneMapping &&
                  ((this._toneMapping = Y), (this.updateShaders = !0));
              }
              get toneMapping() {
                return this._toneMapping;
              }
              destroy() {
                this._resetSky(), (this.root = null), this.off();
              }
              drawLine(
                Y,
                Z,
                ye = T.I.WHITE,
                pe = !0,
                O = this.defaultDrawLayer
              ) {
                this.immediate.getBatch(O, pe).addLines([Y, Z], [ye, ye]);
              }
              drawLines(Y, Z, ye = !0, pe = this.defaultDrawLayer) {
                this.immediate.getBatch(pe, ye).addLines(Y, Z);
              }
              drawLineArrays(Y, Z, ye = !0, pe = this.defaultDrawLayer) {
                this.immediate.getBatch(pe, ye).addLinesArrays(Y, Z);
              }
              applySettings(Y) {
                var Z, ye, pe;
                const O = Y.physics,
                  me = Y.render;
                this._gravity.set(O.gravity[0], O.gravity[1], O.gravity[2]),
                  this.ambientLight.set(
                    me.global_ambient[0],
                    me.global_ambient[1],
                    me.global_ambient[2]
                  ),
                  (this.ambientLuminance = me.ambientLuminance),
                  (this._fog = me.fog),
                  this.fogColor.set(
                    me.fog_color[0],
                    me.fog_color[1],
                    me.fog_color[2]
                  ),
                  (this.fogStart = me.fog_start),
                  (this.fogEnd = me.fog_end),
                  (this.fogDensity = me.fog_density),
                  (this._gammaCorrection = me.gamma_correction),
                  (this._toneMapping = me.tonemapping),
                  (this.lightmapSizeMultiplier = me.lightmapSizeMultiplier),
                  (this.lightmapMaxResolution = me.lightmapMaxResolution),
                  (this.lightmapMode = me.lightmapMode),
                  (this.exposure = me.exposure),
                  (this._skyboxIntensity =
                    (Z = me.skyboxIntensity) != null ? Z : 1),
                  (this._skyboxLuminance =
                    (ye = me.skyboxLuminance) != null ? ye : 2e4),
                  (this._skyboxMip = (pe = me.skyboxMip) != null ? pe : 0),
                  me.skyboxRotation &&
                    (this.skyboxRotation = new c.D().setFromEulerAngles(
                      me.skyboxRotation[0],
                      me.skyboxRotation[1],
                      me.skyboxRotation[2]
                    )),
                  (this.clusteredLightingEnabled = me.clusteredLightingEnabled),
                  this.lighting.applySettings(me),
                  [
                    "lightmapFilterEnabled",
                    "lightmapFilterRange",
                    "lightmapFilterSmoothness",
                    "ambientBake",
                    "ambientBakeNumSamples",
                    "ambientBakeSpherePart",
                    "ambientBakeOcclusionBrightness",
                    "ambientBakeOcclusionContrast",
                  ].forEach((N) => {
                    me.hasOwnProperty(N) && (this[N] = me[N]);
                  }),
                  this._resetSky();
              }
              _getSkyboxTex() {
                const Y = this._prefilteredCubemaps;
                return this._skyboxMip
                  ? Y[[0, 1, 3, 4, 5, 6][this._skyboxMip]] ||
                      this._envAtlas ||
                      Y[0] ||
                      this._skyboxCubeMap
                  : this._skyboxCubeMap || Y[0] || this._envAtlas;
              }
              _updateSky(Y) {
                if (!this.sky) {
                  const Z = this._getSkyboxTex();
                  Z &&
                    ((this.sky = new v(Y, this, Z)),
                    this.fire("set:skybox", Z));
                }
              }
              _resetSky() {
                var Y;
                (Y = this.sky) == null || Y.destroy(),
                  (this.sky = null),
                  (this.updateShaders = !0);
              }
              setSkybox(Y) {
                Y
                  ? ((this.skybox = Y[0] || null),
                    Y[1] && !Y[1].cubemap
                      ? (this.envAtlas = Y[1])
                      : (this.prefilteredCubemaps = Y.slice(1)))
                  : ((this.skybox = null), (this.envAtlas = null));
              }
              get lightmapPixelFormat() {
                return (
                  (this.lightmapHDR &&
                    this.device.getHdrFormat(!1, !0, !1, !0)) ||
                  l.jKI
                );
              }
            }
          },
          7790: (Se, W, a) => {
            "use strict";
            a.d(W, { R: () => x });
            class x {
              constructor() {
                this.code = "";
              }
              append(...g) {
                g.forEach((c) => {
                  c.endsWith(`
`)
                    ? (this.code += c)
                    : (this.code +=
                        c +
                        `
`);
                });
              }
              prepend(...g) {
                g.forEach((c) => {
                  c.endsWith(`
`)
                    ? (this.code = c + this.code)
                    : (this.code =
                        c +
                        `
` +
                        this.code);
                });
              }
            }
          },
          7198: (Se, W, a) => {
            "use strict";
            a.d(W, { a: () => g });
            const x = {
                linear: "decodeLinear",
                srgb: "decodeGamma",
                rgbm: "decodeRGBM",
                rgbe: "decodeRGBE",
                rgbp: "decodeRGBP",
              },
              T = {
                linear: "encodeLinear",
                srgb: "encodeGamma",
                rgbm: "encodeRGBM",
                rgbe: "encodeRGBE",
                rgbp: "encodeRGBP",
              };
            class g {
              static decodeFunc(d) {
                return x[d] || "decodeGamma";
              }
              static encodeFunc(d) {
                return T[d] || "encodeGamma";
              }
            }
          },
          8372: (Se, W, a) => {
            "use strict";
            a.d(W, { i: () => d });
            var x = `
		vec4 dirLm = texture2D(texture_dirLightMap, vUv1);

		if (bakeDir > 0.5) {
				if (dAtten > 0.00001) {
						dirLm.xyz = dirLm.xyz * 2.0 - vec3(1.0);
						dAtten = saturate(dAtten);
						gl_FragColor.rgb = normalize(dLightDirNormW.xyz*dAtten + dirLm.xyz*dirLm.w) * 0.5 + vec3(0.5);
						gl_FragColor.a = dirLm.w + dAtten;
						gl_FragColor.a = max(gl_FragColor.a, 1.0 / 255.0);
				} else {
						gl_FragColor = dirLm;
				}
		} else {
				gl_FragColor.rgb = dirLm.xyz;
				gl_FragColor.a = max(dirLm.w, dAtten > 0.00001? (1.0/255.0) : 0.0);
		}
`,
              T = `
#ifdef LIGHTMAP_RGBM
		gl_FragColor.rgb = dDiffuseLight;
		gl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(0.5));
		gl_FragColor.rgb /= 8.0;
		gl_FragColor.a = clamp( max( max( gl_FragColor.r, gl_FragColor.g ), max( gl_FragColor.b, 1.0 / 255.0 ) ), 0.0,1.0 );
		gl_FragColor.a = ceil(gl_FragColor.a * 255.0) / 255.0;
		gl_FragColor.rgb /= gl_FragColor.a;
#else
		gl_FragColor = vec4(dDiffuseLight, 1.0);
#endif
`,
              g = `

varying vec2 vUv0;

uniform sampler2D source;
uniform vec2 pixelOffset;

void main(void) {
		vec4 c = texture2D(source, vUv0);
		c = c.a>0.0? c : texture2D(source, vUv0 - pixelOffset);
		c = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, -pixelOffset.y));
		c = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, -pixelOffset.y));
		c = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, 0));
		c = c.a>0.0? c : texture2D(source, vUv0 + vec2(pixelOffset.x, 0));
		c = c.a>0.0? c : texture2D(source, vUv0 + vec2(-pixelOffset.x, pixelOffset.y));
		c = c.a>0.0? c : texture2D(source, vUv0 + vec2(0, pixelOffset.y));
		c = c.a>0.0? c : texture2D(source, vUv0 + pixelOffset);
		gl_FragColor = c;
}
`,
              c = `
// bilateral filter, based on https://www.shadertoy.com/view/4dfGDH# and
// http://people.csail.mit.edu/sparis/bf_course/course_notes.pdf

// A bilateral filter is a non-linear, edge-preserving, and noise-reducing smoothing filter for images.
// It replaces the intensity of each pixel with a weighted average of intensity values from nearby pixels.
// This weight can be based on a Gaussian distribution. Crucially, the weights depend not only on
// Euclidean distance of pixels, but also on the radiometric differences (e.g., range differences, such
// as color intensity, depth distance, etc.). This preserves sharp edges.

float normpdf3(in vec3 v, in float sigma) {
		return 0.39894 * exp(-0.5 * dot(v, v) / (sigma * sigma)) / sigma;
}

vec3 decodeRGBM(vec4 rgbm) {
		vec3 color = (8.0 * rgbm.a) * rgbm.rgb;
		return color * color;
}

float saturate(float x) {
		return clamp(x, 0.0, 1.0);
}

vec4 encodeRGBM(vec3 color) { // modified RGBM
		vec4 encoded;
		encoded.rgb = pow(color.rgb, vec3(0.5));
		encoded.rgb *= 1.0 / 8.0;

		encoded.a = saturate( max( max( encoded.r, encoded.g ), max( encoded.b, 1.0 / 255.0 ) ) );
		encoded.a = ceil(encoded.a * 255.0) / 255.0;

		encoded.rgb /= encoded.a;
		return encoded;
}

// filter size
#define MSIZE 15

varying vec2 vUv0;
uniform sampler2D source;
uniform vec2 pixelOffset;
uniform vec2 sigmas;
uniform float bZnorm;
uniform float kernel[MSIZE];

void main(void) {
		
		vec4 pixelRgbm = texture2D(source, vUv0);

		// lightmap specific optimization - skip pixels that were not baked
		// this also allows dilate filter that work on the output of this to work correctly, as it depends on .a being zero
		// to dilate, which the following blur filter would otherwise modify
		if (pixelRgbm.a <= 0.0) {
				gl_FragColor = pixelRgbm;
				return ;
		}

		// range sigma - controls blurriness based on a pixel distance
		float sigma = sigmas.x;

		// domain sigma - controls blurriness based on a pixel similarity (to preserve edges)
		float bSigma = sigmas.y;

		vec3 pixelHdr = decodeRGBM(pixelRgbm);
		vec3 accumulatedHdr = vec3(0.0);
		float accumulatedFactor = 0.0;

		// read out the texels
		const int kSize = (MSIZE-1)/2;
		for (int i = -kSize; i <= kSize; ++i) {
				for (int j = -kSize; j <= kSize; ++j) {
						
						// sample the pixel with offset
						vec2 coord = vUv0 + vec2(float(i), float(j)) * pixelOffset;
						vec4 rgbm = texture2D(source, coord);

						// lightmap - only use baked pixels
						if (rgbm.a > 0.0) {
								vec3 hdr = decodeRGBM(rgbm);

								// bilateral factors
								float factor = kernel[kSize + j] * kernel[kSize + i];
								factor *= normpdf3(hdr - pixelHdr, bSigma) * bZnorm;

								// accumulate
								accumulatedHdr += factor * hdr;
								accumulatedFactor += factor;
						}
				}
		}

		gl_FragColor = encodeRGBM(accumulatedHdr / accumulatedFactor);
}
`;
            const d = {
              bakeDirLmEndPS: x,
              bakeLmEndPS: T,
              dilatePS: g,
              bilateralDeNoisePS: c,
            };
          },
          3200: (Se, W, a) => {
            "use strict";
            a.d(W, { n: () => Ls });
            var x = `
uniform float alpha_ref;

void alphaTest(float a) {
		if (a < alpha_ref) discard;
}
`,
              T = `
void addAmbient(vec3 worldNormal) {
		dDiffuseLight += light_globalAmbient;
}
`,
              g = `
#ifndef ENV_ATLAS
#define ENV_ATLAS
uniform sampler2D texture_envAtlas;
#endif

void addAmbient(vec3 worldNormal) {
		vec3 dir = normalize(cubeMapRotate(worldNormal) * vec3(-1.0, 1.0, 1.0));
		vec2 uv = mapUv(toSphericalUv(dir), vec4(128.0, 256.0 + 128.0, 64.0, 32.0) / atlasSize);

		vec4 raw = texture2D(texture_envAtlas, uv);
		vec3 linear = $DECODE(raw);
		dDiffuseLight += processEnvironment(linear);
}
`,
              c = `
uniform vec3 ambientSH[9];

void addAmbient(vec3 worldNormal) {
		vec3 n = cubeMapRotate(worldNormal);

		vec3 color =
				ambientSH[0] +
				ambientSH[1] * n.x +
				ambientSH[2] * n.y +
				ambientSH[3] * n.z +
				ambientSH[4] * n.x * n.z +
				ambientSH[5] * n.z * n.y +
				ambientSH[6] * n.y * n.x +
				ambientSH[7] * (3.0 * n.z * n.z - 1.0) +
				ambientSH[8] * (n.x * n.x - n.y * n.y);

		dDiffuseLight += processEnvironment(max(color, vec3(0.0)));
}
`,
              d = `

void getAO() {
		dAo = 1.0;

		#ifdef MAPTEXTURE
		float aoBase = texture2DBias($SAMPLER, $UV, textureBias).$CH;
		dAo *= addAoDetail(aoBase);
		#endif

		#ifdef MAPVERTEX
		dAo *= saturate(vVertexColor.$VC);
		#endif
}
`,
              h = `
float addAoDetail(float ao) {
#ifdef MAPTEXTURE
		float aoDetail = texture2DBias($SAMPLER, $UV, textureBias).$CH;
		return detailMode_$DETAILMODE(vec3(ao), vec3(aoDetail)).r;
#else
		return ao;
#endif
}
`,
              f = `
void occludeDiffuse(float ao) {
		dDiffuseLight *= ao;
}
`,
              s = `
uniform float material_occludeSpecularIntensity;

void occludeSpecular(float gloss, float ao, vec3 worldNormal, vec3 viewDir) {
		// approximated specular occlusion from AO
		float specPow = exp2(gloss * 11.0);
		// http://research.tri-ace.com/Data/cedec2011_RealtimePBR_Implementation_e.pptx
		float specOcc = saturate(pow(dot(worldNormal, viewDir) + ao, 0.01*specPow) - 1.0 + ao);
		specOcc = mix(1.0, specOcc, material_occludeSpecularIntensity);

		dSpecularLight *= specOcc;
		dReflection *= specOcc;
		
#ifdef LIT_SHEEN
		sSpecularLight *= specOcc;
		sReflection *= specOcc;
#endif
}
`,
              l = `
void occludeSpecular(float gloss, float ao, vec3 worldNormal, vec3 viewDir) {
		// approximated specular occlusion from AO
		float specPow = exp2(gloss * 11.0);
		// http://research.tri-ace.com/Data/cedec2011_RealtimePBR_Implementation_e.pptx
		float specOcc = saturate(pow(dot(worldNormal, viewDir) + ao, 0.01*specPow) - 1.0 + ao);

		dSpecularLight *= specOcc;
		dReflection *= specOcc;
		
#ifdef LIT_SHEEN
		sSpecularLight *= specOcc;
		sReflection *= specOcc;
#endif
}
`,
              n = `
void occludeSpecular(float gloss, float ao, vec3 worldNormal, vec3 viewDir) {
		dSpecularLight *= ao;
		dReflection *= ao;

#ifdef LIT_SHEEN
		sSpecularLight *= ao;
		sReflection *= ao;
#endif
}
`,
              o = `
uniform float material_occludeSpecularIntensity;

void occludeSpecular(float gloss, float ao, vec3 worldNormal, vec3 viewDir) {
		float specOcc = mix(1.0, ao, material_occludeSpecularIntensity);
		dSpecularLight *= specOcc;
		dReflection *= specOcc;

#ifdef LIT_SHEEN
		sSpecularLight *= specOcc;
		sReflection *= specOcc;
#endif
}
`,
              i = `
uniform vec3 view_position;

uniform vec3 light_globalAmbient;

float square(float x) {
		return x*x;
}

float saturate(float x) {
		return clamp(x, 0.0, 1.0);
}

vec3 saturate(vec3 x) {
		return clamp(x, vec3(0.0), vec3(1.0));
}
`,
              e = `
attribute vec3 vertex_position;
attribute vec3 vertex_normal;
attribute vec4 vertex_tangent;
attribute vec2 vertex_texCoord0;
attribute vec2 vertex_texCoord1;
attribute vec4 vertex_color;

uniform mat4 matrix_viewProjection;
uniform mat4 matrix_model;
uniform mat3 matrix_normal;

vec3 dPositionW;
mat4 dModelMatrix;
mat3 dNormalMatrix;
`,
              t = `
#define NINESLICED

varying vec2 vMask;
varying vec2 vTiledUv;

uniform mediump vec4 innerOffset;
uniform mediump vec2 outerScale;
uniform mediump vec4 atlasRect;

vec2 nineSlicedUv;
`,
              r = `
#define NINESLICED

varying vec2 vMask;
varying vec2 vTiledUv;

uniform mediump vec4 innerOffset;
uniform mediump vec2 outerScale;
uniform mediump vec4 atlasRect;
`,
              u = `
#define NINESLICED
#define NINESLICETILED

varying vec2 vMask;
varying vec2 vTiledUv;

uniform mediump vec4 innerOffset;
uniform mediump vec2 outerScale;
uniform mediump vec4 atlasRect;

vec2 nineSlicedUv;
`,
              y = `
#define SHADOWBIAS
#define SHADOW_SAMPLE_Z_BIAS

float getShadowBias(float resolution, float maxBias) {
		return maxBias;
}
`,
              p = `
varying vec2 vUv0;

uniform sampler2D source;
uniform vec2 pixelOffset;

#ifdef GAUSS
uniform float weight[SAMPLES];
#endif

#ifdef PACKED
float decodeFloatRG(vec2 rg) {
		return rg.y*(1.0/255.0) + rg.x;
}

vec2 encodeFloatRG( float v ) {
		vec2 enc = vec2(1.0, 255.0) * v;
		enc = fract(enc);
		enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);
		return enc;
}
#endif

void main(void) {
		vec3 moments = vec3(0.0);
		vec2 uv = vUv0 - pixelOffset * (float(SAMPLES) * 0.5);
		for (int i=0; i<SAMPLES; i++) {
				vec4 c = texture2D(source, uv + pixelOffset * float(i));

				#ifdef PACKED
				c.xy = vec2(decodeFloatRG(c.xy), decodeFloatRG(c.zw));
				#endif

				#ifdef GAUSS
				moments += c.xyz * weight[i];
				#else
				moments += c.xyz;
				#endif
		}

		#ifndef GAUSS
		moments /= float(SAMPLES);
		#endif

		#ifdef PACKED
		gl_FragColor = vec4(encodeFloatRG(moments.x), encodeFloatRG(moments.y));
		#else
		gl_FragColor = vec4(moments.x, moments.y, moments.z, 1.0);
		#endif
}
`,
              _ = `
#ifdef MAPFLOAT
uniform float material_clearCoat;
#endif

void getClearCoat() {
		ccSpecularity = 1.0;

		#ifdef MAPFLOAT
		ccSpecularity *= material_clearCoat;
		#endif

		#ifdef MAPTEXTURE
		ccSpecularity *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
		#endif

		#ifdef MAPVERTEX
		ccSpecularity *= saturate(vVertexColor.$VC);
		#endif
}
`,
              m = `
#ifdef MAPFLOAT
uniform float material_clearCoatGloss;
#endif

void getClearCoatGlossiness() {
		ccGlossiness = 1.0;

		#ifdef MAPFLOAT
		ccGlossiness *= material_clearCoatGloss;
		#endif

		#ifdef MAPTEXTURE
		ccGlossiness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
		#endif

		#ifdef MAPVERTEX
		ccGlossiness *= saturate(vVertexColor.$VC);
		#endif

		#ifdef MAPINVERT
		ccGlossiness = 1.0 - ccGlossiness;
		#endif

		ccGlossiness += 0.0000001;
}
`,
              E = `
#ifdef MAPTEXTURE
uniform float material_clearCoatBumpiness;
#endif

void getClearCoatNormal() {
#ifdef MAPTEXTURE
		vec3 normalMap = unpackNormal(texture2DBias($SAMPLER, $UV, textureBias));
		normalMap = mix(vec3(0.0, 0.0, 1.0), normalMap, material_clearCoatBumpiness);
		ccNormalW = normalize(dTBN * normalMap);
#else
		ccNormalW = dVertexNormalW;
#endif
}
`,
              v = `
// Converts unnormalized direction vector to a cubemap face index [0..5] and uv coordinates within the face in [0..1] range.
// Additionally offset to a tile in atlas within 3x3 subdivision is provided
vec2 getCubemapFaceCoordinates(const vec3 dir, out float faceIndex, out vec2 tileOffset)
{
		vec3 vAbs = abs(dir);
		float ma;
		vec2 uv;
		if (vAbs.z >= vAbs.x && vAbs.z >= vAbs.y) {   // front / back

				faceIndex = dir.z < 0.0 ? 5.0 : 4.0;
				ma = 0.5 / vAbs.z;
				uv = vec2(dir.z < 0.0 ? -dir.x : dir.x, -dir.y);

				tileOffset.x = 2.0;
				tileOffset.y = dir.z < 0.0 ? 1.0 : 0.0;

		} else if(vAbs.y >= vAbs.x) {  // top index 2, bottom index 3

				faceIndex = dir.y < 0.0 ? 3.0 : 2.0;
				ma = 0.5 / vAbs.y;
				uv = vec2(dir.x, dir.y < 0.0 ? -dir.z : dir.z);

				tileOffset.x = 1.0;
				tileOffset.y = dir.y < 0.0 ? 1.0 : 0.0;

		} else {    // left / right

				faceIndex = dir.x < 0.0 ? 1.0 : 0.0;
				ma = 0.5 / vAbs.x;
				uv = vec2(dir.x < 0.0 ? dir.z : -dir.z, -dir.y);

				tileOffset.x = 0.0;
				tileOffset.y = dir.x < 0.0 ? 1.0 : 0.0;

		}
		return uv * ma + 0.5;
}

// converts unnormalized direction vector to a texture coordinate for a cubemap face stored within texture atlas described by the viewport
vec2 getCubemapAtlasCoordinates(const vec3 omniAtlasViewport, float shadowEdgePixels, float shadowTextureResolution, const vec3 dir) {

		float faceIndex;
		vec2 tileOffset;
		vec2 uv = getCubemapFaceCoordinates(dir, faceIndex, tileOffset);

		// move uv coordinates inwards inside to compensate for larger fov when rendering shadow into atlas
		float atlasFaceSize = omniAtlasViewport.z;
		float tileSize = shadowTextureResolution * atlasFaceSize;
		float offset = shadowEdgePixels / tileSize;
		uv = uv * vec2(1.0 - offset * 2.0) + vec2(offset * 1.0);

		// scale uv coordinates to cube face area within the viewport
		uv *= atlasFaceSize;

		// offset into face of the atlas (3x3 grid)
		uv += tileOffset * atlasFaceSize;

		// offset into the atlas viewport
		uv += omniAtlasViewport.xy;

		return uv;
}
`,
              P = `
vec3 _getCookieClustered(TEXTURE_ACCEPT(tex), vec2 uv, float intensity, bool isRgb, vec4 cookieChannel) {
		vec4 pixel = mix(vec4(1.0), texture2DLodEXT(tex, uv, 0.0), intensity);
		return isRgb == true ? pixel.rgb : vec3(dot(pixel, cookieChannel));
}

// getCookie2D for clustered lighting including channel selector
vec3 getCookie2DClustered(TEXTURE_ACCEPT(tex), mat4 transform, vec3 worldPosition, float intensity, bool isRgb, vec4 cookieChannel) {
		vec4 projPos = transform * vec4(worldPosition, 1.0);
		return _getCookieClustered(TEXTURE_PASS(tex), projPos.xy / projPos.w, intensity, isRgb, cookieChannel);
}

// getCookie for clustered omni light with the cookie texture being stored in the cookie atlas
vec3 getCookieCubeClustered(TEXTURE_ACCEPT(tex), vec3 dir, float intensity, bool isRgb, vec4 cookieChannel, float shadowTextureResolution, float shadowEdgePixels, vec3 omniAtlasViewport) {
		vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);
		return _getCookieClustered(TEXTURE_PASS(tex), uv, intensity, isRgb, cookieChannel);
}
`,
              I = `
// Clustered Omni Sampling using atlas


void _getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {
		vec4 projPos = shadowMatrix * vec4(wPos, 1.0);
		projPos.xyz /= projPos.w;
		dShadowCoord = projPos.xyz;
		// depth bias is already applied on render
}

void getShadowCoordPerspZbufferNormalOffset(mat4 shadowMatrix, vec4 shadowParams, vec3 normal) {
		vec3 wPos = vPositionW + normal * shadowParams.y;
		_getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, wPos);
}

vec3 normalOffsetPointShadow(vec4 shadowParams, vec3 lightPos, inout vec3 lightDir, vec3 lightDirNorm, vec3 normal) {
		float distScale = length(lightDir);
		vec3 wPos = vPositionW + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale; //0.02
		vec3 dir = wPos - lightPos;
		return dir;
}

#ifdef GL2

		#if defined(CLUSTER_SHADOW_TYPE_PCF1)

		float getShadowOmniClusteredPCF1(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {

				float shadowTextureResolution = shadowParams.x;
				vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);

				float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;
				return textureShadow(shadowMap, vec3(uv, shadowZ));
		}

		#endif

		#if defined(CLUSTER_SHADOW_TYPE_PCF3)

		float getShadowOmniClusteredPCF3(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {

				float shadowTextureResolution = shadowParams.x;
				vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);

				float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;
				vec3 shadowCoord = vec3(uv, shadowZ);
				return getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);
		}

		#endif

		#if defined(CLUSTER_SHADOW_TYPE_PCF5)

		float getShadowOmniClusteredPCF5(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {

				float shadowTextureResolution = shadowParams.x;
				vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);

				float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;
				vec3 shadowCoord = vec3(uv, shadowZ);
				return getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);
		}

		#endif

#else

		#if defined(CLUSTER_SHADOW_TYPE_PCF1)

		float getShadowOmniClusteredPCF1(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {

				float shadowTextureResolution = shadowParams.x;
				vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);

				// no filter shadow sampling
				float depth = unpackFloat(textureShadow(shadowMap, uv));
				float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;
				return depth > shadowZ ? 1.0 : 0.0;
		}

		#endif

		#if defined(CLUSTER_SHADOW_TYPE_PCF3)

		float getShadowOmniClusteredPCF3(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {

				float shadowTextureResolution = shadowParams.x;
				vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);

				// pcf3
				float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;
				vec3 shadowCoord = vec3(uv, shadowZ);
				return getShadowPCF3x3(shadowMap, shadowCoord, shadowParams);
		}

		#endif

		#if defined(CLUSTER_SHADOW_TYPE_PCF5)

		// we don't have PCF5 implementation for webgl1, use PCF3
		float getShadowOmniClusteredPCF5(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {

				float shadowTextureResolution = shadowParams.x;
				vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);

				// pcf3
				float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;
				vec3 shadowCoord = vec3(uv, shadowZ);
				return getShadowPCF3x3(shadowMap, shadowCoord, shadowParams);
		}

		#endif

#endif


// Clustered Spot Sampling using atlas

#ifdef GL2

		#if defined(CLUSTER_SHADOW_TYPE_PCF1)

		float getShadowSpotClusteredPCF1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
				return textureShadow(shadowMap, shadowCoord);
		}

		#endif

		#if defined(CLUSTER_SHADOW_TYPE_PCF3)

		float getShadowSpotClusteredPCF3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
				return getShadowSpotPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);
		}

		#endif

		#if defined(CLUSTER_SHADOW_TYPE_PCF5)

		float getShadowSpotClusteredPCF5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
				return getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);
		}
		#endif

#else

		#if defined(CLUSTER_SHADOW_TYPE_PCF1)

		float getShadowSpotClusteredPCF1(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {

				float depth = unpackFloat(textureShadow(shadowMap, shadowCoord.xy));

				return depth > shadowCoord.z ? 1.0 : 0.0;

		}

		#endif

		#if defined(CLUSTER_SHADOW_TYPE_PCF3)

		float getShadowSpotClusteredPCF3(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {
				return getShadowSpotPCF3x3(shadowMap, shadowCoord, shadowParams);
		}

		#endif

		#if defined(CLUSTER_SHADOW_TYPE_PCF5)

		// we don't have PCF5 implementation for webgl1, use PCF3
		float getShadowSpotClusteredPCF5(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {
				return getShadowSpotPCF3x3(shadowMap, shadowCoord, shadowParams);
		}

		#endif

#endif
`,
              A = `
uniform highp sampler2D clusterWorldTexture;
uniform highp sampler2D lightsTexture8;
uniform highp sampler2D lightsTextureFloat;

// complex ifdef expression are not supported, handle it here
// defined(CLUSTER_COOKIES) || defined(CLUSTER_SHADOWS)
#if defined(CLUSTER_COOKIES)
		#define CLUSTER_COOKIES_OR_SHADOWS
#endif
#if defined(CLUSTER_SHADOWS)
		#define CLUSTER_COOKIES_OR_SHADOWS
#endif

#ifdef CLUSTER_SHADOWS
		#ifdef GL2
				// TODO: when VSM shadow is supported, it needs to use sampler2D in webgl2
				uniform sampler2DShadow shadowAtlasTexture;
		#else
				uniform sampler2D shadowAtlasTexture;
		#endif
#endif

#ifdef CLUSTER_COOKIES
		uniform sampler2D cookieAtlasTexture;
#endif

#ifdef GL2
		uniform int clusterMaxCells;
#else
		uniform float clusterMaxCells;
		uniform vec4 lightsTextureInvSize;
#endif

// 1.0 if clustered lighting can be skipped (0 lights in the clusters)
uniform float clusterSkip;

uniform vec3 clusterCellsCountByBoundsSize;
uniform vec3 clusterTextureSize;
uniform vec3 clusterBoundsMin;
uniform vec3 clusterBoundsDelta;
uniform vec3 clusterCellsDot;
uniform vec3 clusterCellsMax;
uniform vec2 clusterCompressionLimit0;
uniform vec2 shadowAtlasParams;

// structure storing light properties of a clustered light
// it's sorted to have all vectors aligned to 4 floats to limit padding
struct ClusterLightData {

		// area light sizes / orientation
		vec3 halfWidth;

		// type of the light (spot or omni)
		float lightType;

		// area light sizes / orientation
		vec3 halfHeight;

		#ifdef GL2
				// light index
				int lightIndex;
		#else
				// v coordinate to look up the light textures - this is the same as lightIndex but in 0..1 range
				float lightV;
		#endif

		// world space position
		vec3 position;

		// area light shape
		float shape;

		// world space direction (spot light only)
		vec3 direction;

		// light follow mode
		float falloffMode;

		// color
		vec3 color;

		// 0.0 if the light doesn't cast shadows
		float shadowIntensity;

		// atlas viewport for omni light shadow and cookie (.xy is offset to the viewport slot, .z is size of the face in the atlas)
		vec3 omniAtlasViewport;

		// range of the light
		float range;

		// channel mask - one of the channels has 1, the others are 0
		vec4 cookieChannelMask;

		// shadow bias values
		float shadowBias;
		float shadowNormalBias;

		// spot light inner and outer angle cosine
		float innerConeAngleCos;
		float outerConeAngleCos;

		// 1.0 if the light has a cookie texture
		float cookie;

		// 1.0 if cookie texture is rgb, otherwise it is using a single channel selectable by cookieChannelMask
		float cookieRgb;

		// intensity of the cookie
		float cookieIntensity;

		// light mask
		float mask;
};

// Note: on some devices (tested on Pixel 3A XL), this matrix when stored inside the light struct has lower precision compared to
// when stored outside, so we store it outside to avoid spot shadow flickering. This might need to be done to other / all members
// of the structure if further similar issues are observed.

// shadow (spot light only) / cookie projection matrix
mat4 lightProjectionMatrix;

// macros for light properties
#define isClusteredLightCastShadow(light) ( light.shadowIntensity > 0.0 )
#define isClusteredLightCookie(light) (light.cookie > 0.5 )
#define isClusteredLightCookieRgb(light) (light.cookieRgb > 0.5 )
#define isClusteredLightSpot(light) ( light.lightType > 0.5 )
#define isClusteredLightFalloffLinear(light) ( light.falloffMode < 0.5 )

// macros to test light shape
// Note: Following functions need to be called serially in listed order as they do not test both '>' and '<'
#define isClusteredLightArea(light) ( light.shape > 0.1 )
#define isClusteredLightRect(light) ( light.shape < 0.3 )
#define isClusteredLightDisk(light) ( light.shape < 0.6 )

// macro to test light mask (mesh accepts dynamic vs lightmapped lights)
#ifdef CLUSTER_MESH_DYNAMIC_LIGHTS
		// accept lights marked as dynamic or both dynamic and lightmapped
		#define acceptLightMask(light) ( light.mask < 0.75)
#else
		// accept lights marked as lightmapped or both dynamic and lightmapped
		#define acceptLightMask(light) ( light.mask > 0.25)
#endif

vec4 decodeClusterLowRange4Vec4(vec4 d0, vec4 d1, vec4 d2, vec4 d3) {
		return vec4(
				bytes2floatRange4(d0, -2.0, 2.0),
				bytes2floatRange4(d1, -2.0, 2.0),
				bytes2floatRange4(d2, -2.0, 2.0),
				bytes2floatRange4(d3, -2.0, 2.0)
		);
}

#ifdef GL2

		vec4 sampleLightsTexture8(const ClusterLightData clusterLightData, int index) {
				return texelFetch(lightsTexture8, ivec2(index, clusterLightData.lightIndex), 0);
		}

		vec4 sampleLightTextureF(const ClusterLightData clusterLightData, int index) {
				return texelFetch(lightsTextureFloat, ivec2(index, clusterLightData.lightIndex), 0);
		}

#else

		vec4 sampleLightsTexture8(const ClusterLightData clusterLightData, float index) {
				return texture2DLodEXT(lightsTexture8, vec2(index * lightsTextureInvSize.z, clusterLightData.lightV), 0.0);
		}

		vec4 sampleLightTextureF(const ClusterLightData clusterLightData, float index) {
				return texture2DLodEXT(lightsTextureFloat, vec2(index * lightsTextureInvSize.x, clusterLightData.lightV), 0.0);
		}

#endif

void decodeClusterLightCore(inout ClusterLightData clusterLightData, float lightIndex) {

		// light index
		#ifdef GL2
				clusterLightData.lightIndex = int(lightIndex);
		#else
				clusterLightData.lightV = (lightIndex + 0.5) * lightsTextureInvSize.w;
		#endif

		// shared data from 8bit texture
		vec4 lightInfo = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_FLAGS);
		clusterLightData.lightType = lightInfo.x;
		clusterLightData.shape = lightInfo.y;
		clusterLightData.falloffMode = lightInfo.z;
		clusterLightData.shadowIntensity = lightInfo.w;

		// color
		vec4 colorA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COLOR_A);
		vec4 colorB = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COLOR_B);
		clusterLightData.color = vec3(bytes2float2(colorA.xy), bytes2float2(colorA.zw), bytes2float2(colorB.xy)) * clusterCompressionLimit0.y;

		// cookie
		clusterLightData.cookie = colorB.z;

		// light mask
		clusterLightData.mask = colorB.w;

		#ifdef CLUSTER_TEXTURE_FLOAT

				vec4 lightPosRange = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_POSITION_RANGE);
				clusterLightData.position = lightPosRange.xyz;
				clusterLightData.range = lightPosRange.w;

				// spot light direction
				vec4 lightDir_Unused = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_SPOT_DIRECTION);
				clusterLightData.direction = lightDir_Unused.xyz;

		#else   // 8bit

				vec4 encPosX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_X);
				vec4 encPosY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_Y);
				vec4 encPosZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_Z);
				clusterLightData.position = vec3(bytes2float4(encPosX), bytes2float4(encPosY), bytes2float4(encPosZ)) * clusterBoundsDelta + clusterBoundsMin;

				vec4 encRange = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_RANGE);
				clusterLightData.range = bytes2float4(encRange) * clusterCompressionLimit0.x;

				// spot light direction
				vec4 encDirX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_X);
				vec4 encDirY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_Y);
				vec4 encDirZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_Z);
				clusterLightData.direction = vec3(bytes2float4(encDirX), bytes2float4(encDirY), bytes2float4(encDirZ)) * 2.0 - 1.0;

		#endif
}

void decodeClusterLightSpot(inout ClusterLightData clusterLightData) {

		// spot light cos angles
		vec4 coneAngle = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_ANGLES);
		clusterLightData.innerConeAngleCos = bytes2float2(coneAngle.xy) * 2.0 - 1.0;
		clusterLightData.outerConeAngleCos = bytes2float2(coneAngle.zw) * 2.0 - 1.0;
}

void decodeClusterLightOmniAtlasViewport(inout ClusterLightData clusterLightData) {
		#ifdef CLUSTER_TEXTURE_FLOAT
				clusterLightData.omniAtlasViewport = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_0).xyz;
		#else
				vec4 viewportA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_ATLAS_VIEWPORT_A);
				vec4 viewportB = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_ATLAS_VIEWPORT_B);
				clusterLightData.omniAtlasViewport = vec3(bytes2float2(viewportA.xy), bytes2float2(viewportA.zw), bytes2float2(viewportB.xy));
		#endif
}

void decodeClusterLightAreaData(inout ClusterLightData clusterLightData) {
		#ifdef CLUSTER_TEXTURE_FLOAT
				clusterLightData.halfWidth = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_AREA_DATA_WIDTH).xyz;
				clusterLightData.halfHeight = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_AREA_DATA_HEIGHT).xyz;
		#else
				vec4 areaWidthX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_X);
				vec4 areaWidthY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_Y);
				vec4 areaWidthZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_Z);
				clusterLightData.halfWidth = vec3(mantissaExponent2Float(areaWidthX), mantissaExponent2Float(areaWidthY), mantissaExponent2Float(areaWidthZ));

				vec4 areaHeightX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_X);
				vec4 areaHeightY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_Y);
				vec4 areaHeightZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_Z);
				clusterLightData.halfHeight = vec3(mantissaExponent2Float(areaHeightX), mantissaExponent2Float(areaHeightY), mantissaExponent2Float(areaHeightZ));
		#endif
}

void decodeClusterLightProjectionMatrixData(inout ClusterLightData clusterLightData) {
		
		// shadow matrix
		#ifdef CLUSTER_TEXTURE_FLOAT
				vec4 m0 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_0);
				vec4 m1 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_1);
				vec4 m2 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_2);
				vec4 m3 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_3);
		#else
				vec4 m00 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_00);
				vec4 m01 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_01);
				vec4 m02 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_02);
				vec4 m03 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_03);
				vec4 m0 = decodeClusterLowRange4Vec4(m00, m01, m02, m03);

				vec4 m10 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_10);
				vec4 m11 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_11);
				vec4 m12 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_12);
				vec4 m13 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_13);
				vec4 m1 = decodeClusterLowRange4Vec4(m10, m11, m12, m13);

				vec4 m20 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_20);
				vec4 m21 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_21);
				vec4 m22 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_22);
				vec4 m23 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_23);
				vec4 m2 = decodeClusterLowRange4Vec4(m20, m21, m22, m23);

				vec4 m30 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_30);
				vec4 m31 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_31);
				vec4 m32 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_32);
				vec4 m33 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_33);
				vec4 m3 = vec4(mantissaExponent2Float(m30), mantissaExponent2Float(m31), mantissaExponent2Float(m32), mantissaExponent2Float(m33));
		#endif
		
		lightProjectionMatrix = mat4(m0, m1, m2, m3);
}

void decodeClusterLightShadowData(inout ClusterLightData clusterLightData) {
		
		// shadow biases
		vec4 biases = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SHADOW_BIAS);
		clusterLightData.shadowBias = bytes2floatRange2(biases.xy, -1.0, 20.0),
		clusterLightData.shadowNormalBias = bytes2float2(biases.zw);
}

void decodeClusterLightCookieData(inout ClusterLightData clusterLightData) {

		vec4 cookieA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COOKIE_A);
		clusterLightData.cookieIntensity = cookieA.x;
		clusterLightData.cookieRgb = cookieA.y;

		clusterLightData.cookieChannelMask = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COOKIE_B);
}

void evaluateLight(
		ClusterLightData light, 
		vec3 worldNormal, 
		vec3 viewDir, 
		vec3 reflectionDir,
#if defined(LIT_CLEARCOAT)
		vec3 clearcoatReflectionDir,
#endif
		float gloss, 
		vec3 specularity, 
		vec3 geometricNormal, 
		mat3 tbn, 
#if defined(LIT_IRIDESCENCE)
		vec3 iridescenceFresnel,
#endif
		vec3 clearcoat_worldNormal,
		float clearcoat_gloss,
		float sheen_gloss,
		float iridescence_intensity
) {

		vec3 cookieAttenuation = vec3(1.0);
		float diffuseAttenuation = 1.0;
		float falloffAttenuation = 1.0;

		// evaluate omni part of the light
		getLightDirPoint(light.position);

		#ifdef CLUSTER_AREALIGHTS

		// distance attenuation
		if (isClusteredLightArea(light)) { // area light

				// area lights
				decodeClusterLightAreaData(light);

				// handle light shape
				if (isClusteredLightRect(light)) {
						calcRectLightValues(light.position, light.halfWidth, light.halfHeight);
				} else if (isClusteredLightDisk(light)) {
						calcDiskLightValues(light.position, light.halfWidth, light.halfHeight);
				} else { // sphere
						calcSphereLightValues(light.position, light.halfWidth, light.halfHeight);
				}

				falloffAttenuation = getFalloffWindow(light.range, dLightDirW);

		} else

		#endif

		{   // punctual light

				if (isClusteredLightFalloffLinear(light))
						falloffAttenuation = getFalloffLinear(light.range, dLightDirW);
				else
						falloffAttenuation = getFalloffInvSquared(light.range, dLightDirW);
		}

		if (falloffAttenuation > 0.00001) {

				#ifdef CLUSTER_AREALIGHTS

				if (isClusteredLightArea(light)) { // area light

						// handle light shape
						if (isClusteredLightRect(light)) {
								diffuseAttenuation = getRectLightDiffuse(worldNormal, viewDir, dLightDirW, dLightDirNormW) * 16.0;
						} else if (isClusteredLightDisk(light)) {
								diffuseAttenuation = getDiskLightDiffuse(worldNormal, viewDir, dLightDirW, dLightDirNormW) * 16.0;
						} else { // sphere
								diffuseAttenuation = getSphereLightDiffuse(worldNormal, viewDir, dLightDirW, dLightDirNormW) * 16.0;
						}

				} else

				#endif

				{
						falloffAttenuation *= getLightDiffuse(worldNormal, viewDir, dLightDirW, dLightDirNormW); 
				}

				// spot light falloff
				if (isClusteredLightSpot(light)) {
						decodeClusterLightSpot(light);
						falloffAttenuation *= getSpotEffect(light.direction, light.innerConeAngleCos, light.outerConeAngleCos, dLightDirNormW);
				}

				#if defined(CLUSTER_COOKIES_OR_SHADOWS)

				if (falloffAttenuation > 0.00001) {

						// shadow / cookie
						if (isClusteredLightCastShadow(light) || isClusteredLightCookie(light)) {

								// shared shadow / cookie data depends on light type
								if (isClusteredLightSpot(light)) {
										decodeClusterLightProjectionMatrixData(light);
								} else {
										decodeClusterLightOmniAtlasViewport(light);
								}

								float shadowTextureResolution = shadowAtlasParams.x;
								float shadowEdgePixels = shadowAtlasParams.y;

								#ifdef CLUSTER_COOKIES

								// cookie
								if (isClusteredLightCookie(light)) {
										decodeClusterLightCookieData(light);

										if (isClusteredLightSpot(light)) {
												cookieAttenuation = getCookie2DClustered(TEXTURE_PASS(cookieAtlasTexture), lightProjectionMatrix, vPositionW, light.cookieIntensity, isClusteredLightCookieRgb(light), light.cookieChannelMask);
										} else {
												cookieAttenuation = getCookieCubeClustered(TEXTURE_PASS(cookieAtlasTexture), dLightDirW, light.cookieIntensity, isClusteredLightCookieRgb(light), light.cookieChannelMask, shadowTextureResolution, shadowEdgePixels, light.omniAtlasViewport);
										}
								}

								#endif

								#ifdef CLUSTER_SHADOWS

								// shadow
								if (isClusteredLightCastShadow(light)) {
										decodeClusterLightShadowData(light);

										vec4 shadowParams = vec4(shadowTextureResolution, light.shadowNormalBias, light.shadowBias, 1.0 / light.range);

										if (isClusteredLightSpot(light)) {

												// spot shadow
												getShadowCoordPerspZbufferNormalOffset(lightProjectionMatrix, shadowParams, geometricNormal);
												
												#if defined(CLUSTER_SHADOW_TYPE_PCF1)
														float shadow = getShadowSpotClusteredPCF1(SHADOWMAP_PASS(shadowAtlasTexture), dShadowCoord, shadowParams);
												#elif defined(CLUSTER_SHADOW_TYPE_PCF3)
														float shadow = getShadowSpotClusteredPCF3(SHADOWMAP_PASS(shadowAtlasTexture), dShadowCoord, shadowParams);
												#elif defined(CLUSTER_SHADOW_TYPE_PCF5)
														float shadow = getShadowSpotClusteredPCF5(SHADOWMAP_PASS(shadowAtlasTexture), dShadowCoord, shadowParams);
												#elif defined(CLUSTER_SHADOW_TYPE_PCSS)
														float shadow = getShadowSpotClusteredPCSS(SHADOWMAP_PASS(shadowAtlasTexture), dShadowCoord, shadowParams);
												#endif
												falloffAttenuation *= mix(1.0, shadow, light.shadowIntensity);

										} else {

												// omni shadow
												vec3 dir = normalOffsetPointShadow(shadowParams, dLightPosW, dLightDirW, dLightDirNormW, geometricNormal);  // normalBias adjusted for distance

												#if defined(CLUSTER_SHADOW_TYPE_PCF1)
														float shadow = getShadowOmniClusteredPCF1(SHADOWMAP_PASS(shadowAtlasTexture), shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);
												#elif defined(CLUSTER_SHADOW_TYPE_PCF3)
														float shadow = getShadowOmniClusteredPCF3(SHADOWMAP_PASS(shadowAtlasTexture), shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);
												#elif defined(CLUSTER_SHADOW_TYPE_PCF5)
														float shadow = getShadowOmniClusteredPCF5(SHADOWMAP_PASS(shadowAtlasTexture), shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);
												#endif
												falloffAttenuation *= mix(1.0, shadow, light.shadowIntensity);
										}
								}

								#endif
						}
				}

				#endif

				// diffuse / specular / clearcoat
				#ifdef CLUSTER_AREALIGHTS

				if (isClusteredLightArea(light)) { // area light

						// area light diffuse
						{
								vec3 areaDiffuse = (diffuseAttenuation * falloffAttenuation) * light.color * cookieAttenuation;

								#if defined(LIT_SPECULAR)
										#if defined(LIT_CONSERVE_ENERGY)
												areaDiffuse = mix(areaDiffuse, vec3(0), dLTCSpecFres);
										#endif
								#endif

								// area light diffuse - it does not mix diffuse lighting into specular attenuation
								dDiffuseLight += areaDiffuse;
						}

						// specular and clear coat are material settings and get included by a define based on the material
						#ifdef LIT_SPECULAR

								// area light specular
								float areaLightSpecular;

								if (isClusteredLightRect(light)) {
										areaLightSpecular = getRectLightSpecular(worldNormal, viewDir);
								} else if (isClusteredLightDisk(light)) {
										areaLightSpecular = getDiskLightSpecular(worldNormal, viewDir);
								} else { // sphere
										areaLightSpecular = getSphereLightSpecular(worldNormal, viewDir);
								}

								dSpecularLight += dLTCSpecFres * areaLightSpecular * falloffAttenuation * light.color * cookieAttenuation;

								#ifdef LIT_CLEARCOAT

										// area light specular clear coat
										float areaLightSpecularCC;

										if (isClusteredLightRect(light)) {
												areaLightSpecularCC = getRectLightSpecular(clearcoat_worldNormal, viewDir);
										} else if (isClusteredLightDisk(light)) {
												areaLightSpecularCC = getDiskLightSpecular(clearcoat_worldNormal, viewDir);
										} else { // sphere
												areaLightSpecularCC = getSphereLightSpecular(clearcoat_worldNormal, viewDir);
										}

										ccSpecularLight += ccLTCSpecFres * areaLightSpecularCC * falloffAttenuation * light.color  * cookieAttenuation;

								#endif

						#endif

				} else

				#endif

				{    // punctual light

						// punctual light diffuse
						{
								vec3 punctualDiffuse = falloffAttenuation * light.color * cookieAttenuation;

								#if defined(CLUSTER_AREALIGHTS)
								#if defined(LIT_SPECULAR)
								#if defined(LIT_CONSERVE_ENERGY)
										punctualDiffuse = mix(punctualDiffuse, vec3(0), specularity);
								#endif
								#endif
								#endif

								dDiffuseLight += punctualDiffuse;
						}
	 
						// specular and clear coat are material settings and get included by a define based on the material
						#ifdef LIT_SPECULAR

								vec3 halfDir = normalize(-dLightDirNormW + viewDir);
								
								// specular
								#ifdef LIT_SPECULAR_FRESNEL
										dSpecularLight += 
												getLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, dLightDirNormW, gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation * 
												getFresnel(
														dot(viewDir, halfDir), 
														gloss, 
														specularity
												#if defined(LIT_IRIDESCENCE)
														, iridescenceFresnel,
														iridescence_intensity
												#endif
														);
								#else
										dSpecularLight += getLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, dLightDirNormW, gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation * specularity;
								#endif

								#ifdef LIT_CLEARCOAT
										#ifdef LIT_SPECULAR_FRESNEL
												ccSpecularLight += getLightSpecular(halfDir, clearcoatReflectionDir, clearcoat_worldNormal, viewDir, dLightDirNormW, clearcoat_gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation * getFresnelCC(dot(viewDir, halfDir));
										#else
												ccSpecularLight += getLightSpecular(halfDir, clearcoatReflectionDir, clearcoat_worldNormal, viewDir, dLightDirNormW, clearcoat_gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation; 
										#endif
								#endif

								#ifdef LIT_SHEEN
										sSpecularLight += getLightSpecularSheen(halfDir, worldNormal, viewDir, dLightDirNormW, sheen_gloss) * falloffAttenuation * light.color * cookieAttenuation;
								#endif

						#endif
				}
		}

		// Write to global attenuation values (for lightmapper)
		dAtten = falloffAttenuation;
		dAttenD = diffuseAttenuation;
		dAtten3 = cookieAttenuation;
}

void evaluateClusterLight(
		float lightIndex, 
		vec3 worldNormal, 
		vec3 viewDir, 
		vec3 reflectionDir, 
#if defined(LIT_CLEARCOAT)
		vec3 clearcoatReflectionDir,
#endif
		float gloss, 
		vec3 specularity, 
		vec3 geometricNormal, 
		mat3 tbn, 
#if defined(LIT_IRIDESCENCE)
		vec3 iridescenceFresnel,
#endif
		vec3 clearcoat_worldNormal,
		float clearcoat_gloss,
		float sheen_gloss,
		float iridescence_intensity
) {

		// decode core light data from textures
		ClusterLightData clusterLightData;
		decodeClusterLightCore(clusterLightData, lightIndex);

		// evaluate light if it uses accepted light mask
		if (acceptLightMask(clusterLightData))
				evaluateLight(
						clusterLightData, 
						worldNormal, 
						viewDir, 
						reflectionDir, 
#if defined(LIT_CLEARCOAT)
						clearcoatReflectionDir, 
#endif
						gloss, 
						specularity, 
						geometricNormal, 
						tbn, 
#if defined(LIT_IRIDESCENCE)
						iridescenceFresnel,
#endif
						clearcoat_worldNormal,
						clearcoat_gloss,
						sheen_gloss,
						iridescence_intensity
				);
}

void addClusteredLights(
		vec3 worldNormal, 
		vec3 viewDir, 
		vec3 reflectionDir, 
#if defined(LIT_CLEARCOAT)
		vec3 clearcoatReflectionDir,
#endif
		float gloss, 
		vec3 specularity, 
		vec3 geometricNormal, 
		mat3 tbn, 
#if defined(LIT_IRIDESCENCE)
		vec3 iridescenceFresnel,
#endif
		vec3 clearcoat_worldNormal,
		float clearcoat_gloss,
		float sheen_gloss,
		float iridescence_intensity
) {

		// skip lights if no lights at all
		if (clusterSkip > 0.5)
				return;

		// world space position to 3d integer cell cordinates in the cluster structure
		vec3 cellCoords = floor((vPositionW - clusterBoundsMin) * clusterCellsCountByBoundsSize);

		// no lighting when cell coordinate is out of range
		if (!(any(lessThan(cellCoords, vec3(0.0))) || any(greaterThanEqual(cellCoords, clusterCellsMax)))) {

				// cell index (mapping from 3d cell coordinates to linear memory)
				float cellIndex = dot(clusterCellsDot, cellCoords);

				// convert cell index to uv coordinates
				float clusterV = floor(cellIndex * clusterTextureSize.y);
				float clusterU = cellIndex - (clusterV * clusterTextureSize.x);

				#ifdef GL2

						// loop over maximum number of light cells
						for (int lightCellIndex = 0; lightCellIndex < clusterMaxCells; lightCellIndex++) {

								// using a single channel texture with data in alpha channel
								float lightIndex = texelFetch(clusterWorldTexture, ivec2(int(clusterU) + lightCellIndex, clusterV), 0).x;

								if (lightIndex <= 0.0)
												return;

								evaluateClusterLight(
										lightIndex * 255.0, 
										worldNormal, 
										viewDir, 
										reflectionDir,
#if defined(LIT_CLEARCOAT)
										clearcoatReflectionDir,
#endif
										gloss, 
										specularity, 
										geometricNormal, 
										tbn, 
#if defined(LIT_IRIDESCENCE)
										iridescenceFresnel,
#endif
										clearcoat_worldNormal,
										clearcoat_gloss,
										sheen_gloss,
										iridescence_intensity
								); 
						}

				#else

						clusterV = (clusterV + 0.5) * clusterTextureSize.z;

						// loop over maximum possible number of supported light cells
						const float maxLightCells = 256.0;
						for (float lightCellIndex = 0.5; lightCellIndex < maxLightCells; lightCellIndex++) {

								float lightIndex = texture2DLodEXT(clusterWorldTexture, vec2(clusterTextureSize.y * (clusterU + lightCellIndex), clusterV), 0.0).x;

								if (lightIndex <= 0.0)
										return;
								
								evaluateClusterLight(
										lightIndex * 255.0, 
										worldNormal, 
										viewDir, 
										reflectionDir,
#if defined(LIT_CLEARCOAT)
										clearcoatReflectionDir,
#endif
										gloss, 
										specularity, 
										geometricNormal, 
										tbn, 
#if defined(LIT_IRIDESCENCE)
										iridescenceFresnel,
#endif
										clearcoat_worldNormal,
										clearcoat_gloss,
										sheen_gloss,
										iridescence_intensity
								); 
								// end of the cell array
								if (lightCellIndex >= clusterMaxCells) {
										break;
								}
						}

				#endif
		}
}
`,
              B = `
vec3 combineColor(vec3 albedo, vec3 sheenSpecularity, float clearcoatSpecularity) {
		vec3 ret = vec3(0);
#ifdef LIT_OLD_AMBIENT
		ret += (dDiffuseLight - light_globalAmbient) * albedo + material_ambient * light_globalAmbient;
#else
		ret += albedo * dDiffuseLight;
#endif
#ifdef LIT_SPECULAR
		ret += dSpecularLight;
#endif
#ifdef LIT_REFLECTIONS
		ret += dReflection.rgb * dReflection.a;
#endif

#ifdef LIT_SHEEN
		float sheenScaling = 1.0 - max(max(sheenSpecularity.r, sheenSpecularity.g), sheenSpecularity.b) * 0.157;
		ret = ret * sheenScaling + (sSpecularLight + sReflection.rgb) * sheenSpecularity;
#endif
#ifdef LIT_CLEARCOAT
		float clearCoatScaling = 1.0 - ccFresnel * clearcoatSpecularity;
		ret = ret * clearCoatScaling + (ccSpecularLight + ccReflection.rgb) * clearcoatSpecularity;
#endif

		return ret;
}
`,
              C = `
// light cookie functionality for non-clustered lights
vec4 getCookie2D(sampler2D tex, mat4 transform, float intensity) {
		vec4 projPos = transform * vec4(vPositionW, 1.0);
		projPos.xy /= projPos.w;
		return mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);
}

vec4 getCookie2DClip(sampler2D tex, mat4 transform, float intensity) {
		vec4 projPos = transform * vec4(vPositionW, 1.0);
		projPos.xy /= projPos.w;
		if (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);
		return mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);
}

vec4 getCookie2DXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {
		vec4 projPos = transform * vec4(vPositionW, 1.0);
		projPos.xy /= projPos.w;
		projPos.xy += cookieOffset;
		vec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);
		return mix(vec4(1.0), texture2D(tex, uv), intensity);
}

vec4 getCookie2DClipXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {
		vec4 projPos = transform * vec4(vPositionW, 1.0);
		projPos.xy /= projPos.w;
		projPos.xy += cookieOffset;
		if (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);
		vec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);
		return mix(vec4(1.0), texture2D(tex, uv), intensity);
}

vec4 getCookieCube(samplerCube tex, mat4 transform, float intensity) {
		return mix(vec4(1.0), textureCube(tex, dLightDirNormW * mat3(transform)), intensity);
}
`,
              w = `
uniform vec3 envBoxMin;
uniform vec3 envBoxMax;

vec3 cubeMapProject(vec3 nrdir) {
		nrdir = cubeMapRotate(nrdir);

		vec3 rbmax = (envBoxMax - vPositionW) / nrdir;
		vec3 rbmin = (envBoxMin - vPositionW) / nrdir;

		vec3 rbminmax;
		rbminmax.x = nrdir.x>0.0? rbmax.x : rbmin.x;
		rbminmax.y = nrdir.y>0.0? rbmax.y : rbmin.y;
		rbminmax.z = nrdir.z>0.0? rbmax.z : rbmin.z;

		float fa = min(min(rbminmax.x, rbminmax.y), rbminmax.z);

		vec3 posonbox = vPositionW + nrdir * fa;
		vec3 envBoxPos = (envBoxMin + envBoxMax) * 0.5;
		return normalize(posonbox - envBoxPos);
}
`,
              k = `
vec3 cubeMapProject(vec3 dir) {
		return cubeMapRotate(dir);
}
`,
              K = `
#ifdef CUBEMAP_ROTATION
uniform mat3 cubeMapRotationMatrix;
#endif

vec3 cubeMapRotate(vec3 refDir) {
#ifdef CUBEMAP_ROTATION
		return refDir * cubeMapRotationMatrix;
#else
		return refDir;
#endif
}
`,
              te = `
#ifdef DEBUG_ALBEDO_PASS
gl_FragColor = vec4(gammaCorrectOutput(litArgs_albedo), 1.0);
#endif

#ifdef DEBUG_UV0_PASS
gl_FragColor = vec4(litArgs_albedo , 1.0);
#endif

#ifdef DEBUG_WORLD_NORMAL_PASS
gl_FragColor = vec4(litArgs_worldNormal * 0.5 + 0.5, 1.0);
#endif

#ifdef DEBUG_OPACITY_PASS
gl_FragColor = vec4(vec3(litArgs_opacity) , 1.0);
#endif

#ifdef DEBUG_SPECULARITY_PASS
gl_FragColor = vec4(litArgs_specularity, 1.0);
#endif

#ifdef DEBUG_GLOSS_PASS
gl_FragColor = vec4(vec3(litArgs_gloss) , 1.0);
#endif

#ifdef DEBUG_METALNESS_PASS
gl_FragColor = vec4(vec3(litArgs_metalness) , 1.0);
#endif

#ifdef DEBUG_AO_PASS
gl_FragColor = vec4(vec3(litArgs_ao) , 1.0);
#endif

#ifdef DEBUG_EMISSION_PASS
gl_FragColor = vec4(gammaCorrectOutput(litArgs_emission), 1.0);
#endif
`,
              X = `
#ifdef DEBUG_LIGHTING_PASS
litArgs_albedo = vec3(0.5);
#endif

#ifdef DEBUG_UV0_PASS
#ifdef VARYING_VUV0
litArgs_albedo = vec3(vUv0, 0);
#else
litArgs_albedo = vec3(0);
#endif
#endif
`,
              $ = `
vec3 decodeLinear(vec4 raw) {
		return raw.rgb;
}

float decodeGamma(float raw) {
		return pow(raw, 2.2);
}

vec3 decodeGamma(vec3 raw) {
		return pow(raw, vec3(2.2));
}

vec3 decodeGamma(vec4 raw) {
		return pow(raw.xyz, vec3(2.2));
}

vec3 decodeRGBM(vec4 raw) {
		vec3 color = (8.0 * raw.a) * raw.rgb;
		return color * color;
}

vec3 decodeRGBP(vec4 raw) {
		vec3 color = raw.rgb * (-raw.a * 7.0 + 8.0);
		return color * color;
}

vec3 decodeRGBE(vec4 raw) {
		if (raw.a == 0.0) {
				return vec3(0.0, 0.0, 0.0);
		} else {
				return raw.xyz * pow(2.0, raw.w * 255.0 - 128.0);
		}
}

vec4 passThrough(vec4 raw) {
		return raw;
}
`,
              ne = `
vec3 detailMode_mul(vec3 c1, vec3 c2) {
		return c1 * c2;
}

vec3 detailMode_add(vec3 c1, vec3 c2) {
		return c1 + c2;
}

// https://en.wikipedia.org/wiki/Blend_modes#Screen
vec3 detailMode_screen(vec3 c1, vec3 c2) {
		return 1.0 - (1.0 - c1)*(1.0 - c2);
}

// https://en.wikipedia.org/wiki/Blend_modes#Overlay
vec3 detailMode_overlay(vec3 c1, vec3 c2) {
		return mix(1.0 - 2.0*(1.0 - c1)*(1.0 - c2), 2.0*c1*c2, step(c1, vec3(0.5)));
}

vec3 detailMode_min(vec3 c1, vec3 c2) {
		return min(c1, c2);
}

vec3 detailMode_max(vec3 c1, vec3 c2) {
		return max(c1, c2);
}
`,
              Y = `
#ifdef MAPCOLOR
uniform vec3 material_diffuse;
#endif

void getAlbedo() {
		dAlbedo = vec3(1.0);

#ifdef MAPCOLOR
		dAlbedo *= material_diffuse.rgb;
#endif

#ifdef MAPTEXTURE
		vec3 albedoBase = $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
		dAlbedo *= addAlbedoDetail(albedoBase);
#endif

#ifdef MAPVERTEX
		dAlbedo *= gammaCorrectInput(saturate(vVertexColor.$VC));
#endif
}
`,
              Z = `
vec3 addAlbedoDetail(vec3 albedo) {
#ifdef MAPTEXTURE
		vec3 albedoDetail = $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
		return detailMode_$DETAILMODE(albedo, albedoDetail);
#else
		return albedo;
#endif
}
`,
              ye = `
#ifdef MAPCOLOR
uniform vec3 material_emissive;
#endif

#ifdef MAPFLOAT
uniform float material_emissiveIntensity;
#endif

void getEmission() {
		dEmission = vec3(1.0);

		#ifdef MAPFLOAT
		dEmission *= material_emissiveIntensity;
		#endif

		#ifdef MAPCOLOR
		dEmission *= material_emissive;
		#endif

		#ifdef MAPTEXTURE
		dEmission *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
		#endif

		#ifdef MAPVERTEX
		dEmission *= gammaCorrectInput(saturate(vVertexColor.$VC));
		#endif
}
`,
              pe = `
vec4 encodeLinear(vec3 source) {
		return vec4(source, 1.0);
}

vec4 encodeGamma(vec3 source) {
		return vec4(pow(source + 0.0000001, vec3(1.0 / 2.2)), 1.0);
}

vec4 encodeRGBM(vec3 source) { // modified RGBM
		vec4 result;
		result.rgb = pow(source.rgb, vec3(0.5));
		result.rgb *= 1.0 / 8.0;

		result.a = saturate( max( max( result.r, result.g ), max( result.b, 1.0 / 255.0 ) ) );
		result.a = ceil(result.a * 255.0) / 255.0;

		result.rgb /= result.a;
		return result;
}

vec4 encodeRGBP(vec3 source) {
		// convert incoming linear to gamma(ish)
		vec3 gamma = pow(source, vec3(0.5));

		// calculate the maximum component clamped to 1..8
		float maxVal = min(8.0, max(1.0, max(gamma.x, max(gamma.y, gamma.z))));

		// calculate storage factor
		float v = 1.0 - ((maxVal - 1.0) / 7.0);

		// round the value for storage in 8bit channel
		v = ceil(v * 255.0) / 255.0;

		return vec4(gamma / (-v * 7.0 + 8.0), v);    
}

vec4 encodeRGBE(vec3 source) {
		float maxVal = max(source.x, max(source.y, source.z));
		if (maxVal < 1e-32) {
				return vec4(0, 0, 0, 0);
		} else {
				float e = ceil(log2(maxVal));
				return vec4(source / pow(2.0, e), (e + 128.0) / 255.0);
		}
}
`,
              O = `
		gl_FragColor.rgb = combineColor(litArgs_albedo, litArgs_sheen_specularity, litArgs_clearcoat_specularity);

		gl_FragColor.rgb += litArgs_emission;
		gl_FragColor.rgb = addFog(gl_FragColor.rgb);

		#ifndef HDR
		gl_FragColor.rgb = toneMap(gl_FragColor.rgb);
		gl_FragColor.rgb = gammaCorrectOutput(gl_FragColor.rgb);
		#endif
`,
              me = `
`,
              N = `
// the envAtlas is fixed at 512 pixels. every equirect is generated with 1 pixel boundary.
const float atlasSize = 512.0;
const float seamSize = 1.0 / atlasSize;

// map a normalized equirect UV to the given rectangle (taking 1 pixel seam into account).
vec2 mapUv(vec2 uv, vec4 rect) {
		return vec2(mix(rect.x + seamSize, rect.x + rect.z - seamSize, uv.x),
								mix(rect.y + seamSize, rect.y + rect.w - seamSize, uv.y));
}

// map a normalized equirect UV and roughness level to the correct atlas rect.
vec2 mapRoughnessUv(vec2 uv, float level) {
		float t = 1.0 / exp2(level);
		return mapUv(uv, vec4(0, 1.0 - t, t, t * 0.5));
}

// map shiny level UV
vec2 mapShinyUv(vec2 uv, float level) {
		float t = 1.0 / exp2(level);
		return mapUv(uv, vec4(1.0 - t, 1.0 - t, t, t * 0.5));
}
`,
              V = `
vec3 processEnvironment(vec3 color) {
		return color;
}
`,
              L = `
uniform float skyboxIntensity;

vec3 processEnvironment(vec3 color) {
		return color * skyboxIntensity;
}
`,
              J = `
`,
              ae = `
`,
              R = `
float getFalloffWindow(float lightRadius, vec3 lightDir) {
		float sqrDist = dot(lightDir, lightDir);
		float invRadius = 1.0 / lightRadius;
		return square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );
}

float getFalloffInvSquared(float lightRadius, vec3 lightDir) {
		float sqrDist = dot(lightDir, lightDir);
		float falloff = 1.0 / (sqrDist + 1.0);
		float invRadius = 1.0 / lightRadius;

		falloff *= 16.0;
		falloff *= square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );

		return falloff;
}
`,
              j = `
float getFalloffLinear(float lightRadius, vec3 lightDir) {
		float d = length(lightDir);
		return max(((lightRadius - d) / lightRadius), 0.0);
}
`,
              se = `
vec3 fixSeams(vec3 vec, float mipmapIndex) {
		return vec;
}

vec3 fixSeams(vec3 vec) {
		return vec;
}

vec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {
		return vec;
}

vec3 calcSeam(vec3 vec) {
		return vec3(0);
}

vec3 applySeam(vec3 vec, vec3 seam, float scale) {
		return vec;
}
`,
              ce = `
vec3 fixSeams(vec3 vec, float mipmapIndex) {
		vec3 avec = abs(vec);
		float scale = 1.0 - exp2(mipmapIndex) / 128.0;
		float M = max(max(avec.x, avec.y), avec.z);
		if (avec.x != M) vec.x *= scale;
		if (avec.y != M) vec.y *= scale;
		if (avec.z != M) vec.z *= scale;
		return vec;
}

vec3 fixSeams(vec3 vec) {
		vec3 avec = abs(vec);
		float scale = 1.0 - 1.0 / 128.0;
		float M = max(max(avec.x, avec.y), avec.z);
		if (avec.x != M) vec.x *= scale;
		if (avec.y != M) vec.y *= scale;
		if (avec.z != M) vec.z *= scale;
		return vec;
}

vec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {
		vec3 avec = abs(vec);
		float scale = invRecMipSize;
		float M = max(max(avec.x, avec.y), avec.z);
		if (avec.x != M) vec.x *= scale;
		if (avec.y != M) vec.y *= scale;
		if (avec.z != M) vec.z *= scale;
		return vec;
}

vec3 calcSeam(vec3 vec) {
		vec3 avec = abs(vec);
		float M = max(avec.x, max(avec.y, avec.z));
		return vec3(avec.x != M ? 1.0 : 0.0,
								avec.y != M ? 1.0 : 0.0,
								avec.z != M ? 1.0 : 0.0);
}

vec3 applySeam(vec3 vec, vec3 seam, float scale) {
		return vec * (seam * -scale + vec3(1.0));
}
`,
              ie = `
// float unpacking functionality, complimentary to float-packing.js
float bytes2float2(vec2 data) {
		return dot(data, vec2(1.0, 1.0 / 255.0));
}

float bytes2float3(vec3 data) {
		return dot(data, vec3(1.0, 1.0 / 255.0, 1.0 / 65025.0));
}

float bytes2float4(vec4 data) {
		return dot(data, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));
}

float bytes2floatRange2(vec2 data, float min, float max) {
		return mix(min, max, bytes2float2(data));
}

float bytes2floatRange3(vec3 data, float min, float max) {
		return mix(min, max, bytes2float3(data));
}

float bytes2floatRange4(vec4 data, float min, float max) {
		return mix(min, max, bytes2float4(data));
}

float mantissaExponent2Float(vec4 pack)
{
		float value = bytes2floatRange3(pack.xyz, -1.0, 1.0);
		float exponent = floor(pack.w * 255.0 - 127.0);
		return value * exp2(exponent);
}
`,
              b = `
uniform vec3 fog_color;
uniform float fog_density;
float dBlendModeFogFactor = 1.0;

vec3 addFog(vec3 color) {
		float depth = gl_FragCoord.z / gl_FragCoord.w;
		float fogFactor = exp(-depth * fog_density);
		fogFactor = clamp(fogFactor, 0.0, 1.0);
		return mix(fog_color * dBlendModeFogFactor, color, fogFactor);
}
`,
              M = `
uniform vec3 fog_color;
uniform float fog_density;
float dBlendModeFogFactor = 1.0;

vec3 addFog(vec3 color) {
		float depth = gl_FragCoord.z / gl_FragCoord.w;
		float fogFactor = exp(-depth * depth * fog_density * fog_density);
		fogFactor = clamp(fogFactor, 0.0, 1.0);
		return mix(fog_color * dBlendModeFogFactor, color, fogFactor);
}
`,
              F = `
uniform vec3 fog_color;
uniform float fog_start;
uniform float fog_end;
float dBlendModeFogFactor = 1.0;

vec3 addFog(vec3 color) {
		float depth = gl_FragCoord.z / gl_FragCoord.w;
		float fogFactor = (fog_end - depth) / (fog_end - fog_start);
		fogFactor = clamp(fogFactor, 0.0, 1.0);
		return mix(fog_color * dBlendModeFogFactor, color, fogFactor);
}
`,
              z = `
float dBlendModeFogFactor = 1.0;

vec3 addFog(vec3 color) {
		return color;
}
`,
              oe = `
// Schlick's approximation
vec3 getFresnel(
				float cosTheta, 
				float gloss, 
				vec3 specularity
#if defined(LIT_IRIDESCENCE)
				, vec3 iridescenceFresnel, 
				float iridescenceIntensity
#endif
		) {
		float fresnel = pow(1.0 - max(cosTheta, 0.0), 5.0);
		float glossSq = gloss * gloss;
		vec3 ret = specularity + (max(vec3(glossSq), specularity) - specularity) * fresnel;
#if defined(LIT_IRIDESCENCE)
		return mix(ret, iridescenceFresnel, iridescenceIntensity);
#else
		return ret;
#endif    
}

float getFresnelCC(float cosTheta) {
		float fresnel = pow(1.0 - max(cosTheta, 0.0), 5.0);
		return 0.04 + (1.0 - 0.04) * fresnel;
}
`,
              de = `
varying vec2 vUv0;

uniform sampler2D source;

void main(void) {
		gl_FragColor = texture2D(source, vUv0);
}
`,
              ge = `
attribute vec2 vertex_position;

varying vec2 vUv0;

void main(void)
{
		gl_Position = vec4(vertex_position, 0.5, 1.0);
		vUv0 = vertex_position.xy*0.5+0.5;
}
`,
              Re = `
float gammaCorrectInput(float color) {
		return color;
}

vec3 gammaCorrectInput(vec3 color) {
		return color;
}

vec4 gammaCorrectInput(vec4 color) {
		return color;
}

vec3 gammaCorrectOutput(vec3 color) {
		return color;
}
`,
              Te = `
float gammaCorrectInput(float color) {
		return decodeGamma(color);
}

vec3 gammaCorrectInput(vec3 color) {
		return decodeGamma(color);
}

vec4 gammaCorrectInput(vec4 color) {
		return vec4(decodeGamma(color.xyz), color.w);
}

vec3 gammaCorrectOutput(vec3 color) {
#ifdef HDR
		return color;
#else
		return pow(color + 0.0000001, vec3(1.0 / 2.2));
#endif
}
`,
              Ne = a(2462),
              Le = a(7086),
              ke = a(5910),
              ht = `
#ifdef MAPFLOAT
uniform float material_gloss;
#endif

void getGlossiness() {
		dGlossiness = 1.0;

		#ifdef MAPFLOAT
		dGlossiness *= material_gloss;
		#endif

		#ifdef MAPTEXTURE
		dGlossiness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
		#endif

		#ifdef MAPVERTEX
		dGlossiness *= saturate(vVertexColor.$VC);
		#endif

		#ifdef MAPINVERT
		dGlossiness = 1.0 - dGlossiness;
		#endif

		dGlossiness += 0.0000001;
}
`,
              _e = `
uniform float material_iridescenceRefractionIndex;

#ifndef PI
#define PI 3.14159265
#endif

float iridescence_iorToFresnel(float transmittedIor, float incidentIor) {
		return pow((transmittedIor - incidentIor) / (transmittedIor + incidentIor), 2.0);
}

vec3 iridescence_iorToFresnel(vec3 transmittedIor, float incidentIor) {
		return pow((transmittedIor - vec3(incidentIor)) / (transmittedIor + vec3(incidentIor)), vec3(2.0));
}

vec3 iridescence_fresnelToIor(vec3 f0) {
		vec3 sqrtF0 = sqrt(f0);
		return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);
}

vec3 iridescence_sensitivity(float opd, vec3 shift) {
		float phase = 2.0 * PI * opd * 1.0e-9;
		const vec3 val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);
		const vec3 pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);
		const vec3 var = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);

		vec3 xyz = val * sqrt(2.0 * PI * var) * cos(pos * phase + shift) * exp(-pow(phase, 2.0) * var);
		xyz.x += 9.7470e-14 * sqrt(2.0 * PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * pow(phase, 2.0));
		xyz /= vec3(1.0685e-07);

		const mat3 XYZ_TO_REC709 = mat3(
				3.2404542, -0.9692660,  0.0556434,
			 -1.5371385,  1.8760108, -0.2040259,
			 -0.4985314,  0.0415560,  1.0572252
		);

		return XYZ_TO_REC709 * xyz;
}

float iridescence_fresnel(float cosTheta, float f0) {
		float x = clamp(1.0 - cosTheta, 0.0, 1.0);
		float x2 = x * x;
		float x5 = x * x2 * x2;
		return f0 + (1.0 - f0) * x5;
} 

vec3 iridescence_fresnel(float cosTheta, vec3 f0) {
		float x = clamp(1.0 - cosTheta, 0.0, 1.0);
		float x2 = x * x;
		float x5 = x * x2 * x2; 
		return f0 + (vec3(1.0) - f0) * x5;
}

vec3 calcIridescence(float outsideIor, float cosTheta, vec3 base_f0, float iridescenceThickness) {

		float iridescenceIor = mix(outsideIor, material_iridescenceRefractionIndex, smoothstep(0.0, 0.03, iridescenceThickness));
		float sinTheta2Sq = pow(outsideIor / iridescenceIor, 2.0) * (1.0 - pow(cosTheta, 2.0));
		float cosTheta2Sq = 1.0 - sinTheta2Sq;

		if (cosTheta2Sq < 0.0) {
				return vec3(1.0);
		}

		float cosTheta2 = sqrt(cosTheta2Sq);

		float r0 = iridescence_iorToFresnel(iridescenceIor, outsideIor);
		float r12 = iridescence_fresnel(cosTheta, r0);
		float r21 = r12;
		float t121 = 1.0 - r12;

		float phi12 = iridescenceIor < outsideIor ? PI : 0.0;
		float phi21 = PI - phi12;

		vec3 baseIor = iridescence_fresnelToIor(base_f0 + vec3(0.0001));
		vec3 r1 = iridescence_iorToFresnel(baseIor, iridescenceIor);
		vec3 r23 = iridescence_fresnel(cosTheta2, r1);

		vec3 phi23 = vec3(0.0);
		if (baseIor[0] < iridescenceIor) phi23[0] = PI;
		if (baseIor[1] < iridescenceIor) phi23[1] = PI;
		if (baseIor[2] < iridescenceIor) phi23[2] = PI;
		float opd = 2.0 * iridescenceIor * iridescenceThickness * cosTheta2;
		vec3 phi = vec3(phi21) + phi23; 

		vec3 r123Sq = clamp(r12 * r23, 1e-5, 0.9999);
		vec3 r123 = sqrt(r123Sq);
		vec3 rs = pow(t121, 2.0) * r23 / (1.0 - r123Sq);

		vec3 c0 = r12 + rs;
		vec3 i = c0;

		vec3 cm = rs - t121;
		for (int m = 1; m <= 2; m++) {
				cm *= r123;
				vec3 sm = 2.0 * iridescence_sensitivity(float(m) * opd, float(m) * phi);
				i += cm * sm;
		}
		return max(i, vec3(0.0));
}

vec3 getIridescence(float cosTheta, vec3 specularity, float iridescenceThickness) {
		return calcIridescence(1.0, cosTheta, specularity, iridescenceThickness);
}
`,
              U = `
#ifdef MAPFLOAT
uniform float material_iridescence;
#endif

void getIridescence() {
		float iridescence = 1.0;

		#ifdef MAPFLOAT
		iridescence *= material_iridescence;
		#endif

		#ifdef MAPTEXTURE
		iridescence *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
		#endif

		dIridescence = iridescence; 
}
`,
              H = `
uniform float material_iridescenceThicknessMax;

#ifdef MAPTEXTURE
uniform float material_iridescenceThicknessMin;
#endif

void getIridescenceThickness() {

		#ifdef MAPTEXTURE
		float blend = texture2DBias($SAMPLER, $UV, textureBias).$CH;
		float iridescenceThickness = mix(material_iridescenceThicknessMin, material_iridescenceThicknessMax, blend);
		#else
		float iridescenceThickness = material_iridescenceThicknessMax;
		#endif

		dIridescenceThickness = iridescenceThickness; 
}
`,
              Ee = `
attribute vec4 instance_line1;
attribute vec4 instance_line2;
attribute vec4 instance_line3;
attribute vec4 instance_line4;
`,
              G = `
#ifdef MAPFLOAT
uniform float material_refractionIndex;
#endif

void getIor() {
#ifdef MAPFLOAT
		dIor = material_refractionIndex;
#else
		dIor = 1.0 / 1.5;
#endif
}
`,
              Q = `
float getLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {
		return max(dot(worldNormal, -lightDirNorm), 0.0);
}
`,
              q = `
void getLightDirPoint(vec3 lightPosW) {
		dLightDirW = vPositionW - lightPosW;
		dLightDirNormW = normalize(dLightDirW);
		dLightPosW = lightPosW;
}
`,
              xe = `
void addLightMap(
		vec3 lightmap, 
		vec3 dir, 
		vec3 worldNormal, 
		vec3 viewDir, 
		vec3 reflectionDir, 
		float gloss, 
		vec3 specularity, 
		vec3 vertexNormal, 
		mat3 tbn
#if defined(LIT_IRIDESCENCE)
		vec3 iridescenceFresnel, 
		float iridescenceIntensity
#endif
) {
		dDiffuseLight += lightmap;
}
`,
              be = `
void addLightMap(
		vec3 lightmap, 
		vec3 dir, 
		vec3 worldNormal, 
		vec3 viewDir, 
		vec3 reflectionDir, 
		float gloss, 
		vec3 specularity, 
		vec3 vertexNormal, 
		mat3 tbn
#if defined(LIT_IRIDESCENCE)
		vec3 iridescenceFresnel, 
		float iridescenceIntensity
#endif
) {
		if (dot(dir, dir) < 0.0001) {
				dDiffuseLight += lightmap;
		} else {
				float vlight = saturate(dot(dir, -vertexNormal));
				float flight = saturate(dot(dir, -worldNormal));
				float nlight = (flight / max(vlight, 0.01)) * 0.5;

				dDiffuseLight += lightmap * nlight * 2.0;

				vec3 halfDir = normalize(-dir + viewDir);
				vec3 specularLight = lightmap * getLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, dir, gloss, tbn);

#ifdef LIT_SPECULAR_FRESNEL
				specularLight *= 
						getFresnel(dot(viewDir, halfDir), 
						gloss, 
						specularity
				#if defined(LIT_IRIDESCENCE)
						, iridescenceFresnel,
						iridescenceIntensity
				#endif
						);
#endif

				dSpecularLight += specularLight;
		}
}
`,
              Pe = `
uniform sampler2D texture_lightMap;
uniform sampler2D texture_dirLightMap;

void getLightMap() {
		dLightmap = $DECODE(texture2DBias(texture_lightMap, $UV, textureBias)).$CH;

		vec3 dir = texture2DBias(texture_dirLightMap, $UV, textureBias).xyz * 2.0 - 1.0;
		float dirDot = dot(dir, dir);
		dLightmapDir = (dirDot > 0.001) ? dir / sqrt(dirDot) : vec3(0.0);
}
`,
              we = `
void getLightMap() {
		dLightmap = vec3(1.0);

		#ifdef MAPTEXTURE
		dLightmap *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
		#endif

		#ifdef MAPVERTEX
		dLightmap *= saturate(vVertexColor.$VC);
		#endif
}
`,
              Oe = `
// Anisotropic GGX
float calcLightSpecular(float gloss, vec3 worldNormal, vec3 viewDir, vec3 h, vec3 lightDirNorm, mat3 tbn) {
		float PI = 3.141592653589793;
		float roughness = max((1.0 - gloss) * (1.0 - gloss), 0.001);
		float anisotropy = material_anisotropy * roughness;
 
		float at = max((roughness + anisotropy), roughness / 4.0);
		float ab = max((roughness - anisotropy), roughness / 4.0);

		float NoH = dot(worldNormal, h);
		float ToH = dot(tbn[0], h);
		float BoH = dot(tbn[1], h);

		float a2 = at * ab;
		vec3 v = vec3(ab * ToH, at * BoH, a2 * NoH);
		float v2 = dot(v, v);
		float w2 = a2 / v2;
		float D = a2 * w2 * w2 * (1.0 / PI);

		float ToV = dot(tbn[0], viewDir);
		float BoV = dot(tbn[1], viewDir);
		float ToL = dot(tbn[0], -lightDirNorm);
		float BoL = dot(tbn[1], -lightDirNorm);
		float NoV = dot(worldNormal, viewDir);
		float NoL = dot(worldNormal, -lightDirNorm);

		float lambdaV = NoL * length(vec3(at * ToV, ab * BoV, NoV));
		float lambdaL = NoV * length(vec3(at * ToL, ab * BoL, NoL));
		float G = 0.5 / (lambdaV + lambdaL);

		return D * G;
}

float getLightSpecular(vec3 h, vec3 reflDir, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float gloss, mat3 tbn) {
		return calcLightSpecular(gloss, worldNormal, viewDir, h, lightDirNorm, tbn);
}
`,
              $e = `
// Energy-conserving (hopefully) Blinn-Phong
float calcLightSpecular(float gloss, vec3 worldNormal, vec3 h) {
		float nh = max( dot( h, worldNormal ), 0.0 );

		float specPow = exp2(gloss * 11.0); // glossiness is linear, power is not; 0 - 2048

		// Hack: On Mac OS X, calling pow with zero for the exponent generates hideous artifacts so bias up a little
		specPow = max(specPow, 0.0001);

		return pow(nh, specPow) * (specPow + 2.0) / 8.0;
}

float getLightSpecular(vec3 h, vec3 reflDir, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float gloss, mat3 tbn) {
		return calcLightSpecular(gloss, worldNormal, h);
}
`,
              gt = `
float calcLightSpecular(float gloss, vec3 reflDir, vec3 lightDirNorm) {
		float specPow = gloss;

		// Hack: On Mac OS X, calling pow with zero for the exponent generates hideous artifacts so bias up a little
		return pow(max(dot(reflDir, -lightDirNorm), 0.0), specPow + 0.0001);
}

float getLightSpecular(vec3 h, vec3 reflDir, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float gloss, mat3 tbn) {
		return calcLightSpecular(gloss, reflDir, lightDirNorm);
}
`,
              qe = `

float sheenD(vec3 normal, vec3 h, float roughness) {
		float invR = 1.0 / (roughness * roughness);
		float cos2h = max(dot(normal, h), 0.0);
		cos2h *= cos2h;
		float sin2h = max(1.0 - cos2h, 0.0078125);
		return (2.0 + invR) * pow(sin2h, invR * 0.5) / (2.0 * PI);
}

float sheenV(vec3 normal, vec3 viewDir, vec3 light) {
		float NoV = max(dot(normal, viewDir), 0.000001);
		float NoL = max(dot(normal, light), 0.000001);
		return 1.0 / (4.0 * (NoL + NoV - NoL * NoV));
}

float getLightSpecularSheen(vec3 h, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float sheenGloss) {
		float D = sheenD(worldNormal, h, sheenGloss);
		float V = sheenV(worldNormal, viewDir, -lightDirNorm);
		return D * V;
}
`,
              Tt = `

#ifndef LINEARIZE_DEPTH
#define LINEARIZE_DEPTH

float linearizeDepth(float z, vec4 cameraParams) {
		if (cameraParams.w == 0.0)
				return (cameraParams.z * cameraParams.y) / (cameraParams.y + z * (cameraParams.z - cameraParams.y));
		else
				return cameraParams.z + z * (cameraParams.y - cameraParams.z);
}

#ifndef CAMERAPLANES
#define CAMERAPLANES
uniform vec4 camera_params; // x: 1 / camera_far,      y: camera_far,     z: camera_near,        w: is_ortho
#endif

#ifdef GL2
float linearizeDepth(float z) {
		return linearizeDepth(z, camera_params);
}
#else
#ifndef UNPACKFLOAT
#define UNPACKFLOAT
float unpackFloat(vec4 rgbaDepth) {
		const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);
		return dot(rgbaDepth, bitShift);
}
#endif
#endif
#endif
`,
              Mt = `

// Surface albedo absorbance
vec3 litArgs_albedo;

// Transparency
float litArgs_opacity;

// Emission color
vec3 litArgs_emission;

// Normal direction in world space
vec3 litArgs_worldNormal;

// Ambient occlusion amount, range [0..1]
float litArgs_ao;

// Light map color
vec3 litArgs_lightmap;

// Light map direction
vec3 litArgs_lightmapDir;

// Surface metalness factor, range [0..1]
float litArgs_metalness;

// The f0 specularity factor
vec3 litArgs_specularity;

// Specularity intensity factor, range [0..1]
float litArgs_specularityFactor;

// The microfacet glossiness factor, range [0..1]
float litArgs_gloss;

// Glossiness of the sheen layer, range [0..1]
float litArgs_sheen_gloss;

// The color of the f0 specularity factor for the sheen layer
vec3 litArgs_sheen_specularity;

// Transmission factor (refraction), range [0..1]
float litArgs_transmission;

// Uniform thickness of medium, used by transmission, range [0..inf]
float litArgs_thickness;

// Index of refraction
float litArgs_ior;

// Iridescence effect intensity, range [0..1]
float litArgs_iridescence_intensity;

// Thickness of the iridescent microfilm layer, value is in nanometers, range [0..1000]
float litArgs_iridescence_thickness;

// The normal used for the clearcoat layer
vec3 litArgs_clearcoat_worldNormal;

// Intensity of the clearcoat layer, range [0..1]
float litArgs_clearcoat_specularity;

// Glossiness of clearcoat layer, range [0..1]
float litArgs_clearcoat_gloss;

`,
              Dt = `
// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines
// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt
// code: https://github.com/selfshadow/ltc_code/

mat3 transposeMat3( const in mat3 m ) {
		mat3 tmp;
		tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
		tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
		tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
		return tmp;
}

vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
		const float LUT_SIZE = 64.0;
		const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
		const float LUT_BIAS = 0.5 / LUT_SIZE;
		float dotNV = saturate( dot( N, V ) );
		// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )
		vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
		uv = uv * LUT_SCALE + LUT_BIAS;
		return uv;
}

float LTC_ClippedSphereFormFactor( const in vec3 f ) {
		// Real-Time Area Lighting: a Journey from Research to Production (p.102)
		// An approximation of the form factor of a horizon-clipped rectangle.
		float l = length( f );
		return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}

vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
		float x = dot( v1, v2 );
		float y = abs( x );
		// rational polynomial approximation to theta / sin( theta ) / 2PI
		float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
		float b = 3.4175940 + ( 4.1616724 + y ) * y;
		float v = a / b;
		float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
		return cross( v1, v2 ) * theta_sintheta;
}

struct Coords {
		vec3 coord0;
		vec3 coord1;
		vec3 coord2;
		vec3 coord3;
};

float LTC_EvaluateRect( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in Coords rectCoords) {
		// bail if point is on back side of plane of light
		// assumes ccw winding order of light vertices
		vec3 v1 = rectCoords.coord1 - rectCoords.coord0;
		vec3 v2 = rectCoords.coord3 - rectCoords.coord0;
		
		vec3 lightNormal = cross( v1, v2 );
		// if( dot( lightNormal, P - rectCoords.coord0 ) < 0.0 ) return 0.0;
		float factor = sign(-dot( lightNormal, P - rectCoords.coord0 ));

		// construct orthonormal basis around N
		vec3 T1, T2;
		T1 = normalize( V - N * dot( V, N ) );
		T2 =  factor * cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system
		// compute transform
		mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
		// transform rect
		vec3 coords[ 4 ];
		coords[ 0 ] = mat * ( rectCoords.coord0 - P );
		coords[ 1 ] = mat * ( rectCoords.coord1 - P );
		coords[ 2 ] = mat * ( rectCoords.coord2 - P );
		coords[ 3 ] = mat * ( rectCoords.coord3 - P );
		// project rect onto sphere
		coords[ 0 ] = normalize( coords[ 0 ] );
		coords[ 1 ] = normalize( coords[ 1 ] );
		coords[ 2 ] = normalize( coords[ 2 ] );
		coords[ 3 ] = normalize( coords[ 3 ] );
		// calculate vector form factor
		vec3 vectorFormFactor = vec3( 0.0 );
		vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
		vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
		vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
		vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
		// adjust for horizon clipping
		float result = LTC_ClippedSphereFormFactor( vectorFormFactor );

		return result;
}

Coords dLTCCoords;
Coords getLTCLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){
		Coords coords;
		coords.coord0 = lightPos + halfWidth - halfHeight;
		coords.coord1 = lightPos - halfWidth - halfHeight;
		coords.coord2 = lightPos - halfWidth + halfHeight;
		coords.coord3 = lightPos + halfWidth + halfHeight;
		return coords;
}

float dSphereRadius;
Coords getSphereLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){
		// used for simple sphere light falloff
		// also, the code only handles a spherical light, it cannot be non-uniformly scaled in world space, and so we enforce it here
		dSphereRadius = max(length(halfWidth), length(halfHeight));

		// Billboard the 2d light quad to reflection vector, as it's used for specular. This allows us to use disk math for the sphere.
		vec3 f = reflect(normalize(lightPos - view_position), vNormalW);
		vec3 w = normalize(cross(f, halfHeight));
		vec3 h = normalize(cross(f, w));

		return getLTCLightCoords(lightPos, w * dSphereRadius, h * dSphereRadius);
}

// used for LTC LUT texture lookup
vec2 dLTCUV;
#ifdef LIT_CLEARCOAT
vec2 ccLTCUV;
#endif
vec2 getLTCLightUV(float gloss, vec3 worldNormal, vec3 viewDir)
{
		float roughness = max((1.0 - gloss) * (1.0 - gloss), 0.001);
		return LTC_Uv( worldNormal, viewDir, roughness );
}

//used for energy conservation and to modulate specular
vec3 dLTCSpecFres;
#ifdef LIT_CLEARCOAT
vec3 ccLTCSpecFres;
#endif
vec3 getLTCLightSpecFres(vec2 uv, vec3 specularity)
{
		vec4 t2 = texture2DLodEXT(areaLightsLutTex2, uv, 0.0);

		#ifdef AREA_R8_G8_B8_A8_LUTS
		t2 *= vec4(0.693103,1,1,1);
		t2 += vec4(0.306897,0,0,0);
		#endif

		return specularity * t2.x + ( vec3( 1.0 ) - specularity) * t2.y;
}

void calcLTCLightValues(float gloss, vec3 worldNormal, vec3 viewDir, vec3 specularity, float clearcoatGloss, vec3 clearcoatWorldNormal, float clearcoatSpecularity)
{
		dLTCUV = getLTCLightUV(gloss, worldNormal, viewDir);
		dLTCSpecFres = getLTCLightSpecFres(dLTCUV, specularity); 

#ifdef LIT_CLEARCOAT
		ccLTCUV = getLTCLightUV(clearcoatGloss, clearcoatWorldNormal, viewDir);
		ccLTCSpecFres = getLTCLightSpecFres(ccLTCUV, vec3(clearcoatSpecularity));
#endif
}

void calcRectLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)
{
		dLTCCoords = getLTCLightCoords(lightPos, halfWidth, halfHeight);
}
void calcDiskLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)
{
		calcRectLightValues(lightPos, halfWidth, halfHeight);
}
void calcSphereLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)
{
		dLTCCoords = getSphereLightCoords(lightPos, halfWidth, halfHeight);
}

// An extended version of the implementation from
// "How to solve a cubic equation, revisited"
// http://momentsingraphics.de/?p=105
vec3 SolveCubic(vec4 Coefficient)
{
		float pi = 3.14159;
		// Normalize the polynomial
		Coefficient.xyz /= Coefficient.w;
		// Divide middle coefficients by three
		Coefficient.yz /= 3.0;

		float A = Coefficient.w;
		float B = Coefficient.z;
		float C = Coefficient.y;
		float D = Coefficient.x;

		// Compute the Hessian and the discriminant
		vec3 Delta = vec3(
				-Coefficient.z * Coefficient.z + Coefficient.y,
				-Coefficient.y * Coefficient.z + Coefficient.x,
				dot(vec2(Coefficient.z, -Coefficient.y), Coefficient.xy)
		);

		float Discriminant = dot(vec2(4.0 * Delta.x, -Delta.y), Delta.zy);

		vec3 RootsA, RootsD;

		vec2 xlc, xsc;

		// Algorithm A
		{
				float A_a = 1.0;
				float C_a = Delta.x;
				float D_a = -2.0 * B * Delta.x + Delta.y;

				// Take the cubic root of a normalized complex number
				float Theta = atan(sqrt(Discriminant), -D_a) / 3.0;

				float x_1a = 2.0 * sqrt(-C_a) * cos(Theta);
				float x_3a = 2.0 * sqrt(-C_a) * cos(Theta + (2.0 / 3.0) * pi);

				float xl;
				if ((x_1a + x_3a) > 2.0 * B)
						xl = x_1a;
				else
						xl = x_3a;

				xlc = vec2(xl - B, A);
		}

		// Algorithm D
		{
				float A_d = D;
				float C_d = Delta.z;
				float D_d = -D * Delta.y + 2.0 * C * Delta.z;

				// Take the cubic root of a normalized complex number
				float Theta = atan(D * sqrt(Discriminant), -D_d) / 3.0;

				float x_1d = 2.0 * sqrt(-C_d) * cos(Theta);
				float x_3d = 2.0 * sqrt(-C_d) * cos(Theta + (2.0 / 3.0) * pi);

				float xs;
				if (x_1d + x_3d < 2.0 * C)
						xs = x_1d;
				else
						xs = x_3d;

				xsc = vec2(-D, xs + C);
		}

		float E =  xlc.y * xsc.y;
		float F = -xlc.x * xsc.y - xlc.y * xsc.x;
		float G =  xlc.x * xsc.x;

		vec2 xmc = vec2(C * F - B * G, -B * F + C * E);

		vec3 Root = vec3(xsc.x / xsc.y, xmc.x / xmc.y, xlc.x / xlc.y);

		if (Root.x < Root.y && Root.x < Root.z)
				Root.xyz = Root.yxz;
		else if (Root.z < Root.x && Root.z < Root.y)
				Root.xyz = Root.xzy;

		return Root;
}

float LTC_EvaluateDisk(vec3 N, vec3 V, vec3 P, mat3 Minv, Coords points)
{
		// construct orthonormal basis around N
		vec3 T1, T2;
		T1 = normalize(V - N * dot(V, N));
		T2 = cross(N, T1);

		// rotate area light in (T1, T2, N) basis
		//mat3 R = transpose(mat3(T1, T2, N));
		mat3 R = transposeMat3( mat3( T1, T2, N ) );
		// polygon (allocate 5 vertices for clipping)
		vec3 L_[ 3 ];
		L_[ 0 ] = R * ( points.coord0 - P );
		L_[ 1 ] = R * ( points.coord1 - P );
		L_[ 2 ] = R * ( points.coord2 - P );

		vec3 Lo_i = vec3(0);

		// init ellipse
		vec3 C  = 0.5 * (L_[0] + L_[2]);
		vec3 V1 = 0.5 * (L_[1] - L_[2]);
		vec3 V2 = 0.5 * (L_[1] - L_[0]);

		C  = Minv * C;
		V1 = Minv * V1;
		V2 = Minv * V2;

		//if(dot(cross(V1, V2), C) > 0.0)
		//    return 0.0;

		// compute eigenvectors of ellipse
		float a, b;
		float d11 = dot(V1, V1);
		float d22 = dot(V2, V2);
		float d12 = dot(V1, V2);
		if (abs(d12) / sqrt(d11 * d22) > 0.0001)
		{
				float tr = d11 + d22;
				float det = -d12 * d12 + d11 * d22;

				// use sqrt matrix to solve for eigenvalues
				det = sqrt(det);
				float u = 0.5 * sqrt(tr - 2.0 * det);
				float v = 0.5 * sqrt(tr + 2.0 * det);
				float e_max = (u + v) * (u + v);
				float e_min = (u - v) * (u - v);

				vec3 V1_, V2_;

				if (d11 > d22)
				{
						V1_ = d12 * V1 + (e_max - d11) * V2;
						V2_ = d12 * V1 + (e_min - d11) * V2;
				}
				else
				{
						V1_ = d12*V2 + (e_max - d22)*V1;
						V2_ = d12*V2 + (e_min - d22)*V1;
				}

				a = 1.0 / e_max;
				b = 1.0 / e_min;
				V1 = normalize(V1_);
				V2 = normalize(V2_);
		}
		else
		{
				a = 1.0 / dot(V1, V1);
				b = 1.0 / dot(V2, V2);
				V1 *= sqrt(a);
				V2 *= sqrt(b);
		}

		vec3 V3 = cross(V1, V2);
		if (dot(C, V3) < 0.0)
				V3 *= -1.0;

		float L  = dot(V3, C);
		float x0 = dot(V1, C) / L;
		float y0 = dot(V2, C) / L;

		float E1 = inversesqrt(a);
		float E2 = inversesqrt(b);

		a *= L * L;
		b *= L * L;

		float c0 = a * b;
		float c1 = a * b * (1.0 + x0 * x0 + y0 * y0) - a - b;
		float c2 = 1.0 - a * (1.0 + x0 * x0) - b * (1.0 + y0 * y0);
		float c3 = 1.0;

		vec3 roots = SolveCubic(vec4(c0, c1, c2, c3));
		float e1 = roots.x;
		float e2 = roots.y;
		float e3 = roots.z;

		vec3 avgDir = vec3(a * x0 / (a - e2), b * y0 / (b - e2), 1.0);

		mat3 rotate = mat3(V1, V2, V3);

		avgDir = rotate * avgDir;
		avgDir = normalize(avgDir);

		float L1 = sqrt(-e2 / e3);
		float L2 = sqrt(-e2 / e1);

		float formFactor = L1 * L2 * inversesqrt((1.0 + L1 * L1) * (1.0 + L2 * L2));
		
		const float LUT_SIZE = 64.0;
		const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
		const float LUT_BIAS = 0.5 / LUT_SIZE;

		// use tabulated horizon-clipped sphere
		vec2 uv = vec2(avgDir.z * 0.5 + 0.5, formFactor);
		uv = uv*LUT_SCALE + LUT_BIAS;

		float scale = texture2DLodEXT(areaLightsLutTex2, uv, 0.0).w;

		return formFactor*scale;
}

float getRectLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {
		return LTC_EvaluateRect( worldNormal, viewDir, vPositionW, mat3( 1.0 ), dLTCCoords );
}

float getDiskLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {
		return LTC_EvaluateDisk( worldNormal, viewDir, vPositionW, mat3( 1.0 ), dLTCCoords );
}

float getSphereLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {
		// NB: this could be improved further with distance based wrap lighting
		float falloff = dSphereRadius / (dot(lightDir, lightDir) + dSphereRadius);
		return getLightDiffuse(worldNormal, viewDir, lightDir, lightDirNorm) * falloff;
}

mat3 getLTCLightInvMat(vec2 uv)
{
		vec4 t1 = texture2DLodEXT(areaLightsLutTex1, uv, 0.0);

		#ifdef AREA_R8_G8_B8_A8_LUTS
		t1 *= vec4(1.001, 0.3239, 0.60437568, 1.0);
		t1 += vec4(0.0, -0.2976, -0.01381, 0.0);
		#endif

		return mat3(
				vec3( t1.x, 0, t1.y ),
				vec3(    0, 1,    0 ),
				vec3( t1.z, 0, t1.w )
		);
}

float calcRectLightSpecular(vec3 worldNormal, vec3 viewDir, vec2 uv) {
		mat3 mInv = getLTCLightInvMat(uv);
		return LTC_EvaluateRect( worldNormal, viewDir, vPositionW, mInv, dLTCCoords );
}

float getRectLightSpecular(vec3 worldNormal, vec3 viewDir) {
		return calcRectLightSpecular(worldNormal, viewDir, dLTCUV);
}

float calcDiskLightSpecular(vec3 worldNormal, vec3 viewDir, vec2 uv) {
		mat3 mInv = getLTCLightInvMat(uv);
		return LTC_EvaluateDisk( worldNormal, viewDir, vPositionW, mInv, dLTCCoords );
}

float getDiskLightSpecular(vec3 worldNormal, vec3 viewDir) {
		return calcDiskLightSpecular(worldNormal, viewDir, dLTCUV);
}

float getSphereLightSpecular(vec3 worldNormal, vec3 viewDir) {
		return calcDiskLightSpecular(worldNormal, viewDir, dLTCUV);
}
`,
              ut = `
#ifdef MAPFLOAT
uniform float material_metalness;
#endif

void getMetalness() {
		float metalness = 1.0;

		#ifdef MAPFLOAT
		metalness *= material_metalness;
		#endif

		#ifdef MAPTEXTURE
		metalness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
		#endif

		#ifdef MAPVERTEX
		metalness *= saturate(vVertexColor.$VC);
		#endif

		dMetalness = metalness;
}
`,
              At = `
uniform sampler2D texture_msdfMap;

#ifdef GL_OES_standard_derivatives
#define USE_FWIDTH
#endif

#ifdef GL2
#define USE_FWIDTH
#endif

float median(float r, float g, float b) {
		return max(min(r, g), min(max(r, g), b));
}

float map (float min, float max, float v) {
		return (v - min) / (max - min);
}

uniform float font_sdfIntensity; // intensity is used to boost the value read from the SDF, 0 is no boost, 1.0 is max boost
uniform float font_pxrange;      // the number of pixels between inside and outside the font in SDF
uniform float font_textureWidth; // the width of the texture atlas

#ifdef UNIFORM_TEXT_PARAMETERS
uniform vec4 outline_color;
uniform float outline_thickness;
uniform vec4 shadow_color;
uniform vec2 shadow_offset;
#else
varying vec4 outline_color;
varying float outline_thickness;
varying vec4 shadow_color;
varying vec2 shadow_offset;
#endif

vec4 applyMsdf(vec4 color) {
		// sample the field
		vec3 tsample = texture2D(texture_msdfMap, vUv0).rgb;
		vec2 uvShdw = vUv0 - shadow_offset;
		vec3 ssample = texture2D(texture_msdfMap, uvShdw).rgb;
		// get the signed distance value
		float sigDist = median(tsample.r, tsample.g, tsample.b);
		float sigDistShdw = median(ssample.r, ssample.g, ssample.b);

		// smoothing limit - smaller value makes for sharper but more aliased text, especially on angles
		// too large value (0.5) creates a dark glow around the letters
		float smoothingMax = 0.2;

		#ifdef USE_FWIDTH
		// smoothing depends on size of texture on screen
		vec2 w = fwidth(vUv0);
		float smoothing = clamp(w.x * font_textureWidth / font_pxrange, 0.0, smoothingMax);
		#else
		float font_size = 16.0; // TODO fix this
		// smoothing gets smaller as the font size gets bigger
		// don't have fwidth we can approximate from font size, this doesn't account for scaling
		// so a big font scaled down will be wrong...
		float smoothing = clamp(font_pxrange / font_size, 0.0, smoothingMax);
		#endif

		float mapMin = 0.05;
		float mapMax = clamp(1.0 - font_sdfIntensity, mapMin, 1.0);

		// remap to a smaller range (used on smaller font sizes)
		float sigDistInner = map(mapMin, mapMax, sigDist);
		float sigDistOutline = map(mapMin, mapMax, sigDist + outline_thickness);
		sigDistShdw = map(mapMin, mapMax, sigDistShdw + outline_thickness);

		float center = 0.5;
		// calculate smoothing and use to generate opacity
		float inside = smoothstep(center-smoothing, center+smoothing, sigDistInner);
		float outline = smoothstep(center-smoothing, center+smoothing, sigDistOutline);
		float shadow = smoothstep(center-smoothing, center+smoothing, sigDistShdw);

		vec4 tcolor = (outline > inside) ? outline * vec4(outline_color.a * outline_color.rgb, outline_color.a) : vec4(0.0);
		tcolor = mix(tcolor, color, inside);

		vec4 scolor = (shadow > outline) ? shadow * vec4(shadow_color.a * shadow_color.rgb, shadow_color.a) : tcolor;
		tcolor = mix(scolor, tcolor, outline);
		
		return tcolor;
}
`,
              xt = `

vec3 getSpecularModulate(in vec3 specularity, in vec3 albedo, in float metalness, in float f0) {
		vec3 dielectricF0 = f0 * specularity;
		return mix(dielectricF0, albedo, metalness);
}

vec3 getAlbedoModulate(in vec3 albedo, in float metalness) {
		return albedo * (1.0 - metalness);
}
`,
              jt = `
attribute vec3 vertex_outlineParameters;
attribute vec3 vertex_shadowParameters;

varying vec4 outline_color;
varying float outline_thickness;
varying vec4 shadow_color;
varying vec2 shadow_offset;

void unpackMsdfParams() {
		vec3 little = mod(vertex_outlineParameters, 256.);
		vec3 big = (vertex_outlineParameters - little) / 256.;

		outline_color.rb = little.xy / 255.;
		outline_color.ga = big.xy / 255.;

		// _outlineThicknessScale === 0.2
		outline_thickness = little.z / 255. * 0.2;

		little = mod(vertex_shadowParameters, 256.);
		big = (vertex_shadowParameters - little) / 256.;

		shadow_color.rb = little.xy / 255.;
		shadow_color.ga = big.xy / 255.;

		// vec2(little.z, big.z) / 127. - 1. remaps shadow offset from [0, 254] to [-1, 1]
		// _shadowOffsetScale === 0.005
		shadow_offset = (vec2(little.z, big.z) / 127. - 1.) * 0.005;
}
`,
              Gt = `
#ifdef MORPHING_TEXTURE_BASED_NORMAL
uniform highp sampler2D morphNormalTex;
#endif

vec3 getNormal() {
		#ifdef SKIN
		dNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);
		#elif defined(INSTANCING)
		dNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);
		#else
		dNormalMatrix = matrix_normal;
		#endif

		vec3 tempNormal = vertex_normal;

		#ifdef MORPHING
		#ifdef MORPHING_NRM03
		tempNormal += morph_weights_a[0] * morph_nrm0;
		tempNormal += morph_weights_a[1] * morph_nrm1;
		tempNormal += morph_weights_a[2] * morph_nrm2;
		tempNormal += morph_weights_a[3] * morph_nrm3;
		#endif
		#ifdef MORPHING_NRM47
		tempNormal += morph_weights_b[0] * morph_nrm4;
		tempNormal += morph_weights_b[1] * morph_nrm5;
		tempNormal += morph_weights_b[2] * morph_nrm6;
		tempNormal += morph_weights_b[3] * morph_nrm7;
		#endif
		#endif

		#ifdef MORPHING_TEXTURE_BASED_NORMAL

				#ifdef WEBGPU
						ivec2 morphUV = getTextureMorphCoords();
						vec3 morphNormal = texelFetch(morphNormalTex, ivec2(morphUV), 0).xyz;
				#else
						vec2 morphUV = getTextureMorphCoords();
						vec3 morphNormal = texture2D(morphNormalTex, morphUV).xyz;
				#endif

		// apply morph offset from texture
		tempNormal += morphNormal;
		#endif

		return normalize(dNormalMatrix * tempNormal);
}
`,
              yt = `
#ifdef MAPTEXTURE
uniform float material_normalDetailMapBumpiness;

vec3 blendNormals(vec3 n1, vec3 n2) {
		// https://blog.selfshadow.com/publications/blending-in-detail/#detail-oriented
		n1 += vec3(0, 0, 1);
		n2 *= vec3(-1, -1, 1);
		return n1 * dot(n1, n2) / n1.z - n2;
}
#endif

vec3 addNormalDetail(vec3 normalMap) {
#ifdef MAPTEXTURE
		vec3 normalDetailMap = unpackNormal(texture2DBias($SAMPLER, $UV, textureBias));
		normalDetailMap = mix(vec3(0.0, 0.0, 1.0), normalDetailMap, material_normalDetailMapBumpiness);
		return blendNormals(normalMap, normalDetailMap);
#else
		return normalMap;
#endif
}
`,
              Ae = `
vec3 getNormal() {
		dNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);
		return normalize(dNormalMatrix * vertex_normal);
}
`,
              Xe = `
#ifdef MAPTEXTURE
uniform float material_bumpiness;
#endif

void getNormal() {
#ifdef MAPTEXTURE
		vec3 normalMap = unpackNormal(texture2DBias($SAMPLER, $UV, textureBias));
		normalMap = mix(vec3(0.0, 0.0, 1.0), normalMap, material_bumpiness);
		dNormalW = normalize(dTBN * addNormalDetail(normalMap));
#else
		dNormalW = dVertexNormalW;
#endif
}
`,
              Ye = `
vec3 getNormal() {
		dNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);
		return normalize(dNormalMatrix * vertex_normal);
}
`,
              it = `
vec3 unpackNormal(vec4 nmap) {
		vec3 normal;
		normal.xy = nmap.wy * 2.0 - 1.0;
		normal.z = sqrt(1.0 - saturate(dot(normal.xy, normal.xy)));
		return normal;
}
`,
              st = `
vec3 unpackNormal(vec4 nmap) {
		return nmap.xyz * 2.0 - 1.0;
}
`,
              He = `
#ifdef MAPFLOAT
uniform float material_opacity;
#endif

void getOpacity() {
		dAlpha = 1.0;

		#ifdef MAPFLOAT
		dAlpha *= material_opacity;
		#endif

		#ifdef MAPTEXTURE
		dAlpha *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
		#endif

		#ifdef MAPVERTEX
		dAlpha *= clamp(vVertexColor.$VC, 0.0, 1.0);
		#endif
}
`,
              at = `
`,
              Pt = `
gl_FragColor.a = litArgs_opacity;
`,
              he = `
		gl_FragColor.a = 1.0;
`,
              fe = `
gl_FragColor.rgb *= litArgs_opacity;
gl_FragColor.a = litArgs_opacity;
`,
              Ie = `
varying vec2 vUv0;

uniform sampler2D source;

void main(void) {
		gl_FragColor = texture2D(source, vUv0);
}
`,
              ue = `
// Packing a float in GLSL with multiplication and mod
// http://blog.gradientstudios.com/2012/08/23/shadow-map-improvement
vec4 packFloat(float depth) {
		const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
		const vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);

		// combination of mod and multiplication and division works better
		vec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);
		res -= res.xxyz * bit_mask;
		return res;
}
`,
              De = `

#ifdef MAPCOLOR
uniform vec3 material_sheen;
#endif

void getSheen() {
		vec3 sheenColor = vec3(1, 1, 1);

		#ifdef MAPCOLOR
		sheenColor *= material_sheen;
		#endif

		#ifdef MAPTEXTURE
		sheenColor *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
		#endif

		#ifdef MAPVERTEX
		sheenColor *= saturate(vVertexColor.$VC);
		#endif

		sSpecularity = sheenColor;
}
`,
              et = `
#ifdef MAPFLOAT
uniform float material_sheenGloss;
#endif

void getSheenGlossiness() {
		float sheenGlossiness = 1.0;

		#ifdef MAPFLOAT
		sheenGlossiness *= material_sheenGloss;
		#endif

		#ifdef MAPTEXTURE
		sheenGlossiness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
		#endif

		#ifdef MAPVERTEX
		sheenGlossiness *= saturate(vVertexColor.$VC);
		#endif

		#ifdef MAPINVERT
		sheenGlossiness = 1.0 - sheenGlossiness;
		#endif

		sheenGlossiness += 0.0000001;
		sGlossiness = sheenGlossiness;
}
`,
              Ze = `
uniform float material_heightMapFactor;

void getParallax() {
		float parallaxScale = material_heightMapFactor;

		float height = texture2DBias($SAMPLER, $UV, textureBias).$CH;
		height = height * parallaxScale - parallaxScale*0.5;
		vec3 viewDirT = dViewDirW * dTBN;

		viewDirT.z += 0.42;
		dUvOffset = height * (viewDirT.xy / viewDirT.z);
}
`,
              Ve = `
varying vec4 texCoordsAlphaLife;

uniform sampler2D colorMap;
uniform sampler2D colorParam;
uniform float graphSampleSize;
uniform float graphNumSamples;

#ifndef CAMERAPLANES
#define CAMERAPLANES
uniform vec4 camera_params;
#endif

uniform float softening;
uniform float colorMult;

float saturate(float x) {
		return clamp(x, 0.0, 1.0);
}

#ifndef UNPACKFLOAT
#define UNPACKFLOAT
float unpackFloat(vec4 rgbaDepth) {
		const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);
		float depth = dot(rgbaDepth, bitShift);
		return depth;
}
#endif

void main(void) {
		vec4 tex  = gammaCorrectInput(texture2D(colorMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y)));
		vec4 ramp = gammaCorrectInput(texture2D(colorParam, vec2(texCoordsAlphaLife.w, 0.0)));
		ramp.rgb *= colorMult;

		ramp.a += texCoordsAlphaLife.z;

		vec3 rgb = tex.rgb * ramp.rgb;
		float a  = tex.a * ramp.a;
`,
              tt = `
vec3 unpack3NFloats(float src) {
		float r = fract(src);
		float g = fract(src * 256.0);
		float b = fract(src * 65536.0);
		return vec3(r, g, b);
}

float saturate(float x) {
		return clamp(x, 0.0, 1.0);
}

vec4 tex1Dlod_lerp(highp sampler2D tex, vec2 tc) {
		return mix( texture2D(tex,tc), texture2D(tex,tc + graphSampleSize), fract(tc.x*graphNumSamples) );
}

vec4 tex1Dlod_lerp(highp sampler2D tex, vec2 tc, out vec3 w) {
		vec4 a = texture2D(tex,tc);
		vec4 b = texture2D(tex,tc + graphSampleSize);
		float c = fract(tc.x*graphNumSamples);

		vec3 unpackedA = unpack3NFloats(a.w);
		vec3 unpackedB = unpack3NFloats(b.w);
		w = mix(unpackedA, unpackedB, c);

		return mix(a, b, c);
}

vec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix) {
		float c = cos(pRotation);
		float s = sin(pRotation);

		mat2 m = mat2(c, -s, s, c);
		rotMatrix = m;

		return m * quadXY;
}

vec3 billboard(vec3 InstanceCoords, vec2 quadXY) {
		#ifdef SCREEN_SPACE
				vec3 pos = vec3(-1, 0, 0) * quadXY.x + vec3(0, -1, 0) * quadXY.y;
		#else
				vec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;
		#endif

		return pos;
}

vec3 customFace(vec3 InstanceCoords, vec2 quadXY) {
		vec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;
		return pos;
}

vec2 safeNormalize(vec2 v) {
		float l = length(v);
		return (l > 1e-06) ? v / l : v;
}

void main(void) {
		vec3 meshLocalPos = particle_vertexData.xyz;
		float id = floor(particle_vertexData.w);

		float rndFactor = fract(sin(id + 1.0 + seed));
		vec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));

		float uv = id / numParticlesPot;
		readInput(uv);

#ifdef LOCAL_SPACE
		inVel = mat3(matrix_model) * inVel;
#endif
		vec2 velocityV = safeNormalize((mat3(matrix_view) * inVel).xy); // should be removed by compiler if align/stretch is not used

		float particleLifetime = lifetime;

		if (inLife <= 0.0 || inLife > particleLifetime || !inShow) meshLocalPos = vec3(0.0);
		vec2 quadXY = meshLocalPos.xy;
		float nlife = clamp(inLife / particleLifetime, 0.0, 1.0);

		vec3 paramDiv;
		vec4 params = tex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);
		float scale = params.y;
		float scaleDiv = paramDiv.x;
		float alphaDiv = paramDiv.z;

		scale += (scaleDiv * 2.0 - 1.0) * scaleDivMult * fract(rndFactor*10000.0);

#ifndef USE_MESH
		texCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);
#else
		texCoordsAlphaLife = vec4(particle_uv, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);
#endif

		vec3 particlePos = inPos;
		vec3 particlePosMoved = vec3(0.0);

		mat2 rotMatrix;
`,
              Be = `
		float animFrame = min(floor(texCoordsAlphaLife.w * animTexParams.y) + animTexParams.x, animTexParams.z);
`,
              ot = `
		float animFrame = floor(mod(texCoordsAlphaLife.w * animTexParams.y + animTexParams.x, animTexParams.z + 1.0));
`,
              Qe = `
		float animationIndex;

		if (animTexIndexParams.y == 1.0) {
				animationIndex = floor((animTexParams.w + 1.0) * rndFactor3.z) * (animTexParams.z + 1.0);
		} else {
				animationIndex = animTexIndexParams.x * (animTexParams.z + 1.0);
		}

		float atlasX = (animationIndex + animFrame) * animTexTilesParams.x;
		float atlasY = 1.0 - floor(atlasX + 1.0) * animTexTilesParams.y;
		atlasX = fract(atlasX);

		texCoordsAlphaLife.xy *= animTexTilesParams.xy;
		texCoordsAlphaLife.xy += vec2(atlasX, atlasY);
`,
              mt = `
void readInput(float uv) {
		vec4 tex = texture2D(particleTexIN, vec2(uv, 0.25));
		vec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.75));

		inPos = tex.xyz;
		inVel = tex2.xyz;
		inAngle = (tex.w < 0.0? -tex.w : tex.w) - 1000.0;
		inShow = tex.w >= 0.0;
		inLife = tex2.w;
}
`,
              je = `
//RG=X, BA=Y
//RG=Z, BA=A
//RGB=V, A=visMode
//RGBA=life

#define PI2 6.283185307179586

uniform vec3 inBoundsSize;
uniform vec3 inBoundsCenter;

uniform float maxVel;

float decodeFloatRG(vec2 rg) {
		return rg.y*(1.0/255.0) + rg.x;
}

float decodeFloatRGBA( vec4 rgba ) {
	return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );
}

void readInput(float uv) {
		vec4 tex0 = texture2D(particleTexIN, vec2(uv, 0.125));
		vec4 tex1 = texture2D(particleTexIN, vec2(uv, 0.375));
		vec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.625));
		vec4 tex3 = texture2D(particleTexIN, vec2(uv, 0.875));

		inPos = vec3(decodeFloatRG(tex0.rg), decodeFloatRG(tex0.ba), decodeFloatRG(tex1.rg));
		inPos = (inPos - vec3(0.5)) * inBoundsSize + inBoundsCenter;

		inVel = tex2.xyz;
		inVel = (inVel - vec3(0.5)) * maxVel;

		inAngle = decodeFloatRG(tex1.ba) * PI2;
		inShow = tex2.a > 0.5;

		inLife = decodeFloatRGBA(tex3);
		float maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));
		float maxPosLife = lifetime+1.0;
		inLife = inLife * (maxNegLife + maxPosLife) - maxNegLife;
}
`,
              lt = `
void writeOutput() {
		if (gl_FragCoord.y<1.0) {
				gl_FragColor = vec4(outPos, (outAngle + 1000.0) * visMode);
		} else {
				gl_FragColor = vec4(outVel, outLife);
		}
}
`,
              Et = `
uniform vec3 outBoundsMul;
uniform vec3 outBoundsAdd;

vec2 encodeFloatRG( float v ) {
		vec2 enc = vec2(1.0, 255.0) * v;
		enc = fract(enc);
		enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);
		return enc;
}

vec4 encodeFloatRGBA( float v ) {
		vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;
		enc = fract(enc);
		enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);
		return enc;
}

void writeOutput() {
		outPos = outPos * outBoundsMul + outBoundsAdd;
		outAngle = fract(outAngle / PI2);

		outVel = (outVel / maxVel) + vec3(0.5); // TODO: mul

		float maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));
		float maxPosLife = lifetime+1.0;
		outLife = (outLife + maxNegLife) / (maxNegLife + maxPosLife);

		if (gl_FragCoord.y < 1.0) {
				gl_FragColor = vec4(encodeFloatRG(outPos.x), encodeFloatRG(outPos.y));
		} else if (gl_FragCoord.y < 2.0) {
				gl_FragColor = vec4(encodeFloatRG(outPos.z), encodeFloatRG(outAngle));
		} else if (gl_FragCoord.y < 3.0) {
				gl_FragColor = vec4(outVel, visMode*0.5+0.5);
		} else {
				gl_FragColor = encodeFloatRGBA(outLife);
		}
}
`,
              ct = `
uniform mat3 spawnBounds;
uniform vec3 spawnPosInnerRatio;

vec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {
		vec3 pos = inBounds - vec3(0.5);

		vec3 posAbs = abs(pos);
		vec3 maxPos = vec3(max(posAbs.x, max(posAbs.y, posAbs.z)));

		vec3 edge = maxPos + (vec3(0.5) - maxPos) * spawnPosInnerRatio;

		pos.x = edge.x * (maxPos.x == posAbs.x ? sign(pos.x) : 2.0 * pos.x);
		pos.y = edge.y * (maxPos.y == posAbs.y ? sign(pos.y) : 2.0 * pos.y);
		pos.z = edge.z * (maxPos.z == posAbs.z ? sign(pos.z) : 2.0 * pos.z);

#ifndef LOCAL_SPACE
		return emitterPos + spawnBounds * pos;
#else
		return spawnBounds * pos;
#endif
}

void addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {
		localVelocity -= vec3(0, 0, initialVelocity);
}
`,
              pt = `
		writeOutput();
}
`,
              vt = `
varying vec2 vUv0;

uniform highp sampler2D particleTexIN;
uniform highp sampler2D internalTex0;
uniform highp sampler2D internalTex1;
uniform highp sampler2D internalTex2;
uniform highp sampler2D internalTex3;

uniform mat3 emitterMatrix, emitterMatrixInv;
uniform vec3 emitterScale;

uniform vec3 emitterPos, frameRandom, localVelocityDivMult, velocityDivMult;
uniform float delta, rate, rateDiv, lifetime, numParticles, rotSpeedDivMult, radialSpeedDivMult, seed;
uniform float startAngle, startAngle2;
uniform float initialVelocity;

uniform float graphSampleSize;
uniform float graphNumSamples;

vec3 inPos;
vec3 inVel;
float inAngle;
bool inShow;
float inLife;
float visMode;

vec3 outPos;
vec3 outVel;
float outAngle;
bool outShow;
float outLife;
`,
              Fe = `
		if (outLife >= lifetime) {
				outLife -= max(lifetime, (numParticles - 1.0) * particleRate);
				visMode = -1.0;
		}
`,
              Yt = `
		visMode = outLife < 0.0? -1.0: visMode;
`,
              Ot = `
		if (outLife >= lifetime) {
				outLife -= max(lifetime, (numParticles - 1.0) * particleRate);
				visMode = 1.0;
		}
		visMode = outLife < 0.0? 1.0: visMode;
`,
              Rt = `
uniform float spawnBoundsSphere;
uniform float spawnBoundsSphereInnerRatio;

vec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {
		float rnd4 = fract(rndFactor * 1000.0);
		vec3 norm = normalize(inBounds.xyz - vec3(0.5));
		float r = rnd4 * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;
#ifndef LOCAL_SPACE
		return emitterPos + norm * r * spawnBoundsSphere;
#else
		return norm * r * spawnBoundsSphere;
#endif
}

void addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {
		localVelocity += normalize(inBounds - vec3(0.5)) * initialVelocity;
}
`,
              Kt = `
float saturate(float x) {
		return clamp(x, 0.0, 1.0);
}

vec3 unpack3NFloats(float src) {
		float r = fract(src);
		float g = fract(src * 256.0);
		float b = fract(src * 65536.0);
		return vec3(r, g, b);
}

vec3 tex1Dlod_lerp(highp sampler2D tex, vec2 tc, out vec3 w) {
		vec4 a = texture2D(tex, tc);
		vec4 b = texture2D(tex, tc + graphSampleSize);
		float c = fract(tc.x * graphNumSamples);

		vec3 unpackedA = unpack3NFloats(a.w);
		vec3 unpackedB = unpack3NFloats(b.w);
		w = mix(unpackedA, unpackedB, c);

		return mix(a.xyz, b.xyz, c);
}

#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)
vec4 hash41(float p) {
		vec4 p4 = fract(vec4(p) * HASHSCALE4);
		p4 += dot(p4, p4.wzxy+19.19);
		return fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));
}

void main(void) {
		if (gl_FragCoord.x > numParticles) discard;

		readInput(vUv0.x);
		visMode = inShow? 1.0 : -1.0;

		vec4 rndFactor = hash41(gl_FragCoord.x + seed);

		float particleRate = rate + rateDiv * rndFactor.x;

		outLife = inLife + delta;
		float nlife = clamp(outLife / lifetime, 0.0, 1.0);

		vec3 localVelocityDiv;
		vec3 velocityDiv;
		vec3 paramDiv;
		vec3 localVelocity = tex1Dlod_lerp(internalTex0, vec2(nlife, 0), localVelocityDiv);
		vec3 velocity =      tex1Dlod_lerp(internalTex1, vec2(nlife, 0), velocityDiv);
		vec3 params =        tex1Dlod_lerp(internalTex2, vec2(nlife, 0), paramDiv);
		float rotSpeed = params.x;
		float rotSpeedDiv = paramDiv.y;

		vec3 radialParams = tex1Dlod_lerp(internalTex3, vec2(nlife, 0), paramDiv);
		float radialSpeed = radialParams.x;
		float radialSpeedDiv = radialParams.y;

		bool respawn = inLife <= 0.0 || outLife >= lifetime;
		inPos = respawn ? calcSpawnPosition(rndFactor.xyz, rndFactor.x) : inPos;
		inAngle = respawn ? mix(startAngle, startAngle2, rndFactor.x) : inAngle;

#ifndef LOCAL_SPACE
		vec3 radialVel = inPos - emitterPos;
#else
		vec3 radialVel = inPos;
#endif
		radialVel = (dot(radialVel, radialVel) > 1.0E-8) ? radialSpeed * normalize(radialVel) : vec3(0.0);
		radialVel += (radialSpeedDiv * vec3(2.0) - vec3(1.0)) * radialSpeedDivMult * rndFactor.xyz;

		localVelocity +=    (localVelocityDiv * vec3(2.0) - vec3(1.0)) * localVelocityDivMult * rndFactor.xyz;
		velocity +=         (velocityDiv * vec3(2.0) - vec3(1.0)) * velocityDivMult * rndFactor.xyz;
		rotSpeed +=         (rotSpeedDiv * 2.0 - 1.0) * rotSpeedDivMult * rndFactor.y;

		addInitialVelocity(localVelocity, rndFactor.xyz);

#ifndef LOCAL_SPACE
		outVel = emitterMatrix * localVelocity + (radialVel + velocity) * emitterScale;
#else
		outVel = (localVelocity + radialVel) / emitterScale + emitterMatrixInv * velocity;
#endif

		outPos = inPos + outVel * delta;
		outAngle = inAngle + rotSpeed * delta;
`,
              Lt = `
		quadXY = rotate(quadXY, inAngle, rotMatrix);
		vec3 localPos = billboard(particlePos, quadXY);
`,
              Ft = `
		dBlendModeFogFactor = 0.0;
		rgb *= saturate(gammaCorrectInput(max(a, 0.0)));
		if ((rgb.r + rgb.g + rgb.b) < 0.000001) discard;
`,
              Jt = `
		rgb = mix(vec3(1.0), rgb, vec3(a));
		if (rgb.r + rgb.g + rgb.b > 2.99) discard;
`,
              zt = `
		if (a < 0.01) discard;
`,
              ss = `
attribute vec4 particle_vertexData;   // XYZ = world pos, W = life
attribute vec4 particle_vertexData2;  // X = angle, Y = scale, Z = alpha, W = velocity.x
attribute vec4 particle_vertexData3;  // XYZ = particle local pos, W = velocity.y
attribute float particle_vertexData4; // particle id

// type depends on useMesh property. Start with X = velocity.z, Y = particle ID and for mesh particles proceeds with Z = mesh UV.x, W = mesh UV.y
#ifndef USE_MESH
attribute vec2 particle_vertexData5;
#else
attribute vec4 particle_vertexData5;
#endif

uniform mat4 matrix_viewProjection;
uniform mat4 matrix_model;

#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif

uniform mat3 matrix_normal;
uniform mat4 matrix_viewInverse;

uniform float numParticles;
uniform float lifetime;
uniform float stretch;
uniform float seed;
uniform vec3 wrapBounds;
uniform vec3 emitterScale;
uniform vec3 faceTangent;
uniform vec3 faceBinorm;
uniform highp sampler2D internalTex0;
uniform highp sampler2D internalTex1;
uniform highp sampler2D internalTex2;
uniform vec3 emitterPos;

varying vec4 texCoordsAlphaLife;

vec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix)
{
		float c = cos(pRotation);
		float s = sin(pRotation);
		//vec4 rotationMatrix = vec4(c, -s, s, c);

		mat2 m = mat2(c, -s, s, c);
		rotMatrix = m;

		return m * quadXY;
}

vec3 billboard(vec3 InstanceCoords, vec2 quadXY)
{
		vec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;
		return pos;
}

vec3 customFace(vec3 InstanceCoords, vec2 quadXY)
{
		vec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;
		return pos;
}

void main(void)
{
		vec3 particlePos = particle_vertexData.xyz;
		vec3 inPos = particlePos;
		vec3 vertPos = particle_vertexData3.xyz;
		vec3 inVel = vec3(particle_vertexData2.w, particle_vertexData3.w, particle_vertexData5.x);

		float id = floor(particle_vertexData4);
		float rndFactor = fract(sin(id + 1.0 + seed));
		vec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));

#ifdef LOCAL_SPACE
		inVel = mat3(matrix_model) * inVel;
#endif
		vec2 velocityV = normalize((mat3(matrix_view) * inVel).xy); // should be removed by compiler if align/stretch is not used

		vec2 quadXY = vertPos.xy;

#ifdef USE_MESH
		texCoordsAlphaLife = vec4(particle_vertexData5.zw, particle_vertexData2.z, particle_vertexData.w);
#else
		texCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, particle_vertexData2.z, particle_vertexData.w);
#endif
		mat2 rotMatrix;

		float inAngle = particle_vertexData2.x;
		vec3 particlePosMoved = vec3(0.0);
		vec3 meshLocalPos = particle_vertexData3.xyz;
`,
              qt = `
		localPos *= particle_vertexData2.y * emitterScale;
		localPos += particlePos;

		gl_Position = matrix_viewProjection * vec4(localPos, 1.0);
`,
              fs = `
		quadXY = rotate(quadXY, inAngle, rotMatrix);
		vec3 localPos = customFace(particlePos, quadXY);
`,
              ls = `
		rgb = addFog(rgb);
		rgb = toneMap(rgb);
		rgb = gammaCorrectOutput(rgb);
		gl_FragColor = vec4(rgb, a);
}
`,
              Es = `
		localPos *= scale * emitterScale;
		localPos += particlePos;

		#ifdef SCREEN_SPACE
		gl_Position = vec4(localPos.x, localPos.y, 0.0, 1.0);
		#else
		gl_Position = matrix_viewProjection * vec4(localPos.xyz, 1.0);
		#endif
`,
              Ke = `
		vec3 negNormal = normal*0.5+0.5;
		vec3 posNormal = -normal*0.5+0.5;
		negNormal *= negNormal;
		posNormal *= posNormal;
`,
              hs = `
attribute vec4 particle_vertexData; // XYZ = particle position, W = particle ID + random factor
#ifdef USE_MESH
attribute vec2 particle_uv;         // mesh UV
#endif

uniform mat4 matrix_viewProjection;
uniform mat4 matrix_model;
uniform mat3 matrix_normal;
uniform mat4 matrix_viewInverse;

#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif

uniform float numParticles, numParticlesPot;
uniform float graphSampleSize;
uniform float graphNumSamples;
uniform float stretch;
uniform vec3 wrapBounds;
uniform vec3 emitterScale, emitterPos, faceTangent, faceBinorm;
uniform float rate, rateDiv, lifetime, deltaRandomnessStatic, scaleDivMult, alphaDivMult, seed, delta;
uniform sampler2D particleTexOUT, particleTexIN;
uniform highp sampler2D internalTex0;
uniform highp sampler2D internalTex1;
uniform highp sampler2D internalTex2;

#ifndef CAMERAPLANES
#define CAMERAPLANES
uniform vec4 camera_params;
#endif

varying vec4 texCoordsAlphaLife;

vec3 inPos;
vec3 inVel;
float inAngle;
bool inShow;
float inLife;
`,
              is = `
		vec3 negNormal = max(normal, vec3(0.0));
		vec3 posNormal = max(-normal, vec3(0.0));
`,
              ys = `
		vec3 light = negNormal.x*lightCube[0] + posNormal.x*lightCube[1] +
												negNormal.y*lightCube[2] + posNormal.y*lightCube[3] +
												negNormal.z*lightCube[4] + posNormal.z*lightCube[5];

		rgb *= light;
`,
              ps = `
		particlePos = (matrix_model * vec4(particlePos, 1.0)).xyz;
`,
              Ns = `
		vec3 localPos = meshLocalPos;
		localPos.xy = rotate(localPos.xy, inAngle, rotMatrix);
		localPos.yz = rotate(localPos.yz, inAngle, rotMatrix);

		billboard(particlePos, quadXY);
`,
              zs = `
		Normal = normalize(localPos + matrix_viewInverse[2].xyz);
`,
              bs = `
		vec3 normalMap = normalize(texture2D(normalMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y)).xyz * 2.0 - 1.0);
		vec3 normal = ParticleMat * normalMap;
`,
              Ws = `
		inAngle = atan(velocityV.x, velocityV.y); // not the fastest way, but easier to plug in; TODO: create rot matrix right from vectors

`,
              Ss = `
		float depth = getLinearScreenDepth();
		float particleDepth = vDepth;
		float depthDiff = saturate(abs(particleDepth - depth) * softening);
		a *= depthDiff;
`,
              ws = `
		vDepth = getLinearDepth(localPos);
`,
              ks = `
		vec3 moveDir = inVel * stretch;
		vec3 posPrev = particlePos - moveDir;
		posPrev += particlePosMoved;

		vec2 centerToVertexV = normalize((mat3(matrix_view) * localPos).xy);

		float interpolation = dot(-velocityV, centerToVertexV) * 0.5 + 0.5;

		particlePos = mix(particlePos, posPrev, interpolation);
`,
              Ys = `
		mat3 rot3 = mat3(rotMatrix[0][0], rotMatrix[0][1], 0.0, rotMatrix[1][0], rotMatrix[1][1], 0.0, 0.0, 0.0, 1.0);
		ParticleMat = mat3(-matrix_viewInverse[0].xyz, -matrix_viewInverse[1].xyz, matrix_viewInverse[2].xyz) * rot3;
`,
              Xs = `
		vec3 origParticlePos = particlePos;
		particlePos -= matrix_model[3].xyz;
		particlePos = mod(particlePos, wrapBounds) - wrapBounds * 0.5;
		particlePos += matrix_model[3].xyz;
		particlePosMoved = particlePos - origParticlePos;
`,
              Zs = `
void getReflDir(vec3 worldNormal, vec3 viewDir, float gloss, mat3 tbn) {
		dReflDirW = normalize(-reflect(viewDir, worldNormal));
}
`,
              We = `
void getReflDir(vec3 worldNormal, vec3 viewDir, float gloss, mat3 tbn) {
		float roughness = sqrt(1.0 - min(gloss, 1.0));
		float anisotropy = material_anisotropy * roughness;
		vec3 anisotropicDirection = anisotropy >= 0.0 ? tbn[1] : tbn[0];
		vec3 anisotropicTangent = cross(anisotropicDirection, viewDir);
		vec3 anisotropicNormal = cross(anisotropicTangent, anisotropicDirection);
		vec3 bentNormal = normalize(mix(normalize(worldNormal), normalize(anisotropicNormal), anisotropy));
		dReflDirW = reflect(-viewDir, bentNormal);
}
`,
              ft = `
#ifdef LIT_CLEARCOAT
void addReflectionCC(vec3 reflDir, float gloss) {
		ccReflection += calcReflection(reflDir, gloss);
}
#endif
`,
              bt = `
uniform samplerCube texture_cubeMap;
uniform float material_reflectivity;

vec3 calcReflection(vec3 reflDir, float gloss) {
		vec3 lookupVec = fixSeams(cubeMapProject(reflDir));
		lookupVec.x *= -1.0;
		return $DECODE(textureCube(texture_cubeMap, lookupVec));
}

void addReflection(vec3 reflDir, float gloss) {   
		dReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);
}
`,
              ts = `
#ifndef ENV_ATLAS
#define ENV_ATLAS
uniform sampler2D texture_envAtlas;
#endif
uniform samplerCube texture_cubeMap;
uniform float material_reflectivity;

vec3 calcReflection(vec3 reflDir, float gloss) {
		vec3 dir = cubeMapProject(reflDir) * vec3(-1.0, 1.0, 1.0);
		vec2 uv = toSphericalUv(dir);

		// calculate roughness level
		float level = saturate(1.0 - gloss) * 5.0;
		float ilevel = floor(level);
		float flevel = level - ilevel;

		vec3 sharp = $DECODE_CUBEMAP(textureCube(texture_cubeMap, fixSeams(dir)));
		vec3 roughA = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel)));
		vec3 roughB = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel + 1.0)));

		return processEnvironment(mix(sharp, mix(roughA, roughB, flevel), min(level, 1.0)));
}

void addReflection(vec3 reflDir, float gloss) {   
		dReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);
}
`,
              Qt = `
#ifndef ENV_ATLAS
#define ENV_ATLAS
uniform sampler2D texture_envAtlas;
#endif
uniform float material_reflectivity;

// calculate mip level for shiny reflection given equirect coords uv.
float shinyMipLevel(vec2 uv) {
		vec2 dx = dFdx(uv);
		vec2 dy = dFdy(uv);

		// calculate second dF at 180 degrees
		vec2 uv2 = vec2(fract(uv.x + 0.5), uv.y);
		vec2 dx2 = dFdx(uv2);
		vec2 dy2 = dFdy(uv2);

		// calculate min of both sets of dF to handle discontinuity at the azim edge
		float maxd = min(max(dot(dx, dx), dot(dy, dy)), max(dot(dx2, dx2), dot(dy2, dy2)));

		return clamp(0.5 * log2(maxd) - 1.0 + textureBias, 0.0, 5.0);
}

vec3 calcReflection(vec3 reflDir, float gloss) {
		vec3 dir = cubeMapProject(reflDir) * vec3(-1.0, 1.0, 1.0);
		vec2 uv = toSphericalUv(dir);

		// calculate roughness level
		float level = saturate(1.0 - gloss) * 5.0;
		float ilevel = floor(level);

		// accessing the shiny (top level) reflection - perform manual mipmap lookup
		float level2 = shinyMipLevel(uv * atlasSize);
		float ilevel2 = floor(level2);

		vec2 uv0, uv1;
		float weight;
		if (ilevel == 0.0) {
				uv0 = mapShinyUv(uv, ilevel2);
				uv1 = mapShinyUv(uv, ilevel2 + 1.0);
				weight = level2 - ilevel2;
		} else {
				// accessing rough reflection - just sample the same part twice
				uv0 = uv1 = mapRoughnessUv(uv, ilevel);
				weight = 0.0;
		}

		vec3 linearA = $DECODE(texture2D(texture_envAtlas, uv0));
		vec3 linearB = $DECODE(texture2D(texture_envAtlas, uv1));
		vec3 linear0 = mix(linearA, linearB, weight);
		vec3 linear1 = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel + 1.0)));

		return processEnvironment(mix(linear0, linear1, level - ilevel));
}

void addReflection(vec3 reflDir, float gloss) {   
		dReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);
}
`,
              rs = `
#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif
uniform sampler2D texture_sphereMap;
uniform float material_reflectivity;

vec3 calcReflection(vec3 reflDir, float gloss) {
		vec3 reflDirV = (mat3(matrix_view) * reflDir).xyz;

		float m = 2.0 * sqrt( dot(reflDirV.xy, reflDirV.xy) + (reflDirV.z+1.0)*(reflDirV.z+1.0) );
		vec2 sphereMapUv = reflDirV.xy / m + 0.5;

		return $DECODE(texture2D(texture_sphereMap, sphereMapUv));
}

void addReflection(vec3 reflDir, float gloss) {   
		dReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);
}
`,
              Ps = `
uniform sampler2D texture_sphereMap;
uniform float material_reflectivity;

vec3 calcReflection(vec3 reflDir, float gloss) {
		vec3 reflDirV = vNormalV;

		vec2 sphereMapUv = reflDirV.xy * 0.5 + 0.5;
		return $DECODE(texture2D(texture_sphereMap, sphereMapUv));
}

void addReflection(vec3 reflDir, float gloss) {   
		dReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);
}
`,
              Ts = `

void addReflectionSheen(vec3 worldNormal, vec3 viewDir, float gloss) {
		float NoV = dot(worldNormal, viewDir);
		float alphaG = gloss * gloss;

		// Avoid using a LUT and approximate the values analytically
		float a = gloss < 0.25 ? -339.2 * alphaG + 161.4 * gloss - 25.9 : -8.48 * alphaG + 14.3 * gloss - 9.95;
		float b = gloss < 0.25 ? 44.0 * alphaG - 23.7 * gloss + 3.26 : 1.97 * alphaG - 3.27 * gloss + 0.72;
		float DG = exp( a * NoV + b ) + ( gloss < 0.25 ? 0.0 : 0.1 * ( gloss - 0.25 ) );
		sReflection += calcReflection(worldNormal, 0.0) * saturate(DG);
}
`,
              ei = `
vec3 refract2(vec3 viewVec, vec3 normal, float IOR) {
		float vn = dot(viewVec, normal);
		float k = 1.0 - IOR * IOR * (1.0 - vn * vn);
		vec3 refrVec = IOR * viewVec - (IOR * vn + sqrt(k)) * normal;
		return refrVec;
}

void addRefraction(
		vec3 worldNormal, 
		vec3 viewDir, 
		float thickness, 
		float gloss, 
		vec3 specularity, 
		vec3 albedo, 
		float transmission,
		float refractionIndex
#if defined(LIT_IRIDESCENCE)
		, vec3 iridescenceFresnel,
		float iridescenceIntensity
#endif 
) {
		// use same reflection code with refraction vector
		vec4 tmpRefl = dReflection;
		vec3 reflectionDir = refract2(-viewDir, worldNormal, refractionIndex);
		dReflection = vec4(0);
		addReflection(reflectionDir, gloss);
		dDiffuseLight = mix(dDiffuseLight, dReflection.rgb * albedo, transmission);
		dReflection = tmpRefl;
}
`,
              Js = `
uniform float material_invAttenuationDistance;
uniform vec3 material_attenuation;

void addRefraction(
		vec3 worldNormal, 
		vec3 viewDir, 
		float thickness, 
		float gloss, 
		vec3 specularity, 
		vec3 albedo, 
		float transmission,
		float refractionIndex
#if defined(LIT_IRIDESCENCE)
		, vec3 iridescenceFresnel,
		float iridescenceIntensity
#endif
) {

		// Extract scale from the model transform
		vec3 modelScale;
		modelScale.x = length(vec3(matrix_model[0].xyz));
		modelScale.y = length(vec3(matrix_model[1].xyz));
		modelScale.z = length(vec3(matrix_model[2].xyz));

		// Calculate the refraction vector, scaled by the thickness and scale of the object
		vec3 refractionVector = normalize(refract(-viewDir, worldNormal, refractionIndex)) * thickness * modelScale;

		// The refraction point is the entry point + vector to exit point
		vec4 pointOfRefraction = vec4(vPositionW + refractionVector, 1.0);

		// Project to texture space so we can sample it
		vec4 projectionPoint = matrix_viewProjection * pointOfRefraction;

		// use built-in getGrabScreenPos function to convert screen position to grab texture uv coords
		vec2 uv = getGrabScreenPos(projectionPoint);

		#ifdef SUPPORTS_TEXLOD
				// Use IOR and roughness to select mip
				float iorToRoughness = (1.0 - gloss) * clamp((1.0 / refractionIndex) * 2.0 - 2.0, 0.0, 1.0);
				float refractionLod = log2(uScreenSize.x) * iorToRoughness;
				vec3 refraction = texture2DLodEXT(uSceneColorMap, uv, refractionLod).rgb;
		#else
				vec3 refraction = texture2D(uSceneColorMap, uv).rgb;
		#endif

		// Transmittance is our final refraction color
		vec3 transmittance;
		if (material_invAttenuationDistance != 0.0)
		{
				vec3 attenuation = -log(material_attenuation) * material_invAttenuationDistance;
				transmittance = exp(-attenuation * length(refractionVector));
		}
		else
		{
				transmittance = refraction;
		}

		// Apply fresnel effect on refraction
		vec3 fresnel = vec3(1.0) - 
				getFresnel(
						dot(viewDir, worldNormal), 
						gloss, 
						specularity
				#if defined(LIT_IRIDESCENCE)
						, iridescenceFresnel,
						iridescenceIntensity
				#endif
				);
		dDiffuseLight = mix(dDiffuseLight, refraction * transmittance * fresnel, transmission);
}
`,
              ti = `
// This shader requires the following #DEFINEs:
//
// PROCESS_FUNC - must be one of reproject, prefilter
// DECODE_FUNC - must be one of decodeRGBM, decodeRGBE, decodeGamma or decodeLinear
// ENCODE_FUNC - must be one of encodeRGBM, encodeRGBE, encideGamma or encodeLinear
// SOURCE_FUNC - must be one of sampleCubemap, sampleEquirect, sampleOctahedral
// TARGET_FUNC - must be one of getDirectionCubemap, getDirectionEquirect, getDirectionOctahedral
//
// When filtering:
// NUM_SAMPLES - number of samples
// NUM_SAMPLES_SQRT - sqrt of number of samples

varying vec2 vUv0;

// source
#ifdef CUBEMAP_SOURCE
		uniform samplerCube sourceCube;
#else
		uniform sampler2D sourceTex;
#endif

#ifdef USE_SAMPLES_TEX
		// samples
		uniform sampler2D samplesTex;
		uniform vec2 samplesTexInverseSize;
#endif

// params:
// x - target cubemap face 0..6
// y - specular power (when prefiltering)
// z - source cubemap seam scale (0 to disable)
// w - target cubemap size for seam calc (0 to disable)
uniform vec4 params;

// params2:
// x - target image total pixels
// y - source cubemap size
uniform vec2 params2;

float targetFace() { return params.x; }
float specularPower() { return params.y; }
float sourceCubeSeamScale() { return params.z; }
float targetCubeSeamScale() { return params.w; }

float targetTotalPixels() { return params2.x; }
float sourceTotalPixels() { return params2.y; }

float PI = 3.141592653589793;

float saturate(float x) {
		return clamp(x, 0.0, 1.0);
}

${$}
${pe}

//-- supported projections

vec3 modifySeams(vec3 dir, float scale) {
		vec3 adir = abs(dir);
		float M = max(max(adir.x, adir.y), adir.z);
		return dir / M * vec3(
				adir.x == M ? 1.0 : scale,
				adir.y == M ? 1.0 : scale,
				adir.z == M ? 1.0 : scale
		);
}

vec2 toSpherical(vec3 dir) {
		return vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));
}

vec3 fromSpherical(vec2 uv) {
		return vec3(cos(uv.y) * sin(uv.x),
								sin(uv.y),
								cos(uv.y) * cos(uv.x));
}

vec3 getDirectionEquirect() {
		return fromSpherical((vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0) * vec2(PI, PI * 0.5));
}

// octahedral code, based on http://jcgt.org/published/0003/02/01
// "Survey of Efficient Representations for Independent Unit Vectors" by Cigolle, Donow, Evangelakos, Mara, McGuire, Meyer

float signNotZero(float k){
		return(k >= 0.0) ? 1.0 : -1.0;
}

vec2 signNotZero(vec2 v) {
		return vec2(signNotZero(v.x), signNotZero(v.y));
}

// Returns a unit vector. Argument o is an octahedral vector packed via octEncode, on the [-1, +1] square
vec3 octDecode(vec2 o) {
		vec3 v = vec3(o.x, 1.0 - abs(o.x) - abs(o.y), o.y);
		if (v.y < 0.0) {
				v.xz = (1.0 - abs(v.zx)) * signNotZero(v.xz);
		}
		return normalize(v);
}

vec3 getDirectionOctahedral() {
		return octDecode(vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0);
}

// Assumes that v is a unit vector. The result is an octahedral vector on the [-1, +1] square
vec2 octEncode(in vec3 v) {
		float l1norm = abs(v.x) + abs(v.y) + abs(v.z);
		vec2 result = v.xz * (1.0 / l1norm);
		if (v.y < 0.0) {
				result = (1.0 - abs(result.yx)) * signNotZero(result.xy);
		}
		return result;
}

/////////////////////////////////////////////////////////////////////

#ifdef CUBEMAP_SOURCE
		vec4 sampleCubemap(vec3 dir) {
				return textureCube(sourceCube, modifySeams(dir, 1.0 - sourceCubeSeamScale()));
		}

		vec4 sampleCubemap(vec2 sph) {
		return sampleCubemap(fromSpherical(sph));
}

		vec4 sampleCubemap(vec3 dir, float mipLevel) {
				return textureCubeLodEXT(sourceCube, modifySeams(dir, 1.0 - exp2(mipLevel) * sourceCubeSeamScale()), mipLevel);
		}

		vec4 sampleCubemap(vec2 sph, float mipLevel) {
				return sampleCubemap(fromSpherical(sph), mipLevel);
		}
#else

		vec4 sampleEquirect(vec2 sph) {
				vec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;
				return texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));
		}

		vec4 sampleEquirect(vec3 dir) {
				return sampleEquirect(toSpherical(dir));
		}

		vec4 sampleEquirect(vec2 sph, float mipLevel) {
				vec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;
				return texture2DLodEXT(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);
		}

		vec4 sampleEquirect(vec3 dir, float mipLevel) {
				return sampleEquirect(toSpherical(dir), mipLevel);
		}

		vec4 sampleOctahedral(vec3 dir) {
				vec2 uv = octEncode(dir) * 0.5 + 0.5;
				return texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));
		}

		vec4 sampleOctahedral(vec2 sph) {
				return sampleOctahedral(fromSpherical(sph));
		}

		vec4 sampleOctahedral(vec3 dir, float mipLevel) {
				vec2 uv = octEncode(dir) * 0.5 + 0.5;
				return texture2DLodEXT(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);
		}

		vec4 sampleOctahedral(vec2 sph, float mipLevel) {
				return sampleOctahedral(fromSpherical(sph), mipLevel);
		}

#endif

vec3 getDirectionCubemap() {
		vec2 st = vUv0 * 2.0 - 1.0;
		float face = targetFace();

		vec3 vec;
		if (face == 0.0) {
				vec = vec3(1, -st.y, -st.x);
		} else if (face == 1.0) {
				vec = vec3(-1, -st.y, st.x);
		} else if (face == 2.0) {
				vec = vec3(st.x, 1, st.y);
		} else if (face == 3.0) {
				vec = vec3(st.x, -1, -st.y);
		} else if (face == 4.0) {
				vec = vec3(st.x, -st.y, 1);
		} else {
				vec = vec3(-st.x, -st.y, -1);
		}

		return normalize(modifySeams(vec, 1.0 / (1.0 - targetCubeSeamScale())));
}

mat3 matrixFromVector(vec3 n) { // frisvad
		float a = 1.0 / (1.0 + n.z);
		float b = -n.x * n.y * a;
		vec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);
		vec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);
		return mat3(b1, b2, n);
}

mat3 matrixFromVectorSlow(vec3 n) {
		vec3 up = (1.0 - abs(n.y) <= 0.0000001) ? vec3(0.0, 0.0, n.y > 0.0 ? 1.0 : -1.0) : vec3(0.0, 1.0, 0.0);
		vec3 x = normalize(cross(up, n));
		vec3 y = cross(n, x);
		return mat3(x, y, n);
}

vec4 reproject() {
		if (NUM_SAMPLES <= 1) {
				// single sample
				return ENCODE_FUNC(DECODE_FUNC(SOURCE_FUNC(TARGET_FUNC())));
		} else {
				// multi sample
				vec3 t = TARGET_FUNC();
				vec3 tu = dFdx(t);
				vec3 tv = dFdy(t);

				vec3 result = vec3(0.0);
				for (float u = 0.0; u < NUM_SAMPLES_SQRT; ++u) {
						for (float v = 0.0; v < NUM_SAMPLES_SQRT; ++v) {
								result += DECODE_FUNC(SOURCE_FUNC(normalize(t +
																														tu * (u / NUM_SAMPLES_SQRT - 0.5) +
																														tv * (v / NUM_SAMPLES_SQRT - 0.5))));
						}
				}
				return ENCODE_FUNC(result / (NUM_SAMPLES_SQRT * NUM_SAMPLES_SQRT));
		}
}

vec4 unpackFloat = vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0);

#ifdef USE_SAMPLES_TEX
		void unpackSample(int i, out vec3 L, out float mipLevel) {
				float u = (float(i * 4) + 0.5) * samplesTexInverseSize.x;
				float v = (floor(u) + 0.5) * samplesTexInverseSize.y;

				vec4 raw;
				raw.x = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;
				raw.y = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;
				raw.z = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;
				raw.w = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat);

				L.xyz = raw.xyz * 2.0 - 1.0;
				mipLevel = raw.w * 8.0;
		}

		// convolve an environment given pre-generated samples
		vec4 prefilterSamples() {
				// construct vector space given target direction
				mat3 vecSpace = matrixFromVectorSlow(TARGET_FUNC());

				vec3 L;
				float mipLevel;

				vec3 result = vec3(0.0);
				float totalWeight = 0.0;
				for (int i = 0; i < NUM_SAMPLES; ++i) {
						unpackSample(i, L, mipLevel);
						result += DECODE_FUNC(SOURCE_FUNC(vecSpace * L, mipLevel)) * L.z;
						totalWeight += L.z;
				}

				return ENCODE_FUNC(result / totalWeight);
		}

		// unweighted version of prefilterSamples
		vec4 prefilterSamplesUnweighted() {
				// construct vector space given target direction
				mat3 vecSpace = matrixFromVectorSlow(TARGET_FUNC());

				vec3 L;
				float mipLevel;

				vec3 result = vec3(0.0);
				float totalWeight = 0.0;
				for (int i = 0; i < NUM_SAMPLES; ++i) {
						unpackSample(i, L, mipLevel);
						result += DECODE_FUNC(SOURCE_FUNC(vecSpace * L, mipLevel));
				}

				return ENCODE_FUNC(result / float(NUM_SAMPLES));
		}
#endif

void main(void) {
		gl_FragColor = PROCESS_FUNC();
}
`,
              Bs = `
uniform highp sampler2D uSceneDepthMap;

#ifndef SCREENSIZE
#define SCREENSIZE
uniform vec4 uScreenSize;
#endif

#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif

#ifndef LINEARIZE_DEPTH
#ifndef CAMERAPLANES
#define CAMERAPLANES
uniform vec4 camera_params; // x: 1 / camera_far,      y: camera_far,     z: camera_near,        w: is_ortho
#endif

#define LINEARIZE_DEPTH
#ifdef GL2
float linearizeDepth(float z) {
		if (camera_params.w == 0.0)
				return (camera_params.z * camera_params.y) / (camera_params.y + z * (camera_params.z - camera_params.y));
		else
				return camera_params.z + z * (camera_params.y - camera_params.z);
}
#else // GL2
#ifndef UNPACKFLOAT
#define UNPACKFLOAT
float unpackFloat(vec4 rgbaDepth) {
		const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);
		return dot(rgbaDepth, bitShift);
}
#endif
#endif
#endif // LINEARIZE_DEPTH

// Retrieves rendered linear camera depth by UV
float getLinearScreenDepth(vec2 uv) {
		#ifdef GL2
				return linearizeDepth(texture2D(uSceneDepthMap, uv).r);
		#else
				return unpackFloat(texture2D(uSceneDepthMap, uv)) * camera_params.y;
		#endif
}

#ifndef VERTEXSHADER
// Retrieves rendered linear camera depth under the current pixel
float getLinearScreenDepth() {
		vec2 uv = gl_FragCoord.xy * uScreenSize.zw;
		return getLinearScreenDepth(uv);
}
#endif

// Generates linear camera depth for the given world position
float getLinearDepth(vec3 pos) {
		return -(matrix_view * vec4(pos, 1.0)).z;
}
`,
              si = `
const float maxCascades = 4.0;

// shadow matrix for selected cascade
mat4 cascadeShadowMat;

// function which selects a shadow projection matrix based on cascade distances 
void getShadowCascadeMatrix(mat4 shadowMatrixPalette[4], float shadowCascadeDistances[4], float shadowCascadeCount) {

		// depth in 0 .. far plane range
		float depth = 1.0 / gl_FragCoord.w;

		// find cascade index based on the depth (loop as there is no per component vec compare operator in webgl)
		float cascadeIndex = 0.0;
		for (float i = 0.0; i < maxCascades; i++) {
				if (depth < shadowCascadeDistances[int(i)]) {
						cascadeIndex = i;
						break;
				}
		}

		// limit to actual number of used cascades
		cascadeIndex = min(cascadeIndex, shadowCascadeCount - 1.0);

		// pick shadow matrix
		#ifdef GL2
				cascadeShadowMat = shadowMatrixPalette[int(cascadeIndex)];
		#else
				// webgl 1 does not allow non-cost index array lookup
				if (cascadeIndex == 0.0) {
						cascadeShadowMat = shadowMatrixPalette[0];
				}
				else if (cascadeIndex == 1.0) {
						cascadeShadowMat = shadowMatrixPalette[1];
				}
				else if (cascadeIndex == 2.0) {
						cascadeShadowMat = shadowMatrixPalette[2];
				}
				else {
						cascadeShadowMat = shadowMatrixPalette[3];
				}
		#endif
}

void fadeShadow(float shadowCascadeDistances[4]) {                  

		// if the pixel is past the shadow distance, remove shadow
		// this enforces straight line instead of corner of shadow which moves when camera rotates  
		float depth = 1.0 / gl_FragCoord.w;
		if (depth > shadowCascadeDistances[int(maxCascades - 1.0)]) {
				dShadowCoord.z = -9999999.0;
		}
}
`,
              Ti = `
float VSM$(sampler2D tex, vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {
		vec3 moments = texture2D(tex, texCoords).xyz;
		return calculateEVSM(moments, Z, vsmBias, exponent);
}

float getShadowVSM$(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {
		return VSM$(shadowMap, shadowCoord.xy, shadowParams.x, shadowCoord.z, shadowParams.y, exponent);
}

float getShadowSpotVSM$(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {
		return VSM$(shadowMap, shadowCoord.xy, shadowParams.x, length(lightDir) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);
}
`,
              xi = `
float VSM$(TEXTURE_ACCEPT(tex), vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {
		float pixelSize = 1.0 / resolution;
		texCoords -= vec2(pixelSize);
		vec3 s00 = texture2D(tex, texCoords).xyz;
		vec3 s10 = texture2D(tex, texCoords + vec2(pixelSize, 0)).xyz;
		vec3 s01 = texture2D(tex, texCoords + vec2(0, pixelSize)).xyz;
		vec3 s11 = texture2D(tex, texCoords + vec2(pixelSize)).xyz;
		vec2 fr = fract(texCoords * resolution);
		vec3 h0 = mix(s00, s10, fr.x);
		vec3 h1 = mix(s01, s11, fr.x);
		vec3 moments = mix(h0, h1, fr.y);
		return calculateEVSM(moments, Z, vsmBias, exponent);
}

float getShadowVSM$(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {
		return VSM$(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, shadowCoord.z, shadowParams.y, exponent);
}

float getShadowSpotVSM$(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {
		return VSM$(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, length(lightDir) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);
}
`,
              Is = `

/**
 * PCSS is a shadow sampling method that provides contact hardening soft shadows. 
 * Based on: 
 * - https://www.gamedev.net/tutorials/programming/graphics/effect-area-light-shadows-part-1-pcss-r4971/
 * - https://github.com/pboechat/PCSS 
 */


#define PCSS_SAMPLE_COUNT 16
uniform float pcssDiskSamples[PCSS_SAMPLE_COUNT];
uniform float pcssSphereSamples[PCSS_SAMPLE_COUNT];

vec2 vogelDisk(int sampleIndex, float count, float phi, float r) {
		const float GoldenAngle = 2.4;
		float theta = float(sampleIndex) * GoldenAngle + phi;

		float sine = sin(theta);
		float cosine = cos(theta);
		return vec2(r * cosine, r * sine);
}

vec3 vogelSphere(int sampleIndex, float count, float phi, float r) {
		const float GoldenAngle = 2.4;
		float theta = float(sampleIndex) * GoldenAngle + phi;

		float weight = float(sampleIndex) / count;
		return vec3(cos(theta) * r, weight, sin(theta) * r);
}

float noise(vec2 screenPos) {
		const float PHI = 1.61803398874989484820459;  // \u03A6 = Golden Ratio   
		return fract(tan(distance(screenPos * PHI, screenPos)) * screenPos.x);
}

#ifndef UNPACKFLOAT
#define UNPACKFLOAT
float unpackFloat(vec4 rgbaDepth) {
		const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);
		return dot(rgbaDepth, bitShift);
}
#endif

float viewSpaceDepth(float depth, mat4 invProjection) {
		float z = depth * 2.0 - 1.0;
		vec4 clipSpace = vec4(0.0, 0.0, z, 1.0);
		vec4 viewSpace = invProjection * clipSpace;
		return viewSpace.z;
}

float PCSSBlockerDistance(TEXTURE_ACCEPT(shadowMap), vec2 sampleCoords[PCSS_SAMPLE_COUNT], vec2 shadowCoords, vec2 searchSize, float z) {

		float blockers = 0.0;
		float averageBlocker = 0.0;
		for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {
				vec2 offset = sampleCoords[i] * searchSize;
				vec2 sampleUV = shadowCoords + offset;

		#ifdef GL2
				float blocker = textureLod(shadowMap, sampleUV, 0.0).r;
		#else // GL1
				float blocker = unpackFloat(texture2D(shadowMap, sampleUV));
		#endif        
				float isBlocking = step(blocker, z);
				blockers += isBlocking;
				averageBlocker += blocker * isBlocking;
		}

		if (blockers > 0.0)
				return averageBlocker /= blockers;
		return -1.0;
}

float PCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoords, vec4 cameraParams, vec2 shadowSearchArea) {
		float receiverDepth = shadowCoords.z;
#ifndef GL2
		// If using packed depth on GL1, we need to normalize to get the correct receiver depth
		receiverDepth *= 1.0 / (cameraParams.y - cameraParams.z);
#endif

		vec2 samplePoints[PCSS_SAMPLE_COUNT];
		float noise = noise( gl_FragCoord.xy ) * 2.0 * PI;
		for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {
				float pcssPresample = pcssDiskSamples[i];
				samplePoints[i] = vogelDisk(i, float(PCSS_SAMPLE_COUNT), noise, pcssPresample);
		}

		float averageBlocker = PCSSBlockerDistance(TEXTURE_PASS(shadowMap), samplePoints, shadowCoords.xy, shadowSearchArea, receiverDepth);
		if (averageBlocker == -1.0) {
				return 1.0;
		} else {

				vec2 filterRadius = ((receiverDepth - averageBlocker) / averageBlocker) * shadowSearchArea * cameraParams.x;

				float shadow = 0.0;

				for (int i = 0; i < PCSS_SAMPLE_COUNT; i ++)
				{
						vec2 sampleUV = samplePoints[i] * filterRadius;
						sampleUV = shadowCoords.xy + sampleUV;

				#ifdef GL2
						float depth = textureLod(shadowMap, sampleUV, 0.0).r;
				#else // GL1
						float depth = unpackFloat(texture2D(shadowMap, sampleUV));
				#endif
						shadow += step(receiverDepth, depth);
				}
				return shadow / float(PCSS_SAMPLE_COUNT);
		} 
}

float PCSSCubeBlockerDistance(samplerCube shadowMap, vec3 lightDirNorm, vec3 samplePoints[PCSS_SAMPLE_COUNT], float z, float shadowSearchArea) {
		float blockers = 0.0;
		float averageBlocker = 0.0;
		for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {
				vec3 sampleDir = lightDirNorm + samplePoints[i] * shadowSearchArea;
				sampleDir = normalize(sampleDir);

		#ifdef GL2
				float blocker = textureCubeLodEXT(shadowMap, sampleDir, 0.0).r;
		#else // GL1
				float blocker = unpackFloat(textureCube(shadowMap, sampleDir));
		#endif
				float isBlocking = step(blocker, z);
				blockers += isBlocking;
				averageBlocker += blocker * isBlocking;
		}

		if (blockers > 0.0)
				return averageBlocker /= float(blockers);
		return -1.0;
}

float PCSSCube(samplerCube shadowMap, vec4 shadowParams, vec3 shadowCoords, vec4 cameraParams, float shadowSearchArea, vec3 lightDir) {
		
		vec3 samplePoints[PCSS_SAMPLE_COUNT];
		float noise = noise( gl_FragCoord.xy ) * 2.0 * PI;
		for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {
				float r = pcssSphereSamples[i];
				samplePoints[i] = vogelSphere(i, float(PCSS_SAMPLE_COUNT), noise, r);
		}

		float receiverDepth = length(lightDir) * shadowParams.w + shadowParams.z;
		vec3 lightDirNorm = normalize(lightDir);
		
		float averageBlocker = PCSSCubeBlockerDistance(shadowMap, lightDirNorm, samplePoints, receiverDepth, shadowSearchArea);
		if (averageBlocker == -1.0) {
				return 1.0;
		} else {

				float filterRadius = ((receiverDepth - averageBlocker) / averageBlocker) * shadowSearchArea;

				float shadow = 0.0;
				for (int i = 0; i < PCSS_SAMPLE_COUNT; i++)
				{
						vec3 offset = samplePoints[i] * filterRadius;
						vec3 sampleDir = lightDirNorm + offset;
						sampleDir = normalize(sampleDir);

						#ifdef GL2
								float depth = textureCubeLodEXT(shadowMap, sampleDir, 0.0).r;
						#else // GL1
								float depth = unpackFloat(textureCube(shadowMap, sampleDir));
						#endif
						shadow += step(receiverDepth, depth);
				}
				return shadow / float(PCSS_SAMPLE_COUNT);
		}
}

float getShadowPointPCSS(samplerCube shadowMap, vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {
		return PCSSCube(shadowMap, shadowParams, shadowCoord, cameraParams, shadowSearchArea.x, lightDir);
}

float getShadowSpotPCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {
		return PCSS(TEXTURE_PASS(shadowMap), shadowCoord, cameraParams, shadowSearchArea);
}

float getShadowPCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {
		return PCSS(TEXTURE_PASS(shadowMap), shadowCoord, cameraParams, shadowSearchArea);
}

`,
              ai = `

vec3 getShadowSampleCoord$LIGHT(mat4 shadowTransform, vec4 shadowParams, vec3 worldPosition, vec3 lightPos, inout vec3 lightDir, vec3 lightDirNorm, vec3 normal) {

		vec3 surfacePosition = worldPosition;

#ifdef SHADOW_SAMPLE_POINT
		#ifdef SHADOW_SAMPLE_NORMAL_OFFSET
				float distScale = length(lightDir);
				surfacePosition = worldPosition + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;
				lightDir = surfacePosition - lightPos;
				return lightDir;
		#endif
#else
		#ifdef SHADOW_SAMPLE_SOURCE_ZBUFFER
				#ifdef SHADOW_SAMPLE_NORMAL_OFFSET
						surfacePosition = worldPosition + normal * shadowParams.y;
				#endif
		#else
				#ifdef SHADOW_SAMPLE_NORMAL_OFFSET
						#ifdef SHADOW_SAMPLE_ORTHO
								float distScale = 1.0;
						#else
								float distScale = abs(dot(vPositionW - lightPos, lightDirNorm));
						#endif
						surfacePosition = worldPosition + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;
				#endif
		#endif

		vec4 positionInShadowSpace = shadowTransform * vec4(surfacePosition, 1.0);
		#ifdef SHADOW_SAMPLE_ORTHO
				positionInShadowSpace.z = saturate(positionInShadowSpace.z) - 0.0001;
		#else
				#ifdef SHADOW_SAMPLE_SOURCE_ZBUFFER
						positionInShadowSpace.xyz /= positionInShadowSpace.w;
				#else
						positionInShadowSpace.xy /= positionInShadowSpace.w;
						positionInShadowSpace.z = length(lightDir) * shadowParams.w;
				#endif
		#endif

		#ifdef SHADOW_SAMPLE_Z_BIAS
				positionInShadowSpace.z += getShadowBias(shadowParams.x, shadowParams.z);
		#endif
		surfacePosition = positionInShadowSpace.xyz;
#endif

		return surfacePosition;
}
`,
              Qs = `
vec3 lessThan2(vec3 a, vec3 b) {
		return clamp((b - a)*1000.0, 0.0, 1.0); // softer version
}

#ifndef UNPACKFLOAT
#define UNPACKFLOAT
		float unpackFloat(vec4 rgbaDepth) {
				const vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);
				return dot(rgbaDepth, bitShift);
		}
#endif

// ----- Direct/Spot Sampling -----

#ifdef GL2

float _getShadowPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec3 shadowParams) {
		float z = shadowCoord.z;
		vec2 uv = shadowCoord.xy * shadowParams.x; // 1 unit - 1 texel
		float shadowMapSizeInv = 1.0 / shadowParams.x;
		vec2 base_uv = floor(uv + 0.5);
		float s = (uv.x + 0.5 - base_uv.x);
		float t = (uv.y + 0.5 - base_uv.y);
		base_uv -= vec2(0.5);
		base_uv *= shadowMapSizeInv;

		float sum = 0.0;

		float uw0 = (3.0 - 2.0 * s);
		float uw1 = (1.0 + 2.0 * s);

		float u0 = (2.0 - s) / uw0 - 1.0;
		float u1 = s / uw1 + 1.0;

		float vw0 = (3.0 - 2.0 * t);
		float vw1 = (1.0 + 2.0 * t);

		float v0 = (2.0 - t) / vw0 - 1.0;
		float v1 = t / vw1 + 1.0;

		u0 = u0 * shadowMapSizeInv + base_uv.x;
		v0 = v0 * shadowMapSizeInv + base_uv.y;

		u1 = u1 * shadowMapSizeInv + base_uv.x;
		v1 = v1 * shadowMapSizeInv + base_uv.y;

		sum += uw0 * vw0 * textureShadow(shadowMap, vec3(u0, v0, z));
		sum += uw1 * vw0 * textureShadow(shadowMap, vec3(u1, v0, z));
		sum += uw0 * vw1 * textureShadow(shadowMap, vec3(u0, v1, z));
		sum += uw1 * vw1 * textureShadow(shadowMap, vec3(u1, v1, z));

		sum *= 1.0f / 16.0;
		return sum;
}

float getShadowPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
		return _getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);
}

float getShadowSpotPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
		return _getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);
}

float getShadowPCF1x1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
		return textureShadow(shadowMap, shadowCoord);
}

float getShadowSpotPCF1x1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
		return textureShadow(shadowMap, shadowCoord);
}

#else // GL1

float _xgetShadowPCF3x3(mat3 depthKernel, vec3 shadowCoord, sampler2D shadowMap, vec3 shadowParams) {
		mat3 shadowKernel;
		vec3 shadowZ = vec3(shadowCoord.z);
		shadowKernel[0] = vec3(greaterThan(depthKernel[0], shadowZ));
		shadowKernel[1] = vec3(greaterThan(depthKernel[1], shadowZ));
		shadowKernel[2] = vec3(greaterThan(depthKernel[2], shadowZ));

		vec2 fractionalCoord = fract( shadowCoord.xy * shadowParams.x );

		shadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);
		shadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);

		vec4 shadowValues;
		shadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);
		shadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);
		shadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);
		shadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);

		return dot( shadowValues, vec4( 1.0 ) ) * 0.25;
}

float _getShadowPCF3x3(sampler2D shadowMap, vec3 shadowCoord, vec3 shadowParams) {
		float xoffset = 1.0 / shadowParams.x; // 1/shadow map width
		float dx0 = -xoffset;
		float dx1 = xoffset;

		mat3 depthKernel;
		depthKernel[0][0] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx0, dx0)));
		depthKernel[0][1] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx0, 0.0)));
		depthKernel[0][2] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx0, dx1)));
		depthKernel[1][0] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(0.0, dx0)));
		depthKernel[1][1] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy));
		depthKernel[1][2] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(0.0, dx1)));
		depthKernel[2][0] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx1, dx0)));
		depthKernel[2][1] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx1, 0.0)));
		depthKernel[2][2] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx1, dx1)));

		return _xgetShadowPCF3x3(depthKernel, shadowCoord, shadowMap, shadowParams);
}

float getShadowPCF3x3(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {
		return _getShadowPCF3x3(shadowMap, shadowCoord, shadowParams.xyz);
}

float getShadowSpotPCF3x3(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {
		return _getShadowPCF3x3(shadowMap, shadowCoord, shadowParams.xyz);
}

float _getShadowPCF1x1(sampler2D shadowMap, vec3 shadowCoord) {
		float shadowSample = unpackFloat(textureShadow(shadowMap, shadowCoord.xy));
		return shadowSample > shadowCoord.z ? 1.0 : 0.0;
}

float getShadowPCF1x1(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {
		return _getShadowPCF1x1(shadowMap, shadowCoord);
}

float getShadowSpotPCF1x1(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {
		return _getShadowPCF1x1(shadowMap, shadowCoord);
}
#endif


// ----- Omni Sampling -----

#ifndef WEBGPU

float _getShadowPoint(samplerCube shadowMap, vec4 shadowParams, vec3 dir) {

		vec3 tc = normalize(dir);
		vec3 tcAbs = abs(tc);

		vec4 dirX = vec4(1,0,0, tc.x);
		vec4 dirY = vec4(0,1,0, tc.y);
		float majorAxisLength = tc.z;
		if ((tcAbs.x > tcAbs.y) && (tcAbs.x > tcAbs.z)) {
				dirX = vec4(0,0,1, tc.z);
				dirY = vec4(0,1,0, tc.y);
				majorAxisLength = tc.x;
		} else if ((tcAbs.y > tcAbs.x) && (tcAbs.y > tcAbs.z)) {
				dirX = vec4(1,0,0, tc.x);
				dirY = vec4(0,0,1, tc.z);
				majorAxisLength = tc.y;
		}

		float shadowParamsInFaceSpace = ((1.0/shadowParams.x) * 2.0) * abs(majorAxisLength);

		vec3 xoffset = (dirX.xyz * shadowParamsInFaceSpace);
		vec3 yoffset = (dirY.xyz * shadowParamsInFaceSpace);
		vec3 dx0 = -xoffset;
		vec3 dy0 = -yoffset;
		vec3 dx1 = xoffset;
		vec3 dy1 = yoffset;

		mat3 shadowKernel;
		mat3 depthKernel;

		depthKernel[0][0] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy0));
		depthKernel[0][1] = unpackFloat(textureCube(shadowMap, tc + dx0));
		depthKernel[0][2] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy1));
		depthKernel[1][0] = unpackFloat(textureCube(shadowMap, tc + dy0));
		depthKernel[1][1] = unpackFloat(textureCube(shadowMap, tc));
		depthKernel[1][2] = unpackFloat(textureCube(shadowMap, tc + dy1));
		depthKernel[2][0] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy0));
		depthKernel[2][1] = unpackFloat(textureCube(shadowMap, tc + dx1));
		depthKernel[2][2] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy1));

		vec3 shadowZ = vec3(length(dir) * shadowParams.w + shadowParams.z);

		shadowKernel[0] = vec3(lessThan2(depthKernel[0], shadowZ));
		shadowKernel[1] = vec3(lessThan2(depthKernel[1], shadowZ));
		shadowKernel[2] = vec3(lessThan2(depthKernel[2], shadowZ));

		vec2 uv = (vec2(dirX.w, dirY.w) / abs(majorAxisLength)) * 0.5;

		vec2 fractionalCoord = fract( uv * shadowParams.x );

		shadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);
		shadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);

		vec4 shadowValues;
		shadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);
		shadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);
		shadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);
		shadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);

		return 1.0 - dot( shadowValues, vec4( 1.0 ) ) * 0.25;
}

float getShadowPointPCF3x3(samplerCube shadowMap, vec3 shadowCoord, vec4 shadowParams, vec3 lightDir) {
		return _getShadowPoint(shadowMap, shadowParams, lightDir);
}

#endif
`,
              ji = `
float _getShadowPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec3 shadowParams) {
		// http://the-witness.net/news/2013/09/shadow-mapping-summary-part-1/

		float z = shadowCoord.z;
		vec2 uv = shadowCoord.xy * shadowParams.x; // 1 unit - 1 texel
		float shadowMapSizeInv = 1.0 / shadowParams.x;
		vec2 base_uv = floor(uv + 0.5);
		float s = (uv.x + 0.5 - base_uv.x);
		float t = (uv.y + 0.5 - base_uv.y);
		base_uv -= vec2(0.5);
		base_uv *= shadowMapSizeInv;


		float uw0 = (4.0 - 3.0 * s);
		float uw1 = 7.0;
		float uw2 = (1.0 + 3.0 * s);

		float u0 = (3.0 - 2.0 * s) / uw0 - 2.0;
		float u1 = (3.0 + s) / uw1;
		float u2 = s / uw2 + 2.0;

		float vw0 = (4.0 - 3.0 * t);
		float vw1 = 7.0;
		float vw2 = (1.0 + 3.0 * t);

		float v0 = (3.0 - 2.0 * t) / vw0 - 2.0;
		float v1 = (3.0 + t) / vw1;
		float v2 = t / vw2 + 2.0;

		float sum = 0.0;

		u0 = u0 * shadowMapSizeInv + base_uv.x;
		v0 = v0 * shadowMapSizeInv + base_uv.y;

		u1 = u1 * shadowMapSizeInv + base_uv.x;
		v1 = v1 * shadowMapSizeInv + base_uv.y;

		u2 = u2 * shadowMapSizeInv + base_uv.x;
		v2 = v2 * shadowMapSizeInv + base_uv.y;

		sum += uw0 * vw0 * textureShadow(shadowMap, vec3(u0, v0, z));
		sum += uw1 * vw0 * textureShadow(shadowMap, vec3(u1, v0, z));
		sum += uw2 * vw0 * textureShadow(shadowMap, vec3(u2, v0, z));

		sum += uw0 * vw1 * textureShadow(shadowMap, vec3(u0, v1, z));
		sum += uw1 * vw1 * textureShadow(shadowMap, vec3(u1, v1, z));
		sum += uw2 * vw1 * textureShadow(shadowMap, vec3(u2, v1, z));

		sum += uw0 * vw2 * textureShadow(shadowMap, vec3(u0, v2, z));
		sum += uw1 * vw2 * textureShadow(shadowMap, vec3(u1, v2, z));
		sum += uw2 * vw2 * textureShadow(shadowMap, vec3(u2, v2, z));

		sum *= 1.0f / 144.0;

		sum = saturate(sum);

		return sum;
}

float getShadowPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
		return _getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);
}

float getShadowSpotPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {
		return _getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);
}
`,
              Di = `
float calculateVSM8(vec3 moments, float Z, float vsmBias) {
		float VSMBias = vsmBias;//0.01 * 0.25;
		float depthScale = VSMBias * Z;
		float minVariance1 = depthScale * depthScale;
		return chebyshevUpperBound(moments.xy, Z, minVariance1, 0.1);
}

float decodeFloatRG(vec2 rg) {
		return rg.y*(1.0/255.0) + rg.x;
}

float VSM8(TEXTURE_ACCEPT(tex), vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {
		vec4 c = texture2D(tex, texCoords);
		vec3 moments = vec3(decodeFloatRG(c.xy), decodeFloatRG(c.zw), 0.0);
		return calculateVSM8(moments, Z, vsmBias);
}

float getShadowVSM8(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {
		return VSM8(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, shadowCoord.z, shadowParams.y, 0.0);
}

float getShadowSpotVSM8(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {
		return VSM8(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, length(lightDir) * shadowParams.w + shadowParams.z, shadowParams.y, 0.0);
}
`,
              Yi = `
float linstep(float a, float b, float v) {
		return saturate((v - a) / (b - a));
}

float reduceLightBleeding(float pMax, float amount) {
	 // Remove the [0, amount] tail and linearly rescale (amount, 1].
	 return linstep(amount, 1.0, pMax);
}

float chebyshevUpperBound(vec2 moments, float mean, float minVariance, float lightBleedingReduction) {
		// Compute variance
		float variance = moments.y - (moments.x * moments.x);
		variance = max(variance, minVariance);

		// Compute probabilistic upper bound
		float d = mean - moments.x;
		float pMax = variance / (variance + (d * d));

		pMax = reduceLightBleeding(pMax, lightBleedingReduction);

		// One-tailed Chebyshev
		return (mean <= moments.x ? 1.0 : pMax);
}

float calculateEVSM(vec3 moments, float Z, float vsmBias, float exponent) {
		Z = 2.0 * Z - 1.0;
		float warpedDepth = exp(exponent * Z);

		moments.xy += vec2(warpedDepth, warpedDepth*warpedDepth) * (1.0 - moments.z);

		float VSMBias = vsmBias;//0.01 * 0.25;
		float depthScale = VSMBias * exponent * warpedDepth;
		float minVariance1 = depthScale * depthScale;
		return chebyshevUpperBound(moments.xy, warpedDepth, minVariance1, 0.1);
}
`,
              Ai = `
attribute float vertex_boneIndices;

uniform vec4 matrix_pose[BONE_LIMIT * 3];

mat4 getBoneMatrix(const in float i) {
		// read 4x3 matrix
		vec4 v1 = matrix_pose[int(3.0 * i)];
		vec4 v2 = matrix_pose[int(3.0 * i + 1.0)];
		vec4 v3 = matrix_pose[int(3.0 * i + 2.0)];

		// transpose to 4x4 matrix
		return mat4(
				v1.x, v2.x, v3.x, 0,
				v1.y, v2.y, v3.y, 0,
				v1.z, v2.z, v3.z, 0,
				v1.w, v2.w, v3.w, 1
		);
}
`,
              Oi = `
attribute float vertex_boneIndices;

uniform highp sampler2D texture_poseMap;
uniform vec4 texture_poseMapSize;

mat4 getBoneMatrix(const in float i) {
		float j = i * 3.0;
		float dx = texture_poseMapSize.z;
		float dy = texture_poseMapSize.w;

		float y = floor(j * dx);
		float x = j - (y * texture_poseMapSize.x);
		y = dy * (y + 0.5);

		// read elements of 4x3 matrix
		vec4 v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));
		vec4 v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));
		vec4 v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));

		// transpose to 4x4 matrix
		return mat4(
				v1.x, v2.x, v3.x, 0,
				v1.y, v2.y, v3.y, 0,
				v1.z, v2.z, v3.z, 0,
				v1.w, v2.w, v3.w, 1
		);
}
`,
              Ci = `
attribute vec4 vertex_boneWeights;
attribute vec4 vertex_boneIndices;

uniform vec4 matrix_pose[BONE_LIMIT * 3];

void getBoneMatrix(const in float i, out vec4 v1, out vec4 v2, out vec4 v3) {
		// read 4x3 matrix
		v1 = matrix_pose[int(3.0 * i)];
		v2 = matrix_pose[int(3.0 * i + 1.0)];
		v3 = matrix_pose[int(3.0 * i + 2.0)];
}

mat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {
		// get 4 bone matrices
		vec4 a1, a2, a3;
		getBoneMatrix(indices.x, a1, a2, a3);

		vec4 b1, b2, b3;
		getBoneMatrix(indices.y, b1, b2, b3);

		vec4 c1, c2, c3;
		getBoneMatrix(indices.z, c1, c2, c3);

		vec4 d1, d2, d3;
		getBoneMatrix(indices.w, d1, d2, d3);

		// multiply them by weights and add up to get final 4x3 matrix
		vec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;
		vec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;
		vec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;

		// add up weights
		float one = dot(weights, vec4(1.0));

		// transpose to 4x4 matrix
		return mat4(
				v1.x, v2.x, v3.x, 0,
				v1.y, v2.y, v3.y, 0,
				v1.z, v2.z, v3.z, 0,
				v1.w, v2.w, v3.w, one
		);
}
`,
              Li = `

attribute vec4 vertex_boneWeights;
attribute vec4 vertex_boneIndices;

uniform highp sampler2D texture_poseMap;
uniform vec4 texture_poseMapSize;

void getBoneMatrix(const in float index, out vec4 v1, out vec4 v2, out vec4 v3) {

		float i = float(index);
		float j = i * 3.0;
		float dx = texture_poseMapSize.z;
		float dy = texture_poseMapSize.w;
		
		float y = floor(j * dx);
		float x = j - (y * texture_poseMapSize.x);
		y = dy * (y + 0.5);

		// read elements of 4x3 matrix
		v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));
		v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));
		v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));
}

mat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {
		// get 4 bone matrices
		vec4 a1, a2, a3;
		getBoneMatrix(indices.x, a1, a2, a3);

		vec4 b1, b2, b3;
		getBoneMatrix(indices.y, b1, b2, b3);

		vec4 c1, c2, c3;
		getBoneMatrix(indices.z, c1, c2, c3);

		vec4 d1, d2, d3;
		getBoneMatrix(indices.w, d1, d2, d3);

		// multiply them by weights and add up to get final 4x3 matrix
		vec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;
		vec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;
		vec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;

		// add up weights
		float one = dot(weights, vec4(1.0));

		// transpose to 4x4 matrix
		return mat4(
				v1.x, v2.x, v3.x, 0,
				v1.y, v2.y, v3.y, 0,
				v1.z, v2.z, v3.z, 0,
				v1.w, v2.w, v3.w, one
		);
}
`,
              Bi = `
varying vec3 vViewDir;

uniform sampler2D texture_envAtlas;
uniform float mipLevel;

void main(void) {
		vec3 dir = vViewDir * vec3(-1.0, 1.0, 1.0);
		vec2 uv = toSphericalUv(normalize(dir));

		vec3 linear = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, mipLevel)));

		gl_FragColor = vec4(gammaCorrectOutput(toneMap(processEnvironment(linear))), 1.0);
}
`,
              Fi = `
varying vec3 vViewDir;

uniform samplerCube texture_cubeMap;

void main(void) {
		vec3 dir=vViewDir;
		dir.x *= -1.0;

		vec3 linear = $DECODE(textureCube(texture_cubeMap, fixSeamsStatic(dir, $FIXCONST)));

		gl_FragColor = vec4(gammaCorrectOutput(toneMap(processEnvironment(linear))), 1.0);
}
`,
              Ui = `
attribute vec3 aPosition;

#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif

uniform mat4 matrix_projectionSkybox;
uniform mat3 cubeMapRotationMatrix;

varying vec3 vViewDir;

void main(void) {
		mat4 view = matrix_view;
		view[3][0] = view[3][1] = view[3][2] = 0.0;
		gl_Position = matrix_projectionSkybox * view * vec4(aPosition, 1.0);

		// Force skybox to far Z, regardless of the clip planes on the camera
		// Subtract a tiny fudge factor to ensure floating point errors don't
		// still push pixels beyond far Z. See:
		// http://www.opengl.org/discussion_boards/showthread.php/171867-skybox-problem

		gl_Position.z = gl_Position.w - 0.00001;
		vViewDir = aPosition * cubeMapRotationMatrix;
}
`,
              pi = `

#ifdef MAPCOLOR
uniform vec3 material_specular;
#endif

void getSpecularity() {
		vec3 specularColor = vec3(1,1,1);

		#ifdef MAPCOLOR
		specularColor *= material_specular;
		#endif

		#ifdef MAPTEXTURE
		specularColor *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;
		#endif

		#ifdef MAPVERTEX
		specularColor *= saturate(vVertexColor.$VC);
		#endif

		dSpecularity = specularColor;
}
`,
              Xi = `
// equirectangular helper functions
const float PI = 3.141592653589793;

vec2 toSpherical(vec3 dir) {
		return vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));
}

vec2 toSphericalUv(vec3 dir) {
		vec2 uv = toSpherical(dir) / vec2(PI * 2.0, PI) + 0.5;
		return vec2(uv.x, 1.0 - uv.y);
}
`,
              Pi = `

#ifdef MAPFLOAT
uniform float material_specularityFactor;
#endif

void getSpecularityFactor() {
		float specularityFactor = 1.0;

		#ifdef MAPFLOAT
		specularityFactor *= material_specularityFactor;
		#endif

		#ifdef MAPTEXTURE
		specularityFactor *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
		#endif

		#ifdef MAPVERTEX
		specularityFactor *= saturate(vVertexColor.$VC);
		#endif

		dSpecularityFactor = specularityFactor;
}
`,
              Zi = `
float getSpotEffect(vec3 lightSpotDir, float lightInnerConeAngle, float lightOuterConeAngle, vec3 lightDirNorm) {
		float cosAngle = dot(lightDirNorm, lightSpotDir);
		return smoothstep(lightOuterConeAngle, lightInnerConeAngle, cosAngle);
}
`,
              Ji = `
void main(void) {
		dReflection = vec4(0);

		#ifdef LIT_CLEARCOAT
		ccSpecularLight = vec3(0);
		ccReflection = vec3(0);
		#endif
`,
              Ni = `
void main(void) {
		gl_Position = getPosition();
`,
              Mi = `
		nineSlicedUv = vUv0;
		nineSlicedUv.y = 1.0 - nineSlicedUv.y;

`,
              bi = `
		vec2 tileMask = step(vMask, vec2(0.99999));
		vec2 tileSize = 0.5 * (innerOffset.xy + innerOffset.zw);
		vec2 tileScale = vec2(1.0) / (vec2(1.0) - tileSize);
		vec2 clampedUv = mix(innerOffset.xy * 0.5, vec2(1.0) - innerOffset.zw * 0.5, fract((vTiledUv - tileSize) * tileScale));
		clampedUv = clampedUv * atlasRect.zw + atlasRect.xy;
		nineSlicedUv = vUv0 * tileMask + clampedUv * (vec2(1.0) - tileMask);
		nineSlicedUv.y = 1.0 - nineSlicedUv.y;
		
`,
              _i = `
float exponent = VSM_EXPONENT;

depth = 2.0 * depth - 1.0;
depth =  exp(exponent * depth);
gl_FragColor = vec4(depth, depth*depth, 1.0, 1.0);
`,
              Qi = `
vec3 getTangent() {
		return normalize(dNormalMatrix * vertex_tangent.xyz);
}

vec3 getBinormal() {
		return cross(vNormalW, vTangentW) * vertex_tangent.w;
}
`,
              $i = `
void getTBN(vec3 tangent, vec3 binormal, vec3 normal) {
		dTBN = mat3(normalize(tangent), normalize(binormal), normalize(normal));
}
`,
              qi = `
uniform float tbnBasis;

// http://www.thetenthplanet.de/archives/1180
void getTBN(vec3 tangent, vec3 binormal, vec3 normal) {
		vec2 uv = $UV;

		// get edge vectors of the pixel triangle
		vec3 dp1 = dFdx( vPositionW );
		vec3 dp2 = dFdy( vPositionW );
		vec2 duv1 = dFdx( uv );
		vec2 duv2 = dFdy( uv );

		// solve the linear system
		vec3 dp2perp = cross( dp2, normal );
		vec3 dp1perp = cross( normal, dp1 );
		vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
		vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;

		// construct a scale-invariant frame
		float denom = max( dot(T,T), dot(B,B) );
		float invmax = (denom == 0.0) ? 0.0 : tbnBasis / sqrt( denom );
		dTBN = mat3(T * invmax, -B * invmax, normal );
}
`,
              en = `
void getTBN(vec3 tangent, vec3 binormal, vec3 normal) {
		dTBN = mat3(tangent, binormal, normal);
}
`,
              zi = `
void getTBN(vec3 tangent, vec3 binormal, vec3 normal) {

		vec3 B = cross(normal, vObjectSpaceUpW);
		vec3 T = cross(normal, B);

		if (dot(B,B)==0.0) // deal with case when vObjectSpaceUpW normal are parallel
		{
				float major=max(max(normal.x, normal.y), normal.z);

				if (normal.x == major)
				{
						B=cross(normal, vec3(0,1,0));
						T=cross(normal, B);
				}
				else if (normal.y == major)
				{
						B=cross(normal, vec3(0,0,1));
						T=cross(normal, B);
				}
				else if (normal.z == major)
				{
						B=cross(normal, vec3(1,0,0));
						T=cross(normal, B);
				}
		}

		dTBN = mat3(normalize(T), normalize(B), normalize(normal));
}
`,
              mi = `
vec4 texture2DSRGB(sampler2D tex, vec2 uv) {
		return gammaCorrectInput(texture2D(tex, uv));
}

vec4 texture2DSRGB(sampler2D tex, vec2 uv, float bias) {
		return gammaCorrectInput(texture2D(tex, uv, bias));
}

vec3 texture2DRGBM(sampler2D tex, vec2 uv) {
		return decodeRGBM(texture2D(tex, uv));
}

vec3 texture2DRGBM(sampler2D tex, vec2 uv, float bias) {
		return decodeRGBM(texture2D(tex, uv, bias));
}

vec3 texture2DRGBE(sampler2D tex, vec2 uv) {
		return decodeRGBM(texture2D(tex, uv));
}

vec3 texture2DRGBE(sampler2D tex, vec2 uv, float bias) {
		return decodeRGBM(texture2D(tex, uv, bias));
}
`,
              tn = `
#ifdef MAPFLOAT
uniform float material_thickness;
#endif

void getThickness() {
		dThickness = 1.0;

		#ifdef MAPFLOAT
		dThickness *= material_thickness;
		#endif

		#ifdef MAPTEXTURE
		dThickness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
		#endif

		#ifdef MAPVERTEX
		dThickness *= saturate(vVertexColor.$VC);
		#endif
}
`,
              Wi = `
uniform float exposure;

vec3 toneMap(vec3 color) {
		float tA = 2.51;
		float tB = 0.03;
		float tC = 2.43;
		float tD = 0.59;
		float tE = 0.14;
		vec3 x = color * exposure;
		return (x*(tA*x+tB))/(x*(tC*x+tD)+tE);
}
`,
              sn = `
uniform float exposure;

// ACES approximation by Stephen Hill

// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT
const mat3 ACESInputMat = mat3(
		0.59719, 0.35458, 0.04823,
		0.07600, 0.90834, 0.01566,
		0.02840, 0.13383, 0.83777
);

// ODT_SAT => XYZ => D60_2_D65 => sRGB
const mat3 ACESOutputMat = mat3(
		 1.60475, -0.53108, -0.07367,
		-0.10208,  1.10813, -0.00605,
		-0.00327, -0.07276,  1.07602
);

vec3 RRTAndODTFit(vec3 v) {
		vec3 a = v * (v + 0.0245786) - 0.000090537;
		vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;
		return a / b;
}

vec3 toneMap(vec3 color) {
		color *= exposure / 0.6;
		color = color * ACESInputMat;

		// Apply RRT and ODT
		color = RRTAndODTFit(color);
		color = color * ACESOutputMat;

		// Clamp to [0, 1]
		color = clamp(color, 0.0, 1.0);

		return color;
}
`,
              nn = `
const float A =  0.15;
const float B =  0.50;
const float C =  0.10;
const float D =  0.20;
const float E =  0.02;
const float F =  0.30;
const float W =  11.2;

uniform float exposure;

vec3 uncharted2Tonemap(vec3 x) {
	 return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;
}

vec3 toneMap(vec3 color) {
		color = uncharted2Tonemap(color * exposure);
		vec3 whiteScale = 1.0 / uncharted2Tonemap(vec3(W,W,W));
		color = color * whiteScale;

		return color;
}
`,
              ki = `
uniform float exposure;

vec3 toneMap(vec3 color) {
		color *= exposure;
		const float  A = 0.22, B = 0.3, C = .1, D = 0.2, E = .01, F = 0.3;
		const float Scl = 1.25;

		vec3 h = max( vec3(0.0), color - vec3(0.004) );
		return (h*((Scl*A)*h+Scl*vec3(C*B,C*B,C*B))+Scl*vec3(D*E,D*E,D*E)) / (h*(A*h+vec3(B,B,B))+vec3(D*F,D*F,D*F)) - Scl*vec3(E/F,E/F,E/F);
}
`,
              rn = `
uniform float exposure;

vec3 toneMap(vec3 color) {
		return color * exposure;
}
`,
              Vi = `
vec3 toneMap(vec3 color) {
		return color;
}
`,
              Gi = `
#ifdef PIXELSNAP
uniform vec4 uScreenSize;
#endif

#ifdef SCREENSPACE
uniform float projectionFlipY;
#endif

#ifdef MORPHING
uniform vec4 morph_weights_a;
uniform vec4 morph_weights_b;
#endif

#ifdef MORPHING_TEXTURE_BASED
		uniform vec4 morph_tex_params;

		#ifdef WEBGPU
				ivec2 getTextureMorphCoords() {

						// turn morph_vertex_id into int grid coordinates
						ivec2 textureSize = ivec2(morph_tex_params.xy);
						int morphGridV = int(morph_vertex_id / textureSize.x);
						int morphGridU = int(morph_vertex_id - (morphGridV * textureSize.x));
						morphGridV = textureSize.y - morphGridV - 1;
						return ivec2(morphGridU, morphGridV);
				}
		#else
				vec2 getTextureMorphCoords() {
						vec2 textureSize = morph_tex_params.xy;
						vec2 invTextureSize = morph_tex_params.zw;

						// turn morph_vertex_id into int grid coordinates
						float morphGridV = floor(morph_vertex_id * invTextureSize.x);
						float morphGridU = morph_vertex_id - (morphGridV * textureSize.x);

						// convert grid coordinates to uv coordinates with half pixel offset
						return vec2(morphGridU, morphGridV) * invTextureSize + (0.5 * invTextureSize);
				}
		#endif

#endif

#ifdef MORPHING_TEXTURE_BASED_POSITION
uniform highp sampler2D morphPositionTex;
#endif

mat4 getModelMatrix() {
		#ifdef DYNAMICBATCH
		return getBoneMatrix(vertex_boneIndices);
		#elif defined(SKIN)
		return matrix_model * getSkinMatrix(vertex_boneIndices, vertex_boneWeights);
		#elif defined(INSTANCING)
		return mat4(instance_line1, instance_line2, instance_line3, instance_line4);
		#else
		return matrix_model;
		#endif
}

vec4 getPosition() {
		dModelMatrix = getModelMatrix();
		vec3 localPos = vertex_position;

		#ifdef NINESLICED
		// outer and inner vertices are at the same position, scale both
		localPos.xz *= outerScale;

		// offset inner vertices inside
		// (original vertices must be in [-1;1] range)
		vec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));
		vec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));
		localPos.xz += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;

		vTiledUv = (localPos.xz - outerScale + innerOffset.xy) * -0.5 + 1.0; // uv = local pos - inner corner

		localPos.xz *= -0.5; // move from -1;1 to -0.5;0.5
		localPos = localPos.xzy;
		#endif

		#ifdef MORPHING
		#ifdef MORPHING_POS03
		localPos.xyz += morph_weights_a[0] * morph_pos0;
		localPos.xyz += morph_weights_a[1] * morph_pos1;
		localPos.xyz += morph_weights_a[2] * morph_pos2;
		localPos.xyz += morph_weights_a[3] * morph_pos3;
		#endif // MORPHING_POS03
		#ifdef MORPHING_POS47
		localPos.xyz += morph_weights_b[0] * morph_pos4;
		localPos.xyz += morph_weights_b[1] * morph_pos5;
		localPos.xyz += morph_weights_b[2] * morph_pos6;
		localPos.xyz += morph_weights_b[3] * morph_pos7;
		#endif // MORPHING_POS47
		#endif // MORPHING

		#ifdef MORPHING_TEXTURE_BASED_POSITION

				#ifdef WEBGPU
						ivec2 morphUV = getTextureMorphCoords();
						vec3 morphPos = texelFetch(morphPositionTex, ivec2(morphUV), 0).xyz;
				#else
						vec2 morphUV = getTextureMorphCoords();
						vec3 morphPos = texture2D(morphPositionTex, morphUV).xyz;
				#endif

				localPos += morphPos;

		#endif

		vec4 posW = dModelMatrix * vec4(localPos, 1.0);
		#ifdef SCREENSPACE
		posW.zw = vec2(0.0, 1.0);
		#endif
		dPositionW = posW.xyz;

		vec4 screenPos;
		#ifdef UV1LAYOUT
		screenPos = vec4(vertex_texCoord1.xy * 2.0 - 1.0, 0.5, 1);
		#else
		#ifdef SCREENSPACE
		screenPos = posW;
		screenPos.y *= projectionFlipY;
		#else
		screenPos = matrix_viewProjection * posW;
		#endif

		#ifdef PIXELSNAP
		// snap vertex to a pixel boundary
		screenPos.xy = (screenPos.xy * 0.5) + 0.5;
		screenPos.xy *= uScreenSize.xy;
		screenPos.xy = floor(screenPos.xy);
		screenPos.xy *= uScreenSize.zw;
		screenPos.xy = (screenPos.xy * 2.0) - 1.0;
		#endif
		#endif

		return screenPos;
}

vec3 getWorldPosition() {
		return dPositionW;
}
`,
              an = `
attribute vec3 vertex_position;

uniform mat4 matrix_model;
uniform mat4 matrix_viewProjection;

vec3 dPositionW;
mat4 dModelMatrix;
`,
              on = `

#ifdef MAPFLOAT
uniform float material_refraction;
#endif

void getRefraction() {
		float refraction = 1.0;

		#ifdef MAPFLOAT
		refraction = material_refraction;
		#endif

		#ifdef MAPTEXTURE
		refraction *= texture2DBias($SAMPLER, $UV, textureBias).$CH;
		#endif

		#ifdef MAPVERTEX
		refraction *= saturate(vVertexColor.$VC);
		#endif

		dTransmission = refraction;
}
`,
              oi = `
#ifdef NINESLICED
vec2 getUv0() {
		vec2 uv = vertex_position.xz;

		// offset inner vertices inside
		// (original vertices must be in [-1;1] range)
		vec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));
		vec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));
		uv += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;

		uv = uv * -0.5 + 0.5;
		uv = uv * atlasRect.zw + atlasRect.xy;

		vMask = vertex_texCoord0.xy;

		return uv;
}
#else
vec2 getUv0() {
		return vertex_texCoord0;
}
#endif
`,
              ii = `
vec2 getUv1() {
		return vertex_texCoord1;
}
`,
              ln = `
void getViewDir() {
		dViewDirW = normalize(view_position - vPositionW);
}
`,
              li = `
#ifndef VIEWMATRIX
#define VIEWMATRIX
uniform mat4 matrix_view;
#endif

vec3 getViewNormal() {
		return mat3(matrix_view) * vNormalW;
}
`,
              hn = a(8694),
              cn = a(9453);
            const Ls = {
              alphaTestPS: x,
              ambientConstantPS: T,
              ambientEnvPS: g,
              ambientSHPS: c,
              aoPS: d,
              aoDetailMapPS: h,
              aoDiffuseOccPS: f,
              aoSpecOccPS: s,
              aoSpecOccConstPS: l,
              aoSpecOccConstSimplePS: n,
              aoSpecOccSimplePS: o,
              basePS: i,
              baseVS: e,
              baseNineSlicedPS: t,
              baseNineSlicedVS: r,
              baseNineSlicedTiledPS: u,
              biasConstPS: y,
              blurVSMPS: p,
              clearCoatPS: _,
              clearCoatGlossPS: m,
              clearCoatNormalPS: E,
              clusteredLightCookiesPS: P,
              clusteredLightShadowsPS: I,
              clusteredLightUtilsPS: v,
              clusteredLightPS: A,
              combinePS: B,
              cookiePS: C,
              cubeMapProjectBoxPS: w,
              cubeMapProjectNonePS: k,
              cubeMapRotatePS: K,
              debugOutputPS: te,
              debugProcessFrontendPS: X,
              detailModesPS: ne,
              diffusePS: Y,
              diffuseDetailMapPS: Z,
              decodePS: $,
              emissivePS: ye,
              encodePS: pe,
              endPS: O,
              endVS: me,
              envAtlasPS: N,
              envConstPS: V,
              envMultiplyPS: L,
              extensionPS: J,
              extensionVS: ae,
              falloffInvSquaredPS: R,
              falloffLinearPS: j,
              fixCubemapSeamsNonePS: se,
              fixCubemapSeamsStretchPS: ce,
              floatUnpackingPS: ie,
              fogExpPS: b,
              fogExp2PS: M,
              fogLinearPS: F,
              fogNonePS: z,
              fresnelSchlickPS: oe,
              fullscreenQuadPS: de,
              fullscreenQuadVS: ge,
              gamma1_0PS: Re,
              gamma2_2PS: Te,
              gles2PS: Ne.Z,
              gles3PS: Le.Z,
              gles3VS: ke.Z,
              glossPS: ht,
              iridescenceDiffractionPS: _e,
              iridescencePS: U,
              iridescenceThicknessPS: H,
              instancingVS: Ee,
              iorPS: G,
              lightDiffuseLambertPS: Q,
              lightDirPointPS: q,
              lightmapAddPS: xe,
              lightmapDirAddPS: be,
              lightmapDirPS: Pe,
              lightmapSinglePS: we,
              lightSpecularAnisoGGXPS: Oe,
              lightSpecularBlinnPS: $e,
              lightSpecularPhongPS: gt,
              lightSheenPS: qe,
              linearizeDepthPS: Tt,
              litShaderArgsPS: Mt,
              ltcPS: Dt,
              metalnessPS: ut,
              metalnessModulatePS: xt,
              msdfPS: At,
              msdfVS: jt,
              normalVS: Gt,
              normalDetailMapPS: yt,
              normalInstancedVS: Ae,
              normalMapPS: Xe,
              normalSkinnedVS: Ye,
              normalXYPS: it,
              normalXYZPS: st,
              opacityPS: He,
              outputPS: at,
              outputAlphaPS: Pt,
              outputAlphaOpaquePS: he,
              outputAlphaPremulPS: fe,
              outputTex2DPS: Ie,
              packDepthPS: ue,
              sheenPS: De,
              sheenGlossPS: et,
              parallaxPS: Ze,
              particlePS: Ve,
              particleVS: tt,
              particleAnimFrameClampVS: Be,
              particleAnimFrameLoopVS: ot,
              particleAnimTexVS: Qe,
              particleInputFloatPS: mt,
              particleInputRgba8PS: je,
              particleOutputFloatPS: lt,
              particleOutputRgba8PS: Et,
              particleUpdaterAABBPS: ct,
              particleUpdaterEndPS: pt,
              particleUpdaterInitPS: vt,
              particleUpdaterNoRespawnPS: Fe,
              particleUpdaterOnStopPS: Yt,
              particleUpdaterRespawnPS: Ot,
              particleUpdaterSpherePS: Rt,
              particleUpdaterStartPS: Kt,
              particle_billboardVS: Lt,
              particle_blendAddPS: Ft,
              particle_blendMultiplyPS: Jt,
              particle_blendNormalPS: zt,
              particle_cpuVS: ss,
              particle_cpu_endVS: qt,
              particle_customFaceVS: fs,
              particle_endPS: ls,
              particle_endVS: Es,
              particle_halflambertPS: Ke,
              particle_initVS: hs,
              particle_lambertPS: is,
              particle_lightingPS: ys,
              particle_localShiftVS: ps,
              particle_meshVS: Ns,
              particle_normalVS: zs,
              particle_normalMapPS: bs,
              particle_pointAlongVS: Ws,
              particle_softPS: Ss,
              particle_softVS: ws,
              particle_stretchVS: ks,
              particle_TBNVS: Ys,
              particle_wrapVS: Xs,
              reflDirPS: Zs,
              reflDirAnisoPS: We,
              reflectionCCPS: ft,
              reflectionCubePS: bt,
              reflectionEnvHQPS: ts,
              reflectionEnvPS: Qt,
              reflectionSpherePS: rs,
              reflectionSphereLowPS: Ps,
              reflectionSheenPS: Ts,
              refractionCubePS: ei,
              refractionDynamicPS: Js,
              reprojectPS: ti,
              screenDepthPS: Bs,
              shadowCascadesPS: si,
              shadowEVSMPS: Ti,
              shadowEVSMnPS: xi,
              shadowPCSSPS: Is,
              shadowSampleCoordPS: ai,
              shadowStandardPS: Qs,
              shadowStandardGL2PS: ji,
              shadowVSM8PS: Di,
              shadowVSM_commonPS: Yi,
              skinBatchConstVS: Ai,
              skinBatchTexVS: Oi,
              skinConstVS: Ci,
              skinTexVS: Li,
              skyboxEnvPS: Bi,
              skyboxHDRPS: Fi,
              skyboxVS: Ui,
              specularPS: pi,
              sphericalPS: Xi,
              specularityFactorPS: Pi,
              spotPS: Zi,
              startPS: Ji,
              startVS: Ni,
              startNineSlicedPS: Mi,
              startNineSlicedTiledPS: bi,
              storeEVSMPS: _i,
              tangentBinormalVS: Qi,
              TBNPS: $i,
              TBNderivativePS: qi,
              TBNfastPS: en,
              TBNObjectSpacePS: zi,
              textureSamplePS: mi,
              thicknessPS: tn,
              tonemappingAcesPS: Wi,
              tonemappingAces2PS: sn,
              tonemappingFilmicPS: nn,
              tonemappingHejlPS: ki,
              tonemappingLinearPS: rn,
              tonemappingNonePS: Vi,
              transformVS: Gi,
              transformDeclVS: an,
              transmissionPS: on,
              uv0VS: oi,
              uv1VS: ii,
              viewDirPS: ln,
              viewNormalVS: li,
              webgpuPS: hn.Z,
              webgpuVS: cn.Z,
            };
          },
          192: (Se, W, a) => {
            "use strict";
            a.d(W, { N: () => g, f: () => c });
            var x = a(7338);
            const T = new x.c();
            function g(d) {
              return T.get(d);
            }
            function c(d, h) {
              T.get(d, () => h);
            }
          },
          3587: (Se, W, a) => {
            "use strict";
            a.d(W, { _: () => f });
            var x = a(2752),
              T = a(9795),
              g = a(6977),
              c = a(3114),
              d = a(1585),
              h = a(7474);
            class f {
              constructor(l, n) {
                (this.processedCache = new Map()),
                  (this.definitionsCache = new Map()),
                  (this._device = l),
                  (this._generators = {}),
                  (this._isClearingCache = !1),
                  (this._precached = !1),
                  (this._programsCollection = []),
                  (this._defaultStdMatOption = new h.J()),
                  (this._defaultStdMatOptionMin = new h.J()),
                  n.shaderOptBuilder.updateRef(
                    this._defaultStdMatOption,
                    {},
                    n,
                    null,
                    [],
                    c.lW,
                    null
                  ),
                  n.shaderOptBuilder.updateMinRef(
                    this._defaultStdMatOptionMin,
                    {},
                    n,
                    null,
                    c.w1,
                    null
                  ),
                  l.on("destroy:shader", (o) => {
                    this.removeFromCache(o);
                  });
              }
              destroy() {
                this.clearCache();
              }
              register(l, n) {
                this.isRegistered(l) || (this._generators[l] = n);
              }
              unregister(l) {
                this.isRegistered(l) && delete this._generators[l];
              }
              isRegistered(l) {
                return this._generators[l] !== void 0;
              }
              generateShaderDefinition(l, n, o, i) {
                let e = this.definitionsCache.get(o);
                if (!e) {
                  var t, r, u;
                  let y;
                  (t = i.litOptions) != null &&
                    t.lights &&
                    ((y = i.litOptions.lights),
                    (i.litOptions.lights = y.map(function (_) {
                      const m = _.clone ? _.clone() : _;
                      return (m.key = _.key), m;
                    }))),
                    this.storeNewProgram(n, i),
                    (r = i.litOptions) != null &&
                      r.lights &&
                      (i.litOptions.lights = y),
                    this._precached;
                  const p = this._device;
                  (e = l.createShaderDefinition(p, i)),
                    (e.name =
                      (u = e.name) != null
                        ? u
                        : i.pass
                        ? `${n}-pass:${i.pass}`
                        : n),
                    this.definitionsCache.set(o, e);
                }
                return e;
              }
              getCachedShader(l) {
                return this.processedCache.get(l);
              }
              setCachedShader(l, n) {
                this.processedCache.set(l, n);
              }
              getProgram(l, n, o, i) {
                const e = this._generators[l];
                if (!e) return null;
                const t = e.generateKey(n),
                  r = (0, x.u)(t),
                  u = o.generateKey(this._device),
                  y = (0, x.u)(u),
                  p = `${r}#${y}`;
                let _ = this.getCachedShader(p);
                if (!_) {
                  const m = this.generateShaderDefinition(e, l, r, n);
                  let E = "",
                    v;
                  n.pass !== void 0 &&
                    ((v = d.T.get(this._device).getByIndex(n.pass)),
                    (E = `-${v.name}`)),
                    this._device.fire("shader:generate", {
                      userMaterialId: i,
                      shaderPassInfo: v,
                      definition: m,
                    });
                  const P = {
                    name: `${m.name}${E}-proc`,
                    attributes: m.attributes,
                    vshader: m.vshader,
                    fshader: m.fshader,
                    processingOptions: o,
                  };
                  (_ = new g.e(this._device, P)), this.setCachedShader(p, _);
                }
                return _;
              }
              storeNewProgram(l, n) {
                let o = {};
                if (l === "standard") {
                  const i = this._getDefaultStdMatOptions(n.pass);
                  for (const e in n)
                    ((n.hasOwnProperty(e) && i[e] !== n[e]) || e === "pass") &&
                      (o[e] = n[e]);
                  for (const e in n.litOptions) o[e] = n.litOptions[e];
                } else o = n;
                this._programsCollection.push(
                  JSON.stringify({ name: l, options: o })
                );
              }
              dumpPrograms() {
                let l = `let device = pc.app ? pc.app.graphicsDevice : pc.Application.getApplication().graphicsDevice;
`;
                (l += "let shaders = ["),
                  this._programsCollection[0] &&
                    (l +=
                      `
	` + this._programsCollection[0]);
                for (let o = 1; o < this._programsCollection.length; ++o)
                  l +=
                    `,
	` + this._programsCollection[o];
                (l += `
];
`),
                  (l += `device.getProgramLibrary().precompile(shaders);
`),
                  (l +=
                    'if (pc.version != "' +
                    T.i8 +
                    '" || pc.revision != "' +
                    T.LB +
                    `")
`),
                  (l +=
                    '	console.warn("precompile-shaders.js: engine version mismatch, rebuild shaders lib with current engine");');
                const n = document.createElement("a");
                n.setAttribute(
                  "href",
                  "data:text/plain;charset=utf-8," + encodeURIComponent(l)
                ),
                  n.setAttribute("download", "precompile-shaders.js"),
                  (n.style.display = "none"),
                  document.body.appendChild(n),
                  n.click(),
                  document.body.removeChild(n);
              }
              clearCache() {
                (this._isClearingCache = !0),
                  this.processedCache.forEach((l) => {
                    l.destroy();
                  }),
                  this.processedCache.clear(),
                  (this._isClearingCache = !1);
              }
              removeFromCache(l) {
                this._isClearingCache ||
                  this.processedCache.forEach((n, o) => {
                    l === n && this.processedCache.delete(o);
                  });
              }
              _getDefaultStdMatOptions(l) {
                const n = d.T.get(this._device).getByIndex(l);
                return l === c.Jb || l === c.WW || n.isShadow
                  ? this._defaultStdMatOptionMin
                  : this._defaultStdMatOption;
              }
              precompile(l) {
                if (l) {
                  const n = new Array(l.length);
                  for (let o = 0; o < l.length; o++) {
                    if (l[o].name === "standard") {
                      const i = l[o].options,
                        e = this._getDefaultStdMatOptions(i.pass);
                      for (const t in e)
                        e.hasOwnProperty(t) && i[t] === void 0 && (i[t] = e[t]);
                    }
                    n[o] = this.getProgram(l[o].name, l[o].options);
                  }
                }
                this._precached = !0;
              }
            }
          },
          2172: (Se, W, a) => {
            "use strict";
            a.d(W, {
              a7: () => f,
              aJ: () => d,
              li: () => g,
              oY: () => h,
              ph: () => c,
              ut: () => s,
            });
            var x = a(3114),
              T = a(3200);
            function g(l, n) {
              return (
                n || (n = T.n),
                l === x.DZ || l === x.O1
                  ? n.gamma2_2PS
                    ? n.gamma2_2PS
                    : T.n.gamma2_2PS
                  : l === x.CH
                  ? `#define HDR
` + (n.gamma2_2PS ? n.gamma2_2PS : T.n.gamma2_2PS)
                  : n.gamma1_0PS
                  ? n.gamma1_0PS
                  : T.n.gamma1_0PS
              );
            }
            function c(l, n) {
              return (
                n || (n = T.n),
                l === x.XT
                  ? n.tonemappingFilmicPS
                    ? n.tonemappingFilmicPS
                    : T.n.tonemappingFilmicPS
                  : l === x.Fz
                  ? n.tonemappingLinearPS
                    ? n.tonemappingLinearPS
                    : T.n.tonemappingLinearPS
                  : l === x.X1
                  ? n.tonemappingHejlPS
                    ? n.tonemappingHejlPS
                    : T.n.tonemappingHejlPS
                  : l === x.pF
                  ? n.tonemappingAcesPS
                    ? n.tonemappingAcesPS
                    : T.n.tonemappingAcesPS
                  : l === x.iC
                  ? n.tonemappingAces2PS
                    ? n.tonemappingAces2PS
                    : T.n.tonemappingAces2PS
                  : n.tonemapingNonePS
                  ? n.tonemapingNonePS
                  : T.n.tonemappingNonePS
              );
            }
            function d(l, n) {
              return (
                n || (n = T.n),
                l === "linear"
                  ? n.fogLinearPS
                    ? n.fogLinearPS
                    : T.n.fogLinearPS
                  : l === "exp"
                  ? n.fogExpPS
                    ? n.fogExpPS
                    : T.n.fogExpPS
                  : l === "exp2"
                  ? n.fogExp2PS
                    ? n.fogExp2PS
                    : T.n.fogExp2PS
                  : n.fogNonePS
                  ? n.fogNonePS
                  : T.n.fogNonePS
              );
            }
            function h(l, n) {
              return (
                n || (n = T.n),
                l.supportsBoneTextures
                  ? n.skinTexVS
                  : "#define BONE_LIMIT " +
                    l.getBoneLimit() +
                    `
` +
                    n.skinConstVS
              );
            }
            function f() {
              return `void main(void)
{
`;
            }
            function s() {
              return `}
`;
            }
          },
          4976: (Se, W, a) => {
            "use strict";
            a.d(W, { W: () => T });
            var x = a(3114);
            const T = {
              generateKey(g) {
                return (
                  "lit" +
                  Object.keys(g)
                    .sort()
                    .map((c) =>
                      c === "chunks"
                        ? T.generateChunksKey(g)
                        : c === "lights"
                        ? T.generateLightsKey(g)
                        : c + g[c]
                    ).join(`
`)
                );
              },
              generateLightsKey(g) {
                return (
                  "lights:" +
                  g.lights
                    .map((c) =>
                      !g.clusteredLightingEnabled || c._type === x.WQ
                        ? `${c.key},`
                        : ""
                    )
                    .join("")
                );
              },
              generateChunksKey(g) {
                var c;
                return (
                  `chunks:
` +
                  Object.keys((c = g.chunks) != null ? c : {})
                    .sort()
                    .map((d) => d + g.chunks[d])
                    .join("")
                );
              },
            };
          },
          3054: (Se, W, a) => {
            "use strict";
            a.d(W, { F: () => T });
            var x = a(3114);
            class T {
              constructor() {
                (this.hasTangents = !1),
                  (this.chunks = {}),
                  (this.pass = 0),
                  (this.alphaTest = !1),
                  (this.blendType = x.He),
                  (this.separateAmbient = !1),
                  (this.screenSpace = !1),
                  (this.skin = !1),
                  (this.useInstancing = !1),
                  (this.useMorphPosition = !1),
                  (this.useMorphNormal = !1),
                  (this.useMorphTextureBased = !1),
                  (this.nineSlicedMode = 0),
                  (this.clusteredLightingEnabled = !0),
                  (this.clusteredLightingCookiesEnabled = !1),
                  (this.clusteredLightingShadowsEnabled = !1),
                  (this.clusteredLightingShadowType = 0),
                  (this.clusteredLightingAreaLightsEnabled = !1),
                  (this.vertexColors = !1),
                  (this.lightMapEnabled = !1),
                  (this.dirLightMapEnabled = !1),
                  (this.useHeights = !1),
                  (this.useNormals = !1),
                  (this.useClearCoatNormals = !1),
                  (this.useAo = !1),
                  (this.diffuseMapEnabled = !1),
                  (this.useAmbientTint = !1),
                  (this.customFragmentShader = null),
                  (this.pixelSnap = !1),
                  (this.shadingModel = 0),
                  (this.ambientSH = !1),
                  (this.fastTbn = !1),
                  (this.twoSidedLighting = !1),
                  (this.occludeDirect = !1),
                  (this.occludeSpecular = 0),
                  (this.occludeSpecularFloat = !1),
                  (this.useMsdf = !1),
                  (this.msdfTextAttribute = !1),
                  (this.alphaToCoverage = !1),
                  (this.opacityFadesSpecular = !1),
                  (this.cubeMapProjection = 0),
                  (this.conserveEnergy = !1),
                  (this.useSpecular = !1),
                  (this.useSpecularityFactor = !1),
                  (this.enableGGXSpecular = !1),
                  (this.fresnelModel = 0),
                  (this.useRefraction = !1),
                  (this.useClearCoat = !1),
                  (this.useSheen = !1),
                  (this.useIridescence = !1),
                  (this.useMetalness = !1),
                  (this.useDynamicRefraction = !1),
                  (this.fog = x.YV),
                  (this.gamma = x.Ie),
                  (this.toneMap = -1),
                  (this.fixSeams = !1),
                  (this.reflectionSource = null),
                  (this.reflectionEncoding = null),
                  (this.reflectionCubemapEncoding = null),
                  (this.ambientSource = "constant"),
                  (this.ambientEncoding = null),
                  (this.skyboxIntensity = 1),
                  (this.useCubeMapRotation = !1),
                  (this.lightMapWithoutAmbient = !1),
                  (this.lights = []),
                  (this.noShadow = !1),
                  (this.lightMaskDynamic = 0);
              }
            }
          },
          1475: (Se, W, a) => {
            "use strict";
            a.d(W, { i: () => i });
            var x = a(7921),
              T = a(3200),
              g = a(7198),
              c = a(3114),
              d = a(8902),
              h = a(1585),
              f = a(2172),
              s = a(3862),
              l = a(7790);
            const n = {
                vertex_normal: x.SA$,
                vertex_tangent: x.ipN,
                vertex_texCoord0: x.$fY,
                vertex_texCoord1: x.Q0q,
                vertex_color: x.wD$,
                vertex_boneWeights: x.d1j,
                vertex_boneIndices: x.MgX,
              },
              o = {
                vVertexColor: "vec4",
                vPositionW: "vec3",
                vNormalV: "vec3",
                vNormalW: "vec3",
                vTangentW: "vec3",
                vBinormalW: "vec3",
                vObjectSpaceUpW: "vec3",
                vUv0: "vec2",
                vUv1: "vec2",
              };
            class i {
              constructor(t, r) {
                if (
                  ((this.device = t),
                  (this.options = r),
                  (this.attributes = { vertex_position: x.Q5v }),
                  r.chunks)
                ) {
                  const u = r.chunks;
                  this.chunks = Object.create(T.n);
                  for (const y in T.n)
                    if (u.hasOwnProperty(y)) {
                      const p = u[y];
                      for (const _ in n)
                        n.hasOwnProperty(_) &&
                          p.indexOf(_) >= 0 &&
                          (this.attributes[_] = n[_]);
                      this.chunks[y] = p;
                    }
                } else this.chunks = T.n;
                (this.shaderPassInfo = h.T.get(this.device).getByIndex(r.pass)),
                  (this.shadowPass = this.shaderPassInfo.isShadow),
                  (this.lighting =
                    r.lights.length > 0 ||
                    r.dirLightMapEnabled ||
                    r.clusteredLightingEnabled),
                  (this.reflections = !!r.reflectionSource),
                  (this.needsNormal =
                    this.lighting ||
                    this.reflections ||
                    r.useSpecular ||
                    r.ambientSH ||
                    r.useHeights ||
                    r.enableGGXSpecular ||
                    (r.clusteredLightingEnabled && !this.shadowPass) ||
                    r.useClearCoatNormals),
                  (this.needsNormal = this.needsNormal && !this.shadowPass),
                  (this.needsSceneColor = r.useDynamicRefraction),
                  (this.needsScreenSize = r.useDynamicRefraction),
                  (this.needsTransforms = r.useDynamicRefraction),
                  (this.varyings = ""),
                  (this.varyingDefines = ""),
                  (this.vshader = null),
                  (this.frontendDecl = null),
                  (this.frontendCode = null),
                  (this.frontendFunc = null),
                  (this.lightingUv = null),
                  (this.defines = []),
                  (this.fshader = null);
              }
              _vsAddBaseCode(t, r, u) {
                return (
                  (t += r.baseVS),
                  (u.nineSlicedMode === c.ei || u.nineSlicedMode === c.DD) &&
                    (t += r.baseNineSlicedVS),
                  t
                );
              }
              _vsAddTransformCode(t, r, u, y) {
                return (t += this.chunks.transformVS), t;
              }
              _setMapTransform(t, r, u, y) {
                const p = u + y * 100;
                if (!t[3][p]) {
                  const _ = `texture_${r}MapTransform`;
                  (t[0] += `uniform vec3 ${_}0;
`),
                    (t[0] += `uniform vec3 ${_}1;
`),
                    (t[1] += `varying vec2 vUV${y}_${u};
`),
                    (t[2] += `   vUV${y}_${u} = vec2(dot(vec3(uv${y}, 1), ${_}0), dot(vec3(uv${y}, 1), ${_}1));
`),
                    (t[3][p] = !0);
                }
                return t;
              }
              _fsGetBaseCode() {
                const t = this.options,
                  r = this.chunks;
                let u = this.chunks.basePS;
                return (
                  t.nineSlicedMode === c.ei
                    ? (u += r.baseNineSlicedPS)
                    : t.nineSlicedMode === c.DD &&
                      (u += r.baseNineSlicedTiledPS),
                  u
                );
              }
              _fsGetStartCode(t, r, u, y) {
                let p = u.startPS;
                return (
                  y.nineSlicedMode === c.ei
                    ? (p += u.startNineSlicedPS)
                    : y.nineSlicedMode === c.DD &&
                      (p += u.startNineSlicedTiledPS),
                  p
                );
              }
              _getLightSourceShapeString(t) {
                switch (t) {
                  case c.XD:
                    return "Rect";
                  case c.Lf:
                    return "Disk";
                  case c.zy:
                    return "Sphere";
                  default:
                    return "";
                }
              }
              generateVertexShader(t, r, u) {
                const y = this.device,
                  p = this.options,
                  _ = this.chunks;
                let m = "",
                  E = "";
                (m = this._vsAddBaseCode(m, _, p)),
                  (E += `   vPositionW    = getWorldPosition();
`),
                  this.options.pass === c.Jb &&
                    ((m += `varying float vDepth;
`),
                    (m += `#ifndef VIEWMATRIX
`),
                    (m += `#define VIEWMATRIX
`),
                    (m += `uniform mat4 matrix_view;
`),
                    (m += `#endif
`),
                    (m += `#ifndef CAMERAPLANES
`),
                    (m += `#define CAMERAPLANES
`),
                    (m += `uniform vec4 camera_params;

`),
                    (m += `#endif
`),
                    (E += `    vDepth = -(matrix_view * vec4(vPositionW,1.0)).z * camera_params.x;
`)),
                  this.options.useInstancing &&
                    ((this.attributes.instance_line1 = x.gLS),
                    (this.attributes.instance_line2 = x.OrD),
                    (this.attributes.instance_line3 = x.nKe),
                    (this.attributes.instance_line4 = x.s36),
                    (m += _.instancingVS)),
                  this.needsNormal &&
                    ((this.attributes.vertex_normal = x.SA$),
                    (E += `   vNormalW = getNormal();
`),
                    p.reflectionSource === "sphereMap" &&
                      y.fragmentUniformsCount <= 16 &&
                      ((m += _.viewNormalVS),
                      (E += `   vNormalV    = getViewNormal();
`)),
                    p.hasTangents &&
                    (p.useHeights || p.useNormals || p.enableGGXSpecular)
                      ? ((this.attributes.vertex_tangent = x.ipN),
                        (m += _.tangentBinormalVS),
                        (E += `   vTangentW   = getTangent();
`),
                        (E += `   vBinormalW  = getBinormal();
`))
                      : (p.enableGGXSpecular || !y.extStandardDerivatives) &&
                        (E += `   vObjectSpaceUpW = normalize(dNormalMatrix * vec3(0, 1, 0));
`));
                const v = 2;
                for (let A = 0; A < v; A++)
                  t[A] &&
                    ((this.attributes["vertex_texCoord" + A] = "TEXCOORD" + A),
                    (m += _["uv" + A + "VS"]),
                    (E +=
                      "   vec2 uv" +
                      A +
                      " = getUv" +
                      A +
                      `();
`)),
                    r[A] &&
                      (E +=
                        "   vUv" +
                        A +
                        " = uv" +
                        A +
                        `;
`);
                const P = [m, this.varyings, E, []];
                if (
                  (u.forEach((A) => {
                    this._setMapTransform(P, A.name, A.id, A.uv);
                  }),
                  (m = P[0]),
                  (this.varyings = P[1]),
                  (E = P[2]),
                  p.vertexColors &&
                    ((this.attributes.vertex_color = x.wD$),
                    (E += `   vVertexColor = vertex_color;
`)),
                  p.useMsdf &&
                    p.msdfTextAttribute &&
                    ((this.attributes.vertex_outlineParameters = x.syi),
                    (this.attributes.vertex_shadowParameters = x.ScY),
                    (E += `    unpackMsdfParams();
`),
                    (m += _.msdfVS)),
                  p.useMorphPosition || p.useMorphNormal)
                )
                  if (p.useMorphTextureBased) {
                    (m += `#define MORPHING_TEXTURE_BASED
`),
                      p.useMorphPosition &&
                        (m += `#define MORPHING_TEXTURE_BASED_POSITION
`),
                      p.useMorphNormal &&
                        (m += `#define MORPHING_TEXTURE_BASED_NORMAL
`),
                      (this.attributes.morph_vertex_id = x.s36);
                    const A = y.isWebGPU ? "uint" : "float";
                    m += `attribute ${A} morph_vertex_id;
`;
                  } else
                    (m += `#define MORPHING
`),
                      p.useMorphPosition
                        ? ((this.attributes.morph_pos0 = x.syi),
                          (this.attributes.morph_pos1 = x.ScY),
                          (this.attributes.morph_pos2 = x.JxJ),
                          (this.attributes.morph_pos3 = x.Az9),
                          (m += `#define MORPHING_POS03
`),
                          (m += `attribute vec3 morph_pos0;
`),
                          (m += `attribute vec3 morph_pos1;
`),
                          (m += `attribute vec3 morph_pos2;
`),
                          (m += `attribute vec3 morph_pos3;
`))
                        : p.useMorphNormal &&
                          ((this.attributes.morph_nrm0 = x.syi),
                          (this.attributes.morph_nrm1 = x.ScY),
                          (this.attributes.morph_nrm2 = x.JxJ),
                          (this.attributes.morph_nrm3 = x.Az9),
                          (m += `#define MORPHING_NRM03
`),
                          (m += `attribute vec3 morph_nrm0;
`),
                          (m += `attribute vec3 morph_nrm1;
`),
                          (m += `attribute vec3 morph_nrm2;
`),
                          (m += `attribute vec3 morph_nrm3;
`)),
                      p.useMorphNormal
                        ? ((this.attributes.morph_nrm4 = x.gLS),
                          (this.attributes.morph_nrm5 = x.OrD),
                          (this.attributes.morph_nrm6 = x.nKe),
                          (this.attributes.morph_nrm7 = x.s36),
                          (m += `#define MORPHING_NRM47
`),
                          (m += `attribute vec3 morph_nrm4;
`),
                          (m += `attribute vec3 morph_nrm5;
`),
                          (m += `attribute vec3 morph_nrm6;
`),
                          (m += `attribute vec3 morph_nrm7;
`))
                        : ((this.attributes.morph_pos4 = x.gLS),
                          (this.attributes.morph_pos5 = x.OrD),
                          (this.attributes.morph_pos6 = x.nKe),
                          (this.attributes.morph_pos7 = x.s36),
                          (m += `#define MORPHING_POS47
`),
                          (m += `attribute vec3 morph_pos4;
`),
                          (m += `attribute vec3 morph_pos5;
`),
                          (m += `attribute vec3 morph_pos6;
`),
                          (m += `attribute vec3 morph_pos7;
`));
                p.skin
                  ? ((this.attributes.vertex_boneWeights = x.d1j),
                    (this.attributes.vertex_boneIndices = x.MgX),
                    (m += (0, f.oY)(y, _)),
                    (m += `#define SKIN
`))
                  : p.useInstancing &&
                    (m += `#define INSTANCING
`),
                  p.screenSpace &&
                    (m += `#define SCREENSPACE
`),
                  p.pixelSnap &&
                    (m += `#define PIXELSNAP
`),
                  (m = this._vsAddTransformCode(m, y, _, p)),
                  this.needsNormal && (m += _.normalVS),
                  (m += `
`),
                  (m += _.startVS),
                  (m += E),
                  (m += _.endVS),
                  (m += "}"),
                  Object.keys(o).forEach((A) => {
                    m.indexOf(A) >= 0 &&
                      ((this.varyings += `varying ${o[A]} ${A};
`),
                      (this.varyingDefines += `#define VARYING_${A.toUpperCase()}
`));
                  });
                const I = this.shaderPassInfo.shaderDefines;
                this.vshader = I + this.varyings + m;
              }
              _fsGetBeginCode() {
                let t = this.shaderPassInfo.shaderDefines;
                for (let r = 0; r < this.defines.length; r++)
                  t += `#define ${this.defines[r]}
`;
                return t;
              }
              _fsGetPickPassCode() {
                let t = this._fsGetBeginCode();
                return (
                  (t += `uniform vec4 uColor;
`),
                  (t += this.varyings),
                  (t += this.varyingDefines),
                  (t += this.frontendDecl),
                  (t += this.frontendCode),
                  (t += (0, f.a7)()),
                  (t += this.frontendFunc),
                  (t += `    gl_FragColor = uColor;
`),
                  (t += (0, f.ut)()),
                  t
                );
              }
              _fsGetDepthPassCode() {
                const t = this.chunks;
                let r = this._fsGetBeginCode();
                return (
                  (r += `varying float vDepth;
`),
                  (r += this.varyings),
                  (r += this.varyingDefines),
                  (r += t.packDepthPS),
                  (r += this.frontendDecl),
                  (r += this.frontendCode),
                  (r += (0, f.a7)()),
                  (r += this.frontendFunc),
                  (r += `    gl_FragColor = packFloat(vDepth);
`),
                  (r += (0, f.ut)()),
                  r
                );
              }
              _fsGetShadowPassCode() {
                const t = this.device,
                  r = this.options,
                  u = this.chunks,
                  y = this.varyings,
                  p = this.shaderPassInfo.lightType;
                let _ = this.shaderPassInfo.shadowType;
                p !== c.WQ &&
                  r.clusteredLightingEnabled &&
                  (_ === c.JN || _ === c.J7 || _ === c.oK || _ === c.b3) &&
                  (_ = c.iW);
                let m = this._fsGetBeginCode();
                t.extStandardDerivatives &&
                  !t.webgl2 &&
                  !t.isWebGPU &&
                  (m += `uniform vec2 polygonOffset;
`),
                  _ === c.oK
                    ? t.textureFloatHighPrecision
                      ? (m += `#define VSM_EXPONENT 15.0

`)
                      : (m += `#define VSM_EXPONENT 5.54

`)
                    : _ === c.J7 &&
                      (m += `#define VSM_EXPONENT 5.54

`),
                  p !== c.WQ &&
                    ((m += `uniform vec3 view_position;
`),
                    (m += `uniform float light_radius;
`)),
                  (m += y),
                  (m += this.varyingDefines),
                  (m += this.frontendDecl),
                  (m += this.frontendCode);
                const E = _ === c.sH || _ === c.iW || _ === c.sz || _ === c.b3,
                  v = p === c.bA && _ !== c.b3 && !r.clusteredLightingEnabled,
                  P = (E && !t.supportsDepthShadow) || v;
                P
                  ? (m += u.packDepthPS)
                  : _ === c.JN &&
                    ((m += `vec2 encodeFloatRG( float v ) {
`),
                    (m += `    vec2 enc = vec2(1.0, 255.0) * v;
`),
                    (m += `    enc = fract(enc);
`),
                    (m += `    enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);
`),
                    (m += `    return enc;
`),
                    (m += `}

`)),
                  _ === c.b3 && (m += T.n.linearizeDepthPS),
                  (m += (0, f.a7)()),
                  (m += this.frontendFunc);
                const I = _ === c.JN || _ === c.J7 || _ === c.oK,
                  A = !t.webgl2 && t.extStandardDerivatives && !t.isWebGPU,
                  B = p === c.WQ || (!I && p === c.z0);
                let C = !1;
                return (
                  B
                    ? (m += `    float depth = gl_FragCoord.z;
`)
                    : ((m += `    float depth = min(distance(view_position, vPositionW) / light_radius, 0.99999);
`),
                      (C = !0)),
                  A &&
                    ((m += `    float minValue = 2.3374370500153186e-10; //(1.0 / 255.0) / (256.0 * 256.0 * 256.0);
`),
                    (m += `    depth += polygonOffset.x * max(abs(dFdx(depth)), abs(dFdy(depth))) + minValue * polygonOffset.y;
`),
                    (C = !0)),
                  P
                    ? (m += `    gl_FragColor = packFloat(depth);
`)
                    : I
                    ? _ === c.JN
                      ? (m += `    gl_FragColor = vec4(encodeFloatRG(depth), encodeFloatRG(depth*depth));
`)
                      : (m += u.storeEVSMPS)
                    : _ === c.b3
                    ? (m += `    gl_FragColor.r = depth;
`)
                    : (C &&
                        (m += `    gl_FragDepth = depth;
`),
                      (m += `    gl_FragColor = vec4(1.0);
`)),
                  (m += (0, f.ut)()),
                  m
                );
              }
              _fsGetLitPassCode() {
                const t = this.device,
                  r = this.options,
                  u = this.chunks,
                  y = new l.R(),
                  p = new l.R(),
                  _ = new l.R(),
                  m = new l.R();
                r.opacityFadesSpecular === !1 &&
                  y.append("uniform float material_alphaFade;"),
                  r.useSpecular &&
                    (this.defines.push("LIT_SPECULAR"),
                    this.reflections && this.defines.push("LIT_REFLECTIONS"),
                    r.useClearCoat && this.defines.push("LIT_CLEARCOAT"),
                    r.fresnelModel > 0 &&
                      this.defines.push("LIT_SPECULAR_FRESNEL"),
                    r.conserveEnergy &&
                      this.defines.push("LIT_CONSERVE_ENERGY"),
                    r.useSheen && this.defines.push("LIT_SHEEN"),
                    r.useIridescence && this.defines.push("LIT_IRIDESCENCE"));
                const E = [];
                let v = 0,
                  P = !1,
                  I = !1,
                  A = !1,
                  B = r.lights.some(function (L) {
                    return L._shape && L._shape !== c.pI;
                  });
                r.clusteredLightingEnabled &&
                  r.clusteredLightingAreaLightsEnabled &&
                  (B = !0);
                let C = "highp";
                t.areaLightLutFormat === x.jKI &&
                  (y.append("#define AREA_R8_G8_B8_A8_LUTS"), (C = "lowp")),
                  (B || r.clusteredLightingEnabled) &&
                    (y.append("#define AREA_LIGHTS"),
                    y.append(`uniform ${C} sampler2D areaLightsLutTex1;`),
                    y.append(`uniform ${C} sampler2D areaLightsLutTex2;`));
                for (let L = 0; L < r.lights.length; L++) {
                  const J = r.lights[L],
                    ae = J._type;
                  if (r.clusteredLightingEnabled && ae !== c.WQ) continue;
                  const R = B && J._shape ? J._shape : c.pI;
                  y.append("uniform vec3 light" + L + "_color;"),
                    J._shadowType === c.b3 &&
                      J.castShadows &&
                      !r.noShadow &&
                      (y.append(`uniform float light${L}_shadowSearchArea;`),
                      y.append(`uniform vec4 light${L}_cameraParams;`)),
                    ae === c.WQ
                      ? y.append("uniform vec3 light" + L + "_direction;")
                      : (y.append("uniform vec3 light" + L + "_position;"),
                        y.append("uniform float light" + L + "_radius;"),
                        ae === c.z0 &&
                          (y.append("uniform vec3 light" + L + "_direction;"),
                          y.append(
                            "uniform float light" + L + "_innerConeAngle;"
                          ),
                          y.append(
                            "uniform float light" + L + "_outerConeAngle;"
                          ))),
                    R !== c.pI &&
                      (ae === c.WQ &&
                        y.append("uniform vec3 light" + L + "_position;"),
                      y.append("uniform vec3 light" + L + "_halfWidth;"),
                      y.append("uniform vec3 light" + L + "_halfHeight;")),
                    J.castShadows &&
                      !r.noShadow &&
                      (y.append("uniform mat4 light" + L + "_shadowMatrix;"),
                      y.append("uniform float light" + L + "_shadowIntensity;"),
                      ae === c.WQ &&
                        (y.append(
                          "uniform mat4 light" + L + "_shadowMatrixPalette[4];"
                        ),
                        y.append(
                          "uniform float light" +
                            L +
                            "_shadowCascadeDistances[4];"
                        ),
                        y.append(
                          "uniform float light" + L + "_shadowCascadeCount;"
                        )),
                      y.append("uniform vec4 light" + L + "_shadowParams;"),
                      ae === c.WQ && (P = !0),
                      ae === c.bA
                        ? y.append(
                            "uniform samplerCube light" + L + "_shadowMap;"
                          )
                        : J._isPcf && t.supportsDepthShadow
                        ? y.append(
                            "uniform sampler2DShadow light" + L + "_shadowMap;"
                          )
                        : y.append(
                            "uniform sampler2D light" + L + "_shadowMap;"
                          ),
                      v++,
                      (E[J._shadowType] = !0),
                      J._isVsm && (I = !0),
                      J._shadowType === c.b3 && (A = !0)),
                    J._cookie &&
                      (J._cookie._cubemap
                        ? ae === c.bA &&
                          (y.append(
                            "uniform samplerCube light" + L + "_cookie;"
                          ),
                          y.append(
                            "uniform float light" + L + "_cookieIntensity;"
                          ),
                          (!J.castShadows || r.noShadow) &&
                            y.append(
                              "uniform mat4 light" + L + "_shadowMatrix;"
                            ))
                        : ae === c.z0 &&
                          (y.append("uniform sampler2D light" + L + "_cookie;"),
                          y.append(
                            "uniform float light" + L + "_cookieIntensity;"
                          ),
                          (!J.castShadows || r.noShadow) &&
                            y.append(
                              "uniform mat4 light" + L + "_shadowMatrix;"
                            ),
                          J._cookieTransform &&
                            (y.append(
                              "uniform vec4 light" + L + "_cookieMatrix;"
                            ),
                            y.append(
                              "uniform vec2 light" + L + "_cookieOffset;"
                            ))));
                }
                const w =
                  this.needsNormal &&
                  (r.useNormals ||
                    r.useClearCoatNormals ||
                    (r.enableGGXSpecular && !r.useHeights));
                if (
                  (w &&
                    (r.hasTangents
                      ? p.append(r.fastTbn ? u.TBNfastPS : u.TBNPS)
                      : t.extStandardDerivatives &&
                        (r.useNormals || r.useClearCoatNormals)
                      ? p.append(
                          u.TBNderivativePS.replace(/\$UV/g, this.lightingUv)
                        )
                      : p.append(u.TBNObjectSpacePS)),
                  p.append(u.sphericalPS),
                  p.append(u.decodePS),
                  p.append((0, f.li)(r.gamma, u)),
                  p.append((0, f.ph)(r.toneMap, u)),
                  p.append((0, f.aJ)(r.fog, u)),
                  p.append(this.frontendCode),
                  r.useCubeMapRotation && y.append("#define CUBEMAP_ROTATION"),
                  this.needsNormal &&
                    (p.append(u.cubeMapRotatePS),
                    p.append(
                      r.cubeMapProjection > 0
                        ? u.cubeMapProjectBoxPS
                        : u.cubeMapProjectNonePS
                    ),
                    p.append(
                      r.skyboxIntensity ? u.envMultiplyPS : u.envConstPS
                    )),
                  ((this.lighting && r.useSpecular) || this.reflections) &&
                    (r.useMetalness && p.append(u.metalnessModulatePS),
                    r.fresnelModel === c.Rx && p.append(u.fresnelSchlickPS),
                    r.useIridescence && p.append(u.iridescenceDiffractionPS)),
                  r.useAo)
                )
                  switch ((p.append(u.aoDiffuseOccPS), r.occludeSpecular)) {
                    case c._f:
                      p.append(
                        r.occludeSpecularFloat
                          ? u.aoSpecOccSimplePS
                          : u.aoSpecOccConstSimplePS
                      );
                      break;
                    case c.X8:
                      p.append(
                        r.occludeSpecularFloat
                          ? u.aoSpecOccPS
                          : u.aoSpecOccConstPS
                      );
                      break;
                  }
                if (r.reflectionSource === "envAtlasHQ")
                  p.append(
                    r.fixSeams
                      ? u.fixCubemapSeamsStretchPS
                      : u.fixCubemapSeamsNonePS
                  ),
                    p.append(u.envAtlasPS),
                    p.append(
                      u.reflectionEnvHQPS
                        .replace(
                          /\$DECODE_CUBEMAP/g,
                          g.a.decodeFunc(r.reflectionCubemapEncoding)
                        )
                        .replace(
                          /\$DECODE/g,
                          g.a.decodeFunc(r.reflectionEncoding)
                        )
                    );
                else if (r.reflectionSource === "envAtlas")
                  p.append(u.envAtlasPS),
                    p.append(
                      u.reflectionEnvPS.replace(
                        /\$DECODE/g,
                        g.a.decodeFunc(r.reflectionEncoding)
                      )
                    );
                else if (r.reflectionSource === "cubeMap")
                  p.append(
                    r.fixSeams
                      ? u.fixCubemapSeamsStretchPS
                      : u.fixCubemapSeamsNonePS
                  ),
                    p.append(
                      u.reflectionCubePS.replace(
                        /\$DECODE/g,
                        g.a.decodeFunc(r.reflectionEncoding)
                      )
                    );
                else if (r.reflectionSource === "sphereMap") {
                  const L =
                    t.fragmentUniformsCount > 16
                      ? u.reflectionSpherePS
                      : u.reflectionSphereLowPS;
                  p.append(
                    L.replace(/\$DECODE/g, g.a.decodeFunc(r.reflectionEncoding))
                  );
                }
                this.reflections &&
                  (r.useClearCoat && p.append(u.reflectionCCPS),
                  r.useSheen && p.append(u.reflectionSheenPS)),
                  r.useRefraction &&
                    (r.useDynamicRefraction
                      ? p.append(u.refractionDynamicPS)
                      : this.reflections && p.append(u.refractionCubePS)),
                  r.useSheen && p.append(u.lightSheenPS),
                  r.clusteredLightingEnabled &&
                    (p.append(u.clusteredLightUtilsPS),
                    r.clusteredLightingCookiesEnabled &&
                      p.append(u.clusteredLightCookiesPS),
                    r.clusteredLightingShadowsEnabled &&
                      !r.noShadow &&
                      ((E[c.iW] = !0), (E[c.sz] = !0), (E[c.b3] = !0))),
                  (v > 0 || r.clusteredLightingEnabled) &&
                    (P && p.append(u.shadowCascadesPS),
                    (E[c.sH] || E[c.iW]) && p.append(u.shadowStandardPS),
                    E[c.sz] &&
                      (t.webgl2 || t.isWebGPU) &&
                      p.append(u.shadowStandardGL2PS),
                    I &&
                      (p.append(u.shadowVSM_commonPS),
                      E[c.JN] && p.append(u.shadowVSM8PS),
                      E[c.J7] &&
                        p.append(
                          t.extTextureHalfFloatLinear
                            ? u.shadowEVSMPS.replace(/\$/g, "16")
                            : u.shadowEVSMnPS.replace(/\$/g, "16")
                        ),
                      E[c.oK] &&
                        p.append(
                          t.extTextureFloatLinear
                            ? u.shadowEVSMPS.replace(/\$/g, "32")
                            : u.shadowEVSMnPS.replace(/\$/g, "32")
                        )),
                    A &&
                      (p.append(u.linearizeDepthPS), p.append(u.shadowPCSSPS)),
                    t.webgl2 ||
                      t.extStandardDerivatives ||
                      t.isWebGPU ||
                      p.append(u.biasConstPS)),
                  r.enableGGXSpecular &&
                    p.append("uniform float material_anisotropy;"),
                  this.lighting &&
                    (p.append(u.lightDiffuseLambertPS),
                    (B || r.clusteredLightingAreaLightsEnabled) &&
                      p.append(u.ltcPS));
                let k = !1;
                r.useSpecular &&
                  (this.lighting &&
                    p.append(
                      r.shadingModel === c.yd
                        ? u.lightSpecularPhongPS
                        : r.enableGGXSpecular
                        ? u.lightSpecularAnisoGGXPS
                        : u.lightSpecularBlinnPS
                    ),
                  !r.fresnelModel &&
                    !this.reflections &&
                    !r.diffuseMapEnabled &&
                    (y.append("uniform vec3 material_ambient;"),
                    y.append("#define LIT_OLD_AMBIENT"),
                    (k = !0))),
                  p.append(u.combinePS),
                  r.lightMapEnabled &&
                    p.append(
                      r.useSpecular && r.dirLightMapEnabled
                        ? u.lightmapDirAddPS
                        : u.lightmapAddPS
                    );
                const K = !r.lightMapEnabled || r.lightMapWithoutAmbient;
                K &&
                  (r.ambientSource === "ambientSH"
                    ? p.append(u.ambientSHPS)
                    : r.ambientSource === "envAtlas"
                    ? (r.reflectionSource !== "envAtlas" &&
                        r.reflectionSource !== "envAtlasHQ" &&
                        p.append(u.envAtlasPS),
                      p.append(
                        u.ambientEnvPS.replace(
                          /\$DECODE/g,
                          g.a.decodeFunc(r.ambientEncoding)
                        )
                      ))
                    : p.append(u.ambientConstantPS)),
                  r.useAmbientTint &&
                    !k &&
                    y.append("uniform vec3 material_ambient;"),
                  r.useMsdf &&
                    (r.msdfTextAttribute ||
                      y.append("#define UNIFORM_TEXT_PARAMETERS"),
                    p.append(u.msdfPS)),
                  this.needsNormal &&
                    (p.append(u.viewDirPS),
                    r.useSpecular &&
                      p.append(
                        r.enableGGXSpecular ? u.reflDirAnisoPS : u.reflDirPS
                      ));
                let te = !1,
                  X = !1,
                  $ = !1,
                  ne = !1,
                  Y = !1,
                  Z;
                if (
                  (r.clusteredLightingEnabled &&
                    this.lighting &&
                    ((ne = !0),
                    (te = !0),
                    (X = !0),
                    (Y = !0),
                    p.append(u.floatUnpackingPS),
                    r.lightMaskDynamic &&
                      y.append("#define CLUSTER_MESH_DYNAMIC_LIGHTS"),
                    r.clusteredLightingCookiesEnabled &&
                      y.append("#define CLUSTER_COOKIES"),
                    r.clusteredLightingShadowsEnabled &&
                      !r.noShadow &&
                      (y.append("#define CLUSTER_SHADOWS"),
                      y.append(
                        "#define CLUSTER_SHADOW_TYPE_" +
                          c.LH[r.clusteredLightingShadowType]
                      )),
                    r.clusteredLightingAreaLightsEnabled &&
                      y.append("#define CLUSTER_AREALIGHTS"),
                    y.append(d.Q.shaderDefines),
                    r.clusteredLightingShadowsEnabled &&
                      !r.noShadow &&
                      p.append(u.clusteredLightShadowsPS),
                    p.append(u.clusteredLightPS)),
                  r.twoSidedLighting &&
                    y.append("uniform float twoSidedLightingNegScaleFactor;"),
                  m.append(this._fsGetStartCode(m, t, u, r)),
                  this.needsNormal &&
                    (r.twoSidedLighting
                      ? m.append(
                          "    dVertexNormalW = normalize(gl_FrontFacing ? vNormalW * twoSidedLightingNegScaleFactor : -vNormalW * twoSidedLightingNegScaleFactor);"
                        )
                      : m.append("    dVertexNormalW = normalize(vNormalW);"),
                    (r.useHeights || r.useNormals) &&
                      r.hasTangents &&
                      (r.twoSidedLighting
                        ? (m.append(
                            "    dTangentW = gl_FrontFacing ? vTangentW * twoSidedLightingNegScaleFactor : -vTangentW * twoSidedLightingNegScaleFactor;"
                          ),
                          m.append(
                            "    dBinormalW = gl_FrontFacing ? vBinormalW * twoSidedLightingNegScaleFactor : -vBinormalW * twoSidedLightingNegScaleFactor;"
                          ))
                        : (m.append("    dTangentW = vTangentW;"),
                          m.append("    dBinormalW = vBinormalW;"))),
                    m.append("    getViewDir();"),
                    w &&
                      m.append(
                        "    getTBN(dTangentW, dBinormalW, dVertexNormalW);"
                      )),
                  m.append(this.frontendFunc),
                  this.needsNormal &&
                    (r.useSpecular &&
                      _.append(
                        "    getReflDir(litArgs_worldNormal, dViewDirW, litArgs_gloss, dTBN);"
                      ),
                    r.useClearCoat &&
                      _.append(
                        "    ccReflDirW = normalize(-reflect(dViewDirW, litArgs_clearcoat_worldNormal));"
                      )),
                  ((this.lighting && r.useSpecular) || this.reflections) &&
                    (r.useMetalness &&
                      (_.append(
                        "    float f0 = 1.0 / litArgs_ior; f0 = (f0 - 1.0) / (f0 + 1.0); f0 *= f0;"
                      ),
                      _.append(
                        "    litArgs_specularity = getSpecularModulate(litArgs_specularity, litArgs_albedo, litArgs_metalness, f0);"
                      ),
                      _.append(
                        "    litArgs_albedo = getAlbedoModulate(litArgs_albedo, litArgs_metalness);"
                      )),
                    r.useIridescence &&
                      _.append(
                        "    vec3 iridescenceFresnel = getIridescence(saturate(dot(dViewDirW, litArgs_worldNormal)), litArgs_specularity, litArgs_iridescence_thickness);"
                      )),
                  K &&
                    (_.append("    addAmbient(litArgs_worldNormal);"),
                    r.conserveEnergy &&
                      r.useSpecular &&
                      _.append(
                        "   dDiffuseLight = dDiffuseLight * (1.0 - litArgs_specularity);"
                      ),
                    r.separateAmbient &&
                      _.append(`
										vec3 dAmbientLight = dDiffuseLight;
										dDiffuseLight = vec3(0);
								`)),
                  r.useAmbientTint &&
                    !k &&
                    _.append("    dDiffuseLight *= material_ambient;"),
                  r.useAo &&
                    !r.occludeDirect &&
                    _.append("    occludeDiffuse(litArgs_ao);"),
                  r.lightMapEnabled &&
                    _.append(`    addLightMap(
								litArgs_lightmap, 
								litArgs_lightmapDir, 
								litArgs_worldNormal, 
								dViewDirW, 
								dReflDirW, 
								litArgs_gloss, 
								litArgs_specularity, 
								dVertexNormalW,
								dTBN
						#if defined(LIT_IRIDESCENCE)
								, iridescenceFresnel,
								litArgs_iridescence_intensity
						#endif
								);`),
                  this.lighting || this.reflections)
                ) {
                  this.reflections &&
                    (r.useClearCoat &&
                      (_.append(
                        "    addReflectionCC(ccReflDirW, litArgs_clearcoat_gloss);"
                      ),
                      r.fresnelModel > 0
                        ? (_.append(
                            "    ccFresnel = getFresnelCC(dot(dViewDirW, litArgs_clearcoat_worldNormal));"
                          ),
                          _.append("    ccReflection.rgb *= ccFresnel;"))
                        : _.append("    ccFresnel = 0.0;")),
                    r.useSpecularityFactor &&
                      _.append(
                        "    ccReflection.rgb *= litArgs_specularityFactor;"
                      ),
                    r.useSheen &&
                      _.append(
                        "    addReflectionSheen(litArgs_worldNormal, dViewDirW, litArgs_sheen_gloss);"
                      ),
                    _.append("    addReflection(dReflDirW, litArgs_gloss);"),
                    r.fresnelModel > 0
                      ? _.append(`    dReflection.rgb *= 
												getFresnel(
														dot(dViewDirW, litArgs_worldNormal), 
														litArgs_gloss, 
														litArgs_specularity
												#if defined(LIT_IRIDESCENCE)
														, iridescenceFresnel,
														litArgs_iridescence_intensity
												#endif
														);`)
                      : _.append("    dReflection.rgb *= litArgs_specularity;"),
                    r.useSpecularityFactor &&
                      _.append(
                        "    dReflection.rgb *= litArgs_specularityFactor;"
                      )),
                    B &&
                      (_.append("    dSpecularLight *= litArgs_specularity;"),
                      r.useSpecular &&
                        _.append(
                          "    calcLTCLightValues(litArgs_gloss, litArgs_worldNormal, dViewDirW, litArgs_specularity, litArgs_clearcoat_gloss, litArgs_clearcoat_worldNormal, litArgs_clearcoat_specularity);"
                        ));
                  for (let L = 0; L < r.lights.length; L++) {
                    const J = r.lights[L],
                      ae = J._type;
                    if (r.clusteredLightingEnabled && ae !== c.WQ) continue;
                    Z = !1;
                    const R = B && J._shape ? J.shape : c.pI,
                      j =
                        B && J._shape ? this._getLightSourceShapeString(R) : "";
                    if (
                      (R !== c.pI &&
                        _.append(
                          "    calc" +
                            j +
                            "LightValues(light" +
                            L +
                            "_position, light" +
                            L +
                            "_halfWidth, light" +
                            L +
                            "_halfHeight);"
                        ),
                      ae === c.WQ
                        ? (_.append(
                            "    dLightDirNormW = light" + L + "_direction;"
                          ),
                          _.append("    dAtten = 1.0;"))
                        : (J._cookie &&
                            ((ae === c.z0 && !J._cookie._cubemap) ||
                              (ae === c.bA && J._cookie._cubemap)) &&
                            ((Y = !0), (Z = !0)),
                          _.append(
                            "    getLightDirPoint(light" + L + "_position);"
                          ),
                          (te = !0),
                          Z &&
                            (ae === c.z0
                              ? _.append(
                                  "    dAtten3 = getCookie2D" +
                                    (J._cookieFalloff ? "" : "Clip") +
                                    (J._cookieTransform ? "Xform" : "") +
                                    "(light" +
                                    L +
                                    "_cookie, light" +
                                    L +
                                    "_shadowMatrix, light" +
                                    L +
                                    "_cookieIntensity" +
                                    (J._cookieTransform
                                      ? ", light" +
                                        L +
                                        "_cookieMatrix, light" +
                                        L +
                                        "_cookieOffset"
                                      : "") +
                                    ")." +
                                    J._cookieChannel +
                                    ";"
                                )
                              : _.append(
                                  "    dAtten3 = getCookieCube(light" +
                                    L +
                                    "_cookie, light" +
                                    L +
                                    "_shadowMatrix, light" +
                                    L +
                                    "_cookieIntensity)." +
                                    J._cookieChannel +
                                    ";"
                                )),
                          R === c.pI
                            ? J._falloffMode === c.MU
                              ? (_.append(
                                  "    dAtten = getFalloffLinear(light" +
                                    L +
                                    "_radius, dLightDirW);"
                                ),
                                (X = !0))
                              : (_.append(
                                  "    dAtten = getFalloffInvSquared(light" +
                                    L +
                                    "_radius, dLightDirW);"
                                ),
                                ($ = !0))
                            : (_.append(
                                "    dAtten = getFalloffWindow(light" +
                                  L +
                                  "_radius, dLightDirW);"
                              ),
                              ($ = !0)),
                          _.append("    if (dAtten > 0.00001) {"),
                          ae === c.z0 &&
                            ((Z && !J._cookieFalloff) ||
                              (_.append(
                                "    dAtten *= getSpotEffect(light" +
                                  L +
                                  "_direction, light" +
                                  L +
                                  "_innerConeAngle, light" +
                                  L +
                                  "_outerConeAngle, dLightDirNormW);"
                              ),
                              (ne = !0)))),
                      R !== c.pI
                        ? ae === c.WQ
                          ? _.append(
                              "    dAttenD = getLightDiffuse(litArgs_worldNormal, dViewDirW, dLightDirW, dLightDirNormW);"
                            )
                          : _.append(
                              "    dAttenD = get" +
                                j +
                                "LightDiffuse(litArgs_worldNormal, dViewDirW, dLightDirW, dLightDirNormW) * 16.0;"
                            )
                        : _.append(
                            "    dAtten *= getLightDiffuse(litArgs_worldNormal, dViewDirW, dLightDirW, dLightDirNormW);"
                          ),
                      J.castShadows && !r.noShadow)
                    ) {
                      const se = J._shadowType === c.b3,
                        ce =
                          J._shadowType === c.JN ||
                          J._shadowType === c.J7 ||
                          J._shadowType === c.oK,
                        ie =
                          J._shadowType === c.sH ||
                          J._shadowType === c.iW ||
                          J._shadowType === c.sz;
                      let b = null,
                        M;
                      switch (J._shadowType) {
                        case c.JN:
                          (b = "VSM8"), (M = "0.0");
                          break;
                        case c.J7:
                          (b = "VSM16"), (M = "5.54");
                          break;
                        case c.oK:
                          (b = "VSM32"),
                            t.textureFloatHighPrecision
                              ? (M = "15.0")
                              : (M = "5.54");
                          break;
                        case c.sH:
                          b = "PCF1x1";
                          break;
                        case c.sz:
                          b = "PCF5x5";
                          break;
                        case c.b3:
                          b = "PCSS";
                          break;
                        case c.iW:
                        default:
                          b = "PCF3x3";
                          break;
                      }
                      if (b !== null) {
                        J._normalOffsetBias &&
                          !J._isVsm &&
                          p.append("#define SHADOW_SAMPLE_NORMAL_OFFSET"),
                          ae === c.WQ &&
                            p.append("#define SHADOW_SAMPLE_ORTHO"),
                          (((ie || se) && t.webgl2) ||
                            t.extStandardDerivatives ||
                            t.isWebGPU) &&
                            p.append("#define SHADOW_SAMPLE_SOURCE_ZBUFFER"),
                          ae === c.bA &&
                            p.append("#define SHADOW_SAMPLE_POINT");
                        const F = u.shadowSampleCoordPS;
                        p.append(F.replace("$LIGHT", L)),
                          p.append("#undef SHADOW_SAMPLE_NORMAL_OFFSET"),
                          p.append("#undef SHADOW_SAMPLE_ORTHO"),
                          p.append("#undef SHADOW_SAMPLE_SOURCE_ZBUFFER"),
                          p.append("#undef SHADOW_SAMPLE_POINT");
                        let z = `light${L}_shadowMatrix`;
                        ae === c.WQ &&
                          J.numCascades > 1 &&
                          (_.append(
                            `    getShadowCascadeMatrix(light${L}_shadowMatrixPalette, light${L}_shadowCascadeDistances, light${L}_shadowCascadeCount);`
                          ),
                          (z = "cascadeShadowMat")),
                          _.append(
                            `    dShadowCoord = getShadowSampleCoord${L}(${z}, light${L}_shadowParams, vPositionW, dLightPosW, dLightDirW, dLightDirNormW, dVertexNormalW);`
                          ),
                          ae === c.WQ &&
                            _.append(
                              `    fadeShadow(light${L}_shadowCascadeDistances);`
                            );
                        var ye = `SHADOWMAP_PASS(light${L}_shadowMap), dShadowCoord, light${L}_shadowParams`;
                        if (ce) ye = `${ye}, ${M}, dLightDirW`;
                        else if (se) {
                          let oe = `vec2(light${L}_shadowSearchArea)`;
                          R !== c.pI &&
                            (oe = `vec2(length(light${L}_halfWidth), length(light${L}_halfHeight)) * light${L}_shadowSearchArea`),
                            (ye = `${ye}, light${L}_cameraParams, ${oe}, dLightDirW`);
                        }
                        ae === c.bA
                          ? ((b = `Point${b}`),
                            se || (ye = `${ye}, dLightDirW`))
                          : ae === c.z0 && (b = `Spot${b}`),
                          _.append(
                            `    float shadow${L} = getShadow${b}(${ye});`
                          ),
                          _.append(
                            `    dAtten *= mix(1.0, shadow${L}, light${L}_shadowIntensity);`
                          );
                      }
                    }
                    if (
                      (R !== c.pI
                        ? r.conserveEnergy && r.useSpecular
                          ? _.append(
                              "    dDiffuseLight += ((dAttenD * dAtten) * light" +
                                L +
                                "_color" +
                                (Z ? " * dAtten3" : "") +
                                ") * (1.0 - dLTCSpecFres);"
                            )
                          : _.append(
                              "    dDiffuseLight += (dAttenD * dAtten) * light" +
                                L +
                                "_color" +
                                (Z ? " * dAtten3" : "") +
                                ";"
                            )
                        : B && r.conserveEnergy && r.useSpecular
                        ? _.append(
                            "    dDiffuseLight += (dAtten * light" +
                              L +
                              "_color" +
                              (Z ? " * dAtten3" : "") +
                              ") * (1.0 - litArgs_specularity);"
                          )
                        : _.append(
                            "    dDiffuseLight += dAtten * light" +
                              L +
                              "_color" +
                              (Z ? " * dAtten3" : "") +
                              ";"
                          ),
                      r.useSpecular &&
                        _.append(
                          "    dHalfDirW = normalize(-dLightDirNormW + dViewDirW);"
                        ),
                      J.affectSpecularity)
                    )
                      if (R !== c.pI)
                        r.useClearCoat &&
                          _.append(
                            `    ccSpecularLight += ccLTCSpecFres * get${j}LightSpecular(litArgs_clearcoat_worldNormal, dViewDirW) * dAtten * light${L}_color` +
                              (Z ? " * dAtten3" : "") +
                              ";"
                          ),
                          r.useSpecular &&
                            _.append(
                              `    dSpecularLight += dLTCSpecFres * get${j}LightSpecular(litArgs_worldNormal, dViewDirW) * dAtten * light${L}_color` +
                                (Z ? " * dAtten3" : "") +
                                ";"
                            );
                      else {
                        var pe = !1;
                        ae === c.WQ && r.fresnelModel > 0 && (pe = !0),
                          r.useClearCoat &&
                            _.append(
                              `    ccSpecularLight += getLightSpecular(dHalfDirW, ccReflDirW, litArgs_clearcoat_worldNormal, dViewDirW, dLightDirNormW, litArgs_clearcoat_gloss, dTBN) * dAtten * light${L}_color` +
                                (Z ? " * dAtten3" : "") +
                                (pe
                                  ? " * getFresnelCC(dot(dViewDirW, dHalfDirW));"
                                  : ";")
                            ),
                          r.useSheen &&
                            _.append(
                              `    sSpecularLight += getLightSpecularSheen(dHalfDirW, litArgs_worldNormal, dViewDirW, dLightDirNormW, litArgs_sheen_gloss) * dAtten * light${L}_color` +
                                (Z ? " * dAtten3;" : ";")
                            ),
                          r.useSpecular &&
                            _.append(
                              `    dSpecularLight += getLightSpecular(dHalfDirW, dReflDirW, litArgs_worldNormal, dViewDirW, dLightDirNormW, litArgs_gloss, dTBN) * dAtten * light${L}_color` +
                                (Z ? " * dAtten3" : "") +
                                (pe
                                  ? ` 
																		* getFresnel(
																				dot(dViewDirW, dHalfDirW), 
																				litArgs_gloss, 
																				litArgs_specularity
																		#if defined(LIT_IRIDESCENCE)
																				, iridescenceFresnel, 
																				litArgs_iridescence_intensity
																		#endif
																		);`
                                  : "* litArgs_specularity;")
                            );
                      }
                    ae !== c.WQ && _.append("    }");
                  }
                  r.clusteredLightingEnabled &&
                    this.lighting &&
                    ((X = !0),
                    ($ = !0),
                    (te = !0),
                    _.append(`    addClusteredLights(
																				litArgs_worldNormal, 
																				dViewDirW, 
																				dReflDirW,
																#if defined(LIT_CLEARCOAT)
																				ccReflDirW,
																#endif
																				litArgs_gloss, 
																				litArgs_specularity, 
																				dVertexNormalW, 
																				dTBN, 
																#if defined(LIT_IRIDESCENCE)
																				iridescenceFresnel,
																#endif
																				litArgs_clearcoat_worldNormal, 
																				litArgs_clearcoat_gloss,
																				litArgs_sheen_gloss,
																				litArgs_iridescence_intensity
																		);`)),
                    B &&
                      (r.useClearCoat &&
                        _.append("    litArgs_clearcoat_specularity = 1.0;"),
                      r.useSpecular &&
                        _.append("    litArgs_specularity = vec3(1);")),
                    r.useRefraction &&
                      _.append(`    addRefraction(
												litArgs_worldNormal, 
												dViewDirW, 
												litArgs_thickness, 
												litArgs_gloss, 
												litArgs_specularity, 
												litArgs_albedo, 
												litArgs_transmission,
												litArgs_ior
										#if defined(LIT_IRIDESCENCE)
												, iridescenceFresnel, 
												litArgs_iridescence_intensity
										#endif
										);`);
                }
                r.useAo &&
                  (r.occludeDirect &&
                    _.append("    occludeDiffuse(litArgs_ao);"),
                  (r.occludeSpecular === c._f || r.occludeSpecular === c.X8) &&
                    _.append(
                      "    occludeSpecular(litArgs_gloss, litArgs_ao, litArgs_worldNormal, dViewDirW);"
                    )),
                  r.useSpecularityFactor &&
                    _.append(
                      "    dSpecularLight *= litArgs_specularityFactor;"
                    ),
                  r.opacityFadesSpecular === !1 &&
                    ((r.blendType === c.lA || r.blendType === c.yp) &&
                      (_.append(
                        "float specLum = dot((dSpecularLight + dReflection.rgb * dReflection.a), vec3( 0.2126, 0.7152, 0.0722 ));"
                      ),
                      _.append(`#ifdef LIT_CLEARCOAT
 specLum += dot(ccSpecularLight * litArgs_clearcoat_specularity + ccReflection.rgb * litArgs_clearcoat_specularity, vec3( 0.2126, 0.7152, 0.0722 ));
#endif`),
                      _.append(
                        "litArgs_opacity = clamp(litArgs_opacity + gammaCorrectInput(specLum), 0.0, 1.0);"
                      )),
                    _.append("litArgs_opacity *= material_alphaFade;")),
                  _.append(u.endPS),
                  r.blendType === c.lA ||
                  r.blendType === c.Yk ||
                  r.alphaToCoverage
                    ? _.append(u.outputAlphaPS)
                    : r.blendType === c.yp
                    ? _.append(u.outputAlphaPremulPS)
                    : _.append(u.outputAlphaOpaquePS),
                  r.useMsdf &&
                    _.append("    gl_FragColor = applyMsdf(gl_FragColor);"),
                  _.append(u.outputPS),
                  _.append(u.debugOutputPS),
                  te && p.prepend(u.lightDirPointPS),
                  X && p.prepend(u.falloffLinearPS),
                  $ && p.prepend(u.falloffInvSquaredPS),
                  ne && p.prepend(u.spotPS),
                  Y && !r.clusteredLightingEnabled && p.prepend(u.cookiePS);
                let O = "";
                const me = `void evaluateBackend() {
${_.code}
}`;
                p.append(me),
                  m.append(u.debugProcessFrontendPS),
                  m.append("    evaluateBackend();"),
                  m.append((0, f.ut)());
                const N = y.code + p.code + m.code;
                return (
                  N.includes("dTBN") &&
                    (O += `mat3 dTBN;
`),
                  N.includes("dVertexNormalW") &&
                    (O += `vec3 dVertexNormalW;
`),
                  N.includes("dTangentW") &&
                    (O += `vec3 dTangentW;
`),
                  N.includes("dBinormalW") &&
                    (O += `vec3 dBinormalW;
`),
                  N.includes("dViewDirW") &&
                    (O += `vec3 dViewDirW;
`),
                  N.includes("dReflDirW") &&
                    (O += `vec3 dReflDirW;
`),
                  N.includes("dHalfDirW") &&
                    (O += `vec3 dHalfDirW;
`),
                  N.includes("ccReflDirW") &&
                    (O += `vec3 ccReflDirW;
`),
                  N.includes("dLightDirNormW") &&
                    (O += `vec3 dLightDirNormW;
`),
                  N.includes("dLightDirW") &&
                    (O += `vec3 dLightDirW;
`),
                  N.includes("dLightPosW") &&
                    (O += `vec3 dLightPosW;
`),
                  N.includes("dShadowCoord") &&
                    (O += `vec3 dShadowCoord;
`),
                  N.includes("dReflection") &&
                    (O += `vec4 dReflection;
`),
                  N.includes("dDiffuseLight") &&
                    (O += `vec3 dDiffuseLight;
`),
                  N.includes("dSpecularLight") &&
                    (O += `vec3 dSpecularLight;
`),
                  N.includes("dAtten") &&
                    (O += `float dAtten;
`),
                  N.includes("dAttenD") &&
                    (O += `float dAttenD;
`),
                  N.includes("dAtten3") &&
                    (O += `vec3 dAtten3;
`),
                  N.includes("dMsdf") &&
                    (O += `vec4 dMsdf;
`),
                  N.includes("ccFresnel") &&
                    (O += `float ccFresnel;
`),
                  N.includes("ccReflection") &&
                    (O += `vec3 ccReflection;
`),
                  N.includes("ccSpecularLight") &&
                    (O += `vec3 ccSpecularLight;
`),
                  N.includes("ccSpecularityNoFres") &&
                    (O += `float ccSpecularityNoFres;
`),
                  N.includes("sSpecularLight") &&
                    (O += `vec3 sSpecularLight;
`),
                  N.includes("sReflection") &&
                    (O += `vec3 sReflection;
`),
                  this._fsGetBeginCode() +
                    this.varyings +
                    this.varyingDefines +
                    this._fsGetBaseCode() +
                    O +
                    this.frontendDecl +
                    N
                );
              }
              generateFragmentShader(t, r, u, y) {
                var p;
                const _ = this.options;
                (this.frontendDecl = t),
                  (this.frontendCode = r),
                  (this.frontendFunc = u),
                  (this.lightingUv = y),
                  _.pass === c.WW
                    ? (this.fshader = this._fsGetPickPassCode())
                    : _.pass === c.Jb
                    ? (this.fshader = this._fsGetDepthPassCode())
                    : this.shadowPass
                    ? (this.fshader = this._fsGetShadowPassCode())
                    : _.customFragmentShader
                    ? (this.fshader =
                        this._fsGetBeginCode() + _.customFragmentShader)
                    : (this.fshader = this._fsGetLitPassCode()),
                  (p = this.handleCompatibility) == null || p.call(this);
              }
              getDefinition() {
                const t = s.x.createDefinition(this.device, {
                  name: "LitShader",
                  attributes: this.attributes,
                  vertexCode: this.vshader,
                  fragmentCode: this.fshader,
                });
                return this.shaderPassInfo.isForward && (t.tag = x.pS1), t;
              }
            }
          },
          9375: (Se, W, a) => {
            "use strict";
            a.d(W, { $x: () => f, JM: () => h, ef: () => d });
            var x = a(6977),
              T = a(3862),
              g = a(3200),
              c = a(192);
            function d(s, l, n, o = !1) {
              return new x.e(
                s,
                T.x.createDefinition(s, {
                  name: `${l}_${n}`,
                  vertexCode: g.n[l],
                  fragmentCode: g.n[n],
                  useTransformFeedback: o,
                })
              );
            }
            function h(s, l, n, o, i, e = !1) {
              const t = (0, c.N)(s);
              let r = t.getCachedShader(o);
              return (
                r ||
                  ((r = new x.e(
                    s,
                    T.x.createDefinition(s, {
                      name: o,
                      vertexCode: l,
                      fragmentCode: n,
                      attributes: i,
                      useTransformFeedback: e,
                    })
                  )),
                  t.setCachedShader(o, r)),
                r
              );
            }
            function f(s, l) {
              var n;
              const o = s.definition,
                e = `${(n = o.name) != null ? n : "shader"}-id-${s.id}`,
                t = {
                  generateKey: function (p) {
                    return e;
                  },
                  createShaderDefinition: function (p, _) {
                    return o;
                  },
                },
                r = "shader",
                u = (0, c.N)(s.device);
              u.register(r, t);
              const y = u.getProgram(r, {}, l);
              return u.unregister(r), y;
            }
            (g.n.createShader = d), (g.n.createShaderFromCode = h);
          },
          1585: (Se, W, a) => {
            "use strict";
            a.d(W, { T: () => d });
            var x = a(3114),
              T = a(7338);
            const g = new T.c();
            class c {
              constructor(f, s, l = {}) {
                (this.index = void 0),
                  (this.name = void 0),
                  (this.shaderDefine = void 0),
                  (this.name = f),
                  (this.index = s),
                  Object.assign(this, l),
                  this.initShaderDefines();
              }
              initShaderDefines() {
                let f;
                this.isShadow
                  ? (f = "SHADOW")
                  : this.isForward
                  ? (f = "FORWARD")
                  : this.index === x.Jb
                  ? (f = "DEPTH")
                  : this.index === x.WW && (f = "PICK");
                const s = f
                    ? `#define ${f}_PASS
`
                    : "",
                  l = `#define ${this.name.toUpperCase()}_PASS
`;
                this.shaderDefines = s + l;
              }
            }
            class d {
              constructor() {
                (this.passesNamed = new Map()),
                  (this.passesIndexed = []),
                  (this.nextIndex = 0);
                const f = (s, l, n) => {
                  this.allocate(s, n);
                };
                f("forward", x.lW, { isForward: !0 }),
                  f("forward_hdr", x.zw, { isForward: !0 }),
                  f("depth"),
                  f("pick"),
                  f("shadow");
              }
              static get(f) {
                return g.get(f, () => new d());
              }
              allocate(f, s) {
                let l = this.passesNamed.get(f);
                return (
                  l === void 0 &&
                    ((l = new c(f, this.nextIndex, s)),
                    this.passesNamed.set(l.name, l),
                    (this.passesIndexed[l.index] = l),
                    this.nextIndex++),
                  l
                );
              }
              getByIndex(f) {
                return this.passesIndexed[f];
              }
              getByName(f) {
                return this.passesNamed.get(f);
              }
            }
          },
          5946: (Se, W, a) => {
            "use strict";
            a.d(W, { J: () => c });
            var x = a(6602),
              T = a(8691);
            class g extends x.M {
              constructor(h, f) {
                super(), (this.skin = h), (this.skinInstance = f);
              }
            }
            class c {
              static createCachedSkinInstance(h, f, s) {
                let l = c.getCachedSkinInstance(h, f);
                return (
                  l ||
                    ((l = new T.u(h)),
                    l.resolve(f, s),
                    c.addCachedSkinInstance(h, f, l)),
                  l
                );
              }
              static getCachedSkinInstance(h, f) {
                let s = null;
                const l = c._skinInstanceCache.get(f);
                if (l) {
                  const n = l.find((o) => o.skin === h);
                  n && (n.incRefCount(), (s = n.skinInstance));
                }
                return s;
              }
              static addCachedSkinInstance(h, f, s) {
                let l = c._skinInstanceCache.get(f);
                l || ((l = []), c._skinInstanceCache.set(f, l));
                let n = l.find((o) => o.skin === h);
                n || ((n = new g(h, s)), l.push(n)), n.incRefCount();
              }
              static removeCachedSkinInstance(h) {
                if (h) {
                  const f = h.rootBone;
                  if (f) {
                    const s = c._skinInstanceCache.get(f);
                    if (s) {
                      const l = s.findIndex((n) => n.skinInstance === h);
                      if (l >= 0) {
                        const n = s[l];
                        n.decRefCount(),
                          n.refCount === 0 &&
                            (s.splice(l, 1),
                            s.length || c._skinInstanceCache.delete(f),
                            h && (h.destroy(), (n.skinInstance = null)));
                      }
                    }
                  }
                }
              }
            }
            c._skinInstanceCache = new Map();
          },
          8691: (Se, W, a) => {
            "use strict";
            a.d(W, { u: () => h });
            var x = a(4585),
              T = a(9758),
              g = a(7921),
              c = a(8869);
            const d = new T.y();
            class h {
              constructor(s) {
                (this.bones = void 0),
                  (this._dirty = !0),
                  (this._rootBone = null),
                  (this._skinUpdateIndex = -1),
                  (this._updateBeforeCull = !0),
                  s && this.initSkin(s);
              }
              set rootBone(s) {
                this._rootBone = s;
              }
              get rootBone() {
                return this._rootBone;
              }
              init(s, l) {
                if (s.supportsBoneTextures) {
                  const n = l * 3;
                  let o = Math.ceil(Math.sqrt(n));
                  o = x.m.roundUp(o, 3);
                  const i = Math.ceil(n / o);
                  (this.boneTexture = new c.x(s, {
                    width: o,
                    height: i,
                    format: g.uC3,
                    mipmaps: !1,
                    minFilter: g.yib,
                    magFilter: g.yib,
                    name: "skin",
                  })),
                    (this.matrixPalette = this.boneTexture.lock());
                } else this.matrixPalette = new Float32Array(l * 12);
              }
              destroy() {
                this.boneTexture &&
                  (this.boneTexture.destroy(), (this.boneTexture = null));
              }
              resolve(s, l) {
                this.rootBone = s;
                const n = this.skin,
                  o = [];
                for (let i = 0; i < n.boneNames.length; i++) {
                  const e = n.boneNames[i];
                  let t = s.findByName(e);
                  t || (t = l), o.push(t);
                }
                this.bones = o;
              }
              initSkin(s) {
                (this.skin = s), (this.bones = []);
                const l = s.inverseBindPose.length;
                this.init(s.device, l), (this.matrices = []);
                for (let n = 0; n < l; n++) this.matrices[n] = new T.y();
              }
              uploadBones(s) {
                s.supportsBoneTextures &&
                  (this.boneTexture.lock(), this.boneTexture.unlock());
              }
              _updateMatrices(s, l) {
                if (this._skinUpdateIndex !== l) {
                  (this._skinUpdateIndex = l),
                    d.copy(s.getWorldTransform()).invert();
                  for (let n = this.bones.length - 1; n >= 0; n--)
                    this.matrices[n].mulAffine2(
                      d,
                      this.bones[n].getWorldTransform()
                    ),
                      this.matrices[n].mulAffine2(
                        this.matrices[n],
                        this.skin.inverseBindPose[n]
                      );
                }
              }
              updateMatrices(s, l) {
                this._updateBeforeCull && this._updateMatrices(s, l);
              }
              updateMatrixPalette(s, l) {
                this._updateMatrices(s, l);
                const n = this.matrixPalette,
                  o = this.bones.length;
                for (let i = 0; i < o; i++) {
                  const e = this.matrices[i].data,
                    t = i * 12;
                  (n[t] = e[0]),
                    (n[t + 1] = e[4]),
                    (n[t + 2] = e[8]),
                    (n[t + 3] = e[12]),
                    (n[t + 4] = e[1]),
                    (n[t + 5] = e[5]),
                    (n[t + 6] = e[9]),
                    (n[t + 7] = e[13]),
                    (n[t + 8] = e[2]),
                    (n[t + 9] = e[6]),
                    (n[t + 10] = e[10]),
                    (n[t + 11] = e[14]);
                }
                this.uploadBones(this.skin.device);
              }
            }
          },
          120: (Se, W, a) => {
            "use strict";
            a.d(W, { A: () => d });
            class x {
              constructor() {
                (this.index = 0), (this.boneIndices = [0, 0, 0, 0]);
              }
            }
            class T {
              constructor() {
                (this.partition = 0),
                  (this.vertexStart = 0),
                  (this.vertexCount = 0),
                  (this.indexStart = 0),
                  (this.indexCount = 0),
                  (this.boneIndices = []),
                  (this.vertices = []),
                  (this.indices = []),
                  (this.indexMap = {}),
                  (this.originalMesh = null);
              }
              addVertex(f, s, l) {
                let n = -1;
                if (this.indexMap[s] !== void 0)
                  (n = this.indexMap[s]), this.indices.push(n);
                else {
                  for (let o = 0; o < 4; o++) {
                    if (l.blendWeight.data[s * 4 + o] === 0) continue;
                    const i = l.blendIndices.data[f.index * 4 + o];
                    f.boneIndices[o] = this.getBoneRemap(i);
                  }
                  (n = this.vertices.length),
                    this.indices.push(n),
                    this.vertices.push(f),
                    (this.indexMap[s] = n);
                }
              }
              addPrimitive(f, s, l, n) {
                const o = [];
                let i = 0;
                const e = f.length;
                for (let t = 0; t < e; t++) {
                  const u = f[t].index;
                  for (let y = 0; y < 4; y++)
                    if (l.blendWeight.data[u * 4 + y] > 0) {
                      const p = l.blendIndices.data[u * 4 + y];
                      let _ = !0;
                      for (let m = 0; m < i; m++)
                        if (o[m] === p) {
                          _ = !1;
                          break;
                        }
                      if (_) {
                        o[i] = p;
                        const m = this.getBoneRemap(p);
                        i += m === -1 ? 1 : 0;
                      }
                    }
                }
                if (this.boneIndices.length + i > n) return !1;
                for (let t = 0; t < i; t++) this.boneIndices.push(o[t]);
                for (let t = 0; t < e; t++) this.addVertex(f[t], s[t], l);
                return !0;
              }
              getBoneRemap(f) {
                for (let s = 0; s < this.boneIndices.length; s++)
                  if (this.boneIndices[s] === f) return s;
                return -1;
              }
            }
            function g(h) {
              const f = h.vertices,
                s = h.skins,
                l = h.meshes,
                n = h.meshInstances;
              for (let o = 0; o < l.length; o++)
                (l[o].vertices = f[l[o].vertices]),
                  l[o].skin !== void 0 && (l[o].skin = s[l[o].skin]);
              for (let o = 0; o < n.length; o++) n[o].mesh = l[n[o].mesh];
            }
            function c(h) {
              const f = h.vertices,
                s = h.skins,
                l = h.meshes,
                n = h.meshInstances;
              for (let o = 0; o < l.length; o++)
                (l[o].vertices = f.indexOf(l[o].vertices)),
                  l[o].skin !== void 0 && (l[o].skin = s.indexOf(l[o].skin));
              for (let o = 0; o < n.length; o++)
                n[o].mesh = l.indexOf(n[o].mesh);
            }
            function d(h, f, s) {
              let l, n, o, i;
              g(h);
              const e = h.vertices,
                t = h.skins;
              let r;
              const u = h.meshes,
                y = h.meshInstances,
                p = function (m) {
                  const E = new x();
                  return (E.index = m), E;
                };
              for (l = t.length - 1; l >= 0; l--)
                if (t[l].boneNames.length > s) {
                  const _ = t.splice(l, 1)[0],
                    m = [];
                  for (n = 0; n < u.length; n++)
                    u[n].skin === _ && m.push(u[n]);
                  for (n = 0; n < m.length; n++)
                    (i = u.indexOf(m[n])), i !== -1 && u.splice(i, 1);
                  if (m.length === 0)
                    throw new Error(
                      "partitionSkin: There should be at least one mesh that references a skin"
                    );
                  const E = m[0].vertices;
                  for (n = 1; n < m.length; n++)
                    if (m[n].vertices !== E)
                      throw new Error(
                        "partitionSkin: All meshes that share a skin should also share the same vertex buffer"
                      );
                  let v;
                  const P = [],
                    I = [],
                    A = [];
                  let B = 0;
                  for (n = 0; n < m.length; n++) {
                    r = m[n];
                    const Y = r.indices;
                    for (let Z = r.base; Z < r.base + r.count; ) {
                      (i = Y[Z++]),
                        (I[0] = p(i)),
                        (A[0] = i),
                        (i = Y[Z++]),
                        (I[1] = p(i)),
                        (A[1] = i),
                        (i = Y[Z++]),
                        (I[2] = p(i)),
                        (A[2] = i);
                      let ye = !1;
                      for (let pe = B; pe < P.length; pe++)
                        if (((v = P[pe]), v.addPrimitive(I, A, E, s))) {
                          ye = !0;
                          break;
                        }
                      ye ||
                        ((v = new T()),
                        (v.originalMesh = r),
                        v.addPrimitive(I, A, E, s),
                        P.push(v));
                    }
                    B = P.length;
                  }
                  const C = [],
                    w = [];
                  for (n = 0; n < P.length; n++)
                    if (((v = P[n]), v.vertices.length && v.indices.length)) {
                      const Y = C.length,
                        Z = v.vertices.length,
                        ye = w.length,
                        pe = v.indices.length;
                      (v.partition = n),
                        (v.vertexStart = Y),
                        (v.vertexCount = Z),
                        (v.indexStart = ye),
                        (v.indexCount = pe);
                      let O, me;
                      for (O = 0, me = Y; O < Z; ) C[me++] = v.vertices[O++];
                      for (O = 0, me = ye; O < pe; )
                        w[me++] = v.indices[O++] + Y;
                    }
                  const k = [];
                  for (n = 0; n < P.length; n++) {
                    v = P[n];
                    const Y = [],
                      Z = [];
                    for (o = 0; o < v.boneIndices.length; o++)
                      Y.push(_.inverseBindMatrices[v.boneIndices[o]]),
                        Z.push(_.boneNames[v.boneIndices[o]]);
                    const ye = { inverseBindMatrices: Y, boneNames: Z };
                    k.push(ye), t.push(ye);
                  }
                  let K, te, X, $;
                  const ne = {};
                  for (te in E)
                    ne[te] = {
                      components: E[te].components,
                      data: [],
                      type: E[te].type,
                    };
                  for (te in E)
                    if (te === "blendIndices") {
                      const Y = ne[te].data;
                      for (n = 0; n < C.length; n++) {
                        const Z = C[n].boneIndices;
                        Y.push(Z[0], Z[1], Z[2], Z[3]);
                      }
                    } else
                      for (
                        K = E[te], X = K.data, $ = K.components, n = 0;
                        n < C.length;
                        n++
                      )
                        for (i = C[n].index, o = 0; o < $; o++)
                          ne[te].data.push(X[i * $ + o]);
                  for (e[e.indexOf(E)] = ne, n = 0; n < P.length; n++)
                    for (
                      v = P[n],
                        r = {
                          aabb: { min: [0, 0, 0], max: [0, 0, 0] },
                          vertices: ne,
                          skin: k[n],
                          indices: w.splice(0, v.indexCount),
                          type: "triangles",
                          base: 0,
                          count: v.indexCount,
                        },
                        u.push(r),
                        o = y.length - 1;
                      o >= 0;
                      o--
                    )
                      y[o].mesh === v.originalMesh &&
                        (y.push({ mesh: r, node: y[o].node }),
                        f &&
                          f.push({ material: f[o].material, path: f[o].path }));
                  for (n = 0; n < P.length; n++)
                    for (v = P[n], o = y.length - 1; o >= 0; o--)
                      y[o].mesh === v.originalMesh &&
                        (y.splice(o, 1), f && f.splice(o, 1));
                }
              c(h);
            }
          },
          4390: (Se, W, a) => {
            "use strict";
            a.d(W, { Z: () => x });
            class x {
              constructor(g, c, d) {
                (this.device = g),
                  (this.inverseBindPose = c),
                  (this.boneNames = d);
              }
            }
          },
          9432: (Se, W, a) => {
            "use strict";
            a.d(W, { j: () => f });
            var x = a(5338),
              T = a(2978),
              g = a(3114),
              c = a(4611);
            const d = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
              h = [0, 1, 3, 2, 3, 1];
            class f extends x.b {
              constructor(l, n) {
                super(),
                  (this._device = l),
                  (this._pixelsPerUnit =
                    n && n.pixelsPerUnit !== void 0 ? n.pixelsPerUnit : 1),
                  (this._renderMode =
                    n && n.renderMode !== void 0 ? n.renderMode : g._r),
                  (this._atlas = n && n.atlas !== void 0 ? n.atlas : null),
                  (this._frameKeys =
                    n && n.frameKeys !== void 0 ? n.frameKeys : null),
                  (this._meshes = []),
                  (this._updatingProperties = !1),
                  (this._meshesDirty = !1),
                  this._atlas && this._frameKeys && this._createMeshes();
              }
              set frameKeys(l) {
                (this._frameKeys = l),
                  this._atlas &&
                    this._frameKeys &&
                    (this._updatingProperties
                      ? (this._meshesDirty = !0)
                      : this._createMeshes()),
                  this.fire("set:frameKeys", l);
              }
              get frameKeys() {
                return this._frameKeys;
              }
              set atlas(l) {
                l !== this._atlas &&
                  (this._atlas &&
                    (this._atlas.off("set:frames", this._onSetFrames, this),
                    this._atlas.off("set:frame", this._onFrameChanged, this),
                    this._atlas.off(
                      "remove:frame",
                      this._onFrameRemoved,
                      this
                    )),
                  (this._atlas = l),
                  this._atlas &&
                    this._frameKeys &&
                    (this._atlas.on("set:frames", this._onSetFrames, this),
                    this._atlas.on("set:frame", this._onFrameChanged, this),
                    this._atlas.on("remove:frame", this._onFrameRemoved, this),
                    this._updatingProperties
                      ? (this._meshesDirty = !0)
                      : this._createMeshes()),
                  this.fire("set:atlas", l));
              }
              get atlas() {
                return this._atlas;
              }
              set pixelsPerUnit(l) {
                this._pixelsPerUnit !== l &&
                  ((this._pixelsPerUnit = l),
                  this.fire("set:pixelsPerUnit", l),
                  this._atlas &&
                    this._frameKeys &&
                    this.renderMode === g._r &&
                    (this._updatingProperties
                      ? (this._meshesDirty = !0)
                      : this._createMeshes()));
              }
              get pixelsPerUnit() {
                return this._pixelsPerUnit;
              }
              set renderMode(l) {
                if (this._renderMode === l) return;
                const n = this._renderMode;
                (this._renderMode = l),
                  this.fire("set:renderMode", l),
                  (n === g._r || l === g._r) &&
                    this._atlas &&
                    this._frameKeys &&
                    (this._updatingProperties
                      ? (this._meshesDirty = !0)
                      : this._createMeshes());
              }
              get renderMode() {
                return this._renderMode;
              }
              get meshes() {
                return this._meshes;
              }
              _createMeshes() {
                const l = this._meshes.length;
                for (let i = 0; i < l; i++) {
                  const e = this._meshes[i];
                  e && e.destroy();
                }
                const n = this._frameKeys.length;
                this._meshes = new Array(n);
                const o =
                  this.renderMode === g.ei || this._renderMode === g.DD
                    ? this._create9SliceMesh
                    : this._createSimpleMesh;
                for (let i = 0; i < n; i++) {
                  const e = this._atlas.frames[this._frameKeys[i]];
                  this._meshes[i] = e ? o.call(this, e) : null;
                }
                this.fire("set:meshes");
              }
              _createSimpleMesh(l) {
                const n = l.rect,
                  o = this._atlas.texture.width,
                  i = this._atlas.texture.height,
                  e = n.z / this._pixelsPerUnit,
                  t = n.w / this._pixelsPerUnit,
                  r = l.pivot.x,
                  u = l.pivot.y,
                  y = [
                    -r * e,
                    -u * t,
                    0,
                    (1 - r) * e,
                    -u * t,
                    0,
                    (1 - r) * e,
                    (1 - u) * t,
                    0,
                    -r * e,
                    (1 - u) * t,
                    0,
                  ],
                  p = n.x / o,
                  _ = 1 - n.y / i,
                  m = (n.x + n.z) / o,
                  E = 1 - (n.y + n.w) / i,
                  v = [p, _, m, _, m, E, p, E];
                return (0, c.Ns)(this._device, y, {
                  uvs: v,
                  normals: d,
                  indices: h,
                });
              }
              _create9SliceMesh() {
                const l = T.S.ONE,
                  n = 3,
                  o = 3,
                  i = [],
                  e = [],
                  t = [],
                  r = [];
                let u = 0;
                for (let p = 0; p <= n; p++) {
                  const _ = p === 0 || p === n ? 0 : 1;
                  for (let m = 0; m <= o; m++) {
                    const E = -l.x + (2 * l.x * (p <= 1 ? 0 : 3)) / n,
                      v = 0,
                      P = -(-l.y + (2 * l.y * (m <= 1 ? 0 : 3)) / o),
                      I = m === 0 || m === o ? 0 : 1;
                    i.push(-E, v, P),
                      e.push(0, 1, 0),
                      t.push(_, I),
                      p < n &&
                        m < o &&
                        (r.push(u + o + 1, u + 1, u),
                        r.push(u + o + 1, u + o + 2, u + 1)),
                      u++;
                  }
                }
                const y = { normals: e, uvs: t, indices: r };
                return (0, c.Ns)(this._device, i, y);
              }
              _onSetFrames(l) {
                this._updatingProperties
                  ? (this._meshesDirty = !0)
                  : this._createMeshes();
              }
              _onFrameChanged(l, n) {
                const o = this._frameKeys.indexOf(l);
                o < 0 ||
                  (n
                    ? this.renderMode === g._r &&
                      (this._meshes[o] = this._createSimpleMesh(n))
                    : (this._meshes[o] = null),
                  this.fire("set:meshes"));
              }
              _onFrameRemoved(l) {
                const n = this._frameKeys.indexOf(l);
                n < 0 || ((this._meshes[n] = null), this.fire("set:meshes"));
              }
              startUpdate() {
                (this._updatingProperties = !0), (this._meshesDirty = !1);
              }
              endUpdate() {
                (this._updatingProperties = !1),
                  this._meshesDirty &&
                    this._atlas &&
                    this._frameKeys &&
                    this._createMeshes(),
                  (this._meshesDirty = !1);
              }
              destroy() {
                for (const l of this._meshes) l && l.destroy();
                this._meshes.length = 0;
              }
            }
          },
          6567: (Se, W, a) => {
            "use strict";
            a.d(W, { Y: () => T });
            var x = a(5338);
            class T extends x.b {
              constructor() {
                super(), (this._texture = null), (this._frames = null);
              }
              set texture(c) {
                (this._texture = c), this.fire("set:texture", c);
              }
              get texture() {
                return this._texture;
              }
              set frames(c) {
                (this._frames = c), this.fire("set:frames", c);
              }
              get frames() {
                return this._frames;
              }
              setFrame(c, d) {
                let h = this._frames[c];
                h
                  ? (h.rect.copy(d.rect),
                    h.pivot.copy(d.pivot),
                    h.border.copy(d.border))
                  : ((h = {
                      rect: d.rect.clone(),
                      pivot: d.pivot.clone(),
                      border: d.border.clone(),
                    }),
                    (this._frames[c] = h)),
                  this.fire("set:frame", c.toString(), h);
              }
              removeFrame(c) {
                const d = this._frames[c];
                d &&
                  (delete this._frames[c],
                  this.fire("remove:frame", c.toString(), d));
              }
              destroy() {
                this._texture && this._texture.destroy();
              }
            }
          },
        },
        Si = {};
      function kt(Se) {
        var W = Si[Se];
        if (W !== void 0) return W.exports;
        var a = (Si[Se] = { exports: {} });
        return Tn[Se](a, a.exports, kt), a.exports;
      }
      (kt.n = (Se) => {
        var W = Se && Se.__esModule ? () => Se.default : () => Se;
        return kt.d(W, { a: W }), W;
      }),
        (kt.d = (Se, W) => {
          for (var a in W)
            kt.o(W, a) &&
              !kt.o(Se, a) &&
              Object.defineProperty(Se, a, { enumerable: !0, get: W[a] });
        }),
        (kt.g = (function () {
          if (typeof globalThis == "object") return globalThis;
          try {
            return this || new Function("return this")();
          } catch (Se) {
            if (typeof window == "object") return window;
          }
        })()),
        (kt.o = (Se, W) => Object.prototype.hasOwnProperty.call(Se, W)),
        (kt.r = (Se) => {
          typeof Symbol != "undefined" &&
            Symbol.toStringTag &&
            Object.defineProperty(Se, Symbol.toStringTag, { value: "Module" }),
            Object.defineProperty(Se, "__esModule", { value: !0 });
        });
      var Fn = {};
      (() => {
        "use strict";
        kt.d(Fn, { l: () => $t });
        const Se = JSON.parse(
          '{"zB":{"sfx_click":"assets/audios/sfx_click.mp3","sfx_coin":"assets/audios/sfx_coin.mp3","sfx_collide_checkPoint":"assets/audios/sfx_collide_checkPoint.mp3","sfx_collide_floor":"assets/audios/sfx_collide_floor.mp3","sfx_collide_pipe":"assets/audios/sfx_collide_pipe.mp3","sfx_hitBox":"assets/audios/sfx_hitBox.mp3","sfx_key":"assets/audios/sfx_key.mp3","sfx_respawn":"assets/audios/sfx_respawn.mp3","sfx_rolling_bridge":"assets/audios/sfx_rolling_bridge.mp3","sfx_rolling_floor":"assets/audios/sfx_rolling_floor.mp3","sfx_rolling_pipe":"assets/audios/sfx_rolling_pipe.mp3","sfx_wingame":"assets/audios/sfx_wingame.mp3"},"Rq":{"font_rounded":"assets/fonts/font_rounded.json"},"Cq":{"model_ball_001":"assets/models/model_ball_001.glb","model_ball_002":"assets/models/model_ball_002.glb","model_ball_003":"assets/models/model_ball_003.glb","model_ball_004":"assets/models/model_ball_004.glb","model_ball_005":"assets/models/model_ball_005.glb","model_ball_006":"assets/models/model_ball_006.glb","model_ball_obstacle_001":"assets/models/model_ball_obstacle_001.glb","model_box_obstacle_001":"assets/models/model_box_obstacle_001.glb","model_barrier_001":"assets/models/model_barrier_001.glb","model_finish_001":"assets/models/model_finish_001.glb","model_key_001":"assets/models/model_key_001.glb","model_coin_001":"assets/models/model_coin_001.glb","model_obstacle_hammerhead_001":"assets/models/model_obstacle_hammerhead_001.glb","model_panel_direction_001":"assets/models/model_panel_direction_001.glb","model_pipe_001":"assets/models/model_pipe_001.glb","model_pipe_003":"assets/models/model_pipe_003.glb","model_pipe_002":"assets/models/model_pipe_002.glb","model_pipe_004":"assets/models/model_pipe_004.glb","model_pipe_004_B":"assets/models/model_pipe_004_B.glb","model_pipe_007":"assets/models/model_pipe_007.glb","model_pipe_010":"assets/models/model_pipe_010.glb","model_pipe_011_A":"assets/models/model_pipe_011_A.glb","model_pipe_012":"assets/models/model_pipe_012.glb","model_pipe_011_B":"assets/models/model_pipe_011_B.glb","model_pipe_014":"assets/models/model_pipe_014.glb","model_pipe_013":"assets/models/model_pipe_013.glb","model_pipe_016":"assets/models/model_pipe_016.glb","model_pipe_018":"assets/models/model_pipe_018.glb","model_pipe_019":"assets/models/model_pipe_019.glb","model_pipe_020":"assets/models/model_pipe_020.glb","model_pipe_021_A":"assets/models/model_pipe_021_A.glb","model_pipe_021_B":"assets/models/model_pipe_021_B.glb","model_pipe_022_B":"assets/models/model_pipe_022_B.glb","model_pipe_023_A":"assets/models/model_pipe_023_A.glb","model_pipe_024":"assets/models/model_pipe_024.glb","model_pipe_025":"assets/models/model_pipe_025.glb","model_pipe_028":"assets/models/model_pipe_028.glb","model_pipe_030":"assets/models/model_pipe_030.glb","model_pipe_029":"assets/models/model_pipe_029.glb","model_pipe_033":"assets/models/model_pipe_033.glb","model_pipe_039":"assets/models/model_pipe_039.glb","model_pipe_042":"assets/models/model_pipe_042.glb","model_pipe_042_B":"assets/models/model_pipe_042_B.glb","model_pipe_039_B":"assets/models/model_pipe_039_B.glb","model_pipe_043":"assets/models/model_pipe_043.glb","model_pipe_044":"assets/models/model_pipe_044.glb","model_pipe_044_B":"assets/models/model_pipe_044_B.glb","model_pipe_27":"assets/models/model_pipe_27.glb","model_pipe_corner_002":"assets/models/model_pipe_corner_002.glb","model_pipe_head":"assets/models/model_pipe_head.glb","model_platform_001":"assets/models/model_platform_001.glb","model_platform_life_bonus_001":"assets/models/model_platform_life_bonus_001.glb","model_platform_jump_001":"assets/models/model_platform_jump_001.glb","model_ring_001":"assets/models/model_ring_001.glb","model_road_001":"assets/models/model_road_001.glb","model_road_002":"assets/models/model_road_002.glb","model_road_004":"assets/models/model_road_004.glb","model_road_003":"assets/models/model_road_003.glb","model_road_006":"assets/models/model_road_006.glb","model_road_007":"assets/models/model_road_007.glb","model_road_008_A":"assets/models/model_road_008_A.glb","model_road_008_B":"assets/models/model_road_008_B.glb","model_road_010":"assets/models/model_road_010.glb","model_road_012":"assets/models/model_road_012.glb","model_road_011":"assets/models/model_road_011.glb","model_road_013":"assets/models/model_road_013.glb","model_road_014":"assets/models/model_road_014.glb","model_road_015":"assets/models/model_road_015.glb","model_road_016":"assets/models/model_road_016.glb","model_road_019":"assets/models/model_road_019.glb","model_road_018":"assets/models/model_road_018.glb","model_road_021":"assets/models/model_road_021.glb","model_road_022":"assets/models/model_road_022.glb","model_road_024":"assets/models/model_road_024.glb","model_road_023":"assets/models/model_road_023.glb","model_road_025":"assets/models/model_road_025.glb","model_road_026":"assets/models/model_road_026.glb","model_road_028":"assets/models/model_road_028.glb","model_road_029":"assets/models/model_road_029.glb","model_road_030":"assets/models/model_road_030.glb","model_road_031":"assets/models/model_road_031.glb","model_road_034":"assets/models/model_road_034.glb","model_road_036":"assets/models/model_road_036.glb","model_road_032":"assets/models/model_road_032.glb","model_road_035":"assets/models/model_road_035.glb","model_road_037":"assets/models/model_road_037.glb","model_road_038":"assets/models/model_road_038.glb","model_road_039":"assets/models/model_road_039.glb","model_road_040":"assets/models/model_road_040.glb","model_road_041":"assets/models/model_road_041.glb","model_road_043_B":"assets/models/model_road_043_B.glb","model_road_042":"assets/models/model_road_042.glb","model_road_043":"assets/models/model_road_043.glb","model_road_boost_002":"assets/models/model_road_boost_002.glb","model_road_044":"assets/models/model_road_044.glb","model_road_bridge_001":"assets/models/model_road_bridge_001.glb","model_static_obstacle_bump":"assets/models/model_static_obstacle_bump.glb"},"P6":{"4side":"assets/textures/4side.jpg","bottom":"assets/textures/bottom.jpg","spr_button_claim_x2":"assets/textures/spr_button_claim_x2.png","spr_button_continue":"assets/textures/spr_button_continue.png","spr_button_reward_ads":"assets/textures/spr_button_reward_ads.png","spr_button_reward_ads_ball":"assets/textures/spr_button_reward_ads_ball.png","spr_circle_white":"assets/textures/spr_circle_white.png","spr_coin":"assets/textures/spr_coin.png","spr_frame_continue":"assets/textures/spr_frame_continue.png","spr_frame_green":"assets/textures/spr_frame_green.png","spr_frame_level_complete":"assets/textures/spr_frame_level_complete.png","spr_frame_lv_false":"assets/textures/spr_frame_lv_false.png","spr_frame_reward":"assets/textures/spr_frame_reward.png","spr_frame_reward_inner":"assets/textures/spr_frame_reward_inner.png","spr_frame_setting":"assets/textures/spr_frame_setting.png","spr_frame_tutorial":"assets/textures/spr_frame_tutorial.png","spr_game_icon":"assets/textures/spr_game_icon.png","spr_glow_effect":"assets/textures/spr_glow_effect.png","spr_hand":"assets/textures/spr_hand.png","spr_icon_arrow":"assets/textures/spr_icon_arrow.png","spr_icon_back":"assets/textures/spr_icon_back.png","spr_icon_ball":"assets/textures/spr_icon_ball.png","spr_icon_ball_001":"assets/textures/spr_icon_ball_001.png","spr_icon_ball_002":"assets/textures/spr_icon_ball_002.png","spr_icon_ball_003":"assets/textures/spr_icon_ball_003.png","spr_icon_ball_004":"assets/textures/spr_icon_ball_004.png","spr_icon_ball_005":"assets/textures/spr_icon_ball_005.png","spr_icon_ball_006":"assets/textures/spr_icon_ball_006.png","spr_icon_ball_dead":"assets/textures/spr_icon_ball_dead.png","spr_icon_ball_select":"assets/textures/spr_icon_ball_select.png","spr_icon_check":"assets/textures/spr_icon_check.png","spr_icon_chest_close":"assets/textures/spr_icon_chest_close.png","spr_icon_chest_open":"assets/textures/spr_icon_chest_open.png","spr_icon_coin_reward":"assets/textures/spr_icon_coin_reward.png","spr_icon_key":"assets/textures/spr_icon_key.png","spr_icon_key_gray":"assets/textures/spr_icon_key_gray.png","spr_icon_level_current":"assets/textures/spr_icon_level_current.png","spr_icon_level_end_in_group":"assets/textures/spr_icon_level_end_in_group.png","spr_icon_level_locked":"assets/textures/spr_icon_level_locked.png","spr_icon_level_passed":"assets/textures/spr_icon_level_passed.png","spr_icon_pause":"assets/textures/spr_icon_pause.png","spr_icon_setting":"assets/textures/spr_icon_setting.png","spr_label_top":"assets/textures/spr_label_top.png","spr_slide_progress_bar":"assets/textures/spr_slide_progress_bar.png","spr_slide_progress_bar_fill":"assets/textures/spr_slide_progress_bar_fill.png","spr_slide_progress_bar_mask":"assets/textures/spr_slide_progress_bar_mask.png","spr_switch_active":"assets/textures/spr_switch_active.png","spr_switch_inactive":"assets/textures/spr_switch_inactive.png","spr_text_tutorial":"assets/textures/spr_text_tutorial.png","spr_tutorial_text":"assets/textures/spr_tutorial_text.png","tex_ball_001":"assets/textures/tex_ball_001.png","tex_ball_001_emissive":"assets/textures/tex_ball_001_emissive.png","tex_ball_002":"assets/textures/tex_ball_002.png","tex_ball_003":"assets/textures/tex_ball_003.jpg","tex_ball_004":"assets/textures/tex_ball_004.jpg","tex_ball_005":"assets/textures/tex_ball_005.jpg","tex_ball_006":"assets/textures/tex_ball_006.jpg","tex_ball_obstacle_001":"assets/textures/tex_ball_obstacle_001.jpg","tex_box_obstacle_001":"assets/textures/tex_box_obstacle_001.jpg","tex_confetti":"assets/textures/tex_confetti.jpg","tex_finish_001":"assets/textures/tex_finish_001.jpg","tex_finish_001_emissive":"assets/textures/tex_finish_001_emissive.jpg","tex_fx_circle":"assets/textures/tex_fx_circle.png","tex_items":"assets/textures/tex_items.jpg","tex_outerRay":"assets/textures/tex_outerRay.png","tex_panel_direction_001":"assets/textures/tex_panel_direction_001.png","tex_particle":"assets/textures/tex_particle.jpg","tex_platform_jump_001":"assets/textures/tex_platform_jump_001.jpg","tex_road_001":"assets/textures/tex_road_001.png","tex_road_001_emissive":"assets/textures/tex_road_001_emissive.png","tex_road_001_roughness":"assets/textures/tex_road_001_roughness.png","tex_road_002":"assets/textures/tex_road_002.png","tex_road_002_emissve":"assets/textures/tex_road_002_emissve.png","tex_road_bridge_001":"assets/textures/tex_road_bridge_001.jpg","top":"assets/textures/top.jpg"},"F1":{"adsConfig":"assets/jsons/adsConfig.json","ballSkin":"assets/jsons/ballSkin.json","externalLibraries":"assets/jsons/externalLibraries.json","levelData":"assets/jsons/levelData.json","map1":"assets/jsons/map1.json","map10":"assets/jsons/map10.json","map11":"assets/jsons/map11.json","map12":"assets/jsons/map12.json","map13":"assets/jsons/map13.json","map14":"assets/jsons/map14.json","map15":"assets/jsons/map15.json","map16":"assets/jsons/map16.json","map17":"assets/jsons/map17.json","map18":"assets/jsons/map18.json","map19":"assets/jsons/map19.json","map2":"assets/jsons/map2.json","map20":"assets/jsons/map20.json","map3":"assets/jsons/map3.json","map4":"assets/jsons/map4.json","map5":"assets/jsons/map5.json","map6":"assets/jsons/map6.json","map7":"assets/jsons/map7.json","map8":"assets/jsons/map8.json","map9":"assets/jsons/map9.json","mapTest":"assets/jsons/mapTest.json"},"d3":{"cm_skybox":"assets/cubemaps/cm_skybox.json"},"NC":{"mat_ball.json":"assets/materials/mat_ball.json","mat_ball_004.json":"assets/materials/mat_ball_004.json","mat_ball_002.json":"assets/materials/mat_ball_002.json","mat_ball_003.json":"assets/materials/mat_ball_003.json","mat_ball_006.json":"assets/materials/mat_ball_006.json","mat_gate_001_teleport.json":"assets/materials/mat_gate_001_teleport.json","mat_ball_005.json":"assets/materials/mat_ball_005.json","mat_box_obstacle_001.json":"assets/materials/mat_box_obstacle_001.json","mat_ball_obstacle_001.json":"assets/materials/mat_ball_obstacle_001.json","mat_gate_001.json":"assets/materials/mat_gate_001.json","mat_road_001.json":"assets/materials/mat_road_001.json","mat_items_001.json":"assets/materials/mat_items_001.json","mat_panel_direction_001.json":"assets/materials/mat_panel_direction_001.json","mat_platform_jump_001.json":"assets/materials/mat_platform_jump_001.json","mat_road_002.json":"assets/materials/mat_road_002.json","tex_road_bridge_001.json":"assets/materials/tex_road_bridge_001.json","mat_road_003.json":"assets/materials/mat_road_003.json"}}'
        );
        var W = kt(1766);
        const a = Object.freeze({
          GAME_WIDTH: 1920,
          GAME_HEIGHT: 1080,
          DEBUG_ON: !0,
          PLATFORM_ANDROID: "android",
          PLATFORM_IOS: "ios",
          SCENE_PLAY: "Play",
          SCENE_LOSE: "Lose",
          SCENE_ENDCARD: "EndCard",
          SCREEN_PLAY: "Play",
          SCREEN_WIN: "WIN",
          SCREEN_LOSE: "Lose",
          SCREEN_CHEST: "Chest",
          SCREEN_MAIN: "Main",
          SCREEN_SKIN_SELECTION: "BallSelection",
          SCREEN_SETTING: "Setting",
          SCREEN_PAUSE: "Pause",
          MINIUM_SPEED: 0.1,
          MAX_SPEED: 40,
          MAX_JUMPING_SPEED: 19,
          BALL_SCALE: 0.8,
          BALL_DIRECTION_ROTATE_SPEED: 5,
          BALL_ROTATION_SPEED: 150,
          BALL_Y_SMOOTH_SPEED: 10,
          CAMERA_FOLLOW_SPEED: 3,
          DEAD_HEIGHT: -40,
          TOTAL_LIFE: 5,
          MAX_FORCE: 20,
          CAN_CONTROL_IN_AIR: !0,
          MAX_VELOCITY_Y: 4,
          JUMP_FORCE_MULTIPLIER: 10,
          ROLLING_PIPE_FORCE: 2,
          JUMP_TIME: 1,
          BOOSTER_SPEED_MULTIPLIER: 2,
          TOTAL_KEY_TO_COLLECT: 3,
          ITEM_COIN_AMOUNT: 5,
          FIXED_TIME_STEP: 1 / 120,
          GRAVITY_X: 0,
          GRAVITY_Y: -9.8,
          GRAVITY_Z: 0,
          DEBUG_ORBIT_CAMERA: !0,
          DEBUG_PHYSICS: !1,
          DEBUG_PHYSICS_MODE: 1,
          STORAGE_CLEAR_ON_START: !1,
          STORAGE_KEY_COIN: "coin",
          STORAGE_KEY_KEY: "Key",
          STORAGE_KEY_LIFE: "life",
          STORAGE_KEY_SKIN: "skin",
          STORAGE_KEY_UNLOCKED_SKIN: "unlocked_skin",
          STORAGE_KEY_LEVEL: "level",
          STORAGE_KEY_SETTING: "setting",
          INIT_SKIN: "ball_001",
          PERCENTAGE_TO_OPEN_SKIN_CHEST: 0.1,
        });
        class x {
          static log(S, D, ...le) {
            this._logConsole("log", S, D, ...le);
          }
          static warn(S, D, ...le) {
            this._logConsole("warn", S, D, ...le);
          }
          static error(S, D, ...le) {
            this._logConsole("error", S, D, ...le);
          }
          static debug(S, D, ...le) {
            this._logConsole("debug", S, D, ...le);
          }
          static _logConsole(S, D, le, ...Ce) {
            this.enabled && console[S] && console[S](`[${D}] ${le}`, ...Ce);
          }
          static get enabled() {
            return a.DEBUG_ON;
          }
        }
        var T = Object.defineProperty,
          g = (ee, S, D) =>
            S in ee
              ? T(ee, S, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: D,
                })
              : (ee[S] = D),
          c = (ee, S, D) => (g(ee, typeof S != "symbol" ? S + "" : S, D), D);
        const d = class Ri {
          static loadSetting() {
            let S = localStorage.getItem(a.STORAGE_KEY_SETTING);
            S ? (Ri._settings = JSON.parse(S)) : Ri.saveSetting(),
              f.muteAllMusic(!Ri._settings.music),
              f.muteAllSound(!Ri._settings.sound);
          }
          static saveSetting() {
            localStorage.setItem(
              a.STORAGE_KEY_SETTING,
              JSON.stringify(Ri._settings)
            );
          }
          static get(S) {
            return Ri._settings[S];
          }
          static set(S, D) {
            switch (((Ri._settings[S] = D), Ri.saveSetting(), S)) {
              case "music":
                f.muteAllMusic(!D);
                break;
              case "sound":
                f.muteAllSound(!D);
                break;
              case "vibration":
                break;
            }
          }
        };
        c(d, "_settings", { music: !0, sound: !0, vibration: !0 });
        let h = d;
        class f {
          static load(S, D) {
            (this._onLoaded = D), (this.audios = {}), (this.songs = {});
            var le = 0;
            for (var Ce in S)
              this.audios[Ce] = new W.Howl({
                src: S[Ce],
                onloaderror: (Ue, rt) =>
                  x.log("SoundManager", "Load error", Ue, rt),
                onplayerror: (Ue, rt) =>
                  x.log("SoundManager", "Play error", Ue, rt),
                onload: () => {
                  le++,
                    le === Object.keys(S).length &&
                      ((this.loaded = !0), D && D());
                },
              });
          }
          static play(S, D = 1, le = !1) {
            if (W.Howler.ctx.state === "running") {
              var Ce = this.audios[S],
                Ue = Ce.play();
              return (
                Ce.volume(D),
                Ce.loop(le),
                h.get("sound") === !1 && this.muteSound(S, !0),
                Ue
              );
            }
          }
          static playMusic(S, D = 1, le = !0) {
            if (W.Howler.ctx.state !== "running") return;
            let Ce = this.play(S, D, le);
            (this.songs[S] = Ce),
              h.get("music") === !1 && this.muteMusic(S, !0);
          }
          static isPlaying(S) {
            return this.audios[S].playing();
          }
          static stop(S) {
            this.audios[S].stop();
          }
          static muteAll(S) {
            W.Howler.mute(S);
          }
          static muteAllSound(S) {
            for (var D in this.audios) this.muteSound(D, S);
          }
          static muteSound(S, D) {
            var le;
            (le = this.audios[S]) == null || le.mute(D);
          }
          static muteAllMusic(S) {
            for (var D in this.songs) this.muteMusic(D, S);
          }
          static muteMusic(S, D) {
            var le;
            (le = this.songs[S]) == null || le.mute(D);
          }
        }
        var s = kt(6204),
          l = kt(8869);
        class n {
          static init(S) {
            (this.loaded = !1),
              (this.app = S),
              (this.assets = S.assets),
              (this._loadedTextures = 0),
              (this._loadedModels = 0),
              (this._loadedFonts = 0),
              (this._loadedAudio = 0),
              (this._loadedJsons = 0),
              (this._loadedCubeMaps = 0),
              (this._loadedMaterials = 0);
          }
          static load(S) {
            this.onLoad = S;
            for (let D in Se.P6)
              this.loadFromURL(
                Se.P6[D],
                D,
                "texture",
                this._onTextureLoaded.bind(this)
              );
            for (let D in Se.NC)
              this.loadFromURL(
                Se.NC[D],
                D,
                "material",
                this._onMaterialLoaded.bind(this)
              );
            for (let D in Se.Cq)
              this.loadFromURL(
                Se.Cq[D],
                D,
                "model",
                this._onModelLoaded.bind(this)
              );
            for (let D in Se.F1)
              this.loadFromURL(
                Se.F1[D],
                D,
                "json",
                this._onJsonLoaded.bind(this)
              );
            for (let D in Se.Rq) {
              let le = new s.x(D, "font", { url: Se.Rq[D] });
              le.once("load", this._onFontLoaded.bind(this)),
                this.assets.add(le),
                this.assets.load(le);
            }
            this._loadCubeMap(), f.load(Se.zB, this._checkLoad.bind(this));
          }
          static _loadCubeMap() {
            for (let S in Se.d3)
              this.assets._loader.getHandler("json").load(Se.d3[S], (D, le) => {
                let Ce = le.textures.filter(
                    (Je, St, Bt) => Bt.indexOf(Je) === St
                  ),
                  Ue = 0;
                var rt = () => {
                  if ((Ue++, Ue === Ce.length)) {
                    var Je = new l.x(this.app.graphicsDevice, { cubemap: !0 });
                    (Je.name = S),
                      (Je.anisotropy = le.anisotropy),
                      (Je.minFilter = le.minFilter),
                      (Je.magFilter = le.magFilter),
                      Je.setSource(
                        le.textures.map((St) => n.find(St).resource.getSource())
                      ),
                      this.registerAsset(Je, S, "cubemap"),
                      this._loadedCubeMaps++,
                      this._checkLoad();
                  }
                };
                for (let Je of Ce) this.loadFromURL(Je, Je, "texture", rt);
              });
          }
          static loadFromURL(S, D, le, Ce) {
            this.assets.loadFromUrl(S, le, (Ue, rt) => {
              (rt.name = D), Ce();
            });
          }
          static _onMaterialLoaded() {
            this._loadedMaterials++, this._checkLoad();
          }
          static _onTextureLoaded() {
            this._loadedTextures++, this._checkLoad();
          }
          static _onModelLoaded() {
            this._loadedModels++, this._checkLoad();
          }
          static _onFontLoaded() {
            this._loadedFonts++, this._checkLoad();
          }
          static _onJsonLoaded() {
            this._loadedJsons++, this._checkLoad();
          }
          static _checkLoad() {
            this._loadedTextures >= Object.keys(Se.P6).length &&
              this._loadedModels >= Object.keys(Se.Cq).length &&
              this._loadedFonts >= Object.keys(Se.Rq).length &&
              this._loadedJsons >= Object.keys(Se.F1).length &&
              this._loadedCubeMaps >= Object.keys(Se.d3).length &&
              this._loadedMaterials >= Object.keys(Se.NC).length &&
              f.loaded &&
              ((this.loaded = !0), this.onLoad && this.onLoad());
          }
          static registerAsset(S, D, le) {
            let Ce = new s.x(D, le, null);
            (Ce.resource = S), (Ce.loaded = !0), this.assets.add(Ce);
          }
          static find(S) {
            return typeof S == "string" ? this.assets.find(S) : S;
          }
          static findAll(S) {
            return typeof S == "string" ? this.assets.findAll(S) : S;
          }
        }
        var o = kt(258);
        (o.J.prototype.enable = function () {
          this.enabled = !0;
        }),
          (o.J.prototype.disable = function () {
            this.enabled = !1;
          });
        var i = kt(6556);
        (i.A.prototype.min2 = function (ee, S) {
          return (
            (this.x = Math.min(ee.x, S.x)),
            (this.y = Math.min(ee.y, S.y)),
            (this.z = Math.min(ee.z, S.z)),
            this
          );
        }),
          (i.A.prototype.max2 = function (ee, S) {
            return (
              (this.x = Math.max(ee.x, S.x)),
              (this.y = Math.max(ee.y, S.y)),
              (this.z = Math.max(ee.z, S.z)),
              this
            );
          });
        var e = kt(9758),
          t = kt(3028),
          r = kt(8792);
        const u = new e.y(),
          y = new t.z();
        r.l.prototype.rayCast = function (ee) {
          u.copy(this.node.getWorldTransform()),
            u.invert(),
            y.set(ee.origin, ee.direction),
            y.transform(u),
            y.direction.normalize();
          const S = this._mesh.rayCast(y),
            D = S && S.dist,
            le = S && S.normal;
          return D
            ? (y.direction.mulScalar(D),
              y.origin.add(y.direction),
              this.node.getWorldTransform().transformPoint(y.origin, y.origin),
              { point: y.origin, normal: le })
            : null;
        };
        var p = kt(3148);
        Object.defineProperty(p.k.prototype, "halfArea", {
          get: function () {
            const { x: ee, y: S, z: D } = this.halfExtents;
            return 4 * (ee * (S + D) + S * D);
          },
        }),
          (t.z.prototype.transform = function (ee) {
            ee.transformPoint(this.origin, this.origin),
              ee.transformVector(this.direction, this.direction);
          });
        var _ = kt(7915);
        const m = Object.getOwnPropertyDescriptor(_.A.prototype, "enabled");
        Object.defineProperty(_.A.prototype, "enabled", {
          get: function () {
            return m.get.call(this);
          },
          set: function (ee) {
            var S, D;
            m.set.call(this, ee),
              ee
                ? (S = this.onEnable) == null || S.call(this)
                : (D = this.onDisable) == null || D.call(this);
          },
        }),
          Object.defineProperty(_.A.prototype, "_selfEnabled", {
            get: function () {
              return m.get.call(this);
            },
            set: function (ee) {
              m.set.call(this, ee);
            },
          });
        var E = kt(6612),
          v = kt(9296),
          P = Object.defineProperty,
          I = Object.defineProperties,
          A = Object.getOwnPropertyDescriptors,
          B = Object.getOwnPropertySymbols,
          C = Object.prototype.hasOwnProperty,
          w = Object.prototype.propertyIsEnumerable,
          k = (ee, S, D) =>
            S in ee
              ? P(ee, S, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: D,
                })
              : (ee[S] = D),
          K = (ee, S) => {
            for (var D in S || (S = {})) C.call(S, D) && k(ee, D, S[D]);
            if (B) for (var D of B(S)) w.call(S, D) && k(ee, D, S[D]);
            return ee;
          },
          te = (ee, S) => I(ee, A(S));
        function X(ee, S = !0, D = !0) {
          const le = {};
          return (
            (le[`${ee}Map`] = "texture"),
            (le[`${ee}MapTiling`] = "vec2"),
            (le[`${ee}MapOffset`] = "vec2"),
            (le[`${ee}MapRotation`] = "number"),
            (le[`${ee}MapUv`] = "number"),
            S &&
              ((le[`${ee}MapChannel`] = "string"),
              D &&
                ((le[`${ee}VertexColor`] = "boolean"),
                (le[`${ee}VertexColorChannel`] = "string"))),
            le
          );
        }
        const $ = te(
            K(
              K(
                te(
                  K(
                    te(
                      K(
                        te(
                          K(
                            te(
                              K(
                                te(
                                  K(
                                    te(
                                      K(
                                        te(
                                          K(
                                            te(
                                              K(
                                                te(
                                                  K(
                                                    te(
                                                      K(
                                                        te(
                                                          K(
                                                            te(
                                                              K(
                                                                te(
                                                                  K(
                                                                    te(
                                                                      K(
                                                                        te(
                                                                          K(
                                                                            te(
                                                                              K(
                                                                                te(
                                                                                  K(
                                                                                    te(
                                                                                      K(
                                                                                        K(
                                                                                          te(
                                                                                            K(
                                                                                              K(
                                                                                                {
                                                                                                  name: "string",
                                                                                                  chunks:
                                                                                                    "chunks",
                                                                                                  mappingFormat:
                                                                                                    "string",
                                                                                                  _engine:
                                                                                                    "boolean",
                                                                                                  ambient:
                                                                                                    "rgb",
                                                                                                  ambientTint:
                                                                                                    "boolean",
                                                                                                },
                                                                                                X(
                                                                                                  "ao"
                                                                                                )
                                                                                              ),
                                                                                              X(
                                                                                                "aoDetail",
                                                                                                !0,
                                                                                                !1
                                                                                              )
                                                                                            ),
                                                                                            {
                                                                                              aoDetailMode:
                                                                                                "string",
                                                                                              diffuse:
                                                                                                "rgb",
                                                                                              diffuseTint:
                                                                                                "boolean",
                                                                                            }
                                                                                          ),
                                                                                          X(
                                                                                            "diffuse"
                                                                                          )
                                                                                        ),
                                                                                        X(
                                                                                          "diffuseDetail",
                                                                                          !0,
                                                                                          !1
                                                                                        )
                                                                                      ),
                                                                                      {
                                                                                        diffuseDetailMode:
                                                                                          "string",
                                                                                        specular:
                                                                                          "rgb",
                                                                                        specularTint:
                                                                                          "boolean",
                                                                                      }
                                                                                    ),
                                                                                    X(
                                                                                      "specular"
                                                                                    )
                                                                                  ),
                                                                                  {
                                                                                    occludeSpecular:
                                                                                      "enum:occludeSpecular",
                                                                                    specularityFactor:
                                                                                      "number",
                                                                                    specularityFactorTint:
                                                                                      "boolean",
                                                                                  }
                                                                                ),
                                                                                X(
                                                                                  "specularityFactor"
                                                                                )
                                                                              ),
                                                                              {
                                                                                useMetalness:
                                                                                  "boolean",
                                                                                metalness:
                                                                                  "number",
                                                                                enableGGXSpecular:
                                                                                  "boolean",
                                                                                anisotropy:
                                                                                  "number",
                                                                                metalnessTint:
                                                                                  "boolean",
                                                                              }
                                                                            ),
                                                                            X(
                                                                              "metalness"
                                                                            )
                                                                          ),
                                                                          {
                                                                            useMetalnessSpecularColor:
                                                                              "boolean",
                                                                            conserveEnergy:
                                                                              "boolean",
                                                                            shininess:
                                                                              "number",
                                                                            gloss:
                                                                              "number",
                                                                            glossInvert:
                                                                              "boolean",
                                                                          }
                                                                        ),
                                                                        X(
                                                                          "gloss"
                                                                        )
                                                                      ),
                                                                      {
                                                                        clearCoat:
                                                                          "number",
                                                                      }
                                                                    ),
                                                                    X(
                                                                      "clearCoat"
                                                                    )
                                                                  ),
                                                                  {
                                                                    clearCoatGloss:
                                                                      "number",
                                                                    clearCoatGlossInvert:
                                                                      "boolean",
                                                                  }
                                                                ),
                                                                X(
                                                                  "clearCoatGloss"
                                                                )
                                                              ),
                                                              {
                                                                clearCoatBumpiness:
                                                                  "number",
                                                              }
                                                            ),
                                                            X(
                                                              "clearCoatNormal",
                                                              !1
                                                            )
                                                          ),
                                                          {
                                                            useSheen: "boolean",
                                                            sheen: "rgb",
                                                            sheenTint:
                                                              "boolean",
                                                          }
                                                        ),
                                                        X("sheen")
                                                      ),
                                                      {
                                                        sheenGloss: "number",
                                                        sheenGlossTint:
                                                          "boolean",
                                                        sheenGlossInvert:
                                                          "boolean",
                                                      }
                                                    ),
                                                    X("sheenGloss")
                                                  ),
                                                  {
                                                    fresnelModel: "number",
                                                    emissive: "rgb",
                                                    emissiveTint: "boolean",
                                                  }
                                                ),
                                                X("emissive")
                                              ),
                                              { emissiveIntensity: "number" }
                                            ),
                                            X("normal", !1)
                                          ),
                                          { bumpiness: "number" }
                                        ),
                                        X("normalDetail", !1)
                                      ),
                                      { normalDetailMapBumpiness: "number" }
                                    ),
                                    X("height", !0, !1)
                                  ),
                                  {
                                    heightMapFactor: "number",
                                    alphaToCoverage: "boolean",
                                    alphaTest: "number",
                                    alphaFade: "number",
                                    opacity: "number",
                                  }
                                ),
                                X("opacity")
                              ),
                              {
                                opacityFadesSpecular: "boolean",
                                reflectivity: "number",
                                refraction: "number",
                                refractionTint: "boolean",
                              }
                            ),
                            X("refraction")
                          ),
                          {
                            refractionIndex: "number",
                            thickness: "number",
                            thicknessTint: "boolean",
                          }
                        ),
                        X("thickness")
                      ),
                      {
                        attenuation: "rgb",
                        attenuationDistance: "number",
                        useDynamicRefraction: "boolean",
                        sphereMap: "texture",
                        cubeMap: "cubemap",
                        cubeMapProjection: "number",
                        cubeMapProjectionBox: "boundingbox",
                        useIridescence: "boolean",
                        iridescence: "number",
                        iridescenceTint: "boolean",
                      }
                    ),
                    X("iridescence")
                  ),
                  {
                    iridescenceThicknessTint: "boolean",
                    iridescenceThicknessMin: "number",
                    iridescenceThicknessMax: "number",
                    iridescenceRefractionIndex: "number",
                  }
                ),
                X("iridescenceThickness")
              ),
              X("light")
            ),
            {
              depthTest: "boolean",
              depthFunc: "enum:depthFunc",
              depthWrite: "boolean",
              depthBias: "number",
              slopeDepthBias: "number",
              cull: "enum:cull",
              blendType: "enum:blendType",
              shadingModel: "enum:shadingModel",
              useFog: "boolean",
              useLighting: "boolean",
              useSkybox: "boolean",
              useGammaTonemap: "boolean",
              envAtlas: "texture",
              twoSidedLighting: "boolean",
            }
          ),
          ne = [];
        for (const ee in $) $[ee] === "texture" && ne.push(ee);
        const Y = [];
        for (const ee in $) $[ee] === "cubemap" && Y.push(ee);
        const Z = {
          aoMapVertexColor: "boolean",
          diffuseMapTint: "boolean",
          diffuseMapVertexColor: "boolean",
          emissiveMapTint: "boolean",
          emissiveMapVertexColor: "boolean",
          glossMapVertexColor: "boolean",
          metalnessMapVertexColor: "boolean",
          opacityMapVertexColor: "boolean",
          specularAntialias: "boolean",
          specularMapTint: "boolean",
          specularMapVertexColor: "boolean",
        };
        (E.o.prototype._loadModel = function (ee, S) {
          const D = ee.getFileUrl(),
            le = v.E.getExtension(D);
          if (le === ".json" || le === ".glb") {
            const Ce = v.E.getDirectory(D),
              Ue = v.E.getBasename(D),
              rt = v.E.join(Ce, Ue.replace(le, ".mapping.json"));
            this._loader.load(rt, "json", (Je, St) => {
              Je
                ? ((ee.data = { mapping: [] }), S(ee))
                : this._loadMaterials(ee, St, (Bt, Nt) => {
                    (ee.data = St),
                      ee.once("load", () => {
                        for (
                          let Ht = 0;
                          Ht < ee.resource.meshInstances.length;
                          Ht++
                        )
                          Nt[Ht] &&
                            (ee.resource.meshInstances[Ht].material =
                              Nt[Ht].resource);
                      }),
                      S(ee);
                  });
            });
          } else S(ee);
        }),
          (E.o.prototype._loadMaterials = function (ee, S, D) {
            const le = [];
            let Ce = 0;
            const Ue = (rt, Je) => {
              this._loadTextures(Je, (St, Bt) => {
                le.push(Je), le.length === Ce && D(null, le);
              });
            };
            for (let rt = 0; rt < S.mapping.length; rt++) {
              const Je = S.mapping[rt].path;
              if (Je) {
                Ce++;
                const St = Je;
                this.loadFromUrl(St, "material", Ue);
              }
            }
            Ce === 0 && D(null, le);
          }),
          (E.o.prototype._loadTextures = function (ee, S) {
            const D = [];
            let le = 0;
            const Ce = ee.data;
            if (Ce.mappingFormat !== "path") {
              S(null, D);
              return;
            }
            const Ue = (Je, St) => {
                Je && console.error(Je),
                  D.push(St),
                  D.length === le && S(null, D);
              },
              rt = ne;
            for (let Je = 0; Je < rt.length; Je++) {
              const St = Ce[rt[Je]];
              if (St && typeof St == "string") {
                le++;
                const Bt = St;
                this.loadFromUrl(Bt, "texture", (Nt, Ht) => {
                  Ue(Nt, Ht), (ee.resource[rt[Je]] = Ht.resource);
                });
              }
            }
            le === 0 && S(null, D);
          });
        var ye = kt(7187),
          pe = kt.n(ye);
        class O {
          static init(S) {
            (this.emitter = new (pe())()), (this.state = S);
          }
          static get state() {
            return this._state;
          }
          static set state(S) {
            this._state !== S &&
              ((this.prevState = this.state),
              (this._state = S),
              this.emitter &&
                this.emitter.emit("changed", this.state, this.prevState));
          }
          static isState(...S) {
            for (var D = 0; D < S.length; D++)
              if (S[D] === this.state) return !0;
            return !1;
          }
          static registerOnStateChangedCallback(S) {
            this.emitter.on("changed", S);
          }
          static removeOnStateChangedCallback(S) {
            this.emitter.off("changed", S);
          }
        }
        const me = {
          MainMenu: "mainmenu",
          Playing: "playing",
          Paused: "paused",
          Lose: "lose",
          Win: "win",
          GameOver: "gameover",
          Tutorial: "tutorial",
          AutoPlay: "autoplay",
          AutoPlayOver: "autoplayover",
        };
        class N {
          static init(S) {
            (this.scenes = S), (this.addtiveScenes = []);
          }
          static loadScene(S) {
            let D = this.currentScene;
            (this.currentScene = S),
              this.addtiveScenes.forEach((le) => le.destroy()),
              $t.app.root.addChild(this.currentScene),
              this.currentScene.create(),
              D && ($t.app.root.removeChild(D), D.destroy());
          }
          static loadSceneAddtive(S) {
            this.addtiveScenes.push(S), $t.app.root.addChild(S);
          }
          static update(S) {
            var D;
            (D = this.currentScene) == null || D.update(S),
              this.addtiveScenes.forEach((le) => le.update(S));
          }
          static resize() {
            var S;
            (S = this.currentScene) == null || S.resize(),
              this.addtiveScenes.forEach((D) => D.resize());
          }
          static pause() {
            var S;
            (S = this.currentScene) == null || S.pause(),
              this.addtiveScenes.forEach((D) => D.pause());
          }
          static resume() {
            var S;
            (S = this.currentScene) == null || S.resume(),
              this.addtiveScenes.forEach((D) => D.resume());
          }
          static getScene(S) {
            return this.scenes.find((D) => D.key === S);
          }
        }
        var V = Object.freeze({
            Linear: Object.freeze({
              None: function (ee) {
                return ee;
              },
              In: function (ee) {
                return this.None(ee);
              },
              Out: function (ee) {
                return this.None(ee);
              },
              InOut: function (ee) {
                return this.None(ee);
              },
            }),
            Quadratic: Object.freeze({
              In: function (ee) {
                return ee * ee;
              },
              Out: function (ee) {
                return ee * (2 - ee);
              },
              InOut: function (ee) {
                return (ee *= 2) < 1
                  ? 0.5 * ee * ee
                  : -0.5 * (--ee * (ee - 2) - 1);
              },
            }),
            Cubic: Object.freeze({
              In: function (ee) {
                return ee * ee * ee;
              },
              Out: function (ee) {
                return --ee * ee * ee + 1;
              },
              InOut: function (ee) {
                return (ee *= 2) < 1
                  ? 0.5 * ee * ee * ee
                  : 0.5 * ((ee -= 2) * ee * ee + 2);
              },
            }),
            Quartic: Object.freeze({
              In: function (ee) {
                return ee * ee * ee * ee;
              },
              Out: function (ee) {
                return 1 - --ee * ee * ee * ee;
              },
              InOut: function (ee) {
                return (ee *= 2) < 1
                  ? 0.5 * ee * ee * ee * ee
                  : -0.5 * ((ee -= 2) * ee * ee * ee - 2);
              },
            }),
            Quintic: Object.freeze({
              In: function (ee) {
                return ee * ee * ee * ee * ee;
              },
              Out: function (ee) {
                return --ee * ee * ee * ee * ee + 1;
              },
              InOut: function (ee) {
                return (ee *= 2) < 1
                  ? 0.5 * ee * ee * ee * ee * ee
                  : 0.5 * ((ee -= 2) * ee * ee * ee * ee + 2);
              },
            }),
            Sinusoidal: Object.freeze({
              In: function (ee) {
                return 1 - Math.sin(((1 - ee) * Math.PI) / 2);
              },
              Out: function (ee) {
                return Math.sin((ee * Math.PI) / 2);
              },
              InOut: function (ee) {
                return 0.5 * (1 - Math.sin(Math.PI * (0.5 - ee)));
              },
            }),
            Exponential: Object.freeze({
              In: function (ee) {
                return ee === 0 ? 0 : Math.pow(1024, ee - 1);
              },
              Out: function (ee) {
                return ee === 1 ? 1 : 1 - Math.pow(2, -10 * ee);
              },
              InOut: function (ee) {
                return ee === 0
                  ? 0
                  : ee === 1
                  ? 1
                  : (ee *= 2) < 1
                  ? 0.5 * Math.pow(1024, ee - 1)
                  : 0.5 * (-Math.pow(2, -10 * (ee - 1)) + 2);
              },
            }),
            Circular: Object.freeze({
              In: function (ee) {
                return 1 - Math.sqrt(1 - ee * ee);
              },
              Out: function (ee) {
                return Math.sqrt(1 - --ee * ee);
              },
              InOut: function (ee) {
                return (ee *= 2) < 1
                  ? -0.5 * (Math.sqrt(1 - ee * ee) - 1)
                  : 0.5 * (Math.sqrt(1 - (ee -= 2) * ee) + 1);
              },
            }),
            Elastic: Object.freeze({
              In: function (ee) {
                return ee === 0
                  ? 0
                  : ee === 1
                  ? 1
                  : -Math.pow(2, 10 * (ee - 1)) *
                    Math.sin((ee - 1.1) * 5 * Math.PI);
              },
              Out: function (ee) {
                return ee === 0
                  ? 0
                  : ee === 1
                  ? 1
                  : Math.pow(2, -10 * ee) * Math.sin((ee - 0.1) * 5 * Math.PI) +
                    1;
              },
              InOut: function (ee) {
                return ee === 0
                  ? 0
                  : ee === 1
                  ? 1
                  : ((ee *= 2),
                    ee < 1
                      ? -0.5 *
                        Math.pow(2, 10 * (ee - 1)) *
                        Math.sin((ee - 1.1) * 5 * Math.PI)
                      : 0.5 *
                          Math.pow(2, -10 * (ee - 1)) *
                          Math.sin((ee - 1.1) * 5 * Math.PI) +
                        1);
              },
            }),
            Back: Object.freeze({
              In: function (ee) {
                var S = 1.70158;
                return ee === 1 ? 1 : ee * ee * ((S + 1) * ee - S);
              },
              Out: function (ee) {
                var S = 1.70158;
                return ee === 0 ? 0 : --ee * ee * ((S + 1) * ee + S) + 1;
              },
              InOut: function (ee) {
                var S = 2.5949095;
                return (ee *= 2) < 1
                  ? 0.5 * (ee * ee * ((S + 1) * ee - S))
                  : 0.5 * ((ee -= 2) * ee * ((S + 1) * ee + S) + 2);
              },
            }),
            Bounce: Object.freeze({
              In: function (ee) {
                return 1 - V.Bounce.Out(1 - ee);
              },
              Out: function (ee) {
                return ee < 1 / 2.75
                  ? 7.5625 * ee * ee
                  : ee < 2 / 2.75
                  ? 7.5625 * (ee -= 1.5 / 2.75) * ee + 0.75
                  : ee < 2.5 / 2.75
                  ? 7.5625 * (ee -= 2.25 / 2.75) * ee + 0.9375
                  : 7.5625 * (ee -= 2.625 / 2.75) * ee + 0.984375;
              },
              InOut: function (ee) {
                return ee < 0.5
                  ? V.Bounce.In(ee * 2) * 0.5
                  : V.Bounce.Out(ee * 2 - 1) * 0.5 + 0.5;
              },
            }),
            generatePow: function (ee) {
              return (
                ee === void 0 && (ee = 4),
                (ee = ee < Number.EPSILON ? Number.EPSILON : ee),
                (ee = ee > 1e4 ? 1e4 : ee),
                {
                  In: function (S) {
                    return Math.pow(S, ee);
                  },
                  Out: function (S) {
                    return 1 - Math.pow(1 - S, ee);
                  },
                  InOut: function (S) {
                    return S < 0.5
                      ? Math.pow(S * 2, ee) / 2
                      : (1 - Math.pow(2 - S * 2, ee)) / 2 + 0.5;
                  },
                }
              );
            },
          }),
          L = function () {
            return performance.now();
          },
          J = (function () {
            function ee() {
              (this._tweens = {}), (this._tweensAddedDuringUpdate = {});
            }
            return (
              (ee.prototype.getAll = function () {
                var S = this;
                return Object.keys(this._tweens).map(function (D) {
                  return S._tweens[D];
                });
              }),
              (ee.prototype.removeAll = function () {
                this._tweens = {};
              }),
              (ee.prototype.add = function (S) {
                (this._tweens[S.getId()] = S),
                  (this._tweensAddedDuringUpdate[S.getId()] = S);
              }),
              (ee.prototype.remove = function (S) {
                delete this._tweens[S.getId()],
                  delete this._tweensAddedDuringUpdate[S.getId()];
              }),
              (ee.prototype.update = function (S, D) {
                S === void 0 && (S = L()), D === void 0 && (D = !1);
                var le = Object.keys(this._tweens);
                if (le.length === 0) return !1;
                for (; le.length > 0; ) {
                  this._tweensAddedDuringUpdate = {};
                  for (var Ce = 0; Ce < le.length; Ce++) {
                    var Ue = this._tweens[le[Ce]],
                      rt = !D;
                    Ue &&
                      Ue.update(S, rt) === !1 &&
                      !D &&
                      delete this._tweens[le[Ce]];
                  }
                  le = Object.keys(this._tweensAddedDuringUpdate);
                }
                return !0;
              }),
              ee
            );
          })(),
          ae = {
            Linear: function (ee, S) {
              var D = ee.length - 1,
                le = D * S,
                Ce = Math.floor(le),
                Ue = ae.Utils.Linear;
              return S < 0
                ? Ue(ee[0], ee[1], le)
                : S > 1
                ? Ue(ee[D], ee[D - 1], D - le)
                : Ue(ee[Ce], ee[Ce + 1 > D ? D : Ce + 1], le - Ce);
            },
            Bezier: function (ee, S) {
              for (
                var D = 0,
                  le = ee.length - 1,
                  Ce = Math.pow,
                  Ue = ae.Utils.Bernstein,
                  rt = 0;
                rt <= le;
                rt++
              )
                D += Ce(1 - S, le - rt) * Ce(S, rt) * ee[rt] * Ue(le, rt);
              return D;
            },
            CatmullRom: function (ee, S) {
              var D = ee.length - 1,
                le = D * S,
                Ce = Math.floor(le),
                Ue = ae.Utils.CatmullRom;
              return ee[0] === ee[D]
                ? (S < 0 && (Ce = Math.floor((le = D * (1 + S)))),
                  Ue(
                    ee[(Ce - 1 + D) % D],
                    ee[Ce],
                    ee[(Ce + 1) % D],
                    ee[(Ce + 2) % D],
                    le - Ce
                  ))
                : S < 0
                ? ee[0] - (Ue(ee[0], ee[0], ee[1], ee[1], -le) - ee[0])
                : S > 1
                ? ee[D] -
                  (Ue(ee[D], ee[D], ee[D - 1], ee[D - 1], le - D) - ee[D])
                : Ue(
                    ee[Ce ? Ce - 1 : 0],
                    ee[Ce],
                    ee[D < Ce + 1 ? D : Ce + 1],
                    ee[D < Ce + 2 ? D : Ce + 2],
                    le - Ce
                  );
            },
            Utils: {
              Linear: function (ee, S, D) {
                return (S - ee) * D + ee;
              },
              Bernstein: function (ee, S) {
                var D = ae.Utils.Factorial;
                return D(ee) / D(S) / D(ee - S);
              },
              Factorial: (function () {
                var ee = [1];
                return function (S) {
                  var D = 1;
                  if (ee[S]) return ee[S];
                  for (var le = S; le > 1; le--) D *= le;
                  return (ee[S] = D), D;
                };
              })(),
              CatmullRom: function (ee, S, D, le, Ce) {
                var Ue = (D - ee) * 0.5,
                  rt = (le - S) * 0.5,
                  Je = Ce * Ce,
                  St = Ce * Je;
                return (
                  (2 * S - 2 * D + Ue + rt) * St +
                  (-3 * S + 3 * D - 2 * Ue - rt) * Je +
                  Ue * Ce +
                  S
                );
              },
            },
          },
          R = (function () {
            function ee() {}
            return (
              (ee.nextId = function () {
                return ee._nextId++;
              }),
              (ee._nextId = 0),
              ee
            );
          })(),
          j = new J(),
          se = (function () {
            function ee(S, D) {
              D === void 0 && (D = j),
                (this._object = S),
                (this._group = D),
                (this._isPaused = !1),
                (this._pauseStart = 0),
                (this._valuesStart = {}),
                (this._valuesEnd = {}),
                (this._valuesStartRepeat = {}),
                (this._duration = 1e3),
                (this._isDynamic = !1),
                (this._initialRepeat = 0),
                (this._repeat = 0),
                (this._yoyo = !1),
                (this._isPlaying = !1),
                (this._reversed = !1),
                (this._delayTime = 0),
                (this._startTime = 0),
                (this._easingFunction = V.Linear.None),
                (this._interpolationFunction = ae.Linear),
                (this._chainedTweens = []),
                (this._onStartCallbackFired = !1),
                (this._onEveryStartCallbackFired = !1),
                (this._id = R.nextId()),
                (this._isChainStopped = !1),
                (this._propertiesAreSetUp = !1),
                (this._goToEnd = !1);
            }
            return (
              (ee.prototype.getId = function () {
                return this._id;
              }),
              (ee.prototype.isPlaying = function () {
                return this._isPlaying;
              }),
              (ee.prototype.isPaused = function () {
                return this._isPaused;
              }),
              (ee.prototype.to = function (S, D) {
                if ((D === void 0 && (D = 1e3), this._isPlaying))
                  throw new Error(
                    "Can not call Tween.to() while Tween is already started or paused. Stop the Tween first."
                  );
                return (
                  (this._valuesEnd = S),
                  (this._propertiesAreSetUp = !1),
                  (this._duration = D),
                  this
                );
              }),
              (ee.prototype.duration = function (S) {
                return S === void 0 && (S = 1e3), (this._duration = S), this;
              }),
              (ee.prototype.dynamic = function (S) {
                return S === void 0 && (S = !1), (this._isDynamic = S), this;
              }),
              (ee.prototype.start = function (S, D) {
                if (
                  (S === void 0 && (S = L()),
                  D === void 0 && (D = !1),
                  this._isPlaying)
                )
                  return this;
                if (
                  (this._group && this._group.add(this),
                  (this._repeat = this._initialRepeat),
                  this._reversed)
                ) {
                  this._reversed = !1;
                  for (var le in this._valuesStartRepeat)
                    this._swapEndStartRepeatValues(le),
                      (this._valuesStart[le] = this._valuesStartRepeat[le]);
                }
                if (
                  ((this._isPlaying = !0),
                  (this._isPaused = !1),
                  (this._onStartCallbackFired = !1),
                  (this._onEveryStartCallbackFired = !1),
                  (this._isChainStopped = !1),
                  (this._startTime = S),
                  (this._startTime += this._delayTime),
                  !this._propertiesAreSetUp || D)
                ) {
                  if (((this._propertiesAreSetUp = !0), !this._isDynamic)) {
                    var Ce = {};
                    for (var Ue in this._valuesEnd)
                      Ce[Ue] = this._valuesEnd[Ue];
                    this._valuesEnd = Ce;
                  }
                  this._setupProperties(
                    this._object,
                    this._valuesStart,
                    this._valuesEnd,
                    this._valuesStartRepeat,
                    D
                  );
                }
                return this;
              }),
              (ee.prototype.startFromCurrentValues = function (S) {
                return this.start(S, !0);
              }),
              (ee.prototype._setupProperties = function (S, D, le, Ce, Ue) {
                for (var rt in le) {
                  var Je = S[rt],
                    St = Array.isArray(Je),
                    Bt = St ? "array" : typeof Je,
                    Nt = !St && Array.isArray(le[rt]);
                  if (!(Bt === "undefined" || Bt === "function")) {
                    if (Nt) {
                      var Ht = le[rt];
                      if (Ht.length === 0) continue;
                      for (
                        var ns = [Je], xs = 0, _s = Ht.length;
                        xs < _s;
                        xs += 1
                      ) {
                        var Rs = this._handleRelativeValue(Je, Ht[xs]);
                        if (isNaN(Rs)) {
                          (Nt = !1),
                            console.warn(
                              "Found invalid interpolation list. Skipping."
                            );
                          break;
                        }
                        ns.push(Rs);
                      }
                      Nt && (le[rt] = ns);
                    }
                    if ((Bt === "object" || St) && Je && !Nt) {
                      D[rt] = St ? [] : {};
                      var ms = Je;
                      for (var Vs in ms) D[rt][Vs] = ms[Vs];
                      Ce[rt] = St ? [] : {};
                      var Ht = le[rt];
                      if (!this._isDynamic) {
                        var hi = {};
                        for (var Vs in Ht) hi[Vs] = Ht[Vs];
                        le[rt] = Ht = hi;
                      }
                      this._setupProperties(ms, D[rt], Ht, Ce[rt], Ue);
                    } else
                      (typeof D[rt] == "undefined" || Ue) && (D[rt] = Je),
                        St || (D[rt] *= 1),
                        Nt
                          ? (Ce[rt] = le[rt].slice().reverse())
                          : (Ce[rt] = D[rt] || 0);
                  }
                }
              }),
              (ee.prototype.stop = function () {
                return (
                  this._isChainStopped ||
                    ((this._isChainStopped = !0), this.stopChainedTweens()),
                  this._isPlaying
                    ? (this._group && this._group.remove(this),
                      (this._isPlaying = !1),
                      (this._isPaused = !1),
                      this._onStopCallback &&
                        this._onStopCallback(this._object),
                      this)
                    : this
                );
              }),
              (ee.prototype.end = function () {
                return (this._goToEnd = !0), this.update(1 / 0), this;
              }),
              (ee.prototype.pause = function (S) {
                return (
                  S === void 0 && (S = L()),
                  this._isPaused || !this._isPlaying
                    ? this
                    : ((this._isPaused = !0),
                      (this._pauseStart = S),
                      this._group && this._group.remove(this),
                      this)
                );
              }),
              (ee.prototype.resume = function (S) {
                return (
                  S === void 0 && (S = L()),
                  !this._isPaused || !this._isPlaying
                    ? this
                    : ((this._isPaused = !1),
                      (this._startTime += S - this._pauseStart),
                      (this._pauseStart = 0),
                      this._group && this._group.add(this),
                      this)
                );
              }),
              (ee.prototype.stopChainedTweens = function () {
                for (var S = 0, D = this._chainedTweens.length; S < D; S++)
                  this._chainedTweens[S].stop();
                return this;
              }),
              (ee.prototype.group = function (S) {
                return S === void 0 && (S = j), (this._group = S), this;
              }),
              (ee.prototype.delay = function (S) {
                return S === void 0 && (S = 0), (this._delayTime = S), this;
              }),
              (ee.prototype.repeat = function (S) {
                return (
                  S === void 0 && (S = 0),
                  (this._initialRepeat = S),
                  (this._repeat = S),
                  this
                );
              }),
              (ee.prototype.repeatDelay = function (S) {
                return (this._repeatDelayTime = S), this;
              }),
              (ee.prototype.yoyo = function (S) {
                return S === void 0 && (S = !1), (this._yoyo = S), this;
              }),
              (ee.prototype.easing = function (S) {
                return (
                  S === void 0 && (S = V.Linear.None),
                  (this._easingFunction = S),
                  this
                );
              }),
              (ee.prototype.interpolation = function (S) {
                return (
                  S === void 0 && (S = ae.Linear),
                  (this._interpolationFunction = S),
                  this
                );
              }),
              (ee.prototype.chain = function () {
                for (var S = [], D = 0; D < arguments.length; D++)
                  S[D] = arguments[D];
                return (this._chainedTweens = S), this;
              }),
              (ee.prototype.onStart = function (S) {
                return (this._onStartCallback = S), this;
              }),
              (ee.prototype.onEveryStart = function (S) {
                return (this._onEveryStartCallback = S), this;
              }),
              (ee.prototype.onUpdate = function (S) {
                return (this._onUpdateCallback = S), this;
              }),
              (ee.prototype.onRepeat = function (S) {
                return (this._onRepeatCallback = S), this;
              }),
              (ee.prototype.onComplete = function (S) {
                return (this._onCompleteCallback = S), this;
              }),
              (ee.prototype.onStop = function (S) {
                return (this._onStopCallback = S), this;
              }),
              (ee.prototype.update = function (S, D) {
                if (
                  (S === void 0 && (S = L()),
                  D === void 0 && (D = !0),
                  this._isPaused)
                )
                  return !0;
                var le,
                  Ce,
                  Ue = this._startTime + this._duration;
                if (!this._goToEnd && !this._isPlaying) {
                  if (S > Ue) return !1;
                  D && this.start(S, !0);
                }
                if (((this._goToEnd = !1), S < this._startTime)) return !0;
                this._onStartCallbackFired === !1 &&
                  (this._onStartCallback && this._onStartCallback(this._object),
                  (this._onStartCallbackFired = !0)),
                  this._onEveryStartCallbackFired === !1 &&
                    (this._onEveryStartCallback &&
                      this._onEveryStartCallback(this._object),
                    (this._onEveryStartCallbackFired = !0)),
                  (Ce = (S - this._startTime) / this._duration),
                  (Ce = this._duration === 0 || Ce > 1 ? 1 : Ce);
                var rt = this._easingFunction(Ce);
                if (
                  (this._updateProperties(
                    this._object,
                    this._valuesStart,
                    this._valuesEnd,
                    rt
                  ),
                  this._onUpdateCallback &&
                    this._onUpdateCallback(this._object, Ce),
                  Ce === 1)
                )
                  if (this._repeat > 0) {
                    isFinite(this._repeat) && this._repeat--;
                    for (le in this._valuesStartRepeat)
                      !this._yoyo &&
                        typeof this._valuesEnd[le] == "string" &&
                        (this._valuesStartRepeat[le] =
                          this._valuesStartRepeat[le] +
                          parseFloat(this._valuesEnd[le])),
                        this._yoyo && this._swapEndStartRepeatValues(le),
                        (this._valuesStart[le] = this._valuesStartRepeat[le]);
                    return (
                      this._yoyo && (this._reversed = !this._reversed),
                      this._repeatDelayTime !== void 0
                        ? (this._startTime = S + this._repeatDelayTime)
                        : (this._startTime = S + this._delayTime),
                      this._onRepeatCallback &&
                        this._onRepeatCallback(this._object),
                      (this._onEveryStartCallbackFired = !1),
                      !0
                    );
                  } else {
                    this._onCompleteCallback &&
                      this._onCompleteCallback(this._object);
                    for (
                      var Je = 0, St = this._chainedTweens.length;
                      Je < St;
                      Je++
                    )
                      this._chainedTweens[Je].start(
                        this._startTime + this._duration,
                        !1
                      );
                    return (this._isPlaying = !1), !1;
                  }
                return !0;
              }),
              (ee.prototype._updateProperties = function (S, D, le, Ce) {
                for (var Ue in le)
                  if (D[Ue] !== void 0) {
                    var rt = D[Ue] || 0,
                      Je = le[Ue],
                      St = Array.isArray(S[Ue]),
                      Bt = Array.isArray(Je),
                      Nt = !St && Bt;
                    Nt
                      ? (S[Ue] = this._interpolationFunction(Je, Ce))
                      : typeof Je == "object" && Je
                      ? this._updateProperties(S[Ue], rt, Je, Ce)
                      : ((Je = this._handleRelativeValue(rt, Je)),
                        typeof Je == "number" && (S[Ue] = rt + (Je - rt) * Ce));
                  }
              }),
              (ee.prototype._handleRelativeValue = function (S, D) {
                return typeof D != "string"
                  ? D
                  : D.charAt(0) === "+" || D.charAt(0) === "-"
                  ? S + parseFloat(D)
                  : parseFloat(D);
              }),
              (ee.prototype._swapEndStartRepeatValues = function (S) {
                var D = this._valuesStartRepeat[S],
                  le = this._valuesEnd[S];
                typeof le == "string"
                  ? (this._valuesStartRepeat[S] =
                      this._valuesStartRepeat[S] + parseFloat(le))
                  : (this._valuesStartRepeat[S] = this._valuesEnd[S]),
                  (this._valuesEnd[S] = D);
              }),
              ee
            );
          })(),
          ce = "21.0.0",
          ie = R.nextId,
          b = j,
          M = b.getAll.bind(b),
          F = b.removeAll.bind(b),
          z = b.add.bind(b),
          oe = b.remove.bind(b),
          de = b.update.bind(b),
          ge = {
            Easing: V,
            Group: J,
            Interpolation: ae,
            now: L,
            Sequence: R,
            nextId: ie,
            Tween: se,
            VERSION: ce,
            getAll: M,
            removeAll: F,
            add: z,
            remove: oe,
            update: de,
          };
        class Re extends ge.Tween {
          constructor(S, D) {
            super(S, D);
          }
          start() {
            return super.start();
          }
        }
        var Te = kt(1367),
          Ne = kt(6847),
          Le = Math.pow;
        class ke {
          static linear(S, D, le) {
            return S + (D - S) * le;
          }
          static easeIn(S, D, le) {
            return S + (D - S) * Le(le, 2);
          }
          static easeOut(S, D, le) {
            return S + (D - S) * (1 - Le(1 - le, 2));
          }
          static easeInOut(S, D, le) {
            return S + (D - S) * (-Math.cos(le * Math.PI) / 2 + 0.5);
          }
          static copyObject(S, D = {}) {
            return (
              Object.keys(S).forEach((le) => {
                D[le] = S[le];
              }),
              D
            );
          }
          static sign(S) {
            return S < 0 ? -1 : 1;
          }
          static random(S, D) {
            return Math.random() * (D - S) + S;
          }
          static randomInt(S, D) {
            return Math.floor(Math.random() * (D - S + 1) + S);
          }
          static randomFromList(S) {
            if (S && S.length > 0) {
              let D = this.randomInt(0, S.length - 1);
              return S[D];
            } else return -1;
          }
          static randomVector(S, D, le = new i.A()) {
            return (
              (le.x = ke.random(S.x, D.x)),
              (le.y = ke.random(S.y, D.y)),
              (le.z = ke.random(S.z, D.z)),
              le
            );
          }
          static distanceBetween(S, D) {
            return Math.abs(Math.abs(S) - Math.abs(D));
          }
          static getAlpha(S, D) {
            return D === 0
              ? 90
              : this.toDegree(Math.atan(Math.abs(S) / Math.abs(D)));
          }
          static toDegree(S) {
            return (S * 180) / Math.PI;
          }
          static toRadian(S) {
            return (S * Math.PI) / 180;
          }
          static getRandomIntExclude(S, D, le) {
            let Ce = Math.floor(Math.random() * (D - S)) + S;
            return Ce === le && (Ce = D), Ce;
          }
          static getSpriteFrame(S, D = 1) {
            let le = S.atlas.frames[S.frameKeys[0]].rect;
            return { x: le.x, y: le.y, width: le.z * D, height: le.w * D };
          }
          static getSpriteAtlasFrame(S) {
            return S.atlas.frames[S.frameKeys[0]];
          }
          static getSpriteWorldSize(S) {
            let D = this.getSpriteAtlasFrame(S);
            return {
              width: D.rect.z / S.pixelsPerUnit,
              height: D.rect.w / S.pixelsPerUnit,
            };
          }
          static createColor(S = 255, D = 255, le = 255, Ce = 1) {
            return new Te.I(S / 255, D / 255, le / 255, Ce);
          }
          static setSpriteDepthTest(S, D = !0) {
            let le = S._meshInstance.material.clone();
            (le.depthTest = D), le.update(), (S._meshInstance.material = le);
          }
          static setUpEffectModel(S) {
            (S.model.castShadows = !1),
              (S.model.castShadowsLightmap = !1),
              (S.model.receiveShadows = !1);
          }
          static setModelOpacity(S, D) {
            S.model.meshInstances.forEach((le) => {
              (le.material.opacity = D), le.material.update();
            });
          }
          static setModelMaterial(S, D, le = 0) {
            S.model.meshInstances[le].material = D;
          }
          static registerOnTouch(S, D, le) {
            (S.useInput = !0),
              S.on("mousedown", D, le),
              S.on("touchstart", D, le);
          }
          static registerOnceTouch(S, D, le) {
            (S.useInput = !0),
              S.once("mousedown", D, le),
              S.once("touchstart", D, le);
          }
          static updateCircleTransform(S, D, le, Ce) {
            let Ue = S.getLocalPosition(),
              rt = Ue.x,
              Je = Le(D, 2),
              St = Le(rt, 2),
              Bt = Math.sqrt(Je + St) + le;
            (Ue.y = Bt), S.setLocalPosition(Ue);
            let Nt = S.getLocalEulerAngles(),
              Ht = ke.sign(Ue.x),
              ns = Math.abs(Bt - le),
              xs = (Math.atan(ns / Math.abs(rt)) * 180) / Math.PI;
            (Nt.z = -Ht * (xs - 90) * Ce), S.setLocalEulerAngles(Nt);
          }
          static getCashFormat(S) {
            return S >= 1e9
              ? `${(S / 1e9).toFixed(1).replace(/\.0$/, "")}B`
              : S >= 1e6
              ? `${(S / 1e6).toFixed(1).replace(/\.0$/, "")}M`
              : S >= 1e3
              ? `${(S / 1e3).toFixed(1).replace(/\.0$/, "")}K`
              : S;
          }
          static shuffleArray(S) {
            for (let D = S.length - 1; D > 0; D--) {
              const le = Math.floor(Math.random() * (D + 1));
              [S[D], S[le]] = [S[le], S[D]];
            }
          }
        }
        function ht(ee, S) {
          return typeof ee != "function" || typeof S != "function"
            ? !1
            : ee.prototype instanceof S;
        }
        function _e(ee) {
          let S,
            D,
            le = [],
            Ce = new p.k(),
            Ue = ee.findComponents("render");
          for (S = 0; S < Ue.length; S++) {
            let Je = Ue[S];
            for (D = 0; D < Je.meshInstances.length; D++)
              le.push(Je.meshInstances[D]);
          }
          let rt = ee.findComponents("model");
          for (S = 0; S < rt.length; S++) {
            let Je = rt[S];
            for (D = 0; D < Je.meshInstances.length; D++)
              le.push(Je.meshInstances[D]);
          }
          for (S = 0; S < le.length; S++)
            S === 0 ? Ce.copy(le[S].aabb) : Ce.add(le[S].aabb);
          return Ce;
        }
        var U = new i.A(),
          H = new i.A(),
          Ee = new Ne.D();
        function G(ee, S, D = void 0) {
          ee = ee.normalize();
          var le = ee.normalize();
          (U = U.cross(S, le).normalize()), (H = H.cross(le, U));
          var Ce = U.x,
            Ue = U.y,
            rt = U.z,
            Je = H.x,
            St = H.y,
            Bt = H.z,
            Nt = le.x,
            Ht = le.y,
            ns = le.z,
            xs = Ce + St + ns;
          if ((Ee.copy(Ne.D.IDENTITY), xs > 0)) {
            var _s = Math.sqrt(xs + 1);
            return (
              (Ee.w = _s * 0.5),
              (_s = 0.5 / _s),
              (Ee.x = (Bt - Ht) * _s),
              (Ee.y = (Nt - rt) * _s),
              (Ee.z = (Ue - Je) * _s),
              Ee
            );
          }
          if (Ce >= St && Ce >= ns) {
            var Rs = Math.sqrt(1 + Ce - St - ns),
              ms = 0.5 / Rs;
            return (
              (Ee.x = 0.5 * Rs),
              (Ee.y = (Ue + Je) * ms),
              (Ee.z = (rt + Nt) * ms),
              (Ee.w = (Bt - Ht) * ms),
              Ee
            );
          }
          if (St > ns) {
            var Vs = Math.sqrt(1 + St - Ce - ns),
              hi = 0.5 / Vs;
            return (
              (Ee.x = (Je + Ue) * hi),
              (Ee.y = 0.5 * Vs),
              (Ee.z = (Ht + Bt) * hi),
              (Ee.w = (Nt - rt) * hi),
              Ee
            );
          }
          var yn = Math.sqrt(1 + ns - Ce - St),
            dn = 0.5 / yn;
          return (
            (Ee.x = (Nt + rt) * dn),
            (Ee.y = (Ht + Bt) * dn),
            (Ee.z = 0.5 * yn),
            (Ee.w = (Ue - Je) * dn),
            D ? (D.copy(Ee), D) : Ee.clone()
          );
        }
        var Q = Object.defineProperty,
          q = (ee, S, D) =>
            S in ee
              ? Q(ee, S, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: D,
                })
              : (ee[S] = D),
          xe = (ee, S, D) => (q(ee, typeof S != "symbol" ? S + "" : S, D), D);
        const be = class Ei {
          static init(S) {
            S.on("start", () => {
              S.on("update", this.update, this);
            });
          }
          static update() {
            ge.update();
          }
          static createShakeTween(S, D = new i.A(), le = 0.1) {
            let Ce = ke.randomVector(D.clone().scale(-1), D);
            return Ei.createLocalTranslateTween(S, Ce, {
              duration: le,
              repeat: 3,
              yoyo: !0,
            });
          }
          static createLocalTranslateTween(S, D = {}, le = Ei.defaultConfig) {
            let Ce = S.getLocalPosition().clone(),
              Ue = new i.A(),
              rt = Object.keys(D),
              Je = this.createTween(Ce, D, le),
              St = Je._onUpdateCallback;
            return (
              Je.onUpdate(() => {
                Ue.copy(S.getLocalPosition()),
                  rt.forEach((Bt) => (Ue[Bt] = Ce[Bt])),
                  S.setLocalPosition(Ue),
                  St();
              }),
              Je
            );
          }
          static createGlobalTranslateTween(S, D = {}, le = Ei.defaultConfig) {
            let Ce = S.getPosition().clone(),
              Ue = new i.A(),
              rt = Object.keys(D),
              Je = this.createTween(Ce, D, le),
              St = Je._onUpdateCallback;
            return (
              Je.onUpdate(() => {
                Ue.copy(S.getPosition()),
                  rt.forEach((Bt) => (Ue[Bt] = Ce[Bt])),
                  S.setPosition(Ue),
                  St();
              }),
              Je
            );
          }
          static createRotateTween(S, D = {}, le = Ei.defaultConfig) {
            let Ce = S.getLocalEulerAngles().clone(),
              Ue = new i.A(),
              rt = Object.keys(D),
              Je = this.createTween(Ce, D, le),
              St = Je._onUpdateCallback;
            return (
              Je.onUpdate(() => {
                Ue.copy(S.getLocalEulerAngles()),
                  rt.forEach((Bt) => (Ue[Bt] = Ce[Bt])),
                  S.setLocalEulerAngles(Ue),
                  St();
              }),
              Je
            );
          }
          static createScaleTween(S, D = {}, le = Ei.defaultConfig) {
            let Ce = S.getLocalScale().clone(),
              Ue = new i.A(),
              rt = Object.keys(D),
              Je = this.createTween(Ce, D, le),
              St = Je._onUpdateCallback;
            return (
              Je.onUpdate(() => {
                Ue.copy(S.getLocalScale()),
                  rt.forEach((Bt) => (Ue[Bt] = Ce[Bt])),
                  S.setLocalScale(Ue),
                  St();
              }),
              Je
            );
          }
          static createMaterialTween(S, D = {}, le = Ei.defaultConfig) {
            let Ce = this.createTween(S, D, le),
              Ue = Ce._onUpdateCallback;
            return (
              Ce.onUpdate(() => {
                S.update(), Ue();
              }),
              Ce
            );
          }
          static createCountTween(S = Ei.defaultConfig) {
            let D = { percent: 0 };
            return this.createTween(D, { percent: 1 }, S);
          }
          static createTween(S, D = {}, le = Ei.defaultConfig) {
            let Ce = this._setupConfig(le),
              Ue = new Re(S);
            return Ue.to(D, Ce.duration * 1e3), this._setupTween(Ue, Ce), Ue;
          }
          static _setupConfig(S) {
            return ke.copyObject(S, ke.copyObject(Ei.defaultConfig));
          }
          static _setupTween(S, D) {
            S.easing(D.easing),
              S.delay(D.delay * 1e3),
              S.repeatDelay(D.repeatDelay * 1e3),
              D.loop ? S.repeat(1 / 0) : S.repeat(D.repeat),
              S.yoyo(D.yoyo),
              S.onStart(D.onStart),
              S.onRepeat(D.onRepeat),
              S.onStop(D.onStop),
              S.onUpdate(D.onUpdate),
              S.onComplete(D.onComplete);
          }
          static get Easing() {
            return ge.Easing;
          }
        };
        xe(
          be,
          "defaultConfig",
          Object.freeze({
            duration: 1,
            easing: ge.Easing.Linear.None,
            loop: !1,
            yoyo: !1,
            delay: 0,
            repeatDelay: 0,
            repeat: 0,
            onStart: () => {},
            onRepeat: () => {},
            onStop: () => {},
            onUpdate: () => {},
            onComplete: () => {},
          })
        );
        let Pe = be;
        var we = kt(3221),
          Oe = kt(6327),
          $e = kt(4094),
          gt = kt(5593),
          qe = kt(6848),
          Tt = kt(8713);
        class Mt {
          static init(S) {
            (this._current = 0),
              (this._dt = 0),
              (this.scale = 1),
              S.on("update", this.update, this);
          }
          static update(S) {
            (this._dt = S * this.scale), (this._current += this._dt);
          }
          static get dt() {
            return this._dt;
          }
          static get current() {
            return this._current;
          }
          static get currentMS() {
            return this._current * 1e3;
          }
        }
        var Dt = kt(5675);
        const ut = Object.freeze({
          PointerDown: "inputmanager:pointerdown",
          PointerMove: "inputmanager:pointermove",
          PointerUp: "inputmanager:pointerup",
        });
        class At {
          static init(S) {
            (this.app = S),
              (this.emitter = new o.J()),
              this._initMouse(),
              this._initTouch();
          }
          static _initMouse() {
            let S = this.app.mouse;
            S.on(Dt.tw, (D) =>
              this._handleInputEvent(D, this._onPointerDown.bind(this))
            ),
              S.on(Dt.qq, (D) =>
                this._handleInputEvent(D, this._onPointerMove.bind(this))
              ),
              S.on(Dt.L_, (D) =>
                this._handleInputEvent(D, this._onPointerUp.bind(this))
              ),
              this.app.graphicsDevice.canvas.addEventListener("mouseout", (D) =>
                this._onPointerUp(D)
              );
          }
          static _initTouch() {
            let S = this.app.touch;
            S.on(Dt.V, (D) =>
              this._handleInputEvent(D, this._onPointerDown.bind(this))
            ),
              S.on(Dt.Nj, (D) =>
                this._handleInputEvent(D, this._onPointerMove.bind(this))
              ),
              S.on(Dt.Lx, (D) =>
                this._handleInputEvent(D, this._onPointerUp.bind(this))
              ),
              S.on(Dt.Rm, (D) =>
                this._handleInputEvent(D, this._onPointerUp.bind(this))
              );
          }
          static _handleInputEvent(S, D) {
            S.event.preventDefault(), D(S);
          }
          static _onPointerDown(S) {
            this.emitter.fire(ut.PointerDown, S);
          }
          static _onPointerMove(S) {
            this.emitter.fire(ut.PointerMove, S);
          }
          static _onPointerUp(S) {
            this.emitter.fire(ut.PointerUp, S);
          }
        }
        for (
          var xt =
              "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
            jt = typeof Uint8Array == "undefined" ? [] : new Uint8Array(256),
            Gt = 0;
          Gt < xt.length;
          Gt++
        )
          jt[xt.charCodeAt(Gt)] = Gt;
        var yt = function (ee) {
            var S = new Uint8Array(ee),
              D,
              le = S.length,
              Ce = "";
            for (D = 0; D < le; D += 3)
              (Ce += xt[S[D] >> 2]),
                (Ce += xt[((S[D] & 3) << 4) | (S[D + 1] >> 4)]),
                (Ce += xt[((S[D + 1] & 15) << 2) | (S[D + 2] >> 6)]),
                (Ce += xt[S[D + 2] & 63]);
            return (
              le % 3 === 2
                ? (Ce = Ce.substring(0, Ce.length - 1) + "=")
                : le % 3 === 1 && (Ce = Ce.substring(0, Ce.length - 2) + "=="),
              Ce
            );
          },
          Ae = function (ee) {
            var S = ee.length * 0.75,
              D = ee.length,
              le,
              Ce = 0,
              Ue,
              rt,
              Je,
              St;
            ee[ee.length - 1] === "=" &&
              (S--, ee[ee.length - 2] === "=" && S--);
            var Bt = new ArrayBuffer(S),
              Nt = new Uint8Array(Bt);
            for (le = 0; le < D; le += 4)
              (Ue = jt[ee.charCodeAt(le)]),
                (rt = jt[ee.charCodeAt(le + 1)]),
                (Je = jt[ee.charCodeAt(le + 2)]),
                (St = jt[ee.charCodeAt(le + 3)]),
                (Nt[Ce++] = (Ue << 2) | (rt >> 4)),
                (Nt[Ce++] = ((rt & 15) << 4) | (Je >> 2)),
                (Nt[Ce++] = ((Je & 3) << 6) | (St & 63));
            return Bt;
          },
          Xe = kt(8764),
          Ye = kt(6450);
        class it {
          static load(S, D = void 0) {
            let le = D || n.find("externalLibraries.json");
            if (!le.loaded) {
              le.on("load", () => {
                it.load(S, le);
              });
              return;
            }
            let Ce = le.resources,
              Ue = Ce.length,
              rt = 0,
              Je = performance.now();
            if (Ue === 0) {
              S();
              return;
            }
            let St = (Bt, Nt) => {
              rt++,
                Bt && console.error(Bt),
                rt === Ue &&
                  ((Je = performance.now() - Je),
                  console.log(`Loaded ${Ue} libraries in ${Je}ms`),
                  S());
            };
            Ce.forEach((Bt) => {
              it._loadScript(Bt, St);
            });
          }
          static _loadScript(S, D) {
            let le;
            if (S.type === "base64") {
              let rt = Ae(S.source);
              if (S.compressed) {
                let Je = Xe.lW.from(rt),
                  St = (0, Ye.TO)(Je);
                le = new TextDecoder("utf-8").decode(St);
              } else le = new TextDecoder("utf-8").decode(rt);
            } else if (S.type === "url" || S.type === "script") le = S.source;
            else throw new Error(`Unknown type ${S.type}`);
            const Ce = document.createElement("script");
            let Ue = (rt) => {
              if (rt) {
                D(rt);
                return;
              }
              let Je = window[S.name];
              (window[S.name] = void 0),
                Je({
                  onAbort: () => {
                    D(`Aborted loading ${S.name}`);
                  },
                }).then((St) => {
                  D(null, St);
                });
            };
            S.type === "url"
              ? (Ce.setAttribute("src", le),
                (Ce.onload = Ue),
                (Ce.onerror = () => Ue(`Error loading ${le}`, S.name)),
                document.body.appendChild(Ce))
              : ((Ce.innerHTML = le), document.body.appendChild(Ce), Ue(null));
          }
        }
        var st = kt(3114),
          He = kt(7921),
          at = kt(6630),
          Pt = kt(8944);
        const he = JSON.parse(
          '[{"name":"ball_001","model":"model_ball_001","price":0,"materials":[{"emissiveIntensity":1,"diffuseMap":"tex_ball_001","emissiveMap":"tex_ball_001_emissive"}]},{"name":"ball_002","model":"model_ball_002","price":200,"materials":[{"emissiveIntensity":1,"diffuseMap":"tex_ball_002","emissiveMap":"tex_ball_002"}]},{"name":"ball_003","model":"model_ball_003","price":500,"materials":[{"emissiveIntensity":1,"diffuseMap":"tex_ball_003","emissiveMap":"tex_ball_003"}]},{"name":"ball_004","model":"model_ball_004","price":1000,"materials":[{"emissiveIntensity":1,"diffuseMap":"tex_ball_004","emissiveMap":"tex_ball_004"}]},{"name":"ball_006","model":"model_ball_006","price":2000,"materials":[{"emissiveIntensity":1,"diffuseMap":"tex_ball_006","emissiveMap":"tex_ball_006"}]},{"name":"ball_005","model":"model_ball_005","price":4000,"materials":[{"emissiveIntensity":1,"diffuseMap":"tex_ball_005","emissiveMap":"tex_ball_005"}]}]'
        );
        class fe {
          static config() {
            this._configRoad(), this._configBallSkins();
          }
          static _configRoad() {
            var S = n.find("mat_road_001.json").resource;
            S.cubeMap = n.find("cm_skybox").resource;
            var D = 10;
            S.diffuseMap && (S.diffuseMap.anisotropy = D),
              S.emissiveMap && (S.emissiveMap.anisotropy = D),
              S.glossMap && (S.glossMap.anisotropy = D);
          }
          static _configBallSkins() {
            he.forEach((S) => {
              let D = n.find(S.model),
                le = new o.J(S.name);
              le.addComponent("model", { type: "asset", asset: D }),
                n.registerAsset(le, S.name, "entity");
            });
          }
          static setTextureFiltering(S, D = He.yib, le = He.SuC) {
            (S.minFilter = D),
              (S.magFilter = D),
              (S.addressU = le),
              (S.addressV = le);
          }
          static setSpriteSlice(S, D = new at.T(), le = 1) {
            let Ce = n.find(S);
            (Ce.resource.renderMode = st.ei),
              this.setSpriteBorder(Ce, D.x, D.y, D.z, D.w),
              this.setSpritePixelsPerUnit(S, le);
          }
          static setSpriteBorder(S, D = 0, le = 0, Ce = 0, Ue = 0) {
            let rt = n.find(S).resource;
            rt.atlas.frames[rt.frameKeys[0]].border.set(D, le, Ce, Ue);
          }
          static setSpritePixelsPerUnit(S, D = 100) {
            let le = n.find(S).resource;
            le.pixelsPerUnit = D;
          }
          static setModelTexture(S, D, le = 0) {
            let Ce = this.getMaterial(S, le),
              Ue = n.find(D);
            Ce.diffuseMap = Ue.resource;
          }
          static setModelDiffuse(S, D, le = 0) {
            let Ce = this.getMaterial(S, le);
            Ce.diffuse.copy(D), (Ce.diffuseTint = !0);
          }
          static setModelMaterial(S, D, le = 0) {
            let Ce = n.find(S).resource;
            Ce.meshInstances[le].material = D;
          }
          static setModelMaterialInRange(S, D, le, Ce) {
            for (var Ue = le; Ue <= Ce; Ue++) this.setModelMaterial(S, D, Ue);
          }
          static setModelMaterialWithIndexes(S, D, le = []) {
            le.forEach((Ce) => {
              this.setModelMaterial(S, D, Ce);
            });
          }
          static createColorMaterial(S = 255, D = 255, le = 255, Ce = 1) {
            let Ue = new Pt.K();
            return (
              typeof S == "object"
                ? (Ue.diffuse = S)
                : (Ue.diffuse = ke.createColor(S, D, le, Ce)),
              Ue
            );
          }
          static getMaterial(S, D = 0) {
            let le = n.find(S),
              Ce = le.resource.meshInstances[D].material;
            return (
              Ce.id === 1 &&
                ((Ce = new Pt.K()),
                (le.resource.meshInstances[D].material = Ce)),
              Ce
            );
          }
        }
        class Ie {
          static config() {
            (this.scene = $t.app.scene),
              fe.config(),
              this._configScene(),
              this._configSkybox();
          }
          static _configSkybox() {
            let S = n.find("cm_skybox").resource;
            this.scene.skybox = S;
          }
          static _configScene() {
            (this.scene.ambientLight = ke.createColor(160, 160, 160)),
              (this.scene.gammaCorrection = st.DZ);
          }
        }
        var ue = kt(7680),
          De = kt(2978);
        class et extends o.J {
          constructor(S) {
            super(),
              (this.key = S),
              this.addComponent("screen", {
                screenSpace: !0,
                scaleMode: ue.A,
                resolution: new De.S(a.GAME_WIDTH, a.GAME_HEIGHT),
                referenceResolution: new De.S(a.GAME_WIDTH, a.GAME_HEIGHT),
              }),
              (this.enabled = !1);
          }
          create() {
            this.created = !0;
          }
          pause() {}
          resume() {}
          destroyChildren() {
            for (; this.children.length > 0; ) this.children[0].destroy();
          }
          update() {}
          resize() {}
          getScreenSpacePosition(S, D = new i.A()) {
            return (
              (D.x = S.x * $t.app.graphicsDevice.maxPixelRatio),
              (D.y =
                $t.app.graphicsDevice.height -
                S.y * $t.app.graphicsDevice.maxPixelRatio),
              (D.z = 0),
              D.scale(1 / this.screen.scale),
              D
            );
          }
        }
        class Ze extends o.J {
          constructor() {
            super("ui_manager"), (this.screens = []);
          }
          update(S) {
            this.screens.forEach((D) => D.enabled && D.update(S));
          }
          pause() {
            this.screens.forEach((S) => S.enabled && S.pause());
          }
          resume() {
            this.screens.forEach((S) => S.enabled && S.resume());
          }
          addScreens(...S) {
            S.forEach((D) => {
              this.addChild(D), this.screens.push(D), D.create();
            });
          }
          removeScreen(...S) {
            S.forEach((D) => {
              let le = this.getScreen(D);
              le && this.screens.splice(le, 1);
            });
          }
          setScreenActive(S, D = !0) {
            let le = this.getScreen(S);
            le
              ? (le.enabled = D)
              : a.DEBUG_ON && console.warn(`Scene ${S} not found!`);
          }
          disableAllScreens() {
            this.screens.forEach((S) => (S.enabled = !1));
          }
          getScreen(S) {
            return this.screens.find((D) => D.key === S);
          }
          resize() {
            this.screens.forEach((S) => S.resize());
          }
          getActiveScreens() {
            return this.screens.filter((S) => S.enabled);
          }
          getLastActiveScreen() {
            return this.getActiveScreens().pop();
          }
        }
        class Ve extends o.J {
          constructor(S) {
            super(S),
              (this.key = S),
              (this.ui = new Ze()),
              this.addChild(this.ui);
          }
          create() {
            x.log(`${this.key}Scene`, "Create");
          }
          update() {
            this.ui.update();
          }
          resize() {
            this.ui.resize();
          }
          pause() {
            this.ui.pause();
          }
          resume() {
            this.ui.resume();
          }
          destroy() {
            super.destroy();
          }
        }
        var tt = kt(3404);
        class Be {
          static createCamera(S, D) {
            let le = new o.J(S);
            return le.addComponent("camera", D), le;
          }
          static createColorBackground(S = new Te.I(), D = 1) {
            let le = new o.J("spr_bg");
            return (
              le.addComponent("element", {
                type: "image",
                anchor: new at.T(0, 0, 1, 1),
                color: S,
                opacity: D,
              }),
              le
            );
          }
          static createModel(S, ...D) {
            let le = n.find(S),
              Ce = new o.J(le.name);
            return (
              Ce.addComponent("model", { asset: le }),
              D.forEach((Ue, rt) => {
                var Je = n.find(Ue).resource;
                Ce.model.meshInstances[rt].material = Je;
              }),
              Ce
            );
          }
          static createBox(S) {
            let D = new o.J();
            if ((D.addComponent("model", { type: "box" }), S)) {
              let le = n.find(S).resource;
              D.model.meshInstances[0].material = le;
            }
            return D;
          }
          static createSphere(S) {
            let D = new o.J();
            if ((D.addComponent("model", { type: "sphere" }), S)) {
              let le = n.find(S).resource;
              D.model.meshInstances[0].material = le;
            }
            return D;
          }
          static createCone(S) {
            let D = new o.J();
            return (
              D.addComponent("model", { type: "cone" }),
              S && (D.model.meshInstances[0].material = S),
              D
            );
          }
          static createPlane(S) {
            let D = new o.J();
            if ((D.addComponent("model", { type: "plane" }), S)) {
              let le = n.find(S);
              D.model.meshInstances[0].material = le.resource;
            }
            return D;
          }
          static createSprite(S) {
            let D = n.find(S),
              le = new o.J(D.name);
            return le.addComponent("sprite", { spriteAsset: D }), le;
          }
          static createImageElement(S, D = {}) {
            let le = n.find(S),
              Ce = D.x || 0,
              Ue = D.y || 0,
              rt = D.z || 0,
              Je = D.scale || 1,
              St = D.opacity || 1,
              Bt = D.anchor || new at.T(0.5, 0.5, 0.5, 0.5),
              Nt = D.pivot || new De.S(0.5, 0.5),
              Ht = D.width || le.resource.width * Je,
              ns = D.height || le.resource.height * Je,
              xs = D.useInput || !1,
              _s = new o.J("element");
            return (
              _s.addComponent("element", {
                type: tt.rf,
                textureAsset: le,
                anchor: Bt,
                pivot: Nt,
                opacity: St,
                width: Ht,
                height: ns,
                useInput: xs,
              }),
              _s.setLocalPosition(Ce, Ue, rt),
              _s
            );
          }
          static createEmptyImageElement(S = {}) {
            let D = S.x || 0,
              le = S.y || 0,
              Ce = S.z || 0,
              Ue = S.opacity || 1,
              rt = S.anchor || new at.T(0.5, 0.5, 0.5, 0.5),
              Je = S.pivot || new De.S(0.5, 0.5),
              St = S.width || 100,
              Bt = S.height || 100,
              Nt = S.useInput || !1,
              Ht = new o.J("element"),
              ns = S.color || new Te.I(1, 1, 1);
            return (
              Ht.addComponent("element", {
                type: tt.rf,
                anchor: rt,
                pivot: Je,
                opacity: Ue,
                color: ns,
                width: St,
                height: Bt,
                useInput: Nt,
              }),
              Ht.setLocalPosition(D, le, Ce),
              Ht
            );
          }
          static createButtonElement(S, D = {}) {
            D.useInput === void 0 && (D.useInput = !0);
            let le = this.createImageElement(S, D),
              Ce = D.hoverTint || new Te.I(0.9, 0.9, 0.9),
              Ue = D.pressedTint || new Te.I(0.5, 0.5, 0.5);
            return (
              le.addComponent("button", {
                active: !0,
                hoverTint: Ce,
                pressedTint: Ue,
                imageEntity: le,
              }),
              le
            );
          }
          static createGroupElement(S = {}) {
            let D = S.x || 0,
              le = S.y || 0,
              Ce = S.z || 0,
              Ue = S.anchor || new at.T(0.5, 0.5, 0.5, 0.5),
              rt = S.pivot || new De.S(0.5, 0.5),
              Je = new o.J("element");
            return (
              Je.addComponent("element", {
                type: tt.Kv,
                anchor: Ue,
                pivot: rt,
                width: S.width,
                height: S.height,
              }),
              Je.setLocalPosition(D, le, Ce),
              Je
            );
          }
          static createTextElement(S, D) {
            var le = n.find(S);
            let Ce = D.text || "",
              Ue = D.fontSize || 16,
              rt = D.anchor || new at.T(0.5, 0.5, 0.5, 0.5),
              Je = D.pivot || new De.S(0.5, 0.5),
              St = D.alignment || new De.S(0.5, 0.5),
              Bt = D.color || new Te.I(0, 0, 0),
              Nt = D.x || 0,
              Ht = D.y || 0,
              ns = D.opacity || 1,
              xs = new o.J("txt_tutorial");
            return (
              xs.addComponent("element", {
                type: tt.l2,
                fontAsset: le,
                text: Ce,
                anchor: rt,
                pivot: Je,
                fontSize: Ue,
                color: Bt,
                opacity: ns,
                margin: new at.T(0, 0, 0, 0),
              }),
              xs.setLocalPosition(Nt, Ht, 0),
              xs
            );
          }
        }
        var ot = kt(5338),
          Qe = Object.defineProperty,
          mt = (ee, S, D) =>
            S in ee
              ? Qe(ee, S, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: D,
                })
              : (ee[S] = D),
          je = (ee, S, D) => (mt(ee, typeof S != "symbol" ? S + "" : S, D), D);
        const lt = Object.freeze({ ValueChanged: "GameStorage:ValueChanged" }),
          Et = class extends ot.b {
            constructor() {
              super(), a.STORAGE_CLEAR_ON_START && this.clear();
            }
            clear() {
              localStorage.clear();
            }
            setValue(S, D) {
              localStorage.setItem(S, D), this.fire(lt.ValueChanged, S);
            }
            addInt(S, D) {
              var le = this.getInt(S);
              return this.setValue(S, le + D), le + D;
            }
            addFloat(S, D) {
              var le = this.getFloat(S);
              this.setValue(S, le + D);
            }
            getInt(S, D = 0) {
              var le = parseInt(localStorage.getItem(S));
              return le || (le = D), le;
            }
            getFloat(S) {
              var D = parseFloat(localStorage.getItem(S));
              return D || (D = 0), D;
            }
            getObject(S) {
              var D = localStorage.getItem(S);
              return D || (D = {}), JSON.parse(D);
            }
            getString(S, D = "") {
              var le = localStorage.getItem(S);
              return le || (le = D), le;
            }
          };
        je(Et, "instance", new Et());
        let ct = Et;
        const pt = Object.freeze({
          LeftToRight: "UiTweenDirection:LeftToRight",
          RightToLeft: "UiTweenDirection:RightToLeft",
          TopToBottom: "UiTweenDirection:TopToBottom",
          BottomToTop: "UiTweenDirection:BottomToTop",
        });
        class vt {
          static createTransitionAppearTween(S, D, le = Pe.defaultConfig) {
            let Ce = S.element.anchor.clone(),
              Ue = Ce.clone();
            D === pt.LeftToRight
              ? ((Ue.x -= 1), (Ue.z -= 1))
              : D === pt.RightToLeft
              ? ((Ue.x += 1), (Ue.z += 1))
              : D === pt.TopToBottom
              ? ((Ue.y += 1), (Ue.w += 1))
              : D === pt.BottomToTop && ((Ue.y -= 1), (Ue.w -= 1));
            let rt = Pe.createTween(Ue, Ce, le),
              Je = rt._onUpdateCallback,
              St = rt._onStartCallback;
            return (
              rt.onStart(() => {
                (S.element.anchor = Ue), (S.element.enabled = !0), St();
              }),
              rt.onUpdate(() => {
                (S.element.anchor = Ue), Je();
              }),
              rt
            );
          }
          static createTransitionDisappearTween(S, D, le = Pe.defaultConfig) {
            let Ce = S.element.anchor.clone(),
              Ue = Ce.clone();
            D === pt.LeftToRight
              ? ((Ue.x += 1), (Ue.z += 1))
              : D === pt.RightToLeft
              ? ((Ue.x -= 1), (Ue.z -= 1))
              : D === pt.TopToBottom
              ? ((Ue.y -= 1), (Ue.w -= 1))
              : D === pt.BottomToTop && ((Ue.y += 1), (Ue.w += 1));
            let rt = Pe.createTween(Ce, Ue, le),
              Je = rt._onUpdateCallback;
            return (
              rt.onUpdate(() => {
                (S.element.anchor = Ce), Je();
              }),
              rt
            );
          }
        }
        const Fe = Object.freeze({
          OpenPauseScreen: "PlayScreen:OpenPauseScreen",
        });
        class Yt extends et {
          constructor() {
            super(a.SCREEN_PLAY);
          }
          create() {
            super.create(),
              this._createLife(),
              this._initProgress(),
              this._initLevelText(),
              this._initButtonPause(),
              this._initAnimation();
          }
          _createLife() {
            (this.currentSkin = ct.instance.getString(
              a.STORAGE_KEY_SKIN,
              a.INIT_SKIN
            )),
              (this.lifeBackground = Be.createEmptyImageElement({
                anchor: new at.T(1, 1, 1, 1),
                pivot: new De.S(1, 1),
                width: 70,
                height: 60 * a.TOTAL_LIFE + 10,
                x: -21,
                y: -10,
                color: new Te.I(0.5, 0.5, 0.5),
                opacity: 0.6,
              })),
              this.addChild(this.lifeBackground),
              (this.lifeGroup = Be.createGroupElement({
                anchor: new at.T(1, 1, 1, 1),
                pivot: new De.S(1, 1),
                x: -28,
                y: -10,
              })),
              this.lifeGroup.addComponent("layoutgroup", {
                orientation: st.Gh,
                spacing: new De.S(0, 10),
              }),
              this.lifeBackground.addChild(this.lifeGroup),
              (this.ballIcons = []);
            for (let S = 0; S < a.TOTAL_LIFE; S++) {
              let D = Be.createImageElement(`spr_icon_${this.currentSkin}`, {
                width: 50,
                height: 50,
              });
              this.lifeGroup.addChild(D), this.ballIcons.push(D);
            }
          }
          updateLife(S) {
            if (!this.ballIcons) return;
            this.currentSkin = ct.instance.getString(
              a.STORAGE_KEY_SKIN,
              a.INIT_SKIN
            );
            let D = n.find(`spr_icon_${this.currentSkin}`),
              le = n.find("spr_icon_ball_dead");
            for (let Ce = 0; Ce < a.TOTAL_LIFE; Ce++) {
              let Ue = this.ballIcons[Ce];
              Ce < S
                ? (Ue.element.textureAsset = D)
                : (Ue.element.textureAsset = le);
            }
          }
          _initProgress() {
            (this.progressBar = Be.createImageElement(
              "spr_slide_progress_bar",
              {
                anchor: new at.T(0.5, 0.8, 0.5, 0.8),
                pivot: new De.S(0.5, 0.5),
                scale: 1.5,
                y: 170,
                opacity: 0.9,
              }
            )),
              this.addChild(this.progressBar),
              (this.progressBarMask = Be.createImageElement(
                "spr_slide_progress_bar_mask",
                {
                  anchor: new at.T(0, 0.5, 0, 0.5),
                  pivot: new De.S(0, 0.5),
                  scale: 1.51,
                  x: 5,
                  y: 3,
                }
              )),
              this.progressBar.addChild(this.progressBarMask),
              (this.progressBarWidth = this.progressBarMask.element.width),
              (this.progressBarMask.element.width = 0),
              (this.progressBarMask.element.mask = !0),
              (this.progressBarFill = Be.createImageElement(
                "spr_slide_progress_bar_fill",
                {
                  anchor: new at.T(0, 0.5, 0, 0.5),
                  pivot: new De.S(0, 0.5),
                  scale: 1.48,
                }
              )),
              this.progressBarMask.addChild(this.progressBarFill);
          }
          setProgress(S) {
            this.progressBarMask.element.width = this.progressBarWidth * S;
          }
          _initLevelText() {
            (this.levelText = Be.createTextElement("font_rounded", {
              anchor: new at.T(0.5, 0.8, 0.5, 0.8),
              pivot: new De.S(0.5, 0.5),
              text: "Level 1",
              y: 100,
              fontSize: 52,
              color: Te.I.WHITE,
            })),
              (this.levelText.element.outlineColor = Te.I.BLACK),
              (this.levelText.element.outlineThickness = 0.6),
              this.addChild(this.levelText);
          }
          setLevelText(S) {
            this.levelText.element.text = `Level ${S}`;
          }
          _initButtonPause() {
            (this.buttonPause = Be.createButtonElement("spr_icon_pause", {
              anchor: new at.T(0, 1, 0, 1),
              pivot: new De.S(0, 1),
              x: 48,
              y: -48,
            })),
              this.addChild(this.buttonPause),
              this.buttonPause.button.on(
                "click",
                this._onButtonPauseClick,
                this
              );
          }
          _onButtonPauseClick() {
            this.fire(Fe.OpenPauseScreen);
          }
          _initAnimation() {
            (this._appearTweens = []), (this._disappearTweens = []);
            let S = { duration: 0.5, easing: Pe.Easing.Back.Out };
            this._appearTweens.push(
              vt.createTransitionAppearTween(
                this.lifeBackground,
                pt.RightToLeft,
                S
              )
            ),
              this._appearTweens.push(
                vt.createTransitionAppearTween(
                  this.progressBar,
                  pt.TopToBottom,
                  S
                )
              ),
              this._appearTweens.push(
                vt.createTransitionAppearTween(
                  this.levelText,
                  pt.TopToBottom,
                  S
                )
              ),
              this._appearTweens.push(
                vt.createTransitionAppearTween(
                  this.buttonPause,
                  pt.TopToBottom,
                  S
                )
              );
          }
          onEnable() {
            this._appearTweens.forEach((S) => S.start());
          }
        }
        var Ot = kt(4585),
          Rt = kt(9124),
          Kt = kt(3428),
          Lt = kt(36);
        class Ft {
          constructor() {
            (this.name = ""),
              (this.attributes = {}),
              (this.initialize = null),
              (this.postInitialize = null),
              (this.update = null),
              (this.fixedUpdate = null),
              (this.postUpdate = null),
              (this.onEnable = null),
              (this.onDisable = null),
              (this.onDestroy = null),
              (this._initialized = !1);
          }
        }
        class Jt {
          static createScript(S = new Ft()) {
            return ke.copyObject(S);
          }
          static _initScript(S) {
            let D = (0, Rt.hT)(S.name);
            Object.keys(S).forEach((le) => {
              le === "attributes"
                ? Object.keys(S.attributes).forEach((Ce) => {
                    D.attributes.add(Ce, S.attributes[Ce]);
                  })
                : (D.prototype[le] = S[le]);
            }),
              (S._initialized = !0);
          }
        }
        (o.J.prototype.addScript = function (ee, S = {}) {
          this.script || this.addComponent("script");
          let D;
          if (ht(ee, Kt.e)) {
            let Ue = ee.name;
            if (
              (Ue || (Ue = ee.prototype.constructor.name),
              !$t.app.scripts.has(Ue))
            ) {
              if (!(ee.attributes instanceof Lt.s))
                (ee._customAttributes = ee.attributes),
                  (ee.attributes = new Lt.s(ee));
              else {
                var le = new ee({ app: $t.app, entity: this }),
                  Ce = Object.keys(le).filter(
                    (Je) =>
                      Je !== "app" && Je !== "entity" && !Je.startsWith("_")
                  );
                (ee._customAttributes = {}),
                  Ce.forEach((Je) => {
                    ee._customAttributes[Je] = {
                      type: typeof le[Je],
                      default: le[Je],
                    };
                  }),
                  Object.keys(S.attributes).forEach((Je) => {
                    Ce.includes(Je) ||
                      (ee._customAttributes[Je] = {
                        type: typeof S.attributes[Je],
                        default: S.attributes[Je],
                      });
                  }),
                  (le = void 0);
              }
              (0, Rt.A8)(ee),
                Object.keys(ee._customAttributes).forEach((Je) => {
                  ee.attributes.add(Je, ee._customAttributes[Je]);
                }),
                delete ee._customAttributes;
            }
            D = this.script.create(Ue, S);
          } else
            ee &&
              (ee._initialized || Jt._initScript(ee),
              (D = this.script.create(ee.name, { attributes: S })));
          return (
            D.onEnable && D.on("enable", D.onEnable, D),
            D.onDisable && D.on("disable", D.onDisable, D),
            D.onDestroy && D.on("destroy", D.onDestroy, D),
            D.enable || (D.enable = () => (D.enabled = !0)),
            D.disable || (D.disable = () => (D.enabled = !1)),
            D
          );
        }),
          (o.J.prototype.getScript = function (ee) {
            return this.script ? this.script[ee.name] : null;
          });
        const zt = Jt.createScript({
            name: "inputHandler",
            initialize() {
              At.emitter.on(ut.PointerDown, this._onPointerDown, this),
                At.emitter.on(ut.PointerMove, this._onPointerMove, this),
                At.emitter.on(ut.PointerUp, this._onPointerUp, this);
            },
            _onPointerDown(ee) {
              this.enabled && this.fire(ss.PointerDown, ee);
            },
            _onPointerMove(ee) {
              this.enabled && this.fire(ss.PointerMove, ee);
            },
            _onPointerUp(ee) {
              this.enabled && this.fire(ss.PointerUp, ee);
            },
          }),
          ss = Object.freeze({
            PointerDown: "inputHandler:pointerdown",
            PointerMove: "inputHandler:pointermove",
            PointerUp: "inputHandler:pointerup",
          }),
          qt = Object.freeze({
            Start: "start",
            Pause: "pause",
            Resume: "resume",
            Lose: "lose",
            Replay: "resplay",
            Win: "win",
          }),
          fs = Jt.createScript({
            name: "gameManager",
            start() {
              x.log("GameManager", "Start"), this.fire(qt.Start);
            },
            pause() {
              x.log("GameManager", "Pause"), this.fire(qt.Pause);
            },
            resume() {
              x.log("GameManager", "Resume"), this.fire(qt.Resume);
            },
            lose() {
              x.log("GameManager", "Lose"), this.fire(qt.Lose);
            },
            replay() {
              x.log("GameManager", "Replay"), this.fire(qt.Replay);
            },
            win() {
              x.log("GameManager", "Win"), this.fire(qt.Win);
            },
          }),
          ls = Object.freeze({
            Current: "spr_icon_level_current",
            Locked: "spr_icon_level_locked",
            Passed: "spr_icon_level_passed",
            EndInGroup: "spr_icon_level_end_in_group",
          });
        class Es extends o.J {
          constructor(S = ls.Current, D = 0, le = "") {
            super("levelElement"),
              (this.frameName = S),
              (this.iconName = le),
              this.addComponent("element", {
                type: "image",
                anchor: new at.T(0.5, 0.5, 0.5, 0.5),
                pivot: new De.S(0.5, 0.5),
                textureAsset: n.find(S),
              }),
              this.setLocalScale(1.8, 1.8, 1.8),
              (this.text = Be.createTextElement("font_rounded", {
                fontSize: 20,
                color: Te.I.WHITE,
                text: D.toString(),
                y: -3,
              })),
              (this.text.element.autoFitHeight = !0),
              (this.text.element.autoWidth = !0),
              (this.text.element.width = this.element.width - 20),
              (this.text.element.height = this.element.height - 20),
              (this.text.element.outlineColor = Te.I.BLACK),
              (this.text.element.outlineThickness = 0.6),
              this.addChild(this.text);
          }
          setIcon(S, D, le) {
            (this.text.enabled = !1),
              this.icon
                ? ((this.icon.element.textureAsset = n.find(S)),
                  (this.icon.enabled = !0))
                : (D === void 0 && (D = this.element.width - 10),
                  le === void 0 && (le = this.element.height - 10),
                  (this.icon = Be.createImageElement(S, {
                    width: D,
                    height: le,
                  })),
                  this.addChild(this.icon));
          }
          setText(S) {
            (this.text.enabled = !0),
              this.icon && (this.icon.enabled = !1),
              (this.text.element.text = S);
          }
          setFrame(S) {
            (this.frameName = S), (this.element.textureAsset = n.find(S));
          }
        }
        var Ke = Object.defineProperty,
          hs = (ee, S, D) =>
            S in ee
              ? Ke(ee, S, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: D,
                })
              : (ee[S] = D),
          is = (ee, S, D) => (hs(ee, typeof S != "symbol" ? S + "" : S, D), D);
        const ys = class Qn {
          static init(S) {
            if (
              ((this.adsConfig = window.SDK_CONFIG), !this.adsConfig.SHOW_ADS)
            ) {
              (this.isReady = !0), S == null || S();
              return;
            }
            this._createBackground(),
              setTimeout(() => {
                (Qn.isReady = !0), this.emitter.fire("ready"), S == null || S();
              }, 550);
          }
          static _createBackground() {
            (this._background = document.createElement("div")),
              (this._background.style.top = "0px"),
              (this._background.style.left = "0px"),
              (this._background.style.margin = "0px"),
              (this._background.style.padding = "0px"),
              (this._background.id = "ads-background"),
              (this._background.style.position = "absolute"),
              (this._background.style.width = "100%"),
              (this._background.style.height = "100%"),
              (this._background.style.backgroundColor = "black"),
              (this._background.style.opacity = "0.8"),
              (this._background.style.zIndex = "10"),
              document.body.appendChild(this._background),
              (this._background.style.display = "none");
            const S = (D) => {
              D.stopPropagation();
            };
            this._background.addEventListener("mousedown", S),
              this._background.addEventListener("mousemove", S),
              this._background.addEventListener("mouseup", S),
              this._background.addEventListener("touchstart", S),
              this._background.addEventListener("touchmove", S),
              this._background.addEventListener("touchend", S),
              this._background.addEventListener("keydown", S),
              this._background.addEventListener("keyup", S),
              this._background.addEventListener("keypress", S),
              this._background.addEventListener("contextmenu", S),
              (this.alphaInTween = Pe.createTween(
                { opacity: 0 },
                { opacity: 0.8 },
                {
                  duration: 0.2,
                  onStart: () => {
                    this._background.style.display = "block";
                  },
                  onUpdate: (D) => {
                    this._background.style.opacity = D.opacity;
                  },
                }
              )),
              (this.alphaOutTween = Pe.createTween(
                { opacity: 0.8 },
                { opacity: 0 },
                {
                  duration: 0.2,
                  onUpdate: (D) => {
                    this._background.style.opacity = D.opacity;
                  },
                  onComplete: () => {
                    this._background.style.display = "none";
                  },
                }
              ));
          }
          static _showBackground() {
            this.alphaInTween.stop(),
              this.alphaOutTween.stop(),
              this.alphaInTween.start();
          }
          static _hideBackground() {
            this.alphaInTween.stop(),
              this.alphaOutTween.stop(),
              this.alphaOutTween.start();
          }
          static _showBackgroundNoOpacity() {
            (this._background.style.display = "block"),
              (this._background.style.opacity = "0.0");
          }
          static _hideBackgroundNoOpacity() {
            (this._background.style.display = "none"),
              (this._background.style.opacity = "0.0");
          }
          static showInterstitialAds(S) {
            if (!this.adsConfig.SHOW_ADS) {
              S == null || S();
              return;
            }
            if (!this.isReady) {
              this.emitter.once("ready", () => {
                this.showInterstitialAds(S);
              });
              return;
            }
            this._showBackgroundNoOpacity(),
              this._hideBackgroundNoOpacity(),
              S == null || S();
          }
          static saveAchievement(S, D) {}
          static checkIsRewardAdsReady(S) {
            if (!this.adsConfig.SHOW_ADS) {
              S == null || S(!1);
              return;
            }
            if (!this.isReady) {
              this.emitter.once("ready", () => {
                this.checkIsRewardAdsReady(S);
              });
              return;
            }
            if (
              performance.now() - this._lastCallRewardAds <
              this._rewardAdsThreshold
            ) {
              S == null || S(!1, "Too fast");
              return;
            }
            this._lastCallRewardAds = performance.now();
            let D = !1,
              le = (rt, Je) => {
                D || ((D = !0), S == null || S(rt, Je));
              };
            if (this._showRewardAdsFn) {
              le(!0);
              return;
            }
            let Ce = (rt, Je) => {
                rt
                  ? ((this._showRewardAdsFn = Je), le(!0))
                  : le(!1, "Reward ads not ready");
              },
              Ue = (rt) => {
                var Je, St;
                this._rewardAdsSuccessCallback &&
                  (rt
                    ? (Je = this._rewardAdsSuccessCallback) == null ||
                      Je.call(this)
                    : (St = this._rewardAdsSuccessCallback) == null ||
                      St.call(this, "Reward ads failed"));
              };
            Ue();
          }
          static showRewardAds(S) {
            if (!this.adsConfig.SHOW_ADS) {
              S == null || S();
              return;
            }
            if (!this._showRewardAdsFn) {
              S == null || S("Reward ads not ready");
              return;
            }
            if (!this.isReady) {
              this.emitter.once("ready", () => {
                this.showRewardAds(S);
              });
              return;
            }
            this._showBackground(),
              (this._rewardAdsSuccessCallback = (D) => {
                this._hideBackground(),
                  S == null || S(D),
                  (this._rewardAdsSuccessCallback = null);
              }),
              this._showRewardAdsFn(),
              (this._showRewardAdsFn = null);
          }
        };
        is(ys, "isReady", !1),
          is(ys, "emitter", new ot.b()),
          is(ys, "_lastCallRewardAds", 0),
          is(ys, "_rewardAdsThreshold", 1e3),
          is(ys, "_showRewardAdsFn", null),
          is(ys, "_rewardAdsSuccessCallback", null);
        let ps = ys;
        var Ns = Object.defineProperty,
          zs = (ee, S, D) =>
            S in ee
              ? Ns(ee, S, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: D,
                })
              : (ee[S] = D),
          bs = (ee, S, D) => (zs(ee, typeof S != "symbol" ? S + "" : S, D), D);
        const Ws = class {
          constructor() {
            (this.lifeCount = 0), (this.coinCount = 0), (this.keyCount = 0);
          }
          reset() {
            (this.coinCount = 0), (this.keyCount = 0);
          }
        };
        bs(Ws, "instance", new Ws());
        let Ss = Ws;
        const ws = Object.freeze({ LevelGroupCount: 4 }),
          ks = Object.freeze({
            NextLevelButtonClicked: "WinScreen:NextLevelButtonClicked",
          });
        class Ys extends et {
          constructor() {
            super(a.SCREEN_WIN);
          }
          create() {
            this._initBackground(),
              this._createLevelInfo(),
              this._initCollectedCoin(),
              this._initButtonClaimX2(),
              this._initButtonSkipRewardAds(),
              this._initButtonContinue(),
              this._createCoins(),
              this._createKeys(),
              this._createAnimations();
          }
          _createLevelInfo() {
            (this.line = Be.createEmptyImageElement({
              anchor: new at.T(0.5, 0.8, 0.5, 0.8),
              pivot: new De.S(0.5, 0.5),
              height: 20,
              width: 300,
              color: new Te.I(0.4, 0.4, 0.4),
              y: -150,
            })),
              this.addChild(this.line),
              (this.levelGroup = Be.createGroupElement({
                anchor: new at.T(0.5, 0.8, 0.5, 0.8),
                y: -150,
              })),
              this.levelGroup.addComponent("layoutgroup", {
                orientation: st.gC,
                alignment: new De.S(0.5, 0.5),
                spacing: new De.S(80, 0),
              }),
              this.addChild(this.levelGroup),
              (this.levelElements = []);
            for (let S = 0; S < ws.LevelGroupCount; S++) {
              let D = new Es();
              D.setLocalScale(2, 2, 2),
                this.levelElements.push(D),
                this.levelGroup.addChild(D);
            }
            (this.levelCompleteBg = new o.J("levelCompleteBg")),
              this.levelCompleteBg.addComponent("element", {
                type: "image",
                anchor: new at.T(-0.1, 0.8, 1.1, 0.8),
                pivot: new De.S(0.5, 0.5),
                height: 120,
                textureAsset: n.find("spr_frame_level_complete"),
              }),
              this.addChild(this.levelCompleteBg),
              (this.textLevelComplete = Be.createTextElement("font_rounded", {
                text: "LEVEL COMPLETED!",
                fontSize: 62,
                color: Te.I.WHITE,
              })),
              (this.textLevelComplete.element.outlineColor = new Te.I(
                13 / 255,
                160 / 255,
                0
              )),
              (this.textLevelComplete.element.outlineThickness = 0.6),
              this.levelCompleteBg.addChild(this.textLevelComplete),
              (this.levelText = Be.createTextElement("font_rounded", {
                anchor: new at.T(0.5, 0.8, 0.5, 0.8),
                pivot: new De.S(0.5, 0.5),
                text: "Level 1",
                y: 100,
                fontSize: 62,
                color: Te.I.WHITE,
              })),
              (this.levelText.element.outlineColor = Te.I.BLACK),
              (this.levelText.element.outlineThickness = 0.6),
              this.addChild(this.levelText);
          }
          updateLevelInfo(S) {
            let D =
                Math.floor((S - 1) / ws.LevelGroupCount) * ws.LevelGroupCount,
              le = D + ws.LevelGroupCount;
            for (let Ce = D; Ce < le; Ce++) {
              let Ue = this.levelElements[Ce % ws.LevelGroupCount];
              Ue.setText(Ce + 1),
                Ce < S - 1
                  ? Ue.setFrame(ls.Passed)
                  : Ce === S - 1
                  ? (Ue.setFrame(ls.Current), Ue.setIcon("spr_icon_check"))
                  : Ue.setFrame(ls.Locked),
                Ce === le - 1 && Ue.setFrame(ls.EndInGroup);
            }
            this.levelText.element.text = `Level ${S}`;
          }
          _initBackground() {
            let S = ke.createColor(0, 0, 0);
            (this.bg = Be.createColorBackground(S)),
              (this.bg.element.opacity = 0.5),
              this.addChild(this.bg);
          }
          _initCollectedCoin() {
            (this.txtCollected = Be.createTextElement("font_rounded", {
              text: "COLLECTED",
              fontSize: 60,
              color: ke.createColor(255, 255, 255),
              anchor: new at.T(0.5, 0.5, 0.5, 0.5),
              y: -50,
            })),
              (this.txtCollected.element.outlineColor = Te.I.BLACK),
              (this.txtCollected.element.outlineThickness = 0.6),
              this.addChild(this.txtCollected),
              (this.collectedGroup = Be.createGroupElement({ y: -100 })),
              this.collectedGroup.addComponent("layoutgroup", {
                orientation: st.gC,
                alignment: new De.S(0.5, 1),
                spacing: new De.S(10, 0),
              }),
              this.addChild(this.collectedGroup),
              (this.txtCollectedCoin = Be.createTextElement("font_rounded", {
                text: "0",
                fontSize: 100,
                pivot: new De.S(1, 0.5),
                color: Te.I.WHITE,
              })),
              (this.txtCollectedCoin.element.outlineColor = Te.I.BLACK),
              (this.txtCollectedCoin.element.outlineThickness = 0.6),
              this.collectedGroup.addChild(this.txtCollectedCoin),
              (this.imgCoin = Be.createImageElement("spr_coin", {
                scale: 0.75,
              })),
              this.collectedGroup.addChild(this.imgCoin),
              this.imgCoin.setLocalPosition(0, 10, 0);
          }
          updateRewardCoin(S) {
            this.txtCollectedCoin.element.text = S;
          }
          _createCoins() {
            (this.coinBackground = new o.J("coinBackground")),
              this.coinBackground.addComponent("element", {
                type: "image",
                anchor: new at.T(1, 1, 1, 1),
                pivot: new De.S(1, 1),
                width: 130,
                height: 50,
                color: new Te.I(0.5, 0.5, 0.5),
                opacity: 0.7,
              }),
              this.coinBackground.setLocalPosition(-10, -20, 0),
              this.addChild(this.coinBackground),
              (this.coinIcon = Be.createImageElement("spr_icon_coin_reward", {
                anchor: new at.T(1, 0.5, 1, 0.5),
                pivot: new De.S(1, 0.5),
                x: -10,
                scale: 0.8,
              })),
              this.coinBackground.addChild(this.coinIcon),
              (this.coinText = Be.createTextElement("font_rounded", {
                anchor: new at.T(1, 0.5, 1, 0.5),
                pivot: new De.S(1, 0.5),
                text: "0",
                fontSize: 46,
                color: Te.I.WHITE,
                x: -80,
                y: -5,
              })),
              (this.coinText.element.autoWidth = !0),
              this.coinBackground.addChild(this.coinText);
          }
          updateCoins(S) {
            (this.coinText.element.text = S),
              setTimeout(() => {
                this.coinBackground.element.width =
                  this.coinText.element.width + 90;
              }, 1);
          }
          _createKeys() {
            (this.keyBackground = new o.J("keyBackground")),
              this.keyBackground.addComponent("element", {
                type: "image",
                anchor: new at.T(0, 1, 0, 1),
                pivot: new De.S(0, 1),
                width: 150,
                height: 50,
                color: new Te.I(0.5, 0.5, 0.5),
                opacity: 0.7,
              }),
              this.keyBackground.setLocalPosition(10, -20, 0),
              this.addChild(this.keyBackground),
              (this.keyGroup = Be.createGroupElement()),
              this.keyGroup.addComponent("layoutgroup", {
                orientation: st.gC,
                alignment: new De.S(0.5, 0.5),
                spacing: new De.S(10, 0),
              }),
              this.keyBackground.addChild(this.keyGroup),
              (this.keys = []);
            for (let S = 0; S < a.TOTAL_KEY_TO_COLLECT; S++) {
              let D = Be.createImageElement("spr_icon_key", { scale: 0.8 });
              this.keys.push(D), this.keyGroup.addChild(D);
            }
          }
          updateKeys(S) {
            S > a.TOTAL_KEY_TO_COLLECT && (S = a.TOTAL_KEY_TO_COLLECT);
            for (let D = 0; D < this.keys.length; D++) {
              let le = this.keys[D];
              D < S
                ? (le.element.textureAsset = n.find("spr_icon_key"))
                : (le.element.textureAsset = n.find("spr_icon_key_gray"));
            }
          }
          _initButtonSkipRewardAds() {
            (this.btnSkipReward = Be.createTextElement("font_rounded", {
              anchor: new at.T(0.5, 0.3, 0.5, 0.3),
              y: -200,
              text: "No Thanks",
              fontSize: 52,
              color: new Te.I(0.5, 0.5, 0.5),
            })),
              (this.enabled = !1),
              this.addChild(this.btnSkipReward),
              ke.registerOnTouch(
                this.btnSkipReward.element,
                this._onNextLevelButtonClicked,
                this
              ),
              (this.tweenShowButtonSkip = Pe.createCountTween({
                delay: 2,
                duration: 0.5,
                onStart: () => {
                  (this.btnSkipReward.enabled = !0),
                    (this.btnSkipReward.element.opacity = 0);
                },
                onUpdate: (S) => {
                  this.btnSkipReward.element.opacity = S.percent;
                },
              }));
          }
          _initButtonClaimX2() {
            (this.btnClaimX2 = Be.createButtonElement("spr_button_claim_x2", {
              anchor: new at.T(0.5, 0.3, 0.5, 0.3),
              y: -80,
              scale: 0.8,
            })),
              this.addChild(this.btnClaimX2),
              ke.registerOnTouch(
                this.btnClaimX2.element,
                this._onClaimX2ButtonClicked,
                this
              ),
              (this.buttonClaimTween = Pe.createScaleTween(
                this.btnClaimX2,
                { x: 1.2, y: 1.2, z: 1.2 },
                {
                  duration: 0.4,
                  easing: Pe.Easing.Quadratic.InOut,
                  yoyo: !0,
                  loop: !0,
                }
              ).start());
          }
          _initButtonContinue() {
            (this.btnContinue = Be.createButtonElement("spr_button_continue", {
              anchor: new at.T(0.5, 0.3, 0.5, 0.3),
              y: -80,
              scale: 0.8,
            })),
              this.addChild(this.btnContinue),
              ke.registerOnTouch(
                this.btnContinue.element,
                this._onNextLevelButtonClicked,
                this
              );
          }
          _onClaimX2ButtonClicked() {
            f.play("sfx_click"),
              (this.btnClaimX2.enabled = !1),
              this.buttonClaimTween.stop(),
              this.tweenShowButtonSkip.stop(),
              $t.pause(),
              ps.showRewardAds((S) => {
                $t.resume(),
                  (this.btnSkipReward.enabled = !1),
                  S
                    ? alert(S)
                    : ((Ss.instance.coinCount *= 2),
                      this.updateRewardCoin(Ss.instance.coinCount)),
                  setTimeout(() => {
                    this._onNextLevelButtonClicked();
                  }, 500);
              });
          }
          _onNextLevelButtonClicked() {
            this.buttonClaimTween.stop(),
              (this.btnSkipReward.enabled = !1),
              f.play("sfx_click");
            let S = Math.floor(this.txtCollectedCoin.element.text),
              D = Math.floor(this.coinText.element.text);
            Pe.createTween(
              { reward: S, coin: D },
              { reward: 0, coin: D + S },
              {
                duration: 0.5,
                onUpdate: (le) => {
                  this.updateRewardCoin(Math.floor(le.reward)),
                    this.updateCoins(Math.floor(le.coin));
                },
                onComplete: () => {
                  this.fire(ks.NextLevelButtonClicked);
                },
              }
            ).start();
          }
          _createAnimations() {
            (this._appearAnimations = []), (this._disappearAnimations = []);
            let S = { duration: 0.4, easing: Pe.Easing.Back.Out };
            this._appearAnimations.push(
              vt.createTransitionAppearTween(this.line, pt.LeftToRight, S)
            ),
              this._appearAnimations.push(
                vt.createTransitionAppearTween(
                  this.levelGroup,
                  pt.LeftToRight,
                  S
                )
              ),
              this._appearAnimations.push(
                vt.createTransitionAppearTween(
                  this.levelText,
                  pt.LeftToRight,
                  S
                )
              ),
              this._appearAnimations.push(
                vt.createTransitionAppearTween(
                  this.coinBackground,
                  pt.TopToBottom,
                  S
                )
              ),
              this._appearAnimations.push(
                vt.createTransitionAppearTween(
                  this.keyBackground,
                  pt.TopToBottom,
                  S
                )
              ),
              this._appearAnimations.push(
                vt.createTransitionAppearTween(
                  this.levelCompleteBg,
                  pt.LeftToRight,
                  S
                )
              ),
              this._appearAnimations.push(
                vt.createTransitionAppearTween(
                  this.btnClaimX2,
                  pt.BottomToTop,
                  S
                )
              ),
              this._appearAnimations.push(
                vt.createTransitionAppearTween(
                  this.btnSkipReward,
                  pt.BottomToTop,
                  S
                )
              ),
              this._appearAnimations.push(
                vt.createTransitionAppearTween(
                  this.txtCollected,
                  pt.BottomToTop,
                  S
                )
              ),
              this._appearAnimations.push(
                vt.createTransitionAppearTween(
                  this.collectedGroup,
                  pt.BottomToTop,
                  S
                )
              );
          }
          checkRewardAdsReady() {
            this.checkRewardAdsIntervalID = setInterval(() => {
              ps.checkIsRewardAdsReady((S) => {
                S
                  ? ((this.btnClaimX2.enabled = !0),
                    (this.btnContinue.enabled = !1),
                    (this.isRewardAdsReady = !0),
                    clearInterval(this.checkRewardAdsIntervalID))
                  : ((this.btnClaimX2.enabled = !1),
                    (this.btnContinue.enabled = !0),
                    (this.isRewardAdsReady = !1));
              });
            }, 1e3);
          }
          onEnable() {
            var S;
            (S = this._disappearAnimations) == null ||
              S.forEach((D) => D.stop()),
              this._appearAnimations.forEach((D) => D.start()),
              this.tweenShowButtonSkip.stop(),
              (this.btnSkipReward.enabled = !1),
              (this.btnClaimX2.enabled = !1),
              $t.pause(),
              ps.showInterstitialAds(() => {
                $t.resume(),
                  this.isRewardAdsReady &&
                    (this.buttonClaimTween.start(),
                    (this.btnClaimX2.enabled = !0),
                    this.tweenShowButtonSkip.start());
              });
          }
        }
        class Xs extends Kt.e {
          constructor(S) {
            var D, le, Ce;
            super(S),
              (this.maxSpeed =
                ((D = S.attributes) == null ? void 0 : D.maxSpeed) || 0),
              (this.maxJumpingSpeed =
                ((le = S.attributes) == null ? void 0 : le.maxJumpingSpeed) ||
                0),
              (this.jumpTime =
                ((Ce = S.attributes) == null ? void 0 : Ce.jumpTime) || 0),
              (this._rotation = null),
              (this._currentRotation = null),
              (this._screenVector = null);
          }
          initialize() {
            (this.force = new i.A()),
              (this._rotation = new Ne.D()),
              (this._currentRotation = new Ne.D()),
              (this.speed = 0),
              (this._screenScaleRatio = $t.height / a.GAME_HEIGHT),
              (this.soundNameRollingFloor = "sfx_rolling_floor"),
              (this.soundNameRollingPipe = "sfx_rolling_pipe"),
              (this.soundNameRollingBridge = "sfx_rolling_bridge"),
              (this.speedSoundFloorThreshold = 4),
              (this.speedSoundPipeThreshold = 1),
              (this.isResetting = !1),
              (this._lastJumpTime = 0),
              (this.pauseSoundTime = 5),
              this.entity;
          }
          postUpdate(S) {
            var D, le;
            if (S === 0) return;
            if (this.isResetting) {
              (this.entity.ballBody.rigidbody.enabled = !0),
                (this.isResetting = !1);
              return;
            }
            this.entity.preVelocity =
              this.entity.ballBody.rigidbody.linearVelocity;
            let Ce = this.entity.ballBody.rigidbody.linearVelocity;
            if (
              (this.entity.requestJump &&
                ((Ce.y = a.JUMP_FORCE_MULTIPLIER),
                (this.entity.requestJump = !1),
                (this.entity.jumping = !0),
                (this._lastJumpTime = Mt.current)),
              this.entity.requestBoostSpeed)
            ) {
              let Bt =
                (le =
                  (D = this.entity._currentCollides.find((Nt) =>
                    Nt.name.includes("road_speed_booster")
                  )) == null
                    ? void 0
                    : D.forward) == null
                  ? void 0
                  : le.clone();
              Bt
                ? (Ce.add(Bt.mulScalar(a.BOOSTER_SPEED_MULTIPLIER * -1)),
                  (this.entity.requestBoostSpeed = !1),
                  (this.entity.boosting = !0),
                  (this._lastJumpTime = Mt.current))
                : (this.entity.requestBoostSpeed = !1);
            }
            this.entity.jumping || this.entity.boosting
              ? Mt.current - this._lastJumpTime > this.jumpTime &&
                ((this.entity.jumping = !1), (this.entity.boosting = !1))
              : (Ce.y = Math.min(Ce.y, a.MAX_VELOCITY_Y));
            let Ue = Ce.x,
              rt = Ce.z,
              Je = Math.sqrt(Ue * Ue + rt * rt);
            if (
              (Je > this.maxSpeed && Ce.normalize().mulScalar(this.maxSpeed),
              (this.entity.ballBody.rigidbody.linearVelocity = Ce),
              (this.speed = Je),
              Je > a.MINIUM_SPEED)
            ) {
              let Bt = Math.atan2(Ce.x, Ce.z) * Ot.m.RAD_TO_DEG,
                Nt = this.entity.getEulerAngles();
              this._rotation.setFromEulerAngles(0, Bt, 0),
                this._currentRotation.slerp(
                  this._currentRotation,
                  this._rotation,
                  S * a.BALL_DIRECTION_ROTATE_SPEED
                ),
                this.entity.setRotation(this._currentRotation);
              let Ht = Nt.x;
              (Nt = this.entity.getEulerAngles()),
                (Nt.x = Ht),
                this.entity.setEulerAngles(Nt),
                this.entity.setPosition(this.entity.ballBody.getPosition());
            }
            let St = Je * a.BALL_ROTATION_SPEED * S;
            this.entity.rotateLocal(St, 0, 0),
              this.entity.getPosition().y < a.DEAD_HEIGHT &&
                this.entity.fire(Ts.Dead),
              this._onRolling(Je);
          }
          _onRolling(S) {
            (S > this.speedSoundFloorThreshold && this.entity.isGrounded()) ||
            (S > this.speedSoundPipeThreshold &&
              this.entity.isRollingOnTheBridged())
              ? (this._playSound(this.soundNameRollingFloor, 1), (this.dt = 0))
              : ((this.dt += 0.1),
                this.dt >= this.pauseSoundTime &&
                  this._stopSound(this.soundNameRollingFloor)),
              S > this.speedSoundPipeThreshold &&
              this.entity.isRollingOnTheRoadPipe()
                ? this._playSound(this.soundNameRollingPipe, 0.4)
                : this._stopSound(this.soundNameRollingPipe);
          }
          _playSound(S, D = 1) {
            f.isPlaying(S) || f.play(S, D, !1);
          }
          _stopSound(S) {
            f.stop(S);
          }
          applyForce(S, D) {
            if (isNaN(this._screenScaleRatio)) {
              this._screenScaleRatio = $t.height / a.GAME_HEIGHT;
              return;
            }
            let le = a.MAX_FORCE * this._screenScaleRatio * D;
            if (this.entity.isGrounded()) this.force.copy(S).mulScalar(le);
            else if (a.CAN_CONTROL_IN_AIR)
              (le *= 0.2), this.force.copy(S).mulScalar(le);
            else return;
            this.entity.isRollingOnTheRoadPipe() &&
              ((le *= a.ROLLING_PIPE_FORCE), this.force.copy(S).mulScalar(le)),
              this.entity.ballBody.rigidbody.applyForce(this.force);
          }
          getRotation() {
            return this._rotation;
          }
          speedRatio() {
            return this.speed / a.MAX_SPEED;
          }
          reset(S) {
            this._currentRotation.copy(S),
              this._rotation.copy(S),
              (this.entity.ballBody.rigidbody.velocity = new i.A(0, 0, 0)),
              (this.entity.ballBody.rigidbody.linearVelocity = new i.A(
                0,
                0,
                0
              )),
              (this.entity.ballBody.rigidbody.angularVelocity = new i.A(
                0,
                0,
                0
              )),
              (this.entity.ballBody.rigidbody.enabled = !1),
              (this.isResetting = !0);
          }
        }
        class Zs extends Kt.e {
          constructor(S = {}) {
            var D, le, Ce, Ue;
            super(S),
              (this.target =
                ((D = S.attributes) == null ? void 0 : D.target) || void 0),
              (this.offset =
                ((le = S.attributes) == null ? void 0 : le.offset) ||
                new i.A(0, 0, 0)),
              (this.speed =
                ((Ce = S.attributes) == null ? void 0 : Ce.speed) || 0.1),
              (this.unbouncingSpeed =
                ((Ue = S.attributes) == null ? void 0 : Ue.unbouncingSpeed) ||
                10);
          }
          initialize() {
            (this._targetPosition = this.target
              .getPosition()
              .clone()
              .add(this.offset)),
              (this._currentPosition = this._targetPosition.clone()),
              this.entity.setPosition(this._currentPosition),
              (this.isTeleporting = !1);
          }
          update(S) {
            if (this.isTeleporting) {
              this.isTeleporting = !1;
              return;
            }
            let D = this._currentPosition.y;
            this._targetPosition
              .copy(this.target.getPosition())
              .add(this.offset),
              this._currentPosition.lerp(
                this._currentPosition,
                this._targetPosition,
                S * this.speed
              ),
              (this._currentPosition.y = Ot.m.lerp(
                D,
                this._targetPosition.y,
                S * this.unbouncingSpeed
              )),
              this.entity.setPosition(this._currentPosition);
          }
          teleport(S) {
            this._targetPosition.copy(S).add(this.offset),
              this._currentPosition.copy(this._targetPosition),
              this.entity.setPosition(this._currentPosition),
              (this.isTeleporting = !0);
          }
        }
        var We = kt(1239),
          ft = kt(429);
        const bt = Object.freeze({ Spawn: "spawn", Despawn: "despawn" }),
          ts = Jt.createScript({
            name: "spawner",
            attributes: {
              class: {},
              args: { default: [] },
              poolSize: { default: 0 },
            },
            initialize() {
              this.pool = [];
            },
            postInitialize() {
              this._createPool();
            },
            spawn(ee = null, S = -1) {
              let D = this.pool.pop();
              return (
                D || (D = this.createEntity()),
                (D.enabled = !0),
                D.once(bt.Despawn, () => this.despawn(D)),
                ee && (S >= 0 ? ee.insertChild(D, S) : ee.addChild(D)),
                D.fire(bt.Spawn),
                D
              );
            },
            despawn(ee) {
              (ee.enabled = !1), ee.parent.removeChild(ee), this.pool.push(ee);
            },
            spawnAt(ee, S = null, D = -1) {
              let le = ee.getPosition(),
                Ce = this.spawn(S || ee, D);
              return Ce.setPosition(le), Ce;
            },
            spawnTo(ee, S = null, D = -1) {
              let le = this.spawn(S || this.entity, D);
              return le.setPosition(ee), le;
            },
            _createPool: function () {
              for (var ee = 0; ee < this.poolSize; ee++)
                this.pool.push(this.createEntity());
            },
            createEntity() {
              return new this.class(...this.args);
            },
          });
        class Qt extends o.J {
          static playAt(S) {
            this._spawner || this._createPool();
            let D = this._spawner.spawn();
            return D.setPosition(S), D.play(), D;
          }
          static _createPool() {
            let S = new o.J("spawner_hitPipeEffect");
            (this._spawner = S.addScript(ts, { class: Qt, poolSize: 10 })),
              $t.app.root.addChild(S);
          }
          constructor() {
            super("fx_hit_pipe"),
              this._configParticle(),
              this._initParticle(),
              $t.app.root.addChild(this);
          }
          _initParticle() {
            this.addComponent("particlesystem", {
              autoPlay: !1,
              loop: !1,
              lifetime: 0.15,
              numParticles: 30,
              rate: 0.001,
              rate2: 0.005,
              blend: st.lA,
              colorMap: n.find("tex_outerRay").resource,
              animNumAnimations: 4,
              animNumFrames: 1,
              randomizeAnimIndex: !0,
              animLoop: !0,
              animSpeed: 1,
              startAngle: 0,
              startAngle2: 0,
              scaleGraph: this.scaleGraph1,
              scaleGraph2: this.scaleGraph2,
              localVelocityGraph: this.velocityParticle1Graph1,
              localVelocityGraph2: this.velocityParticle1Graph2,
              emitterExtents: this.emitterExtents,
            });
          }
          _configParticle() {
            (this.velocityParticle1Graph1 = new We.e([
              [0, 5],
              [0, 5],
              [0, 5],
            ])),
              (this.velocityParticle1Graph2 = new We.e([
                [0, -5],
                [0, -5],
                [0, -5],
              ])),
              (this.scaleGraph1 = new ft.H([0, 0.1, 0.5, 0.2, 1, 0.1])),
              (this.scaleGraph2 = new ft.H([0, 0.1, 0.5, 0.2, 1, 0.1])),
              (this.emitterExtents = [0.5, 0, 0.5]);
          }
          play() {
            this.particlesystem.reset(),
              this.particlesystem.play(),
              Pe.createCountTween({
                duration: 0.5,
                onComplete: () => {
                  this.fire(bt.Despawn);
                },
              });
          }
        }
        class rs extends Kt.e {
          constructor(S = {}) {
            var D, le, Ce, Ue;
            super(S),
              (this.target =
                ((D = S.attributes) == null ? void 0 : D.target) || void 0),
              (this.speed =
                ((le = S.attributes) == null ? void 0 : le.speed) || 10),
              (this.minSpeed =
                ((Ce = S.attributes) == null ? void 0 : Ce.minSpeed) || 0.1),
              (this.ballController =
                ((Ue = S.attributes) == null ? void 0 : Ue.ballController) ||
                null);
          }
          initialize() {
            (this._currentRotation = this.entity.getRotation().clone()),
              (this._targetRotation = new Ne.D()),
              this._targetRotation.copy(this._currentRotation),
              (this.forceUpdate = !1),
              (this.isResetting = !1);
          }
          update(S) {
            if (this.isResetting) {
              this.isResetting = !1;
              return;
            }
            if (this.target.linearVelocity.length() < this.minSpeed) return;
            let D = this.speed * S;
            this.forceUpdate || (D *= this.ballController.speedRatio()),
              (this._targetRotation = G(
                this.target.linearVelocity,
                i.A.UP,
                this._targetRotation
              )),
              this._currentRotation.slerp(
                this._currentRotation,
                this._targetRotation,
                D
              ),
              this.entity.setRotation(this._currentRotation);
          }
          reset(S) {
            this._currentRotation.copy(S),
              this._targetRotation.copy(S),
              this.entity.setRotation(S),
              (this.isResetting = !0);
          }
        }
        class Ps {
          static vibrate(S = 0.1) {
            navigator.vibrate &&
              h.get("vibration") &&
              navigator.vibrate(S * 1e3);
          }
        }
        const Ts = Object.freeze({
          Shake: "Ball:Shake",
          Dead: "Ball:Dead",
          Finish: "Ball:Finish",
          UpdateLife: "Ball:UpdateLife",
        });
        class ei extends o.J {
          constructor() {
            super("ball"),
              this._create(),
              this.setLocalScale(a.BALL_SCALE, a.BALL_SCALE, a.BALL_SCALE),
              (this._currentCollides = []),
              (this.life = ct.instance.getInt(a.STORAGE_KEY_LIFE, 1)),
              (this.isDeadAtLastFrame = !1),
              (this.preVelocity = new i.A()),
              this._createController(),
              (this.isCheck = !0);
          }
          _createController() {
            (this.controller = this.addScript(Xs, {
              attributes: {
                maxSpeed: a.MAX_SPEED,
                maxJumpingSpeed: a.MAX_JUMPING_SPEED,
                jumpTime: a.JUMP_TIME,
              },
            })),
              (this.checkPoint = {
                position: new i.A(0, 0.4, 0),
                rotation: Ne.D.IDENTITY.clone(),
              }),
              (this.rotateFollowVelocity = this.stableMovingBall.addScript(rs, {
                attributes: {
                  target: this.ballBody.rigidbody,
                  speed: 10,
                  ballController: this.controller,
                },
              }));
          }
          _create() {
            this.loadSkin(),
              (this.ballBody = new o.J("ballBody")),
              this.ballBody.addComponent("rigidbody", {
                type: "dynamic",
                mass: 10,
                friction: 1,
                rollingFriction: 0.1,
                linearDamping: 0.1,
                angularDamping: 0.1,
                restitution: 0,
              }),
              this.ballBody.addComponent("collision", {
                type: "sphere",
                radius: 0.4,
              }),
              this.ballBody.rigidbody.on(
                "triggerenter",
                this._onTriggerEnter,
                this
              ),
              this.ballBody.rigidbody.on(
                "collisionstart",
                this._onCollisionStart,
                this
              ),
              this.ballBody.rigidbody.on(
                "collisionend",
                this._onCollisionEnd,
                this
              ),
              (this.stableMovingBall = new o.J("stableMovingBall")),
              this.stableMovingBall.setLocalScale(0.5, 0.5, 1.5),
              (this.unbouncingFollow = this.stableMovingBall.addScript(Zs, {
                attributes: {
                  target: this.ballBody,
                  offset: new i.A(0, 0.5, 0),
                  speed: 10,
                  unbouncingSpeed: 10,
                },
              }));
          }
          loadSkin() {
            this.skin && this.removeChild(this.skin),
              (this.skinName = ct.instance.getString(
                a.STORAGE_KEY_SKIN,
                a.INIT_SKIN
              )),
              (this.skin = n.find(this.skinName).resource.clone()),
              (this.skin.enabled = !0),
              this.addChild(this.skin);
          }
          _onTriggerEnter(S) {
            let D = S.name;
            D.includes("collectable_ball")
              ? this._onCollideCollectableBall(S)
              : D.includes("platform_jump") &&
                this._onCollideWithPlatformJump(S);
          }
          _onCollisionStart(S) {
            this._currentCollides.indexOf(S.other) < 0 &&
              this._currentCollides.push(S.other);
            let D = S.other.name;
            D.includes("normal_road")
              ? this._onCollideWithRoad()
              : D.includes("normal_pipe")
              ? this._onCollideWithPipe(S)
              : D.includes("road_speed_booster") &&
                this._onCollideWithRoadSpeedBooster(S);
          }
          _onCollideWithPipe(S) {
            let le = this.ballBody.rigidbody.linearVelocity.length();
            le > 1 && this.fire(Ts.Shake, le * 0.02),
              this.ballBody.rigidbody.linearVelocity.mulScalar(-1),
              (this.preVelocity.z > 1.5 || this.preVelocity.z < -1.5) &&
                S.other._onCollide(this),
              Ps.vibrate(0.1);
          }
          _onCollideWithRoad() {
            this.preVelocity.y < -0.3 &&
              this.isCheck &&
              (f.play("sfx_collide_floor"),
              Qt.playAt(this.getPosition()),
              (this.isCheck = !1),
              Pe.createCountTween({
                duration: 1,
                onComplete: () => {
                  this.isCheck = !0;
                },
              }).start());
          }
          _onCollideCollectableBall(S) {
            let D = S.getPosition();
            this.checkPoint.position.set(D.x, D.y + 0.4, D.z),
              this.checkPoint.rotation.copy(S.getRotation()),
              this.life < a.TOTAL_LIFE &&
                (this.life++, this.fire(Ts.UpdateLife, this.life));
          }
          _onCollisionEnd(S) {
            this._currentCollides.indexOf(S) >= 0 &&
              this._currentCollides.splice(this._currentCollides.indexOf(S), 1);
          }
          _onCollideWithPlatformJump() {
            this.requestJump = !0;
          }
          _onCollideWithRoadSpeedBooster() {
            this.requestBoostSpeed = !0;
          }
          isGrounded() {
            return !!(
              this._currentCollides.length > 0 &&
              this._currentCollides[0].name.includes("normal_road")
            );
          }
          isRollingOnTheRoadPipe() {
            return !!(
              this._currentCollides.length > 0 &&
              this._currentCollides[0].name.includes("road_pipe")
            );
          }
          isRollingOnTheBridged() {
            return !!(
              (this._currentCollides.length > 0 &&
                this._currentCollides[0].name.includes("bridgeModel")) ||
              (this._currentCollides.length > 0 &&
                this._currentCollides[0].name.includes("model_road_bridge"))
            );
          }
          reset() {
            this.ballBody.rigidbody.teleport(0, 0.5, 0),
              (this.ballBody.rigidbody.velocity = new i.A(0, 0, 0)),
              (this.ballBody.rigidbody.linearVelocity = new i.A(0, 0, 0)),
              (this.ballBody.rigidbody.angularVelocity = new i.A(0, 0, 0));
          }
          teleport(S) {
            this.ballBody.rigidbody.teleport(S),
              this.setPosition(S),
              this.stableMovingBall.setEulerAngles(0, 0, 0),
              this.unbouncingFollow.teleport(S),
              this.rotateFollowVelocity.reset();
          }
          respawn() {
            let S = this.checkPoint.position,
              D = this.checkPoint.rotation;
            this.setPosition(S),
              this.setRotation(D),
              this.ballBody.setRotation(D),
              this.ballBody.rigidbody.teleport(S),
              this.unbouncingFollow.teleport(S),
              this.controller.reset(D),
              this.rotateFollowVelocity.reset(D);
          }
        }
        const Js = Object.freeze({ Start: "start", Move: "move", End: "end" }),
          ti = Jt.createScript({
            name: "swipeMovement",
            attributes: {
              screenEntity: {},
              multiplier: { default: 0 },
              speed: { default: 10 },
              range: { default: 20 },
            },
            touchedDown: !1,
            startPos: new i.A(),
            currPos: new i.A(),
            _deltaPos: new i.A(),
            _tmpTouchPosition: new i.A(),
            distance: 0,
            direction: new i.A(),
            initialize() {
              this._vector = new i.A();
            },
            onEnable() {
              this.startPos = this.currPos;
            },
            update() {
              if (!this.touchedDown) return;
              let ee = Math.min(1, this.speed * Mt.dt);
              (this.startPos = this.startPos.lerp(
                this.startPos,
                this.currPos,
                ee
              )),
                this.startPos.distance(this.currPos) > this.range &&
                  (this._vector
                    .copy(this.currPos)
                    .sub(this.startPos)
                    .normalize()
                    .mulScalar(this.range),
                  this.startPos.copy(this.currPos).sub(this._vector));
            },
            onPointerDown(ee) {
              (this.touchedDown = !0),
                ee.touches && ee.touches[0]
                  ? this.setStart(ee.touches[0])
                  : this.setStart(ee);
            },
            onPointerMove(ee) {
              this.touchedDown &&
                (ee.touches && ee.touches[0]
                  ? this.setMove(ee.touches[0])
                  : this.setMove(ee));
            },
            onPointerUp() {
              (this.touchedDown = !1),
                this.startPos.set(0, 0, 0),
                this.currPos.set(0, 0, 0);
            },
            setStart(ee) {
              this.getScreenSpacePosition(ee, this._tmpTouchPosition),
                this.startPos.copy(this._tmpTouchPosition),
                this.currPos.copy(this._tmpTouchPosition),
                this._deltaPos.set(0, 0, 0),
                (this.distance = 0),
                this.direction.set(0, 0, 0);
            },
            setMove(ee) {
              this.getScreenSpacePosition(ee, this._tmpTouchPosition),
                this.currPos.copy(this._tmpTouchPosition),
                this._deltaPos.copy(this.currPos).sub(this.startPos),
                (this.distance = this._deltaPos.length()),
                this.direction.copy(this._deltaPos).normalize(),
                this.entity.fire(Js.Move, this.direction, this.distance);
            },
            getScreenSpacePosition(ee, S = new i.A()) {
              (S.x = -ee.x * this.app.graphicsDevice.maxPixelRatio),
                (S.z =
                  this.app.graphicsDevice.height -
                  ee.y * this.app.graphicsDevice.maxPixelRatio),
                (S.y = 0),
                S.mulScalar(1 / this.screenEntity.screen.scale);
            },
          });
        var Bs = kt(3620);
        class si {
          constructor(S = {}) {
            if (!window.Ammo) {
              console.warn(
                "Warning! Trying to initialize Ammo Debug Drawer without Ammo lib in the project. Aborting."
              );
              return;
            }
            const D = S.app || Bs.Application.getApplication(),
              Ce = D.scene.layers,
              Ue = this,
              rt =
                S.layer ||
                Ce.getLayerByName("Debug Draw") ||
                Ce.getLayerById(Bs.LAYERID_UI),
              { entity: Je, distance: St, ignorePartials: Bt } = S.limit || {},
              Nt = new Ti(),
              Ht = new Bs.Vec3(),
              ns = new Bs.Vec3(),
              xs = new Bs.Vec3();
            let _s = 1,
              Rs = !1;
            const ms = new Ammo.DebugDrawer();
            (ms.drawLine = Un.bind(this)),
              (ms.drawContactPoint = dn.bind(this)),
              (ms.reportErrorWarning = hi.bind(this)),
              (ms.draw3dText = yn.bind(this)),
              (ms.setDebugMode = Nn.bind(this)),
              (ms.getDebugMode = un.bind(this)),
              (ms.enable = zn.bind(this)),
              (ms.disable = wn.bind(this)),
              (ms.update = Mn.bind(this));
            const Vs = D.systems.rigidbody.dynamicsWorld;
            Vs.setDebugDrawer(ms), (Ue.clear = es), (Ue.toggle = In);
            function hi(Ds) {}
            function yn(Ds, vn) {}
            function dn(Ds, vn, Dn, Ii, yi) {
              const vs = Ammo.wrapPointer(Ds, Ammo.btVector3),
                Hi = Ammo.wrapPointer(vn, Ammo.btVector3),
                ci = Ammo.wrapPointer(yi, Ammo.btVector3),
                fn = vs.x(),
                On = vs.y(),
                Ln = vs.z();
              Nt.pushPos(
                fn,
                On,
                Ln,
                fn + Hi.x() * 0.5,
                On + Hi.y() * 0.5,
                Ln + Hi.z() * 0.5
              ),
                Nt.pushColor(
                  ci.x(),
                  ci.y(),
                  ci.z(),
                  1,
                  ci.x(),
                  ci.y(),
                  ci.z(),
                  1
                );
            }
            function Un(Ds, vn, Dn) {
              const Ii = Ammo.wrapPointer(Ds, Ammo.btVector3),
                yi = Ammo.wrapPointer(vn, Ammo.btVector3),
                vs = Ammo.wrapPointer(Dn, Ammo.btVector3);
              if (Je) {
                Ht.set(Ii.x(), Ii.y(), Ii.z()), ns.set(yi.x(), yi.y(), yi.z());
                const Hi = Je.getPosition(),
                  ci = Hi.distance(Ht),
                  fn = Hi.distance(ns);
                ((ci < St && fn < St) || (Je && !Bt && (ci < St || fn < St))) &&
                  (Nt.pushPos(Ht.x, Ht.y, Ht.z, ns.x, ns.y, ns.z),
                  Nt.pushColor(
                    vs.x(),
                    vs.y(),
                    vs.z(),
                    1,
                    vs.x(),
                    vs.y(),
                    vs.z(),
                    1
                  ));
              } else
                Nt.pushPos(Ii.x(), Ii.y(), Ii.z(), yi.x(), yi.y(), yi.z()),
                  Nt.pushColor(
                    vs.x(),
                    vs.y(),
                    vs.z(),
                    1,
                    vs.x(),
                    vs.y(),
                    vs.z(),
                    1
                  );
            }
            function es() {
              Nt.clear();
            }
            function Nn(Ds) {
              _s = Ds;
            }
            function un() {
              return _s;
            }
            function zn() {
              Ue.enabled = !0;
            }
            function wn() {
              Ue.enabled = !1;
            }
            function In() {
              Ue.enabled = !Rs;
            }
            function Wn() {
              try {
                Nt.entries.forEach((Ds) => {
                  D.drawLineArrays(Ds.positions, Ds.colors, !1, rt);
                });
              } catch (Ds) {
                console.warn("Error drawing debug lines", Ds), wn();
              }
            }
            function Mn() {
              Rs && Vs.debugDrawWorld();
            }
            function Rn() {
              Rs && (Wn(), es());
            }
            Object.defineProperties(Ue, {
              enabled: {
                get: () => Rs,
                set: (Ds) => {
                  (Rs = Ds),
                    Rs
                      ? (D.systems.on("update", Mn, Ue),
                        D.systems.on("postUpdate", Rn, Ue))
                      : (D.systems.off("update", Mn, Ue),
                        D.systems.off("postUpdate", Rn, Ue),
                        es());
                },
              },
              mode: {
                get: () => _s,
                set: (Ds) => {
                  _s = Ds;
                },
              },
            });
          }
        }
        class Ti {
          constructor() {
            const S = this,
              D = new Map(),
              le = 64e3;
            let Ce = 0;
            D.set(Ce, { positions: [], colors: [] }),
              (S.entries = D),
              (S.clear = Ue),
              (S.pushColor = rt),
              (S.pushPos = Je),
              St(Ce);
            function Ue() {
              D.clear(), (Ce = 0), St(Ce);
            }
            function rt(Nt, Ht, ns, xs, _s, Rs, ms, Vs) {
              Bt("colors", 8).colors.push(Nt, Ht, ns, xs, _s, Rs, ms, Vs);
            }
            function Je(Nt, Ht, ns, xs, _s, Rs) {
              Bt("positions", 6).positions.push(Nt, Ht, ns, xs, _s, Rs);
            }
            function St(Nt) {
              const Ht = { positions: [], colors: [] };
              return D.set(Nt, Ht), Ht;
            }
            function Bt(Nt, Ht) {
              let ns = D.get(Ce);
              return ns[Nt].length + Ht > le && (ns = St(++Ce)), ns;
            }
          }
        }
        const xi = Jt.createScript({
          name: "rotateScript ",
          attributes: { speed: { default: new i.A(0, 0, 0) } },
          update(ee) {
            this.entity.rotateLocal(
              this.speed.x * ee,
              this.speed.y * ee,
              this.speed.z * ee
            );
          },
        });
        class Is extends o.J {
          constructor(S) {
            super(S.name),
              (this.data = S),
              this._initModel(),
              this._applyTransformData();
          }
          _applyTransformData() {
            this.setPosition(...this.data.position),
              this.setEulerAngles(...this.data.eulerAngles),
              this.setLocalScale(...this.data.scale);
          }
          _initModel() {
            if (!this.data.model) return;
            let S = n.find(this.data.model);
            if (!S) {
              console.error(`Model asset ${this.data.model} not found`);
              return;
            }
            this.addComponent("model", { asset: S, castShadows: !1 }),
              this.data.materials &&
                this.data.materials.forEach((D, le) => {
                  let Ce = n.find(D);
                  if (!Ce) {
                    console.error(`Material asset ${D} not found`);
                    return;
                  }
                  this.model.meshInstances[le].material = Ce.resource;
                });
          }
        }
        class ai extends Is {
          constructor(S) {
            super(S);
          }
          _applyTransformData() {
            this._initCollider(), super._applyTransformData();
          }
          _initCollider(S = null) {
            let le = _e(S || this).halfExtents;
            this.addComponent("collision", { type: "box", halfExtents: le }),
              this.collision.on("triggerenter", this._onTriggerEnter, this);
          }
          _onTriggerEnter(S) {
            S.name === "ballBody" && this._playTween(S);
          }
          _playTween(S) {
            Pe.createLocalTranslateTween(
              this,
              {
                x: this.getLocalPosition().x,
                y: this.getLocalPosition().y + 2,
              },
              {
                duration: 0.3,
                onUpdate: () => {
                  this.rotateLocal(0, -6, 0);
                },
                onComplete: () => {
                  Pe.createLocalTranslateTween(
                    this,
                    { y: S.getLocalPosition().y + 1 },
                    {
                      duration: 0.3,
                      delay: 0,
                      onUpdate: () => {
                        this.rotateLocal(0, -6, 0);
                      },
                      onComplete: () => {
                        this.destroy();
                      },
                    }
                  ).start(),
                    Pe.createScaleTween(
                      this,
                      { x: 0.7, y: 0.7, z: 0.7 },
                      {
                        duration: 0.3,
                        delay: 0.1,
                        onComplete: () => {
                          this.destroy();
                        },
                      }
                    ).start();
                },
              }
            ).start(),
              Pe.createLocalTranslateTween(
                this,
                {},
                {
                  duration: 0.8,
                  delay: 0,
                  onUpdate: () => {
                    let Ce = this.getLocalPosition(),
                      Ue = S.getLocalPosition(),
                      rt = Ue.x,
                      Je = Ce.y,
                      St = Ue.z;
                    this.setPosition(rt, Je, St);
                  },
                }
              ).start();
          }
        }
        class Qs extends o.J {
          static playAt(S, D) {
            this._spawner || this._createPool();
            let le = this._spawner.spawn();
            return (
              le.setPosition(S.x, S.y + 0.5, S.z),
              le.setEulerAngles(D),
              le.play(),
              le
            );
          }
          static _createPool() {
            let S = new o.J("spawner_hitCoinEffect");
            (this._spawner = S.addScript(ts, { class: Qs, poolSize: 10 })),
              $t.app.root.addChild(S);
          }
          constructor() {
            super("fx_hit_coin"),
              this._initPlane(),
              this._initTween(),
              $t.app.root.addChild(this);
          }
          _initPlane() {
            (this.texture = n.find("tex_outerRay").resource),
              (this.plane = new o.J()),
              this.plane.addComponent("model", { type: "plane" }),
              (this.plane.model.castShadows = !1),
              this.plane.setEulerAngles(-90, 0, 0);
            let S = new Pt.K();
            (S.diffuse = new Te.I(226 / 255, 1, 80 / 255)),
              (S.blendType = st.Yk),
              (S.opacityMap = this.texture),
              (S.opacityMapChannel = "a"),
              (S.cull = He.OL2),
              (this.plane.model.meshInstances[0].material = S),
              this.addChild(this.plane);
          }
          _initTween() {
            this.plane.setLocalScale(0.2, 0.2, 0.2),
              (this.scaleTween1 = Pe.createScaleTween(
                this.plane,
                { x: 4, y: 4, z: 4 },
                {
                  duration: 0.2,
                  onComplete: () => {
                    (this.scaleBackTween1 = Pe.createScaleTween(
                      this.plane,
                      { x: 0, y: 0, z: 0 },
                      { duration: 0.1 }
                    )),
                      this.scaleBackTween1.start();
                  },
                }
              ));
          }
          play() {
            this.scaleTween1.stop(),
              this.scaleTween1.start(),
              Pe.createCountTween({
                duration: 0.5,
                onComplete: () => {
                  this.fire(bt.Despawn);
                },
              });
          }
        }
        class ji extends ai {
          constructor(S) {
            super(S);
          }
          _initModel() {
            (this.bodyModel = new o.J("bodyModel")),
              this.addChild(this.bodyModel),
              this.bodyModel.addScript(xi, { speed: new i.A(0, 200, 0) }),
              this.bodyModel.addComponent("model", {
                asset: n.find(this.data.model),
                castShadows: !1,
              }),
              (this.bodyModel.model.castShadows = !1);
          }
          _initCollider(S = null) {
            let le = _e(S || this).halfExtents;
            le.set(le.x * 1.5, le.y * 1.5, le.z * 1.5),
              this.addComponent("collision", { type: "box", halfExtents: le }),
              this.collision.on("triggerenter", this._onTriggerEnter, this);
          }
          _onTriggerEnter(S) {
            S.name === "ballBody" &&
              (this.collision.onDisable(),
              super._onTriggerEnter(S),
              f.play("sfx_coin", 0.5),
              (Ss.instance.coinCount += a.ITEM_COIN_AMOUNT),
              this._onCollide(S));
          }
          _onCollide(S) {
            Qs.playAt(this.getPosition(), S.parent.mainCamera.getEulerAngles());
          }
        }
        var Di = kt(8433);
        class Yi extends Is {
          constructor(S) {
            super(S);
          }
          _applyTransformData() {
            let S = new i.A();
            this.model.meshInstances.forEach((D) => {
              S.add(D.aabb.halfExtents);
            }),
              S.mul(new i.A(...this.data.scale)),
              this.addComponent("collision", { type: "box", halfExtents: S }),
              super._applyTransformData(),
              setTimeout(() => {
                this.addComponent("rigidbody", { type: "dynamic", mass: 0.5 }),
                  setTimeout(() => {
                    this.rigidbody.body.setActivationState(Di.qJ);
                  }, 1);
              }, 1),
              this.collision.on("collisionstart", this._onCollide, this);
          }
          _onCollide(S) {
            S.other.name === "ballBody" &&
              (f.isPlaying("sfx_hitBox") ||
                (f.play("sfx_hitBox", 1, !1), Qt.playAt(this.getPosition())));
          }
        }
        class Ai extends ai {
          constructor(S) {
            super(S), this._initParticle();
          }
          _initModel() {
            super._initModel(), this._initBall();
          }
          _initBall() {
            let S = ct.instance.getString(a.STORAGE_KEY_SKIN, a.INIT_SKIN),
              D = n.find(S).resource.clone();
            (D.enabled = !0),
              this.addChild(D),
              D.setLocalPosition(0, 2, 0),
              D.setEulerAngles(0, 0, 0),
              (this.tween = Pe.createLocalTranslateTween(
                D,
                { y: 1 },
                {
                  duration: 2,
                  yoyo: !0,
                  loop: !0,
                  easing: Pe.Easing.Quadratic.InOut,
                }
              )),
              this.tween.start();
          }
          _initCollider() {
            let S = _e(this),
              D = S.center.sub(this.getPosition());
            this.addComponent("collision", {
              type: "box",
              halfExtents: S.halfExtents,
              linearOffset: D,
            }),
              this.collision.on("triggerenter", this._onTriggerEnter, this);
          }
          _onTriggerEnter(S) {
            S.name === "ballBody" &&
              (this.tween.stop(),
              this.children.forEach((D) => {
                D instanceof o.J && (this.removeChild(D), D.destroy());
              }),
              this.particles.particlesystem.stop(),
              f.play("sfx_collide_checkPoint"),
              this.removeComponent("collision"));
          }
          _initParticle() {
            this._createParticle(), this._createCircleParticle();
          }
          _createParticle() {
            let S = new We.e([
                [0, 0],
                [0, 2],
                [0, 0],
              ]),
              D = new ft.H([0, 0.2]),
              le = new ft.H([0, 0.4]),
              Ce = n.find("tex_outerRay").resource;
            this.particles = new o.J();
            let Ue = new ft.H([0, 1, 0.5, 0.6, 1, 0]),
              rt = new We.e([
                [0, 120 / 255],
                [0, 226 / 255],
                [0, 1],
              ]);
            this.addChild(this.particles),
              this.particles.addComponent("particlesystem", {
                autoPlay: !0,
                loop: !0,
                lifetime: 1,
                numParticles: 40,
                colorMap: Ce,
                rate: 0.02,
                rate2: 0.1,
                randomizeAnimIndex: !0,
                animLoop: !0,
                blendType: st.$U,
                scaleGraph: D,
                scaleGraph2: le,
                localVelocityGraph: S,
                alphaGraph: Ue,
                colorGraph: rt,
                emitterShape: st.mx,
                emitterRadius: 1,
              });
          }
          _createCircleParticle() {
            let S = n.find("tex_fx_circle").resource;
            this.circleParticle = new o.J();
            let D = new We.e([
                [0, 0],
                [0, 1.5],
                [0, 0],
              ]),
              le = new ft.H([0, 1, 0.7, 1, 1, 0]),
              Ce = new We.e([
                [0, 120 / 255],
                [0, 226 / 255],
                [0, 1],
              ]);
            this.addChild(this.circleParticle),
              this.circleParticle.addComponent("particlesystem", {
                autoPlay: !0,
                loop: !0,
                orientation: st.GS,
                lifetime: 1.5,
                numParticles: 2,
                colorMap: S,
                rate: 0.7,
                rate2: 0.7,
                randomizeAnimIndex: !0,
                animLoop: !0,
                blendType: st.$U,
                localVelocityGraph: D,
                alphaGraph: le,
                colorGraph: Ce,
              });
          }
        }
        class Oi extends ai {
          constructor(S) {
            super(S), this._initAnimation();
          }
          _initCollider() {
            (this.ring = Be.createModel("model_ring_001")),
              this.addChild(this.ring),
              super._initCollider(this.ring);
          }
          _onTriggerEnter(S) {
            S.name === "ballBody" && this._onCollide(S);
          }
          _initAnimation() {
            Pe.createCountTween({
              duration: 0.5,
              loop: !0,
              onUpdate: () => {
                this.ring.rotateLocal(0, -1.5, 0);
              },
            }).start();
          }
          _onCollide(S) {
            Ss.instance.keyCount++,
              f.play("sfx_key"),
              Qs.playAt(
                this.getPosition(),
                S.parent.mainCamera.getEulerAngles()
              ),
              Pe.createLocalTranslateTween(
                this,
                { y: this.getPosition().y + 7 },
                {
                  duration: 0.4,
                  easing: Pe.Easing.Back.InOut,
                  onComplete: () => {
                    this.destroy();
                  },
                }
              ).start();
          }
        }
        class Ci extends Is {
          constructor(S) {
            super(S), this._initCollider();
          }
          _initCollider() {
            let S = _e(this),
              D = S.center.sub(this.getPosition());
            this.addComponent("collision", {
              type: "box",
              halfExtents: S.halfExtents,
              linearOffset: D,
            }),
              this.addComponent("rigidbody", { type: "static" });
          }
        }
        class Li extends Ci {
          constructor(S) {
            super(S), this._initMovement();
          }
          _initCollider() {
            let S = this.getLocalScale();
            this.addComponent("collision", {
              type: "cylinder",
              radius: 0.57 * S.z,
              height: 2 * S.x,
              axis: 0,
              linearOffset: new i.A(0, -3.92 * S.y, 0),
            }),
              this.addComponent("rigidbody", { type: "kinematic" });
          }
          _initMovement() {
            if (this.data.hammerType && this.data.hammerType === "double") {
              this.setLocalEulerAngles(0, 0, 20);
              let S = Pe.createTween(
                  { x: 0, y: 0, z: 20 },
                  { x: 0, y: 0, z: -50 },
                  {
                    duration: 0.7,
                    easing: Pe.Easing.Cubic.In,
                    onUpdate: (le) => {
                      this.setLocalEulerAngles(le.x, le.y, le.z);
                    },
                  }
                ),
                D = Pe.createTween(
                  { x: 0, y: 0, z: -50 },
                  { x: 0, y: 0, z: 20 },
                  {
                    duration: 2,
                    delay: 0.2,
                    easing: Pe.Easing.Sinusoidal.InOut,
                    onUpdate: (le) => {
                      this.setLocalEulerAngles(le.x, le.y, le.z);
                    },
                  }
                );
              S.chain(D), D.chain(S), S.start();
            } else
              this.setLocalEulerAngles(0, 0, 50),
                Pe.createRotateTween(
                  this,
                  { x: 0, y: 0, z: -50 },
                  {
                    duration: 1.3,
                    loop: !0,
                    yoyo: !0,
                    easing: Pe.Easing.Cubic.InOut,
                  }
                ).start();
          }
        }
        class Bi extends o.J {
          constructor(S) {
            super(S.name),
              (this.data = S),
              this.setPosition(...this.data.position),
              this.setEulerAngles(...this.data.eulerAngles),
              this.setLocalScale(...this.data.scale),
              this._initModel(S),
              this._initColliders();
          }
          _initModel(S) {
            (this.bridgeModel = new o.J("bridgeModel")),
              this.bridgeModel.addComponent("model", {
                asset: n.find(S.model),
                castShadows: !1,
              }),
              this.addChild(this.bridgeModel),
              S.materials &&
                S.materials.forEach((D, le) => {
                  let Ce = n.find(D);
                  this.bridgeModel.model.meshInstances[le].material =
                    Ce.resource;
                });
          }
          _initColliders() {
            let S = _e(this.bridgeModel),
              D = S.halfExtents,
              le = S.center.sub(this.getPosition());
            this.bridgeModel.addComponent("collision", {
              type: "box",
              halfExtents: D,
              linearOffset: le,
            }),
              this.bridgeModel.addComponent("rigidbody", {
                type: "kinematic",
                friction: 0,
                rollingFriction: 0,
              }),
              this.bridgeModel.setLocalEulerAngles(-90, 0, 0),
              this.bridgeModel.rigidbody.on(
                "collisionstart",
                this._onCollisionStart,
                this
              );
          }
          _onCollisionStart(S) {
            S.other.name === "ballBody" &&
              (Pe.createRotateTween(
                this.bridgeModel,
                { x: 0, y: 0, z: 0 },
                { duration: 0.5 }
              ).start(),
              this.bridgeModel.collision.off(
                "triggerenter",
                this._onTriggerEnter,
                this
              ));
          }
        }
        class Fi extends Is {
          constructor(S) {
            super(S), this._initCollider();
          }
          _initCollider() {
            var S = _e(this);
            let D = S.center.sub(this.getPosition());
            this.addComponent("collision", {
              type: "box",
              halfExtents: S.halfExtents,
              linearOffset: D,
              trigger: !0,
            }),
              this.collision.on("triggerenter", this._onTriggerEnter, this);
          }
        }
        class Ui extends Fi {
          constructor(S) {
            super(S);
          }
          _onTriggerEnter(S) {
            S.name === "ballBody" && S.fire(Ts.Finish, this);
          }
        }
        class pi extends Is {
          constructor(S) {
            super(S), this._createCollider();
          }
          _createCollider() {
            var S;
            let D = {};
            (D.type = (S = this.model) == null ? void 0 : S.type),
              D.type === "asset" &&
                ((D.type = "mesh"), (D.asset = n.find(this.data.model))),
              this.addComponent("collision", D),
              this.addComponent("rigidbody", {
                type: "static",
                friction: 1,
                rollingFriction: 0.5,
                linearDamping: 0,
                angularDamping: 0,
                restitution: 0,
              }),
              this.data.contactProcessingThreshold !== void 0 &&
                setTimeout(() => {
                  var le = this.rigidbody.body;
                  le.setContactProcessingThreshold(
                    this.data.contactProcessingThreshold
                  );
                }, 10),
              this._recreateCollider();
          }
          _recreateCollider() {
            setTimeout(() => {
              (this.enabled = !1),
                Ammo.destroy(this.collision.shape),
                (this.collision.shape = null);
              for (const S of this.collision.model.meshInstances)
                delete $t.app.systems.collision._triMeshCache[S.mesh.id];
              this.enabled = !0;
            }, 1);
          }
        }
        class Xi extends pi {
          constructor(S) {
            super(S);
          }
          _createCollider() {
            var S;
            let D = {};
            (D.type = (S = this.model) == null ? void 0 : S.type),
              D.type === "asset" &&
                ((D.type = "mesh"), (D.asset = n.find(this.data.model))),
              this.addComponent("collision", D),
              this.addComponent("rigidbody", {
                type: "static",
                friction: 0,
                rollingFriction: 0,
                linearDamping: 0,
                angularDamping: 0,
                restitution: 0,
              }),
              this._recreateCollider();
          }
          _onCollide(S) {
            let D = S.getPosition(),
              le = D,
              Ce = D.clone().add(new i.A(0.5, 0, 0)),
              Ue = D.clone().add(new i.A(-0.5, 0, 0)),
              rt = $t.app.systems.rigidbody.raycastFirst(le, Ce),
              Je = $t.app.systems.rigidbody.raycastFirst(le, Ue);
            rt && Qt.playAt(rt.point),
              Je && Qt.playAt(Je.point),
              f.play("sfx_collide_pipe");
          }
        }
        var Pi = Object.defineProperty,
          Zi = (ee, S, D) =>
            S in ee
              ? Pi(ee, S, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: D,
                })
              : (ee[S] = D),
          Ji = (ee, S, D) => (Zi(ee, typeof S != "symbol" ? S + "" : S, D), D);
        const Ni = class Gn extends Is {
          constructor(S) {
            if ((super(S), !Gn._animationRegistered)) {
              Gn._animationRegistered = !0;
              let D = this.model.meshInstances[0].material,
                le = 0,
                Ce = -0.005;
              Pe.createCountTween({
                duration: 1,
                loop: !0,
                onUpdate: () => {
                  (D.diffuseMapOffset.x = le),
                    (D.emissiveMapOffset.x = le),
                    D.update(),
                    (le += Ce);
                },
              }).start();
            }
          }
        };
        Ji(Ni, "_animationRegistered", !1);
        let Mi = Ni;
        class bi extends Is {
          constructor(S) {
            super(S);
          }
          _applyTransformData() {
            super._applyTransformData(),
              this.addComponent("collision", {
                type: "sphere",
                radius: this.data.scale[0] / 2,
              }),
              this.addComponent("rigidbody", { type: "dynamic", mass: 10 }),
              setTimeout(() => {
                setTimeout(() => {
                  this.rigidbody.body.setActivationState(Di.qJ);
                }, 1);
              }, 1);
          }
        }
        class _i extends pi {
          constructor(S) {
            super(S);
          }
          _createCollider() {
            var S;
            let D = {};
            (D.type = (S = this.model) == null ? void 0 : S.type),
              D.type === "asset" &&
                ((D.type = "mesh"), (D.asset = n.find(this.data.model))),
              this.addComponent("collision", D),
              this.addComponent("rigidbody", {
                type: "static",
                friction: 0,
                rollingFriction: 0.5,
                linearDamping: 0,
                angularDamping: 0,
                restitution: 0,
              });
          }
        }
        class Qi extends Is {
          constructor(S) {
            super(S), this._createCollider();
          }
          _createCollider() {
            let S = _e(this),
              D = S.halfExtents,
              le = S.center.sub(this.getPosition());
            this.addComponent("collision", {
              type: "box",
              halfExtents: D,
              center: le,
            });
          }
        }
        var $i = Object.defineProperty,
          qi = (ee, S, D) =>
            S in ee
              ? $i(ee, S, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: D,
                })
              : (ee[S] = D),
          en = (ee, S, D) => (qi(ee, typeof S != "symbol" ? S + "" : S, D), D);
        const zi = class Hn extends pi {
          constructor(S) {
            if ((super(S), !Hn._animationRegistered)) {
              Hn._animationRegistered = !0;
              let D = this.model.meshInstances[1].material,
                le = 0,
                Ce = -0.005;
              Pe.createCountTween({
                duration: 1,
                loop: !0,
                onUpdate: () => {
                  (D.diffuseMapOffset.x = le),
                    (D.emissiveMapOffset.x = le),
                    D.update(),
                    (le += Ce);
                },
              }).start();
            }
          }
        };
        en(zi, "_animationRegistered", !1);
        const tn = {
          coin: ji,
          key: Oi,
          boxObstacle: Yi,
          ballObstacle: bi,
          bridge: Bi,
          staticObstacle: Ci,
          collectableBall: Ai,
          pipeObject: Xi,
          finishObject: Ui,
          directionSign: Mi,
          hammerObstacle: Li,
          roadPipeObject: _i,
          platformJump: Qi,
          roadSpeedBooster: zi,
          collisionObject: pi,
          mapObject: Is,
        };
        class Wi extends o.J {
          constructor(S) {
            super("map"), (this.finish = null), this._addEntityNode(S, this);
          }
          _addEntityNode(S, D) {
            var le = this._createEntityNode(S, D),
              Ce = le.getWorldTransform().clone(),
              Ue = D.getWorldTransform().clone().invert();
            Ce.mul2(Ue, Ce);
            var rt = Ce.getTranslation(),
              Je = new Ne.D().setFromMat4(Ce),
              St = Ce.getScale();
            le.reparent(D),
              le.setLocalPosition(rt),
              le.setLocalRotation(Je),
              le.setLocalScale(St);
          }
          _createEntityNode(S) {
            var D;
            return (
              (D = new tn[S.type](S)),
              S.type === "finishObject" && (this.finish = D),
              S.children &&
                S.children.length > 0 &&
                S.children.forEach((le) => {
                  this._addEntityNode(le, D);
                }),
              D
            );
          }
        }
        class sn extends o.J {
          constructor(S, D) {
            super(D), (this.mapData = S), (this.numLevel = 0);
          }
          create() {
            (this.map = new Wi(this.mapData)), this.addChild(this.map);
          }
        }
        const nn = JSON.parse(
            '[{"mapData":"map1"},{"mapData":"map2"},{"mapData":"map3"},{"mapData":"map4"},{"mapData":"map5"},{"mapData":"map6"},{"mapData":"map7"},{"mapData":"map8"},{"mapData":"map9"},{"mapData":"map10"},{"mapData":"map11"},{"mapData":"map12"},{"mapData":"map13"},{"mapData":"map14"},{"mapData":"map15"},{"mapData":"map16"},{"mapData":"map17"},{"mapData":"map18"},{"mapData":"map19"},{"mapData":"map20"}]'
          ),
          ki = Object.freeze({ LevelLoaded: "LevelManager:LevelLoaded" });
        class rn extends o.J {
          constructor() {
            super(),
              (this.levels = []),
              (this.currentLevelIndex = 0),
              (this.currentLevel = null),
              this._initLevels();
          }
          _initLevels() {
            nn.forEach((S, D) => {
              let le = n.find(S.mapData).resource,
                Ce = new sn(le, `Level_${D}`);
              this.addChild(Ce), this.levels.push(Ce);
            });
          }
          loadNextLevel() {
            this.loadLevel(this.currentLevelIndex + 1);
          }
          loadLevel(S) {
            this.currentLevelIndex = S;
            var D = this.levels[this.currentLevelIndex % this.levels.length];
            if (!D) {
              console.warn(`Level "${this.currentLevelIndex}" is not found!`);
              return;
            }
            this.currentLevel && this.currentLevel.destroy(),
              (D.numLevel = this.currentLevelIndex + 1),
              D.create(),
              (this.currentLevel = D),
              this.fire(ki.LevelLoaded, D);
          }
        }
        const Vi = Object.freeze({ Opened: "ChestItem:Opened" }),
          Gi = Object.freeze({ Complete: "ChestScreen:Complete" });
        class an extends et {
          constructor() {
            super(a.SCREEN_CHEST);
          }
          create() {
            this._createBackground(),
              this._createBase(),
              this._createReward(),
              this._createKeys(),
              this._createBestReward(),
              this._createAnimations();
          }
          _createBackground() {
            (this.bg = Be.createColorBackground(Te.I.BLACK, 0.5)),
              this.addChild(this.bg);
          }
          _createBase() {
            (this.base = Be.createImageElement("spr_frame_reward")),
              (this.glow = Be.createImageElement("spr_glow_effect", {
                y: 250,
              })),
              this.base.addChild(this.glow),
              (this.label = Be.createImageElement("spr_label_top", {
                anchor: new at.T(0.5, 1, 0.5, 1),
                pivot: new De.S(0.5, 0.8),
                y: 10,
              })),
              this.base.addChild(this.label),
              (this.txtBestPrize = Be.createTextElement("font_rounded", {
                text: "Best prize",
                fontSize: 40,
                color: Te.I.WHITE,
                y: 5,
              })),
              this.label.addChild(this.txtBestPrize),
              (this.txtChoose = Be.createTextElement("font_rounded", {
                text: "Choose a chest",
                fontSize: 40,
                anchor: new at.T(0.5, 0, 0.5, 0),
                pivot: new De.S(0.5, 0.5),
                color: Te.I.WHITE,
                y: 130,
              })),
              this.base.addChild(this.txtChoose),
              this.addChild(this.base);
          }
          _createReward() {
            (this.chests = []),
              (this.rewardGroupBackground = Be.createImageElement(
                "spr_frame_reward_inner",
                {
                  anchor: new at.T(0.5, 0.5, 0.5, 0.5),
                  pivot: new De.S(0.5, 0.5),
                  y: -50,
                }
              )),
              this.base.addChild(this.rewardGroupBackground),
              (this.rewardGroup = Be.createGroupElement({
                width: 300,
                height: 300,
              })),
              this.rewardGroup.addComponent("layoutgroup", {
                orientation: st.gC,
                alignment: new De.S(0.5, 0.5),
                spacing: new De.S(100, 100),
                wrap: !0,
              });
            for (let S = 0; S < 9; S++) {
              let D = new on();
              D.on(Vi.Opened, this._onChestOpened, this),
                this.rewardGroup.addChild(D),
                this.chests.push(D);
            }
            this.rewardGroupBackground.addChild(this.rewardGroup);
          }
          _createKeys() {
            (this.keys = []),
              (this.keyGroup = Be.createGroupElement({
                anchor: new at.T(0.5, 0, 0.5, 0),
                pivot: new De.S(0.5, 0.5),
                width: 300,
                height: 50,
                y: 70,
              })),
              this.keyGroup.addComponent("layoutgroup", {
                orientation: st.gC,
                alignment: new De.S(0.5, 0.5),
                spacing: new De.S(30, 0),
              });
            for (let S = 0; S < a.TOTAL_KEY_TO_COLLECT; S++) {
              let D = Be.createImageElement("spr_icon_key");
              this.keys.push(D), this.keyGroup.addChild(D);
            }
            this.base.addChild(this.keyGroup);
          }
          _onChestOpened(S) {
            let D, le;
            Math.random() < a.PERCENTAGE_TO_OPEN_SKIN_CHEST &&
            this.rewards.skin === "" &&
            this.skin
              ? ((D = "skin"), (le = this.skin), (this.rewards.skin = le))
              : ((D = "coin"),
                (le = ke.randomInt(this.minCoin, this.maxCoin)),
                (this.rewards.coin += le)),
              S.setReward(D, le),
              S.open(),
              this.openedChests++,
              this._updateKeys(),
              this.openedChests === this.keys.length &&
                (this.chests.forEach((Ce) => {
                  Ce.canOpen = !1;
                }),
                this.fire(Gi.Complete, this.rewards)),
              f.play("sfx_click");
          }
          _updateKeys() {
            for (let S = 0; S < this.keys.length; S++) {
              let D = this.keys[S];
              S < this.keys.length - this.openedChests
                ? (D.element.textureAsset = n.find("spr_icon_key"))
                : (D.element.textureAsset = n.find("spr_icon_key_gray"));
            }
          }
          updateReward(S, D, le) {
            (this.rewards = { coin: 0, skin: "" }),
              (this.openedChests = 0),
              this._updateKeys(),
              (this.maxCoin = D),
              (this.minCoin = S),
              (this.skin = le),
              this.chests.forEach((Ce) => {
                Ce.reset();
              }),
              this._updateBestReward();
          }
          _createBestReward() {
            (this.bestCoinReward = Be.createGroupElement({
              width: 300,
              height: 300,
              y: 250,
            })),
              this.bestCoinReward.addComponent("layoutgroup", {
                orientation: st.gC,
                alignment: new De.S(0.5, 0.5),
                spacing: new De.S(10, 0),
                wrap: !0,
              }),
              (this.bestRewardText = Be.createTextElement("font_rounded", {
                text: "123",
                fontSize: 52,
                color: Te.I.WHITE,
              })),
              (this.bestRewardText.element.outlineThickness = 0.1),
              this.bestCoinReward.addChild(this.bestRewardText),
              (this.bestRewardIcon = Be.createImageElement(
                "spr_icon_coin_reward"
              )),
              this.bestCoinReward.addChild(this.bestRewardIcon),
              this.base.addChild(this.bestCoinReward),
              (this.bestCoinReward.enabled = !1),
              (this.bestBallReward = Be.createImageElement(
                "spr_icon_ball_001",
                { width: 150, height: 150, y: 260 }
              )),
              this.base.addChild(this.bestBallReward),
              (this.bestBallReward.enabled = !1);
          }
          _updateBestReward() {
            this.skin
              ? ((this.bestBallReward.enabled = !0),
                (this.bestCoinReward.enabled = !1),
                (this.bestBallReward.element.textureAsset = n.find(
                  `spr_icon_${this.skin}`
                )))
              : ((this.bestBallReward.enabled = !1),
                (this.bestCoinReward.enabled = !0),
                (this.bestRewardText.element.text = this.maxCoin));
          }
          _createAnimations() {
            this._appearAnimation = Pe.createTween(
              { x: 0, y: 0, z: 0 },
              { x: 1, y: 1, z: 1 },
              {
                duration: 0.5,
                easing: Pe.Easing.Back.Out,
                onUpdate: (S) => {
                  this.base.setLocalScale(S.x, S.y, S.z);
                },
              }
            );
          }
          onEnable() {
            this._appearAnimation.start();
          }
        }
        class on extends o.J {
          constructor() {
            super("chest_item"),
              this.addComponent("element", {
                type: tt.Kv,
                anchor: new at.T(0.5, 0.5, 0.5, 0.5),
                pivot: new De.S(0.5, 0.5),
              }),
              this._initCloseChest(),
              this._initOpenChest(),
              this._initReward();
          }
          _initCloseChest() {
            (this.closeChest = Be.createImageElement("spr_icon_chest_close", {
              anchor: new at.T(0.5, 0.5, 0.5, 0.5),
              pivot: new De.S(0.5, 0.5),
            })),
              this.addChild(this.closeChest),
              ke.registerOnTouch(this.closeChest.element, this._onClick, this);
          }
          _initOpenChest() {
            (this.openChest = Be.createImageElement("spr_icon_chest_open", {
              anchor: new at.T(0.5, 0.5, 0.5, 0.5),
              pivot: new De.S(0.5, 0.5),
            })),
              this.addChild(this.openChest),
              (this.openChest.enabled = !1);
          }
          setReward(S, D) {
            (this.rewardType = S),
              (this.rewardValue = D),
              S === "coin"
                ? ((this.textReward.enabled = !0),
                  (this.textReward.element.text = D),
                  (this.textReward.element.opacity = 0),
                  (this.iconReward.element.textureAsset = n.find(
                    "spr_icon_coin_reward"
                  )),
                  this.iconReward.setLocalScale(0.7, 0.7, 0.7))
                : S === "skin" &&
                  ((this.textReward.enabled = !1),
                  (this.iconReward.element.textureAsset = n.find(
                    `spr_icon_${D}`
                  )),
                  this.iconReward.setLocalScale(1, 1, 1));
          }
          reset() {
            (this.closeChest.enabled = !0),
              (this.openChest.enabled = !1),
              (this.canOpen = !0),
              (this.iconReward.element.opacity = 0),
              (this.textReward.enabled = !1);
          }
          _initReward() {
            (this.reward = Be.createGroupElement({ width: 100, height: 100 })),
              this.reward.addComponent("layoutgroup", {
                orientation: st.gC,
                alignment: new De.S(0.5, 0.5),
                spacing: new De.S(5, 0),
              }),
              (this.iconReward = Be.createImageElement("spr_icon_coin_reward", {
                width: 50,
                height: 50,
              })),
              this.reward.addChild(this.iconReward),
              (this.iconReward.element.opacity = 0),
              (this.textReward = Be.createTextElement("font_rounded", {
                text: this.rewardValue,
                fontSize: 30,
                color: Te.I.WHITE,
              })),
              this.reward.addChild(this.textReward),
              (this.textReward.element.opacity = 0),
              this.addChild(this.reward);
          }
          _onClick() {
            (this.closeChest.enabled = !1),
              (this.openChest.enabled = !0),
              this.fire(Vi.Opened, this);
          }
          open() {
            this.openChest.setLocalScale(0.5, 0.5, 0.5),
              Pe.createScaleTween(
                this.openChest,
                { x: 1, y: 1 },
                { duration: 0.5, easing: Pe.Easing.Back.Out }
              ).start(),
              this.rewardType &&
                (Pe.createTween(
                  this.iconReward.element,
                  { opacity: 1 },
                  { duration: 0.5, delay: 0.25 }
                ).start(),
                this.textReward &&
                  Pe.createTween(
                    this.textReward.element,
                    { opacity: 1 },
                    { duration: 0.5, delay: 0.25 }
                  ).start());
          }
          set canOpen(S) {
            this.closeChest.element.useInput = S;
          }
        }
        const oi = Object.freeze({ LevelGroupCount: 4 }),
          ii = Object.freeze({
            Complete: "MainScreen:Complete",
            OpenSetting: "MainScreen:OpenSetting",
            OpenSelectingSkin: "MainScreen:OpenSelectingSkin",
          });
        class ln extends et {
          constructor() {
            super(a.SCREEN_MAIN);
          }
          create() {
            this._createFakeBackground(),
              this._createKeys(),
              this._createCoins(),
              this._createSettingButton(),
              this._createLevelInfo(),
              this._createSelectingSkinButton(),
              this._createTutorial(),
              this._createAnimations();
          }
          _createFakeBackground() {
            (this.fakeBackground = new o.J("fakeBackground")),
              this.fakeBackground.addComponent("element", {
                type: "image",
                anchor: new at.T(0, 0, 1, 1),
                color: new Te.I(0.5, 0.5, 0.5),
                opacity: 0,
              }),
              this.addChild(this.fakeBackground),
              ke.registerOnTouch(
                this.fakeBackground.element,
                this._onTapBackground,
                this
              );
          }
          _onTapBackground() {
            this.fire(ii.Complete);
          }
          _createKeys() {
            (this.keyBackground = new o.J("keyBackground")),
              this.keyBackground.addComponent("element", {
                type: "image",
                anchor: new at.T(0, 1, 0, 1),
                pivot: new De.S(0, 1),
                width: 150,
                height: 50,
                color: new Te.I(0.5, 0.5, 0.5),
                opacity: 0.7,
              }),
              this.keyBackground.setLocalPosition(10, -20, 0),
              this.addChild(this.keyBackground),
              (this.keyGroup = Be.createGroupElement()),
              this.keyGroup.addComponent("layoutgroup", {
                orientation: st.gC,
                alignment: new De.S(0.5, 0.5),
                spacing: new De.S(10, 0),
              }),
              this.keyBackground.addChild(this.keyGroup),
              (this.keys = []);
            for (let S = 0; S < a.TOTAL_KEY_TO_COLLECT; S++) {
              let D = Be.createImageElement("spr_icon_key", { scale: 0.8 });
              this.keys.push(D), this.keyGroup.addChild(D);
            }
          }
          updateKeys(S) {
            S > a.TOTAL_KEY_TO_COLLECT && (S = a.TOTAL_KEY_TO_COLLECT);
            for (let D = 0; D < this.keys.length; D++) {
              let le = this.keys[D];
              D < S
                ? (le.element.textureAsset = n.find("spr_icon_key"))
                : (le.element.textureAsset = n.find("spr_icon_key_gray"));
            }
          }
          _createCoins() {
            (this.coinBackground = new o.J("coinBackground")),
              this.coinBackground.addComponent("element", {
                type: "image",
                anchor: new at.T(1, 1, 1, 1),
                pivot: new De.S(1, 1),
                width: 130,
                height: 50,
                color: new Te.I(0.5, 0.5, 0.5),
                opacity: 0.7,
              }),
              this.coinBackground.setLocalPosition(-10, -20, 0),
              this.addChild(this.coinBackground),
              (this.coinIcon = Be.createImageElement("spr_icon_coin_reward", {
                anchor: new at.T(1, 0.5, 1, 0.5),
                pivot: new De.S(1, 0.5),
                x: -10,
                scale: 0.8,
              })),
              this.coinBackground.addChild(this.coinIcon),
              (this.coinText = Be.createTextElement("font_rounded", {
                anchor: new at.T(1, 0.5, 1, 0.5),
                pivot: new De.S(1, 0.5),
                text: "0",
                fontSize: 46,
                color: Te.I.WHITE,
                x: -80,
                y: -5,
              })),
              (this.coinText.element.autoWidth = !0),
              this.coinBackground.addChild(this.coinText);
          }
          updateCoins(S) {
            (this.coinText.element.text = S),
              (this.coinBackground.element.width =
                this.coinText.element.width + 90);
          }
          _createLevelInfo() {
            (this.line = Be.createEmptyImageElement({
              anchor: new at.T(0.5, 0.8, 0.5, 0.8),
              pivot: new De.S(0.5, 0.5),
              height: 20,
              width: 250,
              color: new Te.I(0.5, 0.5, 0.5),
              y: 80,
            })),
              this.addChild(this.line),
              (this.levelGroup = Be.createGroupElement()),
              this.levelGroup.addComponent("layoutgroup", {
                orientation: st.gC,
                alignment: new De.S(0.5, 0.5),
                spacing: new De.S(50, 0),
              }),
              this.line.addChild(this.levelGroup),
              (this.levelElements = []);
            for (let S = 0; S < oi.LevelGroupCount; S++) {
              let D = new Es();
              this.levelElements.push(D), this.levelGroup.addChild(D);
            }
            (this.levelText = Be.createTextElement("font_rounded", {
              anchor: new at.T(0.5, 0.8, 0.5, 0.8),
              pivot: new De.S(0.5, 0.5),
              text: "Level 1",
              y: 150,
              fontSize: 52,
              color: Te.I.WHITE,
            })),
              (this.levelText.element.outlineColor = Te.I.BLACK),
              (this.levelText.element.outlineThickness = 0.6),
              this.addChild(this.levelText);
          }
          updateLevelInfo(S) {
            let D =
                Math.floor((S - 1) / oi.LevelGroupCount) * oi.LevelGroupCount,
              le = D + oi.LevelGroupCount;
            for (let Ce = D; Ce < le; Ce++) {
              let Ue = this.levelElements[Ce % oi.LevelGroupCount];
              Ue.setText(Ce + 1),
                Ce < S - 1
                  ? Ue.setFrame(ls.Passed)
                  : Ce === S - 1
                  ? Ue.setFrame(ls.Current)
                  : Ue.setFrame(ls.Locked),
                Ce === le - 1 && Ue.setFrame(ls.EndInGroup);
            }
            this.levelText.element.text = `Level ${S}`;
          }
          _createTutorial() {
            (this.tutorialBackground = new o.J("tutorialBackground")),
              this.tutorialBackground.addComponent("element", {
                type: "image",
                anchor: new at.T(0, 0.25, 1, 0.25),
                pivot: new De.S(0.5, 0.5),
                height: 150,
                textureAsset: n.find("spr_frame_tutorial"),
              }),
              this.addChild(this.tutorialBackground),
              (this.textTutorial = Be.createImageElement("spr_text_tutorial", {
                scale: 1.2,
              })),
              this.tutorialBackground.addChild(this.textTutorial);
          }
          _createSettingButton() {
            (this.settingButton = Be.createButtonElement("spr_icon_setting", {
              anchor: new at.T(1, 0, 1, 0),
              pivot: new De.S(1, 0),
              x: -10,
              y: 10,
            })),
              this.addChild(this.settingButton),
              this.settingButton.button.on("click", this._onTapSetting, this);
          }
          _onTapSetting() {
            this.fire(ii.OpenSetting), f.play("sfx_click", 1, !1);
          }
          _createSelectingSkinButton() {
            (this.selectingSkinButton = Be.createButtonElement(
              "spr_icon_ball_select",
              {
                anchor: new at.T(1, 0.5, 1, 0.5),
                pivot: new De.S(1, 0.5),
                x: -10,
              }
            )),
              this.addChild(this.selectingSkinButton),
              this.selectingSkinButton.button.on(
                "click",
                this._onTapSelectingSkin,
                this
              );
          }
          _onTapSelectingSkin() {
            this.fire(ii.OpenSelectingSkin), f.play("sfx_click", 1, !1);
          }
          _createAnimations() {
            this._appearAnimations = [];
            let S = { duration: 0.5, easing: Pe.Easing.Back.Out };
            this._appearAnimations.push(
              vt.createTransitionAppearTween(this.line, pt.TopToBottom, S)
            ),
              this._appearAnimations.push(
                vt.createTransitionAppearTween(
                  this.levelGroup,
                  pt.TopToBottom,
                  S
                )
              ),
              this._appearAnimations.push(
                vt.createTransitionAppearTween(
                  this.levelText,
                  pt.TopToBottom,
                  S
                )
              ),
              this._appearAnimations.push(
                vt.createTransitionAppearTween(
                  this.coinBackground,
                  pt.TopToBottom,
                  S
                )
              ),
              this._appearAnimations.push(
                vt.createTransitionAppearTween(
                  this.keyBackground,
                  pt.TopToBottom,
                  S
                )
              ),
              this._appearAnimations.push(
                vt.createTransitionAppearTween(
                  this.settingButton,
                  pt.RightToLeft,
                  S
                )
              ),
              this._appearAnimations.push(
                vt.createTransitionAppearTween(
                  this.selectingSkinButton,
                  pt.RightToLeft,
                  S
                )
              ),
              this._appearAnimations.push(
                vt.createTransitionAppearTween(
                  this.tutorialBackground,
                  pt.BottomToTop,
                  S
                )
              );
          }
          onEnable() {
            var S;
            (S = this._disappearAnimations) == null ||
              S.forEach((D) => D.stop()),
              this._appearAnimations.forEach((D) => D.start());
          }
        }
        const li = Object.freeze({
          ContinueButtonClicked: "LoseScreen:ContinueButtonClicked",
          RespawnGame: "LoseScreen:RespawnGame",
        });
        class hn extends et {
          constructor() {
            super(a.SCREEN_LOSE),
              (this.isRewardAdsReady = !1),
              this._initBackground(),
              this._initLogo(),
              this._initButton(),
              this._createButtonRewardAds(),
              this.resize();
          }
          resize() {
            this.logo.setLocalPosition(0, 400, 0),
              this.logo.setLocalScale(2, 2, 2),
              this.buttonContinue.setLocalPosition(0, -400, 0),
              this.buttonContinue.setLocalScale(2, 2, 2),
              $t.width >= $t.height
                ? (this.logo.setLocalScale(1, 1, 1),
                  this.logo.setLocalPosition(0, 200, 0),
                  this.buttonContinue.setLocalPosition(0, -100, 0),
                  this.buttonContinue.setLocalScale(1, 1, 1),
                  this.rewardButton.setLocalScale(0.7, 0.7, 0.7),
                  this.rewardButton.setLocalPosition(0, -300, 0))
                : (this.buttonContinue.setLocalPosition(0, -200, 0),
                  this.buttonContinue.setLocalScale(1.5, 1.5, 1.5),
                  this.rewardButton.setLocalScale(1, 1, 1),
                  this.rewardButton.setLocalPosition(0, -550, 0));
          }
          _initBackground() {
            let S = ke.createColor(0, 0, 0);
            (this.bg = Be.createColorBackground(S)),
              (this.bg.element.opacity = 0.5),
              this.addChild(this.bg);
          }
          _initLogo() {
            (this.logo = Be.createImageElement("spr_frame_lv_false", {
              pivot: new De.S(0.5, 0.5),
              anchor: new at.T(0.5, 0.5, 0.5, 0.5),
            })),
              this.addChild(this.logo);
          }
          _initButton() {
            (this.buttonContinue = Be.createButtonElement(
              "spr_frame_continue",
              {
                pivot: new De.S(0.5, 0.5),
                anchor: new at.T(0.5, 0.5, 0.5, 0.5),
              }
            )),
              this.addChild(this.buttonContinue),
              ke.registerOnTouch(
                this.buttonContinue.element,
                this._onContinue,
                this
              );
          }
          _onContinue() {
            this.fire(li.ContinueButtonClicked), f.play("sfx_click");
          }
          _createButtonRewardAds() {
            (this.rewardButton = Be.createButtonElement(
              "spr_button_reward_ads_ball",
              {
                anchor: new at.T(0.5, 0.5, 0.5, 0.5),
                pivot: new De.S(0.5, 0.5),
                y: -500,
                x: 0,
                scale: 1,
              }
            )),
              this.rewardButton.button.on(
                "click",
                this._onButtonRewardAdsClick,
                this
              ),
              this.addChild(this.rewardButton);
            let S = Be.createTextElement("font_rounded", {
              anchor: new at.T(1, 0.5, 1, 0.5),
              pivot: new De.S(1, 0.5),
              text: "+3 balls",
              fontSize: 46,
              color: Te.I.WHITE,
              x: -110,
              y: 0,
            });
            this.rewardButton.addChild(S);
          }
          _onButtonRewardAdsClick() {
            this.isShowingRewardAds ||
              (f.play("sfx_click"),
              (this.isShowingRewardAds = !0),
              ps.showRewardAds((S) => {
                if (((this.isShowingRewardAds = !1), S))
                  console.warn(S), alert(S);
                else {
                  let D = ct.instance.getInt(a.STORAGE_KEY_LIFE);
                  (D = 3),
                    ct.instance.setValue(a.STORAGE_KEY_LIFE, D),
                    this.fire(li.RespawnGame, D);
                }
                this.checkIsRewardAdsReady();
              }));
          }
          checkIsRewardAdsReady() {
            (this.rewardButton.enabled = !1),
              (this.checkRewardAdsIntervalID = setInterval(() => {
                ps.checkIsRewardAdsReady((S) => {
                  console.log("Reward ads ready", S),
                    (this.rewardButton.enabled = S),
                    S && clearInterval(this.checkRewardAdsIntervalID);
                });
              }, 1e3));
          }
          onEnable() {
            this.checkIsRewardAdsReady();
          }
        }
        class cn extends o.J {
          constructor() {
            super("ballSelection"),
              (this.nextSkinPosition = new i.A(5, 0, 0)),
              (this.previousSkinPosition = new i.A(-5, 0, 0)),
              (this.currentSkinPosition = new i.A(0, 0, 0)),
              this._init(),
              (this.enabled = !1);
          }
          _init() {
            (this.skins = []),
              (this.currentSkinName = ct.instance.getString(
                a.STORAGE_KEY_SKIN,
                a.INIT_SKIN
              )),
              (this.currentSkinIndex = -1),
              he.forEach((S, D) => {
                let le = n.find(S.name).resource.clone();
                (le.data = S),
                  (le.rotateTween = Pe.createRotateTween(
                    le,
                    { x: 0, y: 360, z: 0 },
                    { duration: 5, loop: !0 }
                  )),
                  this.skins.push(le),
                  this.addChild(le),
                  (le.enabled = !1),
                  S.name === this.currentSkinName &&
                    ((this.currentSkinIndex = D),
                    (this.currentSkin = le),
                    (le.enabled = !0),
                    le.setLocalPosition(this.currentSkinPosition));
              });
          }
          nexSkin() {
            this.currentSkinTween && this.currentSkinTween.stop(),
              this.nexSkinTween && this.nexSkinTween.stop();
            let S = this.skins[this.currentSkinIndex];
            (this.currentSkinIndex =
              (this.currentSkinIndex + 1) % this.skins.length),
              (this.currentSkinTween = Pe.createLocalTranslateTween(
                this.currentSkin,
                this.previousSkinPosition,
                {
                  duration: 0.2,
                  onComplete: () => {
                    (S.enabled = !1), S.rotateTween.stop();
                  },
                  onStop: () => {
                    S.rotateTween.stop(), (S.enabled = !1);
                  },
                }
              ).start()),
              (this.currentSkin = this.skins[this.currentSkinIndex]),
              (this.currentSkin.enabled = !0),
              this.currentSkin.rotateTween.start(),
              (this.nexSkinTween = this.currentSkin.setLocalPosition(
                this.nextSkinPosition
              )),
              Pe.createLocalTranslateTween(
                this.currentSkin,
                this.currentSkinPosition,
                { duration: 0.2 }
              ).start();
          }
          previousSkin() {
            this.currentSkinTween && this.currentSkinTween.stop(),
              this.previousSkinTween && this.previousSkinTween.stop(),
              (this.currentSkinIndex =
                (this.currentSkinIndex - 1 + this.skins.length) %
                this.skins.length);
            let S = this.currentSkin;
            (this.currentSkinTween = Pe.createLocalTranslateTween(
              S,
              this.nextSkinPosition,
              {
                duration: 0.2,
                onComplete: () => {
                  (S.enabled = !1), S.rotateTween.stop();
                },
                onStop: () => {
                  S.rotateTween.stop(), (S.enabled = !1);
                },
              }
            ).start()),
              (this.currentSkin = this.skins[this.currentSkinIndex]),
              (this.currentSkin.enabled = !0),
              (this.previousSkinTween = this.currentSkin.setLocalPosition(
                this.previousSkinPosition
              )),
              this.currentSkin.rotateTween.start(),
              Pe.createLocalTranslateTween(
                this.currentSkin,
                this.currentSkinPosition,
                { duration: 0.2 }
              ).start();
          }
          onBoughtFail() {
            this.shakeTween && this.shakeTween.stop(),
              (this.shakeTween = Pe.createShakeTween(
                this.currentSkin,
                new i.A(0.2, 0, 0),
                0.05
              )),
              this.shakeTween.start();
          }
        }
        const Ls = Object.freeze({
          Complete: "SkinSelection:Complete",
          NextSkin: "SkinSelection:NextSkin",
          PreviousSkin: "SkinSelection:PreviousSkin",
          SelectSkin: "SkinSelection:SelectSkin",
          BoughtFailed: "SkinSelection:BoughtFailed",
        });
        class xn extends et {
          constructor() {
            super(a.SCREEN_SKIN_SELECTION), (this.isRewardAdsReady = !1);
          }
          create() {
            this._createButton(),
              this._createCenterButton(),
              this._createAnimations(),
              this._createCoins(),
              this._createButtonRewardAds();
          }
          _createCoins() {
            (this.coinBackground = new o.J("coinBackground")),
              this.coinBackground.addComponent("element", {
                type: "image",
                anchor: new at.T(1, 1, 1, 1),
                pivot: new De.S(1, 1),
                width: 130,
                height: 50,
                color: new Te.I(0.5, 0.5, 0.5),
                opacity: 0.7,
              }),
              this.coinBackground.setLocalPosition(-10, -20, 0),
              this.addChild(this.coinBackground),
              (this.coinIcon = Be.createImageElement("spr_icon_coin_reward", {
                anchor: new at.T(1, 0.5, 1, 0.5),
                pivot: new De.S(1, 0.5),
                x: -10,
                scale: 0.8,
              })),
              this.coinBackground.addChild(this.coinIcon),
              (this.coinText = Be.createTextElement("font_rounded", {
                anchor: new at.T(1, 0.5, 1, 0.5),
                pivot: new De.S(1, 0.5),
                text: "0",
                fontSize: 46,
                color: Te.I.WHITE,
                x: -80,
                y: -5,
              })),
              (this.coinText.element.autoWidth = !0),
              this.coinBackground.addChild(this.coinText);
          }
          updateCoins(S) {
            (this.coinText.element.text = S),
              (this.coinBackground.element.width =
                this.coinText.element.width + 90);
          }
          _createButtonRewardAds() {
            (this.rewardButton = Be.createButtonElement(
              "spr_button_reward_ads",
              {
                anchor: new at.T(1, 1, 1, 1),
                pivot: new De.S(1, 0.5),
                y: -200,
                x: 10,
                scale: 1.2,
              }
            )),
              this.rewardButton.button.on(
                "click",
                this._onButtonRewardAdsClick,
                this
              ),
              this.addChild(this.rewardButton);
            let S = Be.createImageElement("spr_icon_coin_reward", {
              anchor: new at.T(1, 0.5, 1, 0.5),
              pivot: new De.S(1, 0.5),
              x: -20,
              scale: 0.8,
              y: -20,
            });
            this.rewardButton.addChild(S);
            let D = Be.createTextElement("font_rounded", {
              anchor: new at.T(1, 0.5, 1, 0.5),
              pivot: new De.S(1, 0.5),
              text: "+300",
              fontSize: 46,
              color: Te.I.WHITE,
              x: -90,
              y: -25,
            });
            (this.coinText.element.autoWidth = !0),
              this.rewardButton.addChild(D);
          }
          _createButton() {
            (this.leftButton = Be.createButtonElement("spr_icon_arrow", {
              anchor: new at.T(0, 0.5, 0, 0.5),
              x: 40,
            })),
              this.addChild(this.leftButton),
              this.leftButton.button.on(
                "click",
                this.fire.bind(this, Ls.PreviousSkin)
              ),
              (this.rightButton = Be.createButtonElement("spr_icon_arrow", {
                anchor: new at.T(1, 0.5, 1, 0.5),
                x: -40,
              })),
              this.addChild(this.rightButton),
              this.rightButton.setLocalScale(-1, 1, 1),
              this.rightButton.button.on(
                "click",
                this.fire.bind(this, Ls.NextSkin)
              ),
              (this.exitButton = Be.createButtonElement("spr_icon_back", {
                anchor: new at.T(0, 1, 0, 1),
                x: 40,
                y: -50,
              })),
              this.addChild(this.exitButton),
              this.exitButton.button.on(
                "click",
                this.fire.bind(this, Ls.Complete)
              );
          }
          _createCenterButton() {
            (this.centerButton = Be.createButtonElement("spr_frame_green", {
              y: -150,
            })),
              this.addChild(this.centerButton),
              (this.centerGroup = Be.createGroupElement({
                anchor: new at.T(0.5, 0.5, 0.5, 0.5),
              })),
              this.centerGroup.addComponent("layoutgroup", {
                orientation: st.Gh,
                alignment: new De.S(0.5, 0.5),
                spacing: new De.S(0, 10),
              }),
              this.centerButton.addChild(this.centerGroup),
              (this.centerButtonText = Be.createTextElement("font_rounded", {
                text: "Selected",
                anchor: new at.T(0.5, 0.5, 0.5, 0.5),
                fontSize: 46,
                color: Te.I.WHITE,
              })),
              this.centerGroup.addChild(this.centerButtonText),
              (this.centerButtonText.element.autoWidth = !0),
              (this.centerButtonText.element.outlineColor = new Te.I(
                13 / 255,
                160 / 255,
                0
              )),
              (this.centerButtonText.element.outlineThickness = 0.6),
              (this.priceGroup = Be.createGroupElement({
                anchor: new at.T(0.5, 0.5, 0.5, 0.5),
              })),
              this.priceGroup.addComponent("layoutgroup", {
                orientation: st.gC,
                alignment: new De.S(0.5, 0.5),
                spacing: new De.S(10, 0),
              }),
              this.centerGroup.addChild(this.priceGroup),
              (this.priceText = Be.createTextElement("font_rounded", {
                text: "1000",
                anchor: new at.T(0.5, 0.5, 0.5, 0.5),
                fontSize: 46,
                color: Te.I.WHITE,
              })),
              this.priceGroup.addChild(this.priceText),
              (this.priceText.element.autoWidth = !0),
              (this.priceText.element.outlineColor = new Te.I(
                13 / 255,
                160 / 255,
                0
              )),
              (this.priceText.element.outlineThickness = 0.6),
              (this.priceIcon = Be.createImageElement("spr_icon_coin_reward", {
                anchor: new at.T(0.5, 0.5, 0.5, 0.5),
                pivot: new De.S(0.5, 0.5),
                scale: 0.8,
              })),
              this.priceGroup.addChild(this.priceIcon),
              (this.priceGroup.enabled = !1);
          }
          changeCenterButtonText(S) {
            (this.centerButtonText.element.text = S),
              (this.priceGroup.enabled = !1);
          }
          changeCenterButtonPrice(S) {
            (this.centerButtonText.element.text = "Unlock"),
              (this.priceText.element.text = S),
              (this.priceGroup.enabled = !0);
          }
          updateSkinInfo(S) {
            let le =
                ct.instance
                  .getString(a.STORAGE_KEY_UNLOCKED_SKIN)
                  .split(",")
                  .indexOf(S.name) !== -1 || S.name === a.INIT_SKIN,
              Ce = ct.instance.getString(a.STORAGE_KEY_SKIN, a.INIT_SKIN);
            this.centerButton.button.off("click"),
              S.name === Ce
                ? this.changeCenterButtonText("Selected")
                : le
                ? (this.changeCenterButtonText("Select"),
                  this.centerButton.button.on(
                    "click",
                    this._selectSkin.bind(this, S)
                  ),
                  f.play("sfx_click"))
                : (this.changeCenterButtonPrice(S.price),
                  this.centerButton.button.on(
                    "click",
                    this._unlockSkin.bind(this, S)
                  ),
                  f.play("sfx_click"));
          }
          _selectSkin(S) {
            this.changeCenterButtonText("Selected"),
              this.fire(Ls.SelectSkin, S);
          }
          _unlockSkin(S) {
            let D = ct.instance.getInt(a.STORAGE_KEY_COIN);
            if (D >= S.price) {
              this.changeCenterButtonText("Selected"),
                this.fire(Ls.SelectSkin, S),
                (D -= S.price),
                ct.instance.setValue(a.STORAGE_KEY_COIN, D),
                this.updateCoins(D);
              let le = ct.instance.getString(a.STORAGE_KEY_UNLOCKED_SKIN);
              (le += `,${S.name}`),
                (le = le.replace(/^,/, "")),
                ct.instance.setValue(a.STORAGE_KEY_UNLOCKED_SKIN, le);
            } else this.fire(Ls.BoughtFailed);
          }
          _createAnimations() {
            this._appearAnimations = [];
            let S = { duration: 0.5, easing: Pe.Easing.Back.Out };
            this._appearAnimations.push(
              vt.createTransitionAppearTween(this.leftButton, pt.LeftToRight, S)
            ),
              this._appearAnimations.push(
                vt.createTransitionAppearTween(
                  this.rightButton,
                  pt.RightToLeft,
                  S
                )
              ),
              this._appearAnimations.push(
                vt.createTransitionAppearTween(
                  this.exitButton,
                  pt.TopToBottom,
                  S
                )
              );
          }
          onEnable() {
            this._appearAnimations.forEach((S) => {
              S.start();
            }),
              this.checkIsRewardAdsReady();
          }
          checkIsRewardAdsReady() {
            (this.rewardButton.enabled = !1),
              (this.checkRewardAdsIntervalID = setInterval(() => {
                ps.checkIsRewardAdsReady((S) => {
                  console.log("Reward ads ready", S),
                    (this.rewardButton.enabled = S),
                    S && clearInterval(this.checkRewardAdsIntervalID);
                });
              }, 1e3));
          }
          _onButtonRewardAdsClick() {
            this.isShowingRewardAds ||
              (f.play("sfx_click"),
              (this.isShowingRewardAds = !0),
              ps.showRewardAds((S) => {
                if (((this.isShowingRewardAds = !1), S))
                  console.warn(S), alert(S);
                else {
                  let D = ct.instance.getInt(a.STORAGE_KEY_COIN);
                  (D += 300),
                    ct.instance.setValue(a.STORAGE_KEY_COIN, D),
                    this.updateCoins(D);
                }
                this.checkIsRewardAdsReady();
              }));
          }
        }
        class wi extends o.J {
          static playAt(S) {
            this._spawner || this._createPool();
            let D = this._spawner.spawn();
            return D.setPosition(S), D.play(), D;
          }
          static _createPool() {
            let S = new o.J("spawner_bulletHitEffect");
            (this._spawner = S.addScript(ts, { class: wi, poolSize: 10 })),
              $t.app.root.addChild(S);
          }
          constructor() {
            super("fx_finish"),
              (this.numParticles = 100),
              (this.particles = []),
              this._initAsset(),
              this._configParticle(),
              this._initParticle(),
              $t.app.root.addChild(this);
          }
          _initAsset() {
            (this.texture = n.find("tex_particle").resource),
              (this.renderAsset = n.find("model_plane"));
          }
          _configParticle() {
            (this.velocityGraph1 = new We.e([
              [0, 3, 0.5, 1.5, 1, 1],
              [0, 12, 0.5, -8, 1, -10],
              [0, -5, -0.5, 0.5, 1, -2],
            ])),
              (this.velocityGraph2 = new We.e([
                [0, 5, 0.5, 3, 1, 2],
                [0, 27, 0.5, -4, 1, -6],
                [0, 5, -0.5, 2, 1, 2],
              ])),
              (this.scaleGraph = new ft.H([0, 0.08])),
              (this.scaleGraph2 = new ft.H([0, 0.12])),
              (this.rotationSpeedGraph = new ft.H([0, 500, 0.5, 500, 1, 300])),
              (this.emitterExtents = [6, 3, 5]);
          }
          _createParticle(S) {
            let D = new o.J();
            return (
              this.addChild(D),
              D.addComponent("particlesystem", {
                autoPlay: !1,
                loop: !1,
                lifetime: 3,
                numParticles: this.numParticles,
                rate: 0.001,
                rate2: 0.005,
                colorMap: this.texture,
                blend: st.Yk,
                mesh: this.renderAsset,
                animNumAnimations: 4,
                animNumFrames: 1,
                randomizeAnimIndex: !0,
                animLoop: !0,
                animSpeed: 1,
                startAngle: 0,
                startAngle2: 0,
                colorGraph: S,
                scaleGraph: this.scaleGraph,
                scaleGraph2: this.scaleGraph2,
                localVelocityGraph: this.velocityGraph1,
                localVelocityGraph2: this.velocityGraph2,
                rotationSpeedGraph: this.rotationSpeedGraph,
                emitterExtents: this.emitterExtents,
              }),
              D
            );
          }
          _initParticle() {
            (this.particleBlue = this._createParticle(
              new We.e([
                [0, 108 / 255],
                [0, 211 / 255],
                [0, 1],
              ])
            )),
              (this.particleGreen = this._createParticle(
                new We.e([
                  [0, 0],
                  [0, 1],
                  [0, 0],
                ])
              )),
              (this.particleOrange = this._createParticle(
                new We.e([
                  [0, 255 / 255],
                  [0, 140 / 255],
                  [0, 0],
                ])
              )),
              (this.particlePink = this._createParticle(
                new We.e([
                  [0, 215 / 255],
                  [0, 100 / 255],
                  [0, 199 / 255],
                ])
              )),
              this.particles.push(
                this.particleBlue,
                this.particleGreen,
                this.particleOrange,
                this.particlePink
              );
          }
          play() {
            this.particles.forEach((S) => {
              S.particlesystem.reset(), S.particlesystem.play();
            }),
              Pe.createCountTween({
                duration: 0.5,
                onComplete: () => {
                  this.fire(bt.Despawn);
                },
              });
          }
        }
        class An extends Kt.e {
          constructor(S = {}) {
            super(S),
              (this.target = S.target || void 0),
              (this.offset = S.offset || new i.A(0, 5, -10)),
              (this.speed = S.speed || 0.99),
              (this.alwaysBehind = S.alwaysBehind || !1);
          }
          initialize() {
            (this.targetPos = new i.A()),
              (this.matrix = new e.y()),
              (this.quat = new Ne.D()),
              (this.vec = new i.A()),
              (this._targetEuler = new i.A()),
              this.target
                ? (this.updateTargetPosition(),
                  (this.currentPos = this.targetPos.clone()))
                : (this.currentPos = this.entity.getPosition().clone());
          }
          updateTargetPosition() {
            this.alwaysBehind &&
              (this._targetEuler.copy(this.target.getEulerAngles()),
              this.quat.setFromEulerAngles(this._targetEuler)),
              this.matrix.setTRS(this.target.getPosition(), this.quat, i.A.ONE),
              this.matrix.transformPoint(this.offset, this.targetPos);
          }
          postUpdate(S) {
            if (this.isTeleporting) {
              this.isTeleporting = !1;
              return;
            }
            this.target &&
              (this.updateTargetPosition(),
              this.currentPos.lerp(
                this.currentPos,
                this.targetPos,
                this.speed * S
              ),
              this.entity.setPosition(this.currentPos),
              this.entity.lookAt(this.target.getPosition()));
          }
          teleportToTarget() {
            this.updateTargetPosition(),
              this.currentPos.copy(this.targetPos),
              this.entity.setPosition(this.currentPos),
              this.entity.lookAt(this.target.getPosition()),
              (this.isTeleporting = !0);
          }
        }
        const _n = { ValueChanged: "SwitchElement:ValueChanged" };
        class Cn extends o.J {
          constructor(
            S,
            D = "spr_switch_inactive",
            le = "spr_switch_active",
            Ce = "spr_circle_white"
          ) {
            super("switchElement"),
              (this.key = S),
              (this.inactiveTextureName = D),
              (this.activeTextureName = le),
              (this.controlTextureName = Ce),
              (this._value = !1);
            let Ue = n.find(this.inactiveTextureName),
              rt = Ue.resource.width * 0.45,
              Je = Ue.resource.height * 0.45;
            this.addComponent("element", {
              anchor: new at.T(0.5, 0.5, 0.5, 0.5),
              pivot: new De.S(0.5, 0.5),
              type: "image",
              textureAsset: Ue,
              useInput: !0,
              width: rt,
              height: Je,
            }),
              this.element.on("mousedown", this._onClick, this),
              this.element.on("touchstart", this._onClick, this),
              (this.controlPivot = new De.S(1, 0.5)),
              (this.control = Be.createImageElement(this.controlTextureName, {
                y: 2,
                scale: 0.4,
                pivot: this.controlPivot,
              })),
              this.addChild(this.control),
              (this.toggleOnTween = Pe.createTween(
                { x: 1 },
                { x: 0 },
                {
                  duration: 0.2,
                  easing: Pe.Easing.Circular.Out,
                  onUpdate: (St) => {
                    (this.controlPivot.x = St.x),
                      (this.control.element.pivot = this.controlPivot);
                  },
                  onComplete: () => {
                    this.element.textureAsset = n.find(this.activeTextureName);
                  },
                }
              )),
              (this.toggleOffTween = Pe.createTween(
                { x: 0 },
                { x: 1 },
                {
                  duration: 0.2,
                  easing: Pe.Easing.Circular.Out,
                  onUpdate: (St) => {
                    (this.controlPivot.x = St.x),
                      (this.control.element.pivot = this.controlPivot);
                  },
                  onComplete: () => {
                    this.element.textureAsset = n.find(
                      this.inactiveTextureName
                    );
                  },
                }
              ));
          }
          _onClick() {
            this.toggleOffTween.stop(),
              this.toggleOnTween.stop(),
              this._value
                ? this.toggleOffTween.start()
                : this.toggleOnTween.start(),
              (this._value = !this._value),
              this.fire(_n.ValueChanged, this.key, this._value);
          }
          get value() {
            return this._value;
          }
          set value(S) {
            this._value !== S && this._onClick();
          }
        }
        const mn = Object.freeze({ Complete: "SettingScreen:Complete" });
        class gi extends et {
          constructor() {
            super(a.SCREEN_SETTING);
          }
          create() {
            this._createBackground(),
              this._createControls(),
              this._createContinueButton(),
              this._createVersion(),
              this._createAnimations();
          }
          _createBackground() {
            (this.background = Be.createImageElement("spr_frame_setting", {
              scale: 0.9,
            })),
              this.addChild(this.background),
              (this.label = Be.createTextElement("font_rounded", {
                anchor: new at.T(0.5, 1, 0.5, 1),
                pivot: new De.S(0.5, 1),
                fontSize: 65,
                text: "Setting",
                color: Te.I.WHITE,
                y: -50,
              })),
              this.background.addChild(this.label);
          }
          _createContinueButton() {
            var S;
            (this.continueButton = Be.createButtonElement(
              "spr_button_continue",
              {
                anchor: new at.T(0.5, 0, 0.5, 0),
                pivot: new De.S(0.5, 0),
                y: 50,
                scale: 0.8,
              }
            )),
              this.background.addChild(this.continueButton),
              (S = this.continueButton) == null ||
                S.button.once("click", this._onContinue, this);
          }
          _createControls() {
            (this.controlGroup = Be.createGroupElement()),
              this.background.addChild(this.controlGroup),
              this.controlGroup.addComponent("layoutgroup", {
                orientation: st.Gh,
                padding: new at.T(150, 0, 0, 0),
                spacing: new De.S(0, 50),
                alignment: new De.S(0, 0),
              }),
              this._createSwitch("Music", "music"),
              this._createSwitch("Sound", "sound"),
              this._createSwitch("Vibration", "vibration");
          }
          _createVersion() {
            let S = Be.createTextElement("font_rounded", {
              anchor: new at.T(0.5, 1, 0.5, 1),
              pivot: new De.S(0.5, 1),
              fontSize: 20,
              text: "Version 1.0.0#973452",
              color: Te.I.WHITE,
              y: -130,
              opacity: 0.5,
            });
            this.background.addChild(S);
          }
          _createSwitch(S, D) {
            let le = Be.createGroupElement();
            this.controlGroup.addChild(le),
              le.addComponent("layoutgroup", {
                orientation: st.gC,
                spacing: new De.S(40, 0),
                alignment: new De.S(1, 0.5),
              });
            let Ce = Be.createTextElement("font_rounded", {
              text: S,
              fontSize: 50,
              color: Te.I.WHITE,
            });
            le.addChild(Ce);
            let Ue = new Cn(D);
            le.addChild(Ue),
              Ue.on(_n.ValueChanged, this._onSwitchChanged, this),
              (Ue.value = h.get(D));
          }
          _onSwitchChanged(S, D) {
            h.set(S, D);
          }
          onEnable() {
            var S;
            $t.pause(),
              (S = this.continueButton) == null ||
                S.button.once("click", this._onContinue, this),
              this._appearAnimation.start();
          }
          onDisable() {
            var S;
            (S = this.continueButton) == null ||
              S.button.off("click", this._onContinue, this);
          }
          _onContinue() {
            $t.resume(), this.fire(mn.Complete);
          }
          _createAnimations() {
            this._appearAnimation = Pe.createTween(
              { x: 0, y: 0, z: 0 },
              { x: 1, y: 1, z: 1 },
              {
                duration: 0.5,
                easing: Pe.Easing.Back.Out,
                onUpdate: (S) => {
                  this.background.setLocalScale(S.x, S.y, S.z);
                },
              }
            );
          }
        }
        class Pn extends Ve {
          constructor() {
            super(a.SCENE_PLAY);
          }
          create() {
            super.create(),
              this._initUI(),
              this._initLight(),
              this._initGameplay(),
              this._initSkinSelection();
          }
          _onStart() {
            $t.resume(),
              (this.inputHandler.enabled = !0),
              (this.startPosition =
                this.levelManager.currentLevel.map.getPosition()),
              (this.targetPosition =
                this.levelManager.currentLevel.map.finish.getPosition()),
              (this.levelLength = this.startPosition.distance(
                this.targetPosition
              )),
              this.ui.disableAllScreens(),
              this.playScreen.setLevelText(
                this.levelManager.currentLevelIndex + 1
              ),
              this.ui.setScreenActive(a.SCREEN_PLAY);
          }
          pause() {
            var S;
            (S = this.gameManager) == null || S.pause();
          }
          resume() {
            var S;
            (S = this.gameManager) == null || S.resume();
          }
          _onLose() {
            $t.onLose(),
              (O.state = me.Lose),
              Pe.createCountTween({
                duration: 0.5,
                onComplete: () => {
                  this._showWinScreen();
                },
              }).start();
          }
          _onWin() {
            Pe.createCountTween({
              duration: 0.8,
              onComplete: () => {
                this._showWinScreen();
              },
            }).start();
          }
          _showLoseScreen() {
            this.ui.disableAllScreens(), this.ui.setScreenActive(a.SCREEN_LOSE);
          }
          _showWinScreen() {
            let S = `level_${this.levelManager.currentLevelIndex + 1}`,
              D = window.SDK_CONFIG;
            D != null && D.API_AWARDS[S] && ps.saveAchievement(D.API_AWARDS[S]),
              this.ui.disableAllScreens();
            let le = this.levelManager.currentLevelIndex + 1,
              Ce = ct.instance.getInt(a.STORAGE_KEY_COIN),
              Ue = ct.instance.getInt(a.STORAGE_KEY_KEY);
            this.winScreen.updateLevelInfo(le),
              this.winScreen.updateCoins(Ce),
              this.winScreen.updateKeys(Ue);
            let rt = Ss.instance.coinCount;
            this.winScreen.updateRewardCoin(rt),
              this.ui.setScreenActive(a.SCREEN_WIN);
          }
          _onWinScreenCompleted() {
            this._saveLevelReward(), this.levelManager.loadNextLevel();
          }
          _showChestScreen() {
            this.ui.disableAllScreens();
            let S = ct.instance
                .getString(a.STORAGE_KEY_UNLOCKED_SKIN)
                .split(","),
              D = he
                .map((Ce) => Ce.name)
                .filter((Ce) => S.indexOf(Ce) === -1 && Ce !== a.INIT_SKIN),
              le = "";
            D.length > 0 && (le = ke.randomFromList(D)),
              this.chestScreen.updateReward(10, 200, le),
              this.ui.setScreenActive(a.SCREEN_CHEST);
          }
          _showMainScreen() {
            this.ui.disableAllScreens(), this.ui.setScreenActive(a.SCREEN_MAIN);
            let S = this.levelManager.currentLevelIndex + 1,
              D = ct.instance.getInt(a.STORAGE_KEY_COIN),
              le = ct.instance.getInt(a.STORAGE_KEY_KEY);
            this.mainScreen.updateLevelInfo(S),
              this.mainScreen.updateCoins(D),
              this.mainScreen.updateKeys(le);
          }
          _initLight() {
            (this.directionalLight = new o.J("light-directional")),
              this.addChild(this.directionalLight),
              this.directionalLight.addComponent("light", {
                type: st.WQ,
                color: new Te.I(1, 1, 1),
                castShadows: !0,
                shadowDistance: 15,
                shadowResolution: 1024,
                shadowBias: 0.2,
                normalOffsetBias: 0.05,
                intensity: 1,
              }),
              this.directionalLight.setLocalPosition(2, 2, -2),
              this.directionalLight.setLocalEulerAngles(32.33, 27.44, -5.91);
          }
          _initUI() {
            this.ui.addScreens(
              new Yt(),
              new Ys(),
              new an(),
              new ln(),
              new hn(),
              new xn(),
              new gi()
            ),
              (this.playScreen = this.ui.getScreen(a.SCREEN_PLAY)),
              (this.winScreen = this.ui.getScreen(a.SCREEN_WIN)),
              (this.chestScreen = this.ui.getScreen(a.SCREEN_CHEST)),
              (this.mainScreen = this.ui.getScreen(a.SCREEN_MAIN)),
              (this.loseScreen = this.ui.getScreen(a.SCREEN_LOSE)),
              (this.skinSelectionScreen = this.ui.getScreen(
                a.SCREEN_SKIN_SELECTION
              )),
              (this.settingScreen = this.ui.getScreen(a.SCREEN_SETTING)),
              this.chestScreen.on(
                Gi.Complete,
                this._onChestScreenComplete,
                this
              ),
              this.loseScreen.on(
                li.ContinueButtonClicked,
                this._onLoseScreenComplete,
                this
              ),
              this.loseScreen.on(li.RespawnGame, this._onRespawn, this),
              this.mainScreen.on(ii.Complete, this._onStart, this),
              this.mainScreen.on(
                ii.OpenSelectingSkin,
                this._switchToSkinSelection,
                this
              ),
              this.skinSelectionScreen.on(
                Ls.NextSkin,
                this._selectNextSkin,
                this
              ),
              this.skinSelectionScreen.on(
                Ls.PreviousSkin,
                this._selectPreviousSkin,
                this
              ),
              this.skinSelectionScreen.on(
                Ls.SelectSkin,
                this._selectSkin,
                this
              ),
              this.skinSelectionScreen.on(
                Ls.Complete,
                this._onSelectSkinComplete,
                this
              ),
              this.mainScreen.on(ii.OpenSetting, this._showSettingScreen, this),
              this.playScreen.on(
                Fe.OpenPauseScreen,
                this._showSettingScreen,
                this
              ),
              this.settingScreen.on(
                mn.Complete,
                this._onSettingScreenComplete,
                this
              );
          }
          _initGameplay() {
            this._initInputHandler(),
              this._initBall(),
              this._initCamera(),
              this._initLevelManager(),
              this._cacheShaders();
          }
          _cacheShaders() {
            console.log("Caching shaders...");
            let S = Array.from(n.assets._assets).filter(
                (Bt) => Bt.type === "model"
              ),
              D = new o.J("cache");
            this.addChild(D);
            let le = new i.A(0, 2, 10);
            D.setLocalPosition(le);
            let Ce = -2;
            S.forEach((Bt) => {
              let Nt = new o.J(Bt.name);
              Nt.addComponent("model", {
                type: "asset",
                asset: Bt,
                castShadows: !1,
                receiveShadows: !1,
              }),
                Nt.setLocalScale(0.01, 0.01, 0.01),
                Nt.setLocalPosition(Ce, 0, 0),
                (Ce += 0.1),
                D.addChild(Nt);
            });
            let Ue = wi.playAt(le),
              rt = Qs.playAt(le),
              Je = Qt.playAt(le),
              St = new Ai({
                name: "collectable_ball",
                position: [0, 0, 5],
                eulerAngles: [0, 0, 0],
                scale: [1, 1, 1],
                model: "model_platform_life_bonus_001",
                materials: ["mat_items_001.json"],
              });
            D.addChild(St),
              setTimeout(() => {
                D.destroy(),
                  Ue.destroy(),
                  rt.destroy(),
                  Je.destroy(),
                  console.log("Caching shaders done!"),
                  setTimeout(() => {
                    $t.onReady();
                  }, 500);
              }, 10);
          }
          _initSkydome() {
            (this.skydome = Be.createModel(
              "model_skydome_001",
              "mat_skydome_001"
            )),
              this.skydome.setLocalScale(10, 10, 10),
              this.skydome.setLocalEulerAngles(170.25, 38.59, 173.75),
              this.addChild(this.skydome);
          }
          _initLevelManager() {
            (this.levelManager = new rn()),
              this.addChild(this.levelManager),
              this.levelManager.on(ki.LevelLoaded, this._onLevelLoaded, this),
              this.winScreen.on(
                ks.NextLevelButtonClicked,
                this._onWinScreenCompleted,
                this
              );
            let S = ct.instance.getInt(a.STORAGE_KEY_LEVEL);
            this.levelManager.loadLevel(S);
          }
          _onLoseScreenComplete() {
            this.levelManager.loadLevel(this.levelManager.currentLevelIndex),
              (this.ball.life = 1),
              ct.instance.setValue(a.STORAGE_KEY_LIFE, this.ball.life),
              this.playScreen.updateLife(this.ball.life);
          }
          _onSelectSkinComplete() {
            this.levelManager.loadLevel(this.levelManager.currentLevelIndex),
              (this.skinSelection.enabled = !1),
              this.ball.loadSkin(),
              (this.cameraFollowing.enabled = !0),
              this.playScreen.updateLife(this.ball.life),
              (this.disableSkinSelectionTween = Pe.createCountTween({
                duration: 1,
                onComplete: () => {
                  (this.ball.skin.enabled = !0),
                    (this.inputHandler.enabled = !0);
                },
              }).start());
          }
          _showSettingScreen() {
            (this.previousScreen = this.ui.getLastActiveScreen()),
              this.ui.disableAllScreens(),
              this.ui.setScreenActive(a.SCREEN_SETTING);
          }
          _onSettingScreenComplete() {
            this.ui.disableAllScreens(),
              this.ui.setScreenActive(this.previousScreen.key);
          }
          _onLevelLoaded(S) {
            this.finishEffectLeft &&
              this.finishEffectRight &&
              (this.finishEffectLeft.destroy(),
              this.finishEffectRight.destroy());
            let D = S.getPosition().clone().add(new i.A(0, 0.4, 0));
            this.ball.checkPoint.position.copy(D),
              this.ball.checkPoint.rotation.copy(S.getRotation()),
              this.ball.respawn(),
              this.cameraFollowing.teleportToTarget(),
              (this.ballController.enabled = !0),
              (this.ball.ballBody.enabled = !0),
              (this.cameraFollowing.enabled = !0),
              ct.instance.setValue(
                a.STORAGE_KEY_LEVEL,
                this.levelManager.currentLevelIndex
              ),
              this._showMainScreen(),
              this.winScreen.checkRewardAdsReady();
          }
          _initInputHandler() {
            let S = new o.J("input");
            (this.inputHandler = S.addScript(zt)),
              (this.inputHandler.enabled = !0),
              this.addChild(S);
          }
          _initGameManager() {
            let S = new o.J("game_manager");
            this.addChild(S),
              (this.gameManager = S.addScript(fs)),
              this.gameManager.on(
                qt.Start,
                this.inputHandler.enable,
                this.inputHandler
              ),
              this.gameManager.on(qt.Lose, this._onLose, this),
              this.gameManager.on(
                qt.Lose,
                this.inputHandler.disable,
                this.inputHandler
              ),
              this.gameManager.on(qt.Win, this._onWin, this),
              this.gameManager.on(
                qt.Win,
                this.inputHandler.disable,
                this.inputHandler
              );
          }
          _initCamera() {
            if (
              ((this.mainCamera = new o.J()),
              this.mainCamera.addComponent("camera", {
                clearColor: ke.createColor(0, 0, 0),
                nearClip: 2,
              }),
              this.addChild(this.mainCamera),
              this.mainCamera.setLocalPosition(0, 2, 10),
              (this.cameraFollowing = this.mainCamera.addScript(An, {
                attributes: {
                  target: this.ball.stableMovingBall,
                  offset: new i.A(0, 3, -7),
                  speed: a.CAMERA_FOLLOW_SPEED,
                  alwaysBehind: !0,
                },
              })),
              a.DEBUG_PHYSICS)
            ) {
              const S = new si({
                app: $t.app,
                limit: { entity: this.mainCamera, distance: 50 },
              });
              (S.enabled = !0), (S.mode = a.DEBUG_PHYSICS_MODE);
            }
          }
          _initBall() {
            let S = new ei();
            this.addChild(S),
              (this.ball = S),
              this.addChild(S.ballBody),
              this.addChild(S.stableMovingBall),
              this.playScreen.updateLife(this.ball.life),
              (this.swipeMovement = S.addScript(ti, {
                speed: 20,
                screenEntity: this.playScreen,
              })),
              (this.ballController = S.controller);
            let D = new Ne.D(),
              le = new i.A(0, 0, 0);
            S.on(Js.Move, (Ce, Ue) => {
              let rt = Math.atan2(Ce.x, Ce.z) * Ot.m.RAD_TO_DEG;
              rt = Math.abs(rt);
              let Je = Math.abs(1 - rt / 90);
              (Je = Math.max(0.4, Je)),
                (Ue *= Je),
                le.copy(this.ball.getPosition()),
                le.sub(this.mainCamera.getPosition());
              let St = Math.atan2(le.x, le.z) * Ot.m.RAD_TO_DEG;
              D.setFromEulerAngles(0, St, 0),
                (Ce = D.transformVector(Ce)),
                Ce.normalize(),
                this.ballController.applyForce(Ce, Ue);
            }),
              S.on(Ts.Dead, this._onBallDead, this),
              S.ballBody.on(Ts.Finish, this._onBallFinish, this),
              S.on(Ts.UpdateLife, this.playScreen.updateLife, this.playScreen),
              this.inputHandler.on(
                ss.PointerDown,
                this.swipeMovement.onPointerDown,
                this.swipeMovement
              ),
              this.inputHandler.on(
                ss.PointerMove,
                this.swipeMovement.onPointerMove,
                this.swipeMovement
              ),
              this.inputHandler.on(
                ss.PointerUp,
                this.swipeMovement.onPointerUp,
                this.swipeMovement
              );
          }
          _onBallDead() {
            this.ball.life--,
              this.playScreen.updateLife(this.ball.life),
              this.ball.life > 0
                ? (this.ball.respawn(),
                  this.cameraFollowing.teleportToTarget(),
                  this._showMainScreen())
                : ($t.pause(), this._showLoseScreen());
          }
          _onRespawn() {
            $t.resume(),
              (this.ball.life = ct.instance.getInt(a.STORAGE_KEY_LIFE)),
              this.playScreen.updateLife(this.ball.life),
              this.ball.respawn(),
              this.cameraFollowing.teleportToTarget(),
              this._showMainScreen();
          }
          _onBallFinish(S) {
            (this.inputHandler.enabled = !1),
              f.play("sfx_wingame"),
              this._onCollideFinishObject(S),
              Pe.createGlobalTranslateTween(
                this.ball,
                {
                  x: S.getPosition().x,
                  y: S.getPosition().y + 1.5,
                  z: S.getPosition().z - 0.55,
                },
                {
                  duration: 0.5,
                  onComplete: () => {
                    (this.ballController.enabled = !1),
                      (this.ball.ballBody.enabled = !1),
                      (this.cameraFollowing.enabled = !1);
                  },
                }
              ).start();
            let D = S.getPosition(),
              le = S.forward.clone(),
              Ce = D.clone();
            Ce.add(le.mulScalar(-20)),
              (Ce.y = D.y + 10),
              Pe.createGlobalTranslateTween(this.mainCamera, Ce, {
                duration: 0.5,
                onUpdate: () => {
                  this.mainCamera.lookAt(D);
                },
              }).start(),
              Pe.createCountTween({
                duration: 0.5,
                onComplete: this._levelComplete.bind(this),
              }).start(),
              this.ball.reset();
          }
          _onCollideFinishObject(S) {
            (this.finishEffectLeft = wi.playAt(S.getPosition())),
              (this.finishEffectRight = wi.playAt(S.getPosition())),
              this.finishEffectLeft.setLocalScale(1, 1, 1),
              this.finishEffectRight.setLocalScale(-1, 1, -1);
          }
          _levelComplete() {
            ct.instance.addInt(a.STORAGE_KEY_KEY, Ss.instance.keyCount) >=
            a.TOTAL_KEY_TO_COLLECT
              ? this._showChestScreen()
              : this._onWin();
          }
          _saveLevelReward() {
            let S = ct.instance;
            S.getInt(a.STORAGE_KEY_KEY) >= a.TOTAL_KEY_TO_COLLECT &&
              S.setValue(a.STORAGE_KEY_KEY, 0),
              S.addInt(a.STORAGE_KEY_COIN, Ss.instance.coinCount),
              S.setValue(a.STORAGE_KEY_LIFE, this.ball.life),
              Ss.instance.reset();
          }
          _onChestScreenComplete(S) {
            if (
              ((Ss.instance.coinCount += S.coin),
              ct.instance.getInt(a.STORAGE_KEY_KEY) >= a.TOTAL_KEY_TO_COLLECT &&
                ct.instance.setValue(a.STORAGE_KEY_KEY, 0),
              S.skin)
            ) {
              let le = ct.instance.getString(a.STORAGE_KEY_UNLOCKED_SKIN);
              (le += `,${S.skin}`),
                (le = le.replace(/^,/, "")),
                ct.instance.setValue(a.STORAGE_KEY_UNLOCKED_SKIN, le);
            }
            Pe.createCountTween({
              duration: 1,
              onComplete: this._showWinScreen.bind(this),
            }).start();
          }
          update() {
            if (
              this.startPosition &&
              this.targetPosition &&
              this.levelLength > 0
            ) {
              let S =
                1 -
                this.ball.getPosition().distance(this.targetPosition) /
                  this.levelLength;
              this.playScreen.setProgress(S);
            }
          }
          _initSkinSelection() {
            (this.skinSelection = new cn()),
              this.addChild(this.skinSelection),
              this.skinSelectionScreen.on(
                Ls.BoughtFailed,
                this.skinSelection.onBoughtFail,
                this.skinSelection
              ),
              (this.skinSelectionCameraPivot = new o.J(
                "skin_selection_camera_pivot"
              )),
              this.addChild(this.skinSelectionCameraPivot),
              (this.skinSelectionCameraPoint = new o.J(
                "skin_selection_camera_point"
              )),
              this.skinSelectionCameraPivot.addChild(
                this.skinSelectionCameraPoint
              ),
              this.skinSelectionCameraPoint.setLocalPosition(0, 1, -5);
          }
          _selectNextSkin() {
            this.skinSelection.nexSkin(),
              this.skinSelectionScreen.updateSkinInfo(
                this.skinSelection.currentSkin.data
              );
          }
          _selectPreviousSkin() {
            this.skinSelection.previousSkin(),
              this.skinSelectionScreen.updateSkinInfo(
                this.skinSelection.currentSkin.data
              );
          }
          _selectSkin(S) {
            ct.instance.setValue(a.STORAGE_KEY_SKIN, S.name);
          }
          _switchToSkinSelection() {
            var S, D;
            (S = this.enableSkinSelectionTween) == null || S.stop(),
              (D = this.disableSkinSelectionTween) == null || D.stop(),
              this.ui.disableAllScreens(),
              this.ui.setScreenActive(a.SCREEN_SKIN_SELECTION);
            let le = ct.instance.getInt(a.STORAGE_KEY_COIN);
            this.skinSelectionScreen.updateCoins(le),
              (this.skinSelection.enabled = !0);
            let Ce = this.ball.getPosition().clone();
            (Ce.y += 0.5),
              this.skinSelection.setPosition(Ce),
              this.skinSelectionCameraPivot.setPosition(Ce);
            let Ue = Ce.clone();
            (Ue.y -= 0.5),
              (this.ball.skin.enabled = !1),
              (this.cameraFollowing.enabled = !1),
              (this.inputHandler.enabled = !1),
              this.skinSelection.currentSkin.rotateTween.start(),
              this.swipeMovement.onPointerUp();
            let rt = new Ne.D(),
              Je = new i.A();
            rt.setFromEulerAngles(0, 0, 0);
            let St = this.mainCamera.getPosition();
            this.enableSkinSelectionTween = Pe.createTween(
              Je,
              { y: -170 },
              {
                duration: 0.5,
                easing: Pe.Easing.Sinusoidal.Out,
                onUpdate: () => {
                  rt.setFromEulerAngles(0, Je.y, 0),
                    this.skinSelectionCameraPivot.setLocalRotation(rt),
                    (St = St.lerp(
                      St,
                      this.skinSelectionCameraPoint.getPosition(),
                      0.1
                    )),
                    this.mainCamera.setPosition(St),
                    this.mainCamera.lookAt(Ue);
                },
              }
            ).start();
          }
        }
        class $t {
          static load() {
            x.log("Game", "Load"),
              (this.assetLoaded = !1),
              (this.libraryLoaded = !1),
              (this.canvas = document.getElementById("application-canvas")),
              (this.canvas.id = "application-canvas"),
              (this.canvas.style.zIndex = "0"),
              (this.app = new we.M(this.canvas, {
                elementInput: new Oe.RR(this.canvas),
                mouse: new $e.T(this.canvas),
                touch: new gt.S(this.canvas),
                keyboard: new qe.N(window),
              })),
              (this.app.graphicsDevice.maxPixelRatio = window.devicePixelRatio),
              this.app.setCanvasFillMode(Tt.DP),
              this.app.setCanvasResolution(Tt.Qd),
              h.loadSetting(),
              At.init(this.app),
              O.init(me.Tutorial),
              Mt.init(this.app),
              Pe.init(this.app),
              n.init(this.app),
              n.load(this.onAssetLoaded.bind(this)),
              it.load(this.onLibraryLoaded.bind(this)),
              ps.init();
          }
          static onAssetLoaded() {
            (this.assetLoaded = !0), this.libraryLoaded && this.create();
          }
          static onLibraryLoaded() {
            (this.libraryLoaded = !0), this.assetLoaded && this.create();
          }
          static create() {
            this.app.start(),
              x.log("Game", "Create"),
              (this.width = window.innerWidth),
              (this.height = window.innerHeight),
              this.app.resizeCanvas(this.width, this.height),
              Ie.config(),
              this.app.systems.rigidbody.gravity.set(
                a.GRAVITY_X,
                a.GRAVITY_Y,
                a.GRAVITY_Z
              ),
              (this.app.systems.rigidbody.fixedTimeStep = a.FIXED_TIME_STEP),
              N.init([new Pn()]),
              N.loadScene(N.getScene(a.SCREEN_PLAY)),
              this.app.on("update", this.update, this),
              window.addEventListener("resize", () =>
                this.resize({
                  width: window.innerWidth,
                  height: window.innerHeight,
                })
              ),
              window.addEventListener("focus", () => this.setPause(!1)),
              window.addEventListener("blur", () => this.setPause(!0)),
              (this.gameCreated = !0);
          }
          static update() {
            N.update(Mt.dt);
          }
          static onReady() {
            let S = document.getElementById("loading");
            S.style.display = "none";
          }
          static setPause(S) {
            this.gameCreated &&
              (S ? this.pause() : O.state === me.Paused && this.resume());
          }
          static pause() {
            (O.state = me.Paused),
              (Mt.scale = 0),
              f.muteAll(!0),
              N.pause(),
              (this.app.timeScale = 0);
          }
          static resume() {
            (O.state = O.prevState),
              (Mt.scale = 1),
              f.muteAll(!1),
              N.resume(),
              (this.app.timeScale = 1);
          }
          static resize(S) {
            this.gameCreated
              ? (x.debug("Game", "Resize", S),
                console.assert(
                  S.width && S.height,
                  "Screen size must have width and height greater than 0"
                ),
                (this.width = S.width),
                (this.height = S.height),
                (this.app.graphicsDevice.maxPixelRatio =
                  window.devicePixelRatio),
                this.app.resizeCanvas(this.width, this.height),
                N.resize(),
                this.app.fire("resize"))
              : console.warn("Resize function called before game creation", S);
          }
          static onWin() {}
          static onLose() {}
        }
        let gn = document.getElementById("loading");
        gn &&
          gn.addEventListener("pointerdown", (ee) => {
            ee.preventDefault(), ee.stopPropagation();
          }),
          window.addEventListener("contextmenu", (ee) => ee.preventDefault()),
          window.addEventListener("load", () => {
            $t.load();
          });
      })();
    })();
  });
  Sa();
})();
