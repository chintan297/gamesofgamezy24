<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="authoring-tool" content="Adobe_Animate_CC" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"
    />
    <title>Adam and Eve: Snow</title>
    <script src="./createjs.min.js"></script>

    <script src="adamandevesnow.js?1575102896413"></script>
    <script>
      var mobiledevice;
      var IOS;
      function detectmob() {
        if (
          navigator.userAgent.match(/Android/i) ||
          navigator.userAgent.match(/webOS/i) ||
          navigator.userAgent.match(/iPhone/i) ||
          navigator.userAgent.match(/iPad/i) ||
          navigator.userAgent.match(/iPod/i) ||
          navigator.userAgent.match(/BlackBerry/i) ||
          navigator.userAgent.match(/Windows Phone/i)
        ) {
          mobiledevice = 1;
        } else {
          mobiledevice = 0;
        }

        if (
          navigator.userAgent.match(/iPhone/i) ||
          navigator.userAgent.match(/iPad/i) ||
          navigator.userAgent.match(/iPod/i)
        ) {
          IOS = 1;
        } else {
          IOS = 0;
        }
      }

      detectmob();

      var canvas,
        stage,
        exportRoot,
        anim_container,
        dom_overlay_container,
        fnStartAnimation;

      var loadingBg = new createjs.Bitmap("images/loading/loading.jpg");
      var rotateBg = new createjs.Bitmap("images/loading/rotate.jpg");
      var rotateBg2 = new createjs.Bitmap("images/loading/rotate2.jpg");
      var progressBar = new createjs.Shape();

      rotateBg.scaleX = 1280 / 1024;
      rotateBg2.scaleX = rotateBg2.scaleY = 2;

      loadingBg.x = 0;
      loadingBg.y = 0;

      createjs.Sound.alternateExtensions = ["ogg"];

      function init() {
        canvas = document.getElementById("canvas");
        stage = new createjs.Stage(canvas);
        stage.addChild(loadingBg);
        stage.addChild(progressBar);
        anim_container = document.getElementById("animation_container");
        dom_overlay_container = document.getElementById(
          "dom_overlay_container"
        );
        var comp = AdobeAn.getComposition("F4F7E832DCCC6345B014B0D3A4921B01");
        var lib = comp.getLibrary();
        createjs.MotionGuidePlugin.install();
        var loader = new createjs.LoadQueue(true);
        loader.installPlugin(createjs.Sound);
        loader.addEventListener("fileload", function (evt) {
          handleFileLoad(evt, comp);
        });
        loader.addEventListener("progress", handleProgress);
        loader.addEventListener("complete", function (evt) {
          handleComplete(evt, comp);
        });
        var lib = comp.getLibrary();
        loader.loadManifest(lib.properties.manifest);
        resize();

        var initialized = false;
      }

      /* // Removed all GD_OPTIONS and gamedistribution-jssdk code.
 window["GD_OPTIONS"] = {
    "gameId": "06d2122bdd1945dcbf20cf7b2a48f89d",
    "onEvent": function(event) {
        switch (event.name) {
            case "SDK_GAME_START":
                 if(hudba)
                  createjs.Sound.setMute(false);
                if(exportRoot.currentFrame == 0)
                {
                    createjs.Ticker.addEventListener("tick", stage);
                    stage.update();
                }
                break;
            case "SDK_GAME_PAUSE":
                createjs.Sound.setMute(true);
                if(exportRoot.currentFrame > 0)
                    pauseF();
                else
                {
                    createjs.Ticker.removeEventListener("tick", stage);
                    stage.update();
                }
                break;
            case "SDK_GDPR_TRACKING":
                break;
            case "SDK_GDPR_TARGETING":
                break;
        }
    },
};
(function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s);
    js.id = id;
    js.src = '';
    fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'gamedistribution-jssdk'));
*/

      function handleFileLoad(evt, comp) {
        var images = comp.getImages();
        if (evt && evt.item.type == "image") {
          images[evt.item.id] = evt.result;
        }
        resize();
      }
      function handleProgress(event) {
        progressBar.graphics
          .beginFill("#0099ff")
          .drawRect(0, 740, 1280 * event.progress, 47);
        stage.update();
        //resize();
      }
      function handleComplete(evt, comp) {
        //This function is always called, irrespective of the content. You can use the variable "stage" after it is created in token create_stage.
        currentLevel = 2;
        hudba = true;
        init = true;
        if (localStorage.aae8_currentLevel)
          currentLevel = localStorage.aae8_currentLevel;
        var lib = comp.getLibrary();
        var ss = comp.getSpriteSheet();
        var queue = evt.target;
        var ssMetadata = lib.ssMetadata;

        // currentLevel = 7;
        for (i = 0; i < ssMetadata.length; i++) {
          ss[ssMetadata[i].name] = new createjs.SpriteSheet({
            images: [queue.getResult(ssMetadata[i].name)],
            frames: ssMetadata[i].frames,
          });
        }
        exportRoot = new lib.adamandevesnow();
        stage = new lib.Stage(canvas);
        stage.enableMouseOver();
        //Registers the "tick" event listener.
        fnStartAnimation = function () {
          stage.addChild(exportRoot);
          createjs.Ticker.setFPS(lib.properties.fps);
          createjs.Ticker.addEventListener("tick", stage);
        };
        AdobeAn.compositionLoaded(lib.properties.id);
        createjs.Touch.enable(stage);
        fnStartAnimation();
        resize();

        function getHiddenProp() {
          var prefixes = ["webkit", "moz", "ms", "o"];

          // If 'hidden' is natively supported, returns it
          if ("hidden" in document) return "hidden";

          // Otherwise, loops through all known prefixes
          // until 'hidden' is found
          for (var i = 0; i < prefixes.length; i++) {
            if (prefixes[i] + "Hidden" in document)
              return prefixes[i] + "Hidden";
          }

          // In all other cases, 'hidden' is not supported
          return null;
        }

        function isHidden() {
          var prop = getHiddenProp();
          if (!prop) return false;

          return document[prop];
        }

        function onVisibilityChange(event) {
          if (isHidden()) {
            createjs.Sound.setMute(true);
            if (exportRoot.currentFrame > 0) pauseF();
            else {
              createjs.Ticker.removeEventListener("tick", stage);
              stage.update();
            }
          } else {
            //getDeviceOrientation();
            if (hudba) createjs.Sound.setMute(false);
            //if(exportRoot.currentFrame > 0)
            //    continueF();
            if (exportRoot.currentFrame == 0) {
              createjs.Ticker.addEventListener("tick", stage);
              stage.update();
            }
          }
        }

        var visProp = getHiddenProp();
        if (visProp) {
          // Attaches the correct event name, depending on the browser's renderer
          document.addEventListener(
            visProp.replace(/[H|h]idden/, "") + "visibilitychange",
            onVisibilityChange
          );
        }

        window.onblur = function (e) {
          //console.log("blur");
          createjs.Sound.setMute(true);
          console.log(exportRoot.currentFrame);
          if (exportRoot.currentFrame > 0) pauseF();
          else {
            createjs.Ticker.removeEventListener("tick", stage);
            stage.update();
          }
        };
        window.onfocus = function (e) {
          //console.log("focus");
          //getDeviceOrientation();
          if (hudba) createjs.Sound.setMute(false);

          //if(exportRoot.currentFrame > 0)
          //    continueF();
          if (exportRoot.currentFrame == 0) {
            createjs.Ticker.addEventListener("tick", stage);
            stage.update();
          }
        };

        window.onpagehide = function (e) {
          createjs.Sound.setMute(true);
          if (exportRoot.currentFrame > 0) pauseF();
          else {
            createjs.Ticker.removeEventListener("tick", stage);
            stage.update();
          }
        };

        window.onpageshow = function (e) {
          //getDeviceOrientation();
          if (hudba) createjs.Sound.setMute(false);
          //if(exportRoot.currentFrame > 0)
          //    continueF();
          if (exportRoot.currentFrame == 0) {
            createjs.Ticker.addEventListener("tick", stage);
            stage.update();
          }
        };
      }
      function playSound(id, loop) {
        return createjs.Sound.play(id, {
          interrupt: createjs.Sound.INTERRUPT_EARLY,
          loop: loop,
        });
      }
      function resize() {
        if (
          (window.innerHeight < window.innerWidth &&
            navigator.userAgent.match("Mac OS")) ||
          (screen.width == 720 &&
            screen.height == 1280 &&
            window.innerHeight < window.innerWidth &&
            navigator.userAgent.match("Android")) ||
          (screen.width != 720 &&
            screen.height != 1280 &&
            screen.height < screen.width &&
            navigator.userAgent.match("Android")) ||
          (window.innerHeight < window.innerWidth &&
            navigator.userAgent.match(/BlackBerry/i)) ||
          (window.innerHeight < window.innerWidth &&
            navigator.userAgent.match(/Windows Phone/i)) ||
          !mobiledevice
        ) {
          window.scrollTo(0, 0);
          stage.removeChild(rotateBg);
          stage.removeChild(rotateBg2);
          var GAME_WIDTH = 1280;
          var GAME_HEIGHT = 1024;
          var h = GAME_HEIGHT;
          var width = window.innerWidth || document.body.clientWidth;
          var height = window.innerHeight || document.body.clientHeight;

          scale_window = Math.max(width / GAME_WIDTH, height / GAME_HEIGHT);

          scale_stage = Math.min(width / GAME_WIDTH, height / GAME_HEIGHT);

          //console.log(document.body.clientWidth,window.innerWidth,screen.width);

          //var ratio=width/1680;
          var ratio = document.body.clientWidth / 1280;

          //console.log(window.devicePixelRatio)

          //window.devicePixelRatio = 1;
          canvas.style.height =
            dom_overlay_container.style.height =
            anim_container.style.height =
              GAME_HEIGHT * ratio + "px";
          canvas.style.width =
            dom_overlay_container.style.width =
            anim_container.style.width =
              GAME_WIDTH * ratio + "px";
          //viewstyleheight = h * ratio;
          //viewstylewidth = GAME_WIDTH * ratio;
          //console.log("view.style.height="+view.style.height+" view.style.width="+view.style.width);
          //stage.scale.set(ratio*window.devicePixelRatio);
          //renderer.view.style.position = "fixed";

          //alert(width/height)
          var top_style = 50;
          if (IOS) {
            if (width / height > 2.1) top_style = 47;
          }

          //alert(top_style)

          posun_windowX = Math.round((width - GAME_WIDTH * ratio) / 2);
          posun_windowY = Math.round((height - GAME_HEIGHT * ratio) / 2);

          canvas.style.position = "absolute";
          canvas.style.left = "50%";
          canvas.style.top = top_style + "%";
          canvas.style.transform = "translate3d( -50%, -50%, 0 )";

          dom_overlay_container.style.position = "absolute";
          dom_overlay_container.style.left = "50%";
          dom_overlay_container.style.top = top_style + "%";
          dom_overlay_container.style.transform =
            "translate3d( -50%, -50%, 0 )";

          anim_container.style.position = "fixed";
          anim_container.style.left = "50%";
          anim_container.style.top = top_style + "%";
          anim_container.style.transform = "translate3d( -50%, -50%, 0 )";
          return top_style;
        } else {
          window.scrollTo(0, 0);
          stage.addChild(rotateBg);
          stage.addChild(rotateBg2);
          var GAME_WIDTH = 1280;
          var GAME_HEIGHT = 1024;
          var h = GAME_HEIGHT;
          var width = window.innerWidth || document.body.clientWidth;
          var height = window.innerHeight || document.body.clientHeight;

          scale_window = Math.max(width / GAME_WIDTH, height / GAME_HEIGHT);

          scale_stage = Math.min(width / GAME_WIDTH, height / GAME_HEIGHT);

          //console.log(document.body.clientWidth,window.innerWidth,screen.width);

          //var ratio=width/1680;
          var ratio = document.body.clientWidth / 1280;

          //console.log(window.devicePixelRatio)

          //window.devicePixelRatio = 1;
          canvas.style.height =
            dom_overlay_container.style.height =
            anim_container.style.height =
              GAME_HEIGHT * ratio + "px";
          canvas.style.width =
            dom_overlay_container.style.width =
            anim_container.style.width =
              GAME_WIDTH * ratio + "px";
          //viewstyleheight = h * ratio;
          //viewstylewidth = GAME_WIDTH * ratio;
          //console.log("view.style.height="+view.style.height+" view.style.width="+view.style.width);
          //stage.scale.set(ratio*window.devicePixelRatio);
          //renderer.view.style.position = "fixed";

          posun_windowX = Math.round((width - GAME_WIDTH * ratio) / 2);
          posun_windowY = Math.round((height - GAME_HEIGHT * ratio) / 2);

          canvas.style.position = "absolute";
          canvas.style.left = "50%";
          canvas.style.top = "50%";
          canvas.style.transform = "translate3d( -50%, -50%, 0 )";

          dom_overlay_container.style.position = "absolute";
          dom_overlay_container.style.left = "50%";
          dom_overlay_container.style.top = "50%";
          dom_overlay_container.style.transform =
            "translate3d( -50%, -50%, 0 )";

          anim_container.style.position = "fixed";
          anim_container.style.left = "50%";
          anim_container.style.top = "50%";
          anim_container.style.transform = "translate3d( -50%, -50%, 0 )";

          rotateBg2.x = 1280 / 2 - rotateBg2.getBounds().width;
          rotateBg2.y = 1024 / 2 - rotateBg2.getBounds().height;
        }
      }

      function doubleResize() {
        resize();
        setTimeout(function () {
          resize();
        }, 500);
      }
    </script>
  </head>
  <body onload="init();" style="margin: 0px" onresize="doubleResize();">
    <div
      id="animation_container"
      style="
        background-color: rgba(255, 255, 255, 1);
        width: 1280px;
        height: 1024px;
      "
    >
      <canvas
        id="canvas"
        width="1280"
        height="1024"
        style="
          position: absolute;
          display: block;
          background-color: rgba(255, 255, 255, 1);
        "
      ></canvas>
      <div
        id="dom_overlay_container"
        style="
          pointer-events: none;
          overflow: hidden;
          width: 1280px;
          height: 1024px;
          position: absolute;
          left: 0px;
          top: 0px;
          display: block;
        "
      ></div>
    </div>
  </body>
</html>
