<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, minimal-ui"
    />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black" />
    <meta name="apple-touch-fullscreen" content="yes" />
    <link rel="apple-touch-icon" sizes="256x256" href="../icons/icon256.png" />
    <meta name="HandheldFriendly" content="true" />
    <meta name="mobile-web-app-capable" content="yes" />
    <link rel="shortcut icon" sizes="256x256" href="../icons/icon256.png" />

    <title>tomb-runner</title>

    <link rel="stylesheet" href="css/app.css" type="text/css" />
  </head>

  <body>
    <div id="container"></div>
    <div id="loader">Loading...</div>

    <script>
      // â›” Disable Spil SDK / forced redirection
      window.SpilData = {
        id: null,
        pauseGame: function () {},
        resumeGame: function () {},
        onLoad: function (cb) {
          cb && cb();
        },
        callbacks: [],
      };

      // Stop browser from trying to open parent/top window
      Object.defineProperty(window, "top", { value: window });
      Object.defineProperty(window, "parent", { value: window });
      window.open = () => null;
      window.location.assign = () => {};
      window.location.replace = () => {};
      window.location.href = window.location.href; // freeze redirects

      // Stop forced scroll restore
      window.addEventListener(
        "scroll",
        function () {
          if (document.activeElement === document.body && window.scrollY > 0) {
            document.body.scrollTop = 0;
          }
        },
        true
      );
    </script>
    <script>
      // === Prevent ad/branding SDKs from being injected ===
      (function () {
        const blockedSrcPatterns = [
          "gamedistribution",
          "html5.api.gamedistribution.com",
          "azerion",
          "cdn.azerion",
          "fbrq.io",
          "@azerion",
          "api.gamemonetize.com",
        ];

        // Block adding <script src="..."> for known ad SDKs
        const origCreate = Document.prototype.createElement;
        Document.prototype.createElement = function (tagName) {
          const el = origCreate.call(this, tagName);
          if (String(tagName).toLowerCase() === "script") {
            const origSetSrc = Object.getOwnPropertyDescriptor(
              HTMLScriptElement.prototype,
              "src"
            )?.set;
            Object.defineProperty(el, "src", {
              set: function (v) {
                if (typeof v === "string") {
                  for (const p of blockedSrcPatterns) {
                    if (v.indexOf(p) !== -1) {
                      console.warn("[Guard] blocked script src:", v);
                      return; // ignore assignment (script won't load)
                    }
                  }
                }
                if (origSetSrc) origSetSrc.call(this, v);
              },
              get: function () {
                return "";
              },
            });
          }
          return el;
        };

        // Also guard appendChild / insertBefore just in case scripts are injected by string
        const origAppend = Element.prototype.appendChild;
        Element.prototype.appendChild = function (node) {
          try {
            if (node && node.tagName === "SCRIPT" && node.src) {
              for (const p of blockedSrcPatterns) {
                if (node.src.indexOf(p) !== -1) {
                  console.warn(
                    "[Guard] prevented appendChild of script",
                    node.src
                  );
                  return node; // ignore insertion
                }
              }
            }
          } catch (e) {}
          return origAppend.call(this, node);
        };

        // === Neutralize redirect/open methods ===
        try {
          Object.defineProperty(window, "top", {
            value: window,
            configurable: true,
          });
          Object.defineProperty(window, "parent", {
            value: window,
            configurable: true,
          });
        } catch (e) {
          /* ignore */
        }
        window.open = function () {
          console.warn("[Guard] window.open blocked");
          return null;
        };
        window.location.assign = function () {
          console.warn("[Guard] location.assign blocked");
        };
        window.location.replace = function () {
          console.warn("[Guard] location.replace blocked");
        };

        // === Intercept XHR / fetch for site-lock JSON files and return safe empty lists ===
        const blockedJsonNames = [
          "domains.json",
          "sitelock.json",
          "internal.json",
          "contracted.json",
          "special.json",
        ];

        // fetch interception
        const origFetch = window.fetch;
        window.fetch = function (input, init) {
          try {
            const url = typeof input === "string" ? input : input && input.url;
            if (url && blockedJsonNames.some((n) => url.indexOf(n) !== -1)) {
              console.warn("[Guard] intercepted fetch for", url);
              const body = JSON.stringify({}); // empty object or { frames: [] } depending on usage
              return Promise.resolve(
                new Response(body, {
                  status: 200,
                  headers: { "Content-Type": "application/json" },
                })
              );
            }
          } catch (e) {}
          return origFetch.apply(this, arguments);
        };

        // XHR interception
        const origOpen = XMLHttpRequest.prototype.open;
        XMLHttpRequest.prototype.open = function (method, url) {
          try {
            if (url && blockedJsonNames.some((n) => url.indexOf(n) !== -1)) {
              console.warn("[Guard] intercepted XHR open for", url);
              // make this XHR return empty safe content when send() is called
              this.addEventListener("readystatechange", function () {
                if (this.readyState === 4) {
                  try {
                    Object.defineProperty(this, "responseText", {
                      value: "{}",
                      writable: false,
                    });
                    Object.defineProperty(this, "response", {
                      value: "{}",
                      writable: false,
                    });
                    Object.defineProperty(this, "status", {
                      value: 200,
                      writable: false,
                    });
                  } catch (e) {}
                }
              });
            }
          } catch (e) {}
          return origOpen.apply(this, arguments);
        };

        console.log("[Guard] ad/redirect protections in place");
      })();
    </script>

    <script>
      var gameName = "tomb-runner.min.js";

      function addScript(src, buster, callback) {
        var s = document.createElement("script");
        s.src = src + "?v=" + buster;
        if (callback) s.onload = callback;
        document.body.appendChild(s);
      }

      // load version + game
      addScript("version.js", Date.now(), function () {
        addScript(gameName, window.version || Date.now());
      });
    </script>
  </body>
</html>
